(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.data = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cfg = require('./config');

/*
 * Logger object
 *
 * Tries to abstract away some of the complexity of logging.  If we can consistently
 * call the logger for errors, debugging, etc. instead of directly calling console.log,
 * then this will eventually make it easier to hide excessive stuff in production.
 *
 * Also, sending everything to one consistent place makes maintenance simpler.
 *
 * NOTE: in /standalone/lib/annotator.js, we set `window.log = new Logger()`, so
 *   to use this, call (for example) `log.warn("Some message")`.
 *
 * NOTE: to log "normally", without any of this special formatting, use Logger.out()
 *
 * @param {String} levelName:   one of 'CRITICAL', 'ERROR', 'WARN', 'INFO', 'DEBUG'
 *   used to set when the logger will actually display the message.  for example,
 *   if levelName='WARN', and you call `log.info("Some message")`, this won't be
 *   printed
 *
 * @param {Function} writer:    where to redirect the formatted message, default
 *   is console.error
 */

var Log = function () {
  function Log(levelName) {
    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console.log;

    _classCallCheck(this, Log);

    this._write = writer;
    this.colors = {
      'CRITICAL': 'red',
      'ERROR': 'orange',
      'WARN': 'yellow',
      'INFO': 'green',
      'DEBUG': 'blue',
      'OK': 'green'
    };

    this.level = levelName || cfg.defaultLoggingLevel;

    // try to override the l20n logging
    try {
      L20N_LOGGING = levelName === 'DEBUG';
    } catch (e) {
      if (!(e instanceof ReferenceError)) throw e;
    }
  }

  /*
   * change the logging level
   */


  _createClass(Log, [{
    key: 'toString',


    /*
     * Override prototype toString() method
     */
    value: function toString() {
      return 'Logger (level=' + this._levelName + ')';
    }

    /*
     * `private` method
     * format a message to be printed
     *
     * @param {String} message:   message to be printed
     * @param {String} tag:    keyword to appear between the timestamp (if present)
     *   and the message (default=null implies no tag shown)
     * @param {Boolean} showTimestamp:  set to `false` to suppress the current time
     *   from being output
     *
     * @return {String} formatted message
     */

  }, {
    key: '_format',
    value: function _format(message) {
      var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var showTimestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;


      var title = '',
          raw = '';
      if (showTimestamp) {
        var date = new Date();
        title += '[' + date + '] ';
        raw += '[' + date + '] ';
      }
      var css = [];
      if (tag !== null) {
        title += '%c' + tag + '%c: ';
        raw += tag + ': ';
        css = css.concat(['color:' + (this.colors[tag] || 'black') + ';', 'color:black']);
      }
      title += message.match(/\n/) === null // title should only be 1 line
      ? message : message.split('\n')[0] + ' [...]';
      raw += message;

      return { title: title, raw: raw, css: css };
    }

    /*
     * `private` method
     * helper function for the below functions ... decides whether or not a message
     * should be written out
     *
     * @param {Number} level:     integer representing the output priority level
     * @param {String} tag:       keyword to appear between the timestamp (if present)
     *   and the message (default=null implies no tag shown)
     * @param {String} message:   message to be printed (default='')
     * @param {Boolean} showTimestamp:  set to `false` to suppress the current time
     *   from being output
     *
     * @return <none>
     */

  }, {
    key: '_handle',
    value: function _handle(level, tag) {
      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var writer = arguments[3];

      if (level <= this._level) {
        var _console;

        var formatted = this._format(message, tag, true);
        writer = writer || this._write;
        (_console = console).groupCollapsed.apply(_console, [formatted.title].concat(_toConsumableArray(formatted.css)));
        writer(formatted.raw);
        console.trace();
        console.groupEnd();
      }
    }

    /*
     * `public` methods
     * call these functions to use this class's functionality (see above for details)
     *
     * @param {String} message:   message to be printed
     *
     * @return <none>
     */

  }, {
    key: 'critical',
    value: function critical(message) {
      this._handle(0, 'CRITICAL', message, console.error);
    }
  }, {
    key: 'error',
    value: function error(message) {
      this._handle(1, 'ERROR', message, console.error);
    }
  }, {
    key: 'warn',
    value: function warn(message) {
      this._handle(2, 'WARN', message, console.warn);
    }
  }, {
    key: 'info',
    value: function info(message) {
      this._handle(3, 'INFO', message, console.info);
    }
  }, {
    key: 'debug',
    value: function debug(message) {
      this._handle(4, 'DEBUG', message, console.log);
    }

    /*
     * `public` method
     * log normally (always and without special formatting)
     *
     * @param {...various} args:    zero or more things to be written out
     *
     * @return <none>
     */

  }, {
    key: 'out',
    value: function out(message, tag) {
      var formatted = this._format(message, tag, false);
      if (formatted.css.length) {
        this._write(formatted.title, formatted.css);
      } else {
        this._write(formatted.raw);
      }
    }
  }, {
    key: 'level',
    set: function set(levelName) {
      this._levelName = levelName;
      this._level = ['CRITICAL', 'ERROR', 'WARN', 'INFO', 'DEBUG'].indexOf(levelName);

      if (this._level === -1) {
        this.out('Unrecognized Logger levelName "' + levelName + '", setting level to CRITICAL.');
        this._levelName = 'CRITICAL';
        this._level = 0;
      }

      this.out('logging level set to ' + this._levelName, 'OK');
    }
  }]);

  return Log;
}();

module.exports = Log;

},{"./config":3}],2:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var _ = require('underscore');
var funcs = require('./funcs');

function getTableRow(selfid, userid, user) {

  var name = funcs.getUsername(user);
  var address = user.address;
  var index = isNaN(parseInt(user.index)) ? '?' : user.index + 1;

  if (selfid === userid) username = '<me>';

  return $('<tr>').addClass('online-user').addClass(selfid === userid ? 'self' : 'other').append($('<td>').addClass('online-user-data username').text(username)).append($('<td>').addClass('online-user-data ip-address').text(address)).append($('<td>').addClass('online-user-data view-index').text(index));
}

function update(selfid, room) {
  if (!gui.inBrowser) return;

  // update the number first
  var num = funcs.getPresentUsers(room);
  $('#currently-online-number').text(num);

  // then update the list
  var tbody = $('#currently-online-list tbody');
  tbody.children().detach();
  _.each(room.users, function (user, userid) {
    var tr = getTableRow(selfid, userid, user);
    tbody.append(tr);
  });
}

module.exports = {
  update: update
};

},{"./funcs":9,"jquery":394,"underscore":499}],3:[function(require,module,exports){
'use strict';

module.exports = {
	version: '0.0.0',

	defaultFilename: 'ud-annotatrix-corpus',
	defaultSentence: '',
	defaultInsertedSentence: '',
	defaultLoggingLevel: 'ERROR',
	defaultEdgeHeight: 40,
	defaultEdgeCoeff: 1,

	localStorageKey: 'ud-annotatrix',
	saveInterval: 100000, // msecs

	downloadHasFileHeader: true,
	downloadHasSentenceHeader: true,

	statusNormalFadeout: 3000,
	statusErrorFadeout: 5000
};

},{}],4:[function(require,module,exports){
'use strict';

// is defined in a js file, because fetch doesn't work offline in chrome

var ACTIVE_COLOR = '#2653c9',
    NORMAL_COLOR = '#7fa2ff',
    FANCY_COLOR = '#cc22fc',
    POS_COLOR = '#afa2ff',
    ST_COLOR = '#bcd2ff',
    MOVING_COLOR = '#00f';

var CY_STYLE = [{
  'selector': '*.disabled',
  'style': {
    'opacity': 0.4 /*
                   'background-color': '#f00',
                   'color': '#0ff'*/
  }
}, {
  'selector': 'node',
  'style': {
    'height': 20,
    'background-color': NORMAL_COLOR,
    'shape': 'roundrectangle',
    'text-valign': 'center',
    'text-halign': 'center',
    'border-color': '#000',
    'border-width': 1
  }
}, {
  'selector': 'node.form',
  'style': {
    'width': 'data(length)',
    'label': 'data(label)'
  }
}, {
  'selector': 'node.multiword',
  'style': {
    'background-color': ST_COLOR,
    'text-background-color': NORMAL_COLOR,
    'text-background-opacity': 0.9,
    'text-border-color': '#000',
    'text-border-opacity': 0.9,
    'text-border-width': '1px',
    'text-background-shape': 'roundrectangle',
    'text-valign': 'top',
    'label': 'data(label)'
  }
}, {
  'selector': 'node.multiword-active',
  'style': {
    'background-color': ACTIVE_COLOR
  }
}, {
  'selector': 'node.form.arc-source, node.form.arc-target',
  'style': {
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.form.root',
  'style': {
    'font-weight': 'bold',
    //'text-border-width': '2em',
    'border-width': '2px'
  }
}, {
  'selector': 'node.form.activated',
  'style': {
    'background-color': ACTIVE_COLOR
  }
}, {
  'selector': 'node.form.activated.retokenize',
  'style': {
    'background-color': POS_COLOR,
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.form.merge',
  'style': {
    'background-color': POS_COLOR,
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.form.supertoken',
  'style': {
    'background-color': POS_COLOR,
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.pos',
  'style': {
    'width': 'data(length)',
    'label': 'data(label)',
    'background-color': POS_COLOR
  }
}, {
  'selector': 'edge',
  'style': {
    'width': 3,
    'opacity': 0.766,
    'line-color': '#111',
    'control-point-weights': '0.2 0.25 0.75 0.8'
  }
}, {
  'selector': 'edge.incomplete',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#aaa',
    'line-color': '#aaa',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'arrow-scale': '1.5',
    'edge-distances': 'node-position',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.incomplete.vertical',
  'style': {
    'text-margin-y': 0,
    'text-background-opacity': 1,
    'text-background-color': 'white',
    'text-background-shape': 'roundrectangle',
    'text-border-color': 'black',
    'text-border-width': 1,
    'text-border-opacity': 1,
    'control-point-weights': '0.15 0.45 0.55 0.85',
    'text-margin-x': 'data(length)',
    'source-distance-from-node': 10,
    'target-distance-from-node': 10
  }
}, {
  'selector': 'edge.incomplete.horizontal',
  'style': {
    'text-margin-y': -10,
    'text-margin-x': 0,
    'text-background-opacity': 0,
    'text-border-opacity': 0,
    'control-point-weights': '0 0.25 0.75 1',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0
  }
}, {
  'selector': 'edge.error',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#d11',
    'line-color': '#d11',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'arrow-scale': '1.5',
    'edge-distances': 'node-position',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'node.pos.error',
  'style': {
    'border-color': '#d11'
  }
}, {
  'selector': 'edge.enhanced',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#045',
    'line-color': '#045',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'edge-distances': 'node-position',
    'arrow-scale': '1.5',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.dependency',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#111',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'edge-distances': 'node-position',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.dependency.selected',
  'style': {
    'line-color': FANCY_COLOR,
    'target-arrow-color': FANCY_COLOR
  }
}, { 'selector': 'edge.pos',
  'style': {
    'curve-style': 'haystack'
  }
}, {
  'selector': 'node.number',
  'style': {
    'background-opacity': 0,
    'border-opacity': 0,
    'padding': 0,
    'text-background-color': POS_COLOR,
    'text-background-opacity': 0.9,
    'text-border-color': '#000',
    'text-border-opacity': 0.9,
    'text-border-width': '1px',
    'text-background-shape': 'roundrectangle',
    'text-halign': 'right',
    'label': 'data(label)',
    'events': 'no'
  }
}, {
  'selector': 'edge.moving',
  'style': {
    'line-color': MOVING_COLOR,
    'target-arrow-color': MOVING_COLOR
  }
}];

module.exports = CY_STYLE;

},{}],5:[function(require,module,exports){
(function (global,setImmediate){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["cytoscape"] = factory();else root["cytoscape"] = factory();
})(typeof self !== 'undefined' ? self : undefined, function () {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 20);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      /*global HTMLElement DocumentTouch */

      var window = __webpack_require__(3);
      var navigator = window ? window.navigator : null;
      var document = window ? window.document : null;

      var typeofstr = _typeof('');
      var typeofobj = _typeof({});
      var typeoffn = _typeof(function () {});
      var typeofhtmlele = typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement);

      var instanceStr = function instanceStr(obj) {
        return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;
      };

      var is = {
        defined: function defined(obj) {
          return obj != null; // not undefined or null
        },

        string: function string(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == typeofstr;
        },

        fn: function fn(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeoffn;
        },

        array: function array(obj) {
          return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
        },

        plainObject: function plainObject(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj && !is.array(obj) && obj.constructor === Object;
        },

        object: function object(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj;
        },

        number: function number(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(1) && !isNaN(obj);
        },

        integer: function integer(obj) {
          return is.number(obj) && Math.floor(obj) === obj;
        },

        bool: function bool(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(true);
        },

        htmlElement: function htmlElement(obj) {
          if ('undefined' === typeofhtmlele) {
            return undefined;
          } else {
            return null != obj && obj instanceof HTMLElement;
          }
        },

        elementOrCollection: function elementOrCollection(obj) {
          return is.element(obj) || is.collection(obj);
        },

        element: function element(obj) {
          return instanceStr(obj) === 'collection' && obj._private.single;
        },

        collection: function collection(obj) {
          return instanceStr(obj) === 'collection' && !obj._private.single;
        },

        core: function core(obj) {
          return instanceStr(obj) === 'core';
        },

        style: function style(obj) {
          return instanceStr(obj) === 'style';
        },

        stylesheet: function stylesheet(obj) {
          return instanceStr(obj) === 'stylesheet';
        },

        event: function event(obj) {
          return instanceStr(obj) === 'event';
        },

        thread: function thread(obj) {
          return instanceStr(obj) === 'thread';
        },

        fabric: function fabric(obj) {
          return instanceStr(obj) === 'fabric';
        },

        emptyString: function emptyString(obj) {
          if (obj === undefined || obj === null) {
            // null is empty
            return true;
          } else if (obj === '' || obj.match(/^\s+$/)) {
            return true; // empty string is empty
          }

          return false; // otherwise, we don't know what we've got
        },

        nonemptyString: function nonemptyString(obj) {
          if (obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/)) {
            return true;
          }

          return false;
        },

        domElement: function domElement(obj) {
          if (typeof HTMLElement === 'undefined') {
            return false; // we're not in a browser so it doesn't matter
          } else {
            return obj instanceof HTMLElement;
          }
        },

        boundingBox: function boundingBox(obj) {
          return is.plainObject(obj) && is.number(obj.x1) && is.number(obj.x2) && is.number(obj.y1) && is.number(obj.y2);
        },

        promise: function promise(obj) {
          return is.object(obj) && is.fn(obj.then);
        },

        touch: function touch() {
          return window && ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);
        },

        gecko: function gecko() {
          return window && (typeof InstallTrigger !== 'undefined' || 'MozAppearance' in document.documentElement.style);
        },

        webkit: function webkit() {
          return window && (typeof webkitURL !== 'undefined' || 'WebkitAppearance' in document.documentElement.style);
        },

        chromium: function chromium() {
          return window && typeof chrome !== 'undefined';
        },

        khtml: function khtml() {
          return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
        },

        khtmlEtc: function khtmlEtc() {
          return is.khtml() || is.webkit() || is.chromium();
        },

        ms: function ms() {
          return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
        },

        windows: function windows() {
          return navigator && navigator.appVersion.match(/Win/i);
        },

        mac: function mac() {
          return navigator && navigator.appVersion.match(/Mac/i);
        },

        linux: function linux() {
          return navigator && navigator.appVersion.match(/Linux/i);
        },

        unix: function unix() {
          return navigator && navigator.appVersion.match(/X11/i);
        }
      };

      module.exports = is;

      /***/
    },
    /* 1 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*global console */

      var is = __webpack_require__(0);
      var math = __webpack_require__(2);

      var util = {

        MAX_INT: Number.MAX_SAFE_INTEGER || 9007199254740991,

        trueify: function trueify() {
          return true;
        },

        falsify: function falsify() {
          return false;
        },

        zeroify: function zeroify() {
          return 0;
        },

        noop: function noop() {},

        error: function error(msg) {
          /* eslint-disable */
          if (console.error) {
            console.error.apply(console, arguments);

            if (console.trace) {
              console.trace();
            }
          } else {
            console.log.apply(console, arguments);

            if (console.trace) {
              console.trace();
            }
          }
          /* eslint-enable */
        },

        clone: function clone(obj) {
          return this.extend({}, obj);
        },

        // gets a shallow copy of the argument
        copy: function copy(obj) {
          if (obj == null) {
            return obj;
          }if (is.array(obj)) {
            return obj.slice();
          } else if (is.plainObject(obj)) {
            return this.clone(obj);
          } else {
            return obj;
          }
        },

        copyArray: function copyArray(arr) {
          return arr.slice();
        },

        clonePosition: function clonePosition(pos) {
          return { x: pos.x, y: pos.y };
        },

        uuid: function uuid(a, b // placeholders
        ) {
          for ( // loop :)
          b = a = ''; // b - result , a - numeric letiable
          a++ < 36; //
          b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
          ? //  return a random number or 4
          (a ^ 15 // if "a" is not 15
          ? // genetate a random number from 0 to 15
          8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
          : 4 //  otherwise 4
          ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
          ) {}
          return b;
        }

      };

      util.makeBoundingBox = math.makeBoundingBox.bind(math);

      util._staticEmptyObject = {};

      util.staticEmptyObject = function () {
        return util._staticEmptyObject;
      };

      util.extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
        var args = arguments;

        for (var i = 1; i < args.length; i++) {
          var obj = args[i];

          if (obj == null) {
            continue;
          }

          var keys = Object.keys(obj);

          for (var j = 0; j < keys.length; j++) {
            var k = keys[j];

            tgt[k] = obj[k];
          }
        }

        return tgt;
      };

      util.assign = util.extend;

      util.default = function (val, def) {
        if (val === undefined) {
          return def;
        } else {
          return val;
        }
      };

      util.removeFromArray = function (arr, ele, manyCopies) {
        for (var i = arr.length; i >= 0; i--) {
          if (arr[i] === ele) {
            arr.splice(i, 1);

            if (!manyCopies) {
              break;
            }
          }
        }
      };

      util.clearArray = function (arr) {
        arr.splice(0, arr.length);
      };

      util.push = function (arr, otherArr) {
        for (var i = 0; i < otherArr.length; i++) {
          var el = otherArr[i];

          arr.push(el);
        }
      };

      util.getPrefixedProperty = function (obj, propName, prefix) {
        if (prefix) {
          propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
        }

        return obj[propName];
      };

      util.setPrefixedProperty = function (obj, propName, prefix, value) {
        if (prefix) {
          propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
        }

        obj[propName] = value;
      };

      [__webpack_require__(21), __webpack_require__(22), { memoize: __webpack_require__(13) }, __webpack_require__(23), __webpack_require__(24), __webpack_require__(25), __webpack_require__(27)].forEach(function (req) {
        util.extend(util, req);
      });

      module.exports = util;

      /***/
    },
    /* 2 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = {};

      math.arePositionsSame = function (p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      };

      math.copyPosition = function (p) {
        return { x: p.x, y: p.y };
      };

      math.modelToRenderedPosition = function (p, zoom, pan) {
        return {
          x: p.x * zoom + pan.x,
          y: p.y * zoom + pan.y
        };
      };

      math.renderedToModelPosition = function (p, zoom, pan) {
        return {
          x: (p.x - pan.x) / zoom,
          y: (p.y - pan.y) / zoom
        };
      };

      math.array2point = function (arr) {
        return {
          x: arr[0],
          y: arr[1]
        };
      };

      math.deg2rad = function (deg) {
        return Math.PI * deg / 180;
      };

      math.getAngleFromDisp = function (dispX, dispY) {
        return Math.atan2(dispY, dispX) - Math.PI / 2;
      };

      math.log2 = Math.log2 || function (n) {
        return Math.log(n) / Math.log(2);
      };

      math.signum = function (x) {
        if (x > 0) {
          return 1;
        } else if (x < 0) {
          return -1;
        } else {
          return 0;
        }
      };

      math.dist = function (p1, p2) {
        return Math.sqrt(math.sqdist(p1, p2));
      };

      math.sqdist = function (p1, p2) {
        var dx = p2.x - p1.x;
        var dy = p2.y - p1.y;

        return dx * dx + dy * dy;
      };

      // from http://en.wikipedia.org/wiki/BÃ©zier_curve#Quadratic_curves
      math.qbezierAt = function (p0, p1, p2, t) {
        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
      };

      math.qbezierPtAt = function (p0, p1, p2, t) {
        return {
          x: math.qbezierAt(p0.x, p1.x, p2.x, t),
          y: math.qbezierAt(p0.y, p1.y, p2.y, t)
        };
      };

      math.lineAt = function (p0, p1, t, d) {
        var vec = {
          x: p1.x - p0.x,
          y: p1.y - p0.y
        };

        var vecDist = math.dist(p0, p1);

        var normVec = {
          x: vec.x / vecDist,
          y: vec.y / vecDist
        };

        t = t == null ? 0 : t;

        d = d != null ? d : t * vecDist;

        return {
          x: p0.x + normVec.x * d,
          y: p0.y + normVec.y * d
        };
      };

      math.lineAtDist = function (p0, p1, d) {
        return math.lineAt(p0, p1, undefined, d);
      };

      // get angle at A via cosine law
      math.triangleAngle = function (A, B, C) {
        var a = math.dist(B, C);
        var b = math.dist(A, C);
        var c = math.dist(A, B);

        return Math.acos((a * a + b * b - c * c) / (2 * a * b));
      };

      math.bound = function (min, val, max) {
        return Math.max(min, Math.min(max, val));
      };

      // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
      math.makeBoundingBox = function (bb) {
        if (bb == null) {
          return {
            x1: Infinity,
            y1: Infinity,
            x2: -Infinity,
            y2: -Infinity,
            w: 0,
            h: 0
          };
        } else if (bb.x1 != null && bb.y1 != null) {
          if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
            return {
              x1: bb.x1,
              y1: bb.y1,
              x2: bb.x2,
              y2: bb.y2,
              w: bb.x2 - bb.x1,
              h: bb.y2 - bb.y1
            };
          } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
            return {
              x1: bb.x1,
              y1: bb.y1,
              x2: bb.x1 + bb.w,
              y2: bb.y1 + bb.h,
              w: bb.w,
              h: bb.h
            };
          }
        }
      };

      math.updateBoundingBox = function (bb1, bb2) {
        // update bb1 with bb2 bounds

        bb1.x1 = Math.min(bb1.x1, bb2.x1);
        bb1.x2 = Math.max(bb1.x2, bb2.x2);
        bb1.w = bb1.x2 - bb1.x1;

        bb1.y1 = Math.min(bb1.y1, bb2.y1);
        bb1.y2 = Math.max(bb1.y2, bb2.y2);
        bb1.h = bb1.y2 - bb1.y1;
      };

      math.expandBoundingBoxByPoint = function (bb, x, y) {
        bb.x1 = Math.min(bb.x1, x);
        bb.x2 = Math.max(bb.x2, x);
        bb.w = bb.x2 - bb.x1;

        bb.y1 = Math.min(bb.y1, y);
        bb.y2 = Math.max(bb.y2, y);
        bb.h = bb.y2 - bb.y1;
      };

      math.expandBoundingBox = function (bb, padding) {
        bb.x1 -= padding;
        bb.x2 += padding;
        bb.y1 -= padding;
        bb.y2 += padding;
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

        return bb;
      };

      math.boundingBoxesIntersect = function (bb1, bb2) {
        // case: one bb to right of other
        if (bb1.x1 > bb2.x2) {
          return false;
        }
        if (bb2.x1 > bb1.x2) {
          return false;
        }

        // case: one bb to left of other
        if (bb1.x2 < bb2.x1) {
          return false;
        }
        if (bb2.x2 < bb1.x1) {
          return false;
        }

        // case: one bb above other
        if (bb1.y2 < bb2.y1) {
          return false;
        }
        if (bb2.y2 < bb1.y1) {
          return false;
        }

        // case: one bb below other
        if (bb1.y1 > bb2.y2) {
          return false;
        }
        if (bb2.y1 > bb1.y2) {
          return false;
        }

        // otherwise, must have some overlap
        return true;
      };

      math.inBoundingBox = function (bb, x, y) {
        return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
      };

      math.pointInBoundingBox = function (bb, pt) {
        return this.inBoundingBox(bb, pt.x, pt.y);
      };

      math.boundingBoxInBoundingBox = function (bb1, bb2) {
        return math.inBoundingBox(bb1, bb2.x1, bb2.y1) && math.inBoundingBox(bb1, bb2.x2, bb2.y2);
      };

      math.roundRectangleIntersectLine = function (x, y, nodeX, nodeY, width, height, padding) {

        var cornerRadius = this.getRoundRectangleRadius(width, height);

        var halfWidth = width / 2;
        var halfHeight = height / 2;

        // Check intersections with straight line segments
        var straightLineIntersections = void 0;

        // Top segment, left to right
        {
          var topStartX = nodeX - halfWidth + cornerRadius - padding;
          var topStartY = nodeY - halfHeight - padding;
          var topEndX = nodeX + halfWidth - cornerRadius + padding;
          var topEndY = topStartY;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Right segment, top to bottom
        {
          var rightStartX = nodeX + halfWidth + padding;
          var rightStartY = nodeY - halfHeight + cornerRadius - padding;
          var rightEndX = rightStartX;
          var rightEndY = nodeY + halfHeight - cornerRadius + padding;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Bottom segment, left to right
        {
          var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
          var bottomStartY = nodeY + halfHeight + padding;
          var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
          var bottomEndY = bottomStartY;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Left segment, top to bottom
        {
          var leftStartX = nodeX - halfWidth - padding;
          var leftStartY = nodeY - halfHeight + cornerRadius - padding;
          var leftEndX = leftStartX;
          var leftEndY = nodeY + halfHeight - cornerRadius + padding;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Check intersections with arc segments
        var arcIntersections = void 0;

        // Top Left
        {
          var topLeftCenterX = nodeX - halfWidth + cornerRadius;
          var topLeftCenterY = nodeY - halfHeight + cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        // Top Right
        {
          var topRightCenterX = nodeX + halfWidth - cornerRadius;
          var topRightCenterY = nodeY - halfHeight + cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        // Bottom Right
        {
          var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
          var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        // Bottom Left
        {
          var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
          var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        return []; // if nothing
      };

      math.inLineVicinity = function (x, y, lx1, ly1, lx2, ly2, tolerance) {
        var t = tolerance;

        var x1 = Math.min(lx1, lx2);
        var x2 = Math.max(lx1, lx2);
        var y1 = Math.min(ly1, ly2);
        var y2 = Math.max(ly1, ly2);

        return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
      };

      math.inBezierVicinity = function (x, y, x1, y1, x2, y2, x3, y3, tolerance) {

        var bb = {
          x1: Math.min(x1, x3, x2) - tolerance,
          x2: Math.max(x1, x3, x2) + tolerance,
          y1: Math.min(y1, y3, y2) - tolerance,
          y2: Math.max(y1, y3, y2) + tolerance
        };

        // if outside the rough bounding box for the bezier, then it can't be a hit
        if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
          // console.log('bezier out of rough bb')
          return false;
        } else {
          // console.log('do more expensive check');
          return true;
        }
      };
      math.solveQuadratic = function (a, b, c, val) {
        c -= val;

        var r = b * b - 4 * a * c;

        if (r < 0) {
          return [];
        }

        var sqrtR = Math.sqrt(r);
        var denom = 2 * a;
        var root1 = (-b + sqrtR) / denom;
        var root2 = (-b - sqrtR) / denom;

        return [root1, root2];
      };

      math.solveCubic = function (a, b, c, d, result) {

        // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
        // r is the real component, i is the imaginary component

        // An implementation of the Cardano method from the year 1545
        // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

        b /= a;
        c /= a;
        d /= a;

        var discriminant = void 0,
            q = void 0,
            r = void 0,
            dum1 = void 0,
            s = void 0,
            t = void 0,
            term1 = void 0,
            r13 = void 0;

        q = (3.0 * c - b * b) / 9.0;
        r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
        r /= 54.0;

        discriminant = q * q * q + r * r;
        result[1] = 0;
        term1 = b / 3.0;

        if (discriminant > 0) {
          s = r + Math.sqrt(discriminant);
          s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
          t = r - Math.sqrt(discriminant);
          t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
          result[0] = -term1 + s + t;
          term1 += (s + t) / 2.0;
          result[4] = result[2] = -term1;
          term1 = Math.sqrt(3.0) * (-t + s) / 2;
          result[3] = term1;
          result[5] = -term1;
          return;
        }

        result[5] = result[3] = 0;

        if (discriminant === 0) {
          r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
          result[0] = -term1 + 2.0 * r13;
          result[4] = result[2] = -(r13 + term1);
          return;
        }

        q = -q;
        dum1 = q * q * q;
        dum1 = Math.acos(r / Math.sqrt(dum1));
        r13 = 2.0 * Math.sqrt(q);
        result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
        result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
        result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);

        return;
      };

      math.sqdistToQuadraticBezier = function (x, y, x1, y1, x2, y2, x3, y3) {

        // Find minimum distance by using the minimum of the distance
        // function between the given point and the curve

        // This gives the coefficients of the resulting cubic equation
        // whose roots tell us where a possible minimum is
        // (Coefficients are divided by 4)

        var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

        var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

        var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

        var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

        // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

        var roots = [];

        // Use the cubic solving algorithm
        this.solveCubic(a, b, c, d, roots);

        var zeroThreshold = 0.0000001;

        var params = [];

        for (var index = 0; index < 6; index += 2) {
          if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
            params.push(roots[index]);
          }
        }

        params.push(1.0);
        params.push(0.0);

        var minDistanceSquared = -1;

        var curX = void 0,
            curY = void 0,
            distSquared = void 0;
        for (var i = 0; i < params.length; i++) {
          curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;

          curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;

          distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
          // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
          if (minDistanceSquared >= 0) {
            if (distSquared < minDistanceSquared) {
              minDistanceSquared = distSquared;
            }
          } else {
            minDistanceSquared = distSquared;
          }
        }

        return minDistanceSquared;
      };

      math.sqdistToFiniteLine = function (x, y, x1, y1, x2, y2) {
        var offset = [x - x1, y - y1];
        var line = [x2 - x1, y2 - y1];

        var lineSq = line[0] * line[0] + line[1] * line[1];
        var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

        var dotProduct = offset[0] * line[0] + offset[1] * line[1];
        var adjSq = dotProduct * dotProduct / lineSq;

        if (dotProduct < 0) {
          return hypSq;
        }

        if (adjSq > lineSq) {
          return (x - x2) * (x - x2) + (y - y2) * (y - y2);
        }

        return hypSq - adjSq;
      };

      math.pointInsidePolygonPoints = function (x, y, points) {
        var x1 = void 0,
            y1 = void 0,
            x2 = void 0,
            y2 = void 0;
        var y3 = void 0;

        // Intersect with vertical line through (x, y)
        var up = 0;
        // let down = 0;
        for (var i = 0; i < points.length / 2; i++) {
          x1 = points[i * 2];
          y1 = points[i * 2 + 1];

          if (i + 1 < points.length / 2) {
            x2 = points[(i + 1) * 2];
            y2 = points[(i + 1) * 2 + 1];
          } else {
            x2 = points[(i + 1 - points.length / 2) * 2];
            y2 = points[(i + 1 - points.length / 2) * 2 + 1];
          }

          if (x1 == x && x2 == x) {
            // then ignore
          } else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {

            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

            if (y3 > y) {
              up++;
            }

            // if( y3 < y ){
            // down++;
            // }
          } else {
            continue;
          }
        }

        if (up % 2 === 0) {
          return false;
        } else {
          return true;
        }
      };

      math.pointInsidePolygon = function (x, y, basePoints, centerX, centerY, width, height, direction, padding) {

        //let direction = arguments[6];
        var transformedPoints = new Array(basePoints.length);

        // Gives negative angle
        var angle = void 0;

        if (direction[0] != null) {
          angle = Math.atan(direction[1] / direction[0]);

          if (direction[0] < 0) {
            angle = angle + Math.PI / 2;
          } else {
            angle = -angle - Math.PI / 2;
          }
        } else {
          angle = direction;
        }

        var cos = Math.cos(-angle);
        var sin = Math.sin(-angle);

        //    console.log("base: " + basePoints);
        for (var i = 0; i < transformedPoints.length / 2; i++) {
          transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);

          transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);

          transformedPoints[i * 2] += centerX;
          transformedPoints[i * 2 + 1] += centerY;
        }

        var points = void 0;

        if (padding > 0) {
          var expandedLineSet = this.expandPolygon(transformedPoints, -padding);

          points = this.joinLines(expandedLineSet);
        } else {
          points = transformedPoints;
        }

        return math.pointInsidePolygonPoints(x, y, points);
      };

      math.joinLines = function (lineSet) {

        var vertices = new Array(lineSet.length / 2);

        var currentLineStartX = void 0,
            currentLineStartY = void 0,
            currentLineEndX = void 0,
            currentLineEndY = void 0;
        var nextLineStartX = void 0,
            nextLineStartY = void 0,
            nextLineEndX = void 0,
            nextLineEndY = void 0;

        for (var i = 0; i < lineSet.length / 4; i++) {
          currentLineStartX = lineSet[i * 4];
          currentLineStartY = lineSet[i * 4 + 1];
          currentLineEndX = lineSet[i * 4 + 2];
          currentLineEndY = lineSet[i * 4 + 3];

          if (i < lineSet.length / 4 - 1) {
            nextLineStartX = lineSet[(i + 1) * 4];
            nextLineStartY = lineSet[(i + 1) * 4 + 1];
            nextLineEndX = lineSet[(i + 1) * 4 + 2];
            nextLineEndY = lineSet[(i + 1) * 4 + 3];
          } else {
            nextLineStartX = lineSet[0];
            nextLineStartY = lineSet[1];
            nextLineEndX = lineSet[2];
            nextLineEndY = lineSet[3];
          }

          var intersection = this.finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);

          vertices[i * 2] = intersection[0];
          vertices[i * 2 + 1] = intersection[1];
        }

        return vertices;
      };

      math.expandPolygon = function (points, pad) {

        var expandedLineSet = new Array(points.length * 2);

        var currentPointX = void 0,
            currentPointY = void 0,
            nextPointX = void 0,
            nextPointY = void 0;

        for (var i = 0; i < points.length / 2; i++) {
          currentPointX = points[i * 2];
          currentPointY = points[i * 2 + 1];

          if (i < points.length / 2 - 1) {
            nextPointX = points[(i + 1) * 2];
            nextPointY = points[(i + 1) * 2 + 1];
          } else {
            nextPointX = points[0];
            nextPointY = points[1];
          }

          // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

          // Assume CCW polygon winding

          var offsetX = nextPointY - currentPointY;
          var offsetY = -(nextPointX - currentPointX);

          // Normalize
          var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
          var normalizedOffsetX = offsetX / offsetLength;
          var normalizedOffsetY = offsetY / offsetLength;

          expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
          expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
          expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
          expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
        }

        return expandedLineSet;
      };

      math.intersectLineEllipse = function (x, y, centerX, centerY, ellipseWradius, ellipseHradius) {

        var dispX = centerX - x;
        var dispY = centerY - y;

        dispX /= ellipseWradius;
        dispY /= ellipseHradius;

        var len = Math.sqrt(dispX * dispX + dispY * dispY);

        var newLength = len - 1;

        if (newLength < 0) {
          return [];
        }

        var lenProportion = newLength / len;

        return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
      };

      math.checkInEllipse = function (x, y, width, height, centerX, centerY, padding) {
        x -= centerX;
        y -= centerY;

        x /= width / 2 + padding;
        y /= height / 2 + padding;

        return x * x + y * y <= 1;
      };

      // Returns intersections of increasing distance from line's start point
      math.intersectLineCircle = function (x1, y1, x2, y2, centerX, centerY, radius) {

        // Calculate d, direction vector of line
        var d = [x2 - x1, y2 - y1]; // Direction vector of line
        var f = [x1 - centerX, y1 - centerY];

        var a = d[0] * d[0] + d[1] * d[1];
        var b = 2 * (f[0] * d[0] + f[1] * d[1]);
        var c = f[0] * f[0] + f[1] * f[1] - radius * radius;

        var discriminant = b * b - 4 * a * c;

        if (discriminant < 0) {
          return [];
        }

        var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
        var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);

        var tMin = Math.min(t1, t2);
        var tMax = Math.max(t1, t2);
        var inRangeParams = [];

        if (tMin >= 0 && tMin <= 1) {
          inRangeParams.push(tMin);
        }

        if (tMax >= 0 && tMax <= 1) {
          inRangeParams.push(tMax);
        }

        if (inRangeParams.length === 0) {
          return [];
        }

        var nearIntersectionX = inRangeParams[0] * d[0] + x1;
        var nearIntersectionY = inRangeParams[0] * d[1] + y1;

        if (inRangeParams.length > 1) {

          if (inRangeParams[0] == inRangeParams[1]) {
            return [nearIntersectionX, nearIntersectionY];
          } else {

            var farIntersectionX = inRangeParams[1] * d[0] + x1;
            var farIntersectionY = inRangeParams[1] * d[1] + y1;

            return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
          }
        } else {
          return [nearIntersectionX, nearIntersectionY];
        }
      };

      math.findCircleNearPoint = function (centerX, centerY, radius, farX, farY) {

        var displacementX = farX - centerX;
        var displacementY = farY - centerY;
        var distance = Math.sqrt(displacementX * displacementX + displacementY * displacementY);

        var unitDisplacementX = displacementX / distance;
        var unitDisplacementY = displacementY / distance;

        return [centerX + unitDisplacementX * radius, centerY + unitDisplacementY * radius];
      };

      math.findMaxSqDistanceToOrigin = function (points) {
        var maxSqDistance = 0.000001;
        var sqDistance = void 0;

        for (var i = 0; i < points.length / 2; i++) {

          sqDistance = points[i * 2] * points[i * 2] + points[i * 2 + 1] * points[i * 2 + 1];

          if (sqDistance > maxSqDistance) {
            maxSqDistance = sqDistance;
          }
        }

        return maxSqDistance;
      };

      math.midOfThree = function (a, b, c) {
        if (b <= a && a <= c || c <= a && a <= b) {
          return a;
        } else if (a <= b && b <= c || c <= b && b <= a) {
          return b;
        } else {
          return c;
        }
      };

      // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
      math.finiteLinesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {

        var dx13 = x1 - x3;
        var dx21 = x2 - x1;
        var dx43 = x4 - x3;

        var dy13 = y1 - y3;
        var dy21 = y2 - y1;
        var dy43 = y4 - y3;

        var ua_t = dx43 * dy13 - dy43 * dx13;
        var ub_t = dx21 * dy13 - dy21 * dx13;
        var u_b = dy43 * dx21 - dx43 * dy21;

        if (u_b !== 0) {
          var ua = ua_t / u_b;
          var ub = ub_t / u_b;

          var flptThreshold = 0.001;
          var min = 0 - flptThreshold;
          var max = 1 + flptThreshold;

          if (min <= ua && ua <= max && min <= ub && ub <= max) {
            return [x1 + ua * dx21, y1 + ua * dy21];
          } else {
            if (!infiniteLines) {
              return [];
            } else {
              return [x1 + ua * dx21, y1 + ua * dy21];
            }
          }
        } else {
          if (ua_t === 0 || ub_t === 0) {

            // Parallel, coincident lines. Check if overlap

            // Check endpoint of second line
            if (this.midOfThree(x1, x2, x4) === x4) {
              return [x4, y4];
            }

            // Check start point of second line
            if (this.midOfThree(x1, x2, x3) === x3) {
              return [x3, y3];
            }

            // Endpoint of first line
            if (this.midOfThree(x3, x4, x2) === x2) {
              return [x2, y2];
            }

            return [];
          } else {

            // Parallel, non-coincident
            return [];
          }
        }
      };

      // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
      // intersect a node polygon (pts transformed)
      //
      // math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
      // intersect the points (no transform)
      math.polygonIntersectLine = function (x, y, basePoints, centerX, centerY, width, height, padding) {

        var intersections = [];
        var intersection = void 0;

        var transformedPoints = new Array(basePoints.length);

        var doTransform = true;
        if (arguments.length === 5) {
          doTransform = false;
        }

        var points = void 0;

        if (doTransform) {
          for (var i = 0; i < transformedPoints.length / 2; i++) {
            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
          }

          if (padding > 0) {
            var expandedLineSet = math.expandPolygon(transformedPoints, -padding);

            points = math.joinLines(expandedLineSet);
          } else {
            points = transformedPoints;
          }
        } else {
          points = basePoints;
        }

        var currentX = void 0,
            currentY = void 0,
            nextX = void 0,
            nextY = void 0;

        for (var _i = 0; _i < points.length / 2; _i++) {

          currentX = points[_i * 2];
          currentY = points[_i * 2 + 1];

          if (_i < points.length / 2 - 1) {
            nextX = points[(_i + 1) * 2];
            nextY = points[(_i + 1) * 2 + 1];
          } else {
            nextX = points[0];
            nextY = points[1];
          }

          intersection = this.finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

          if (intersection.length !== 0) {
            intersections.push(intersection[0], intersection[1]);
          }
        }

        return intersections;
      };

      math.shortenIntersection = function (intersection, offset, amount) {

        var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];

        var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);

        var lenRatio = (length - amount) / length;

        if (lenRatio < 0) {
          lenRatio = 0.00001;
        }

        return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
      };

      math.generateUnitNgonPointsFitToSquare = function (sides, rotationRadians) {
        var points = math.generateUnitNgonPoints(sides, rotationRadians);
        points = math.fitPolygonToSquare(points);

        return points;
      };

      math.fitPolygonToSquare = function (points) {
        var x = void 0,
            y = void 0;
        var sides = points.length / 2;
        var minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;

        for (var i = 0; i < sides; i++) {
          x = points[2 * i];
          y = points[2 * i + 1];

          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        // stretch factors
        var sx = 2 / (maxX - minX);
        var sy = 2 / (maxY - minY);

        for (var _i2 = 0; _i2 < sides; _i2++) {
          x = points[2 * _i2] = points[2 * _i2] * sx;
          y = points[2 * _i2 + 1] = points[2 * _i2 + 1] * sy;

          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        if (minY < -1) {
          for (var _i3 = 0; _i3 < sides; _i3++) {
            y = points[2 * _i3 + 1] = points[2 * _i3 + 1] + (-1 - minY);
          }
        }

        return points;
      };

      math.generateUnitNgonPoints = function (sides, rotationRadians) {

        var increment = 1.0 / sides * 2 * Math.PI;
        var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;

        startAngle += rotationRadians;

        var points = new Array(sides * 2);

        var currentAngle = void 0;
        for (var i = 0; i < sides; i++) {
          currentAngle = i * increment + startAngle;

          points[2 * i] = Math.cos(currentAngle); // x
          points[2 * i + 1] = Math.sin(-currentAngle); // y
        }

        return points;
      };

      math.getRoundRectangleRadius = function (width, height) {

        // Set the default radius, unless half of width or height is smaller than default
        return Math.min(width / 4, height / 4, 8);
      };

      math.getCutRectangleCornerLength = function () {
        return 8;
      };

      math.bezierPtsToQuadCoeff = function (p0, p1, p2) {
        return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
      };

      math.getBarrelCurveConstants = function (width, height) {
        // get curve width, height, and control point position offsets as a percentage of node height / width
        return {
          heightOffset: Math.min(15, 0.05 * height),
          widthOffset: Math.min(100, 0.25 * width),
          ctrlPtOffsetPct: 0.05
        };
      };

      module.exports = math;

      /***/
    },
    /* 3 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

      /***/
    },
    /* 4 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      // use this module to cherry pick functions into your prototype
      // (useful for functions shared between the core and collections, for example)

      // e.g.
      // let foo = define.foo({ /* params... */ })

      var util = __webpack_require__(1);

      var define = {};

      [__webpack_require__(44), __webpack_require__(46), __webpack_require__(47)].forEach(function (m) {
        util.assign(define, m);
      });

      module.exports = define;

      /***/
    },
    /* 5 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      /*!
      Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
      Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
      Licensed under The MIT License (http://opensource.org/licenses/MIT)
      */

      /*  promise states [Promises/A+ 2.1]  */
      var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */
      var STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */
      var STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */

      /*  promise object constructor  */
      var api = function api(executor) {
        /*  optionally support non-constructor/plain-function call  */
        if (!(this instanceof api)) return new api(executor);

        /*  initialize object  */
        this.id = 'Thenable/1.0.7';
        this.state = STATE_PENDING; /*  initial state  */
        this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */
        this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */
        this.onFulfilled = []; /*  initial handlers  */
        this.onRejected = []; /*  initial handlers  */

        /*  provide optional information-hiding proxy  */
        this.proxy = {
          then: this.then.bind(this)
        };

        /*  support optional executor function  */
        if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
      };

      /*  promise API methods  */
      api.prototype = {
        /*  promise resolving methods  */
        fulfill: function fulfill(value) {
          return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
        },
        reject: function reject(value) {
          return deliver(this, STATE_REJECTED, 'rejectReason', value);
        },

        /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
        then: function then(onFulfilled, onRejected) {
          var curr = this;
          var next = new api(); /*  [Promises/A+ 2.2.7]  */
          curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */
          curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */
          execute(curr);
          return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */
        }
      };

      /*  deliver an action  */
      var deliver = function deliver(curr, state, name, value) {
        if (curr.state === STATE_PENDING) {
          curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
          curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
          execute(curr);
        }
        return curr;
      };

      /*  execute all handlers  */
      var execute = function execute(curr) {
        if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
      };

      /*  execute particular set of handlers  */
      var execute_handlers = function execute_handlers(curr, name, value) {
        /* global setImmediate: true */
        /* global setTimeout: true */

        /*  short-circuit processing  */
        if (curr[name].length === 0) return;

        /*  iterate over all handlers, exactly once  */
        var handlers = curr[name];
        curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
        var func = function func() {
          for (var i = 0; i < handlers.length; i++) {
            handlers[i](value);
          } /*  [Promises/A+ 2.2.5]  */
        };

        /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */
        if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
      };

      /*  generate a resolver function  */
      var resolver = function resolver(cb, next, method) {
        return function (value) {
          if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
            next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
          else {
              var result;
              try {
                result = cb(value);
              } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
              catch (e) {
                next.reject(e); /*  [Promises/A+ 2.2.7.2]  */
                return;
              }
              resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */
            }
        };
      };

      /*  "Promise Resolution Procedure"  */ /*  [Promises/A+ 2.3]  */
      var resolve = function resolve(promise, x) {
        /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */
        if (promise === x || promise.proxy === x) {
          promise.reject(new TypeError('cannot resolve promise with itself'));
          return;
        }

        /*  surgically check for a "then" method
          (mainly to just call the "getter" of "then" only once)  */
        var then;
        if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function') {
          try {
            then = x.then;
          } /*  [Promises/A+ 2.3.3.1, 3.5]  */
          catch (e) {
            promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */
            return;
          }
        }

        /*  handle own Thenables    [Promises/A+ 2.3.2]
          and similar "thenables" [Promises/A+ 2.3.3]  */
        if (typeof then === 'function') {
          var resolved = false;
          try {
            /*  call retrieved "then" method */ /*  [Promises/A+ 2.3.3.3]  */
            then.call(x,
            /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */
            function (y) {
              if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
              if (y === x) /*  [Promises/A+ 3.6]  */
                promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
            },

            /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */
            function (r) {
              if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
              promise.reject(r);
            });
          } catch (e) {
            if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */
              promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */
          }
          return;
        }

        /*  handle other values  */
        promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
      };

      // so we always have Promise.all()
      api.all = function (ps) {
        return new api(function (resolveAll, rejectAll) {
          var vals = new Array(ps.length);
          var doneCount = 0;

          var fulfill = function fulfill(i, val) {
            vals[i] = val;
            doneCount++;

            if (doneCount === ps.length) {
              resolveAll(vals);
            }
          };

          for (var i = 0; i < ps.length; i++) {
            (function (i) {
              var p = ps[i];
              var isPromise = p != null && p.then != null;

              if (isPromise) {
                p.then(function (val) {
                  fulfill(i, val);
                }, function (err) {
                  rejectAll(err);
                });
              } else {
                var val = p;
                fulfill(i, val);
              }
            })(i);
          }
        });
      };

      api.resolve = function (val) {
        return new api(function (resolve, reject) {
          resolve(val);
        });
      };

      api.reject = function (val) {
        return new api(function (resolve, reject) {
          reject(val);
        });
      };

      module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

      /***/
    },
    /* 6 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var newQuery = __webpack_require__(10);

      var Selector = function Selector(selector) {
        var self = this;

        self._private = {
          selectorText: selector,
          invalid: true
        };

        if (selector == null || is.string(selector) && selector.match(/^\s*$/)) {

          self.length = 0;
        } else if (selector === '*' || selector === 'edge' || selector === 'node') {

          // make single, group-only selectors cheap to make and cheap to filter

          self[0] = newQuery();
          self[0].group = selector === '*' ? selector : selector + 's';
          self[0].groupOnly = true;
          self[0].length = 1;
          self._private.invalid = false;
          self.length = 1;
        } else if (is.elementOrCollection(selector)) {

          var collection = selector.collection();

          self[0] = newQuery();
          self[0].collection = collection;
          self[0].length = 1;
          self.length = 1;
        } else if (is.fn(selector)) {

          self[0] = newQuery();
          self[0].filter = selector;
          self[0].length = 1;
          self.length = 1;
        } else if (is.string(selector)) {
          if (!self.parse(selector)) {
            return;
          }
        } else {
          util.error('A selector must be created from a string; found ', selector);
          return;
        }

        self._private.invalid = false;
      };

      var selfn = Selector.prototype;

      selfn.valid = function () {
        return !this._private.invalid;
      };

      selfn.invalid = function () {
        return this._private.invalid;
      };

      selfn.text = function () {
        return this._private.selectorText;
      };

      selfn.size = function () {
        return this.length;
      };

      selfn.eq = function (i) {
        return this[i];
      };

      selfn.sameText = function (otherSel) {
        return this.text() === otherSel.text();
      };

      selfn.toString = selfn.selector = function () {

        if (this._private.toStringCache != null) {
          return this._private.toStringCache;
        }

        var i = void 0;
        var str = '';

        var clean = function clean(obj) {
          if (obj == null) {
            return '';
          } else {
            return obj;
          }
        };

        var cleanVal = function cleanVal(val) {
          if (is.string(val)) {
            return '"' + val + '"';
          } else {
            return clean(val);
          }
        };

        var space = function space(val) {
          return ' ' + val + ' ';
        };

        var queryToString = function queryToString(query) {
          var str = '';
          var j = void 0,
              sel = void 0;

          if (query.subject === query) {
            str += '$';
          }

          var group = clean(query.group);
          str += group.substring(0, group.length - 1);

          for (j = 0; j < query.data.length; j++) {
            var data = query.data[j];

            if (data.value) {
              str += '[' + data.field + space(clean(data.operator)) + cleanVal(data.value) + ']';
            } else {
              str += '[' + clean(data.operator) + data.field + ']';
            }
          }

          for (j = 0; j < query.meta.length; j++) {
            var meta = query.meta[j];
            str += '[[' + meta.field + space(clean(meta.operator)) + cleanVal(meta.value) + ']]';
          }

          for (j = 0; j < query.colonSelectors.length; j++) {
            sel = query.colonSelectors[i];
            str += sel;
          }

          for (j = 0; j < query.ids.length; j++) {
            sel = '#' + query.ids[i];
            str += sel;
          }

          for (j = 0; j < query.classes.length; j++) {
            sel = '.' + query.classes[j];
            str += sel;
          }

          if (query.source != null && query.target != null) {
            str = queryToString(query.source) + ' -> ' + queryToString(query.target);
          }

          if (query.connectedNodes != null) {
            var n = query.connectedNodes;

            str = queryToString(n[0]) + ' <-> ' + queryToString(n[1]);
          }

          if (query.parent != null) {
            str = queryToString(query.parent) + ' > ' + str;
          }

          if (query.ancestor != null) {
            str = queryToString(query.ancestor) + ' ' + str;
          }

          if (query.child != null) {
            str += ' > ' + queryToString(query.child);
          }

          if (query.descendant != null) {
            str += ' ' + queryToString(query.descendant);
          }

          return str;
        };

        for (i = 0; i < this.length; i++) {
          var query = this[i];

          str += queryToString(query);

          if (this.length > 1 && i < this.length - 1) {
            str += ', ';
          }
        }

        this._private.toStringCache = str;

        return str;
      };

      [__webpack_require__(50), __webpack_require__(53)].forEach(function (p) {
        return util.assign(selfn, p);
      });

      module.exports = Selector;

      /***/
    },
    /* 7 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Map = __webpack_require__(28);
      var Set = __webpack_require__(8);

      var Element = __webpack_require__(14);

      // factory for generating edge ids when no id is specified for a new element
      var idFactory = {
        generate: function generate(cy, element, tryThisId) {
          var id = tryThisId != null ? tryThisId : util.uuid();

          while (cy.hasElementWithId(id)) {
            id = util.uuid();
          }

          return id;
        }
      };

      // represents a set of nodes, edges, or both together
      var Collection = function Collection(cy, elements, options) {
        if (cy === undefined || !is.core(cy)) {
          util.error('A collection must have a reference to the core');
          return;
        }

        var map = new Map();
        var createdElements = false;

        if (!elements) {
          elements = [];
        } else if (elements.length > 0 && is.plainObject(elements[0]) && !is.element(elements[0])) {
          createdElements = true;

          // make elements from json and restore all at once later
          var eles = [];
          var elesIds = new Set();

          for (var i = 0, l = elements.length; i < l; i++) {
            var json = elements[i];

            if (json.data == null) {
              json.data = {};
            }

            var data = json.data;

            // make sure newly created elements have valid ids
            if (data.id == null) {
              data.id = idFactory.generate(cy, json);
            } else if (cy.hasElementWithId(data.id) || elesIds.has(data.id)) {
              continue; // can't create element if prior id already exists
            }

            var ele = new Element(cy, json, false);
            eles.push(ele);
            elesIds.add(data.id);
          }

          elements = eles;
        }

        this.length = 0;

        for (var _i = 0, _l = elements.length; _i < _l; _i++) {
          var element = elements[_i];
          if (element == null) {
            continue;
          }

          var id = element._private.data.id;

          if (options == null || options.unique && !map.has(id)) {
            map.set(id, {
              index: this.length,
              ele: element
            });

            this[this.length] = element;
            this.length++;
          }
        }

        this._private = {
          cy: cy,
          map: map
        };

        // restore the elements if we created them from json
        if (createdElements) {
          this.restore();
        }
      };

      // Functions
      ////////////////////////////////////////////////////////////////////////////////////////////////////

      // keep the prototypes in sync (an element has the same functions as a collection)
      // and use elefn and elesfn as shorthands to the prototypes
      var elesfn = Element.prototype = Collection.prototype;

      elesfn.instanceString = function () {
        return 'collection';
      };

      elesfn.spawn = function (cy, eles, opts) {
        if (!is.core(cy)) {
          // cy is optional
          opts = eles;
          eles = cy;
          cy = this.cy();
        }

        return new Collection(cy, eles, opts);
      };

      elesfn.spawnSelf = function () {
        return this.spawn(this);
      };

      elesfn.cy = function () {
        return this._private.cy;
      };

      elesfn.renderer = function () {
        return this._private.cy.renderer();
      };

      elesfn.element = function () {
        return this[0];
      };

      elesfn.collection = function () {
        if (is.collection(this)) {
          return this;
        } else {
          // an element
          return new Collection(this._private.cy, [this]);
        }
      };

      elesfn.unique = function () {
        return new Collection(this._private.cy, this, { unique: true });
      };

      elesfn.hasElementWithId = function (id) {
        return this._private.map.has(id);
      };

      elesfn.getElementById = function (id) {
        var cy = this._private.cy;
        var entry = this._private.map.get(id);

        return entry ? entry.ele : new Collection(cy); // get ele or empty collection
      };

      elesfn.$id = elesfn.getElementById;

      elesfn.poolIndex = function () {
        var cy = this._private.cy;
        var eles = cy._private.elements;
        var id = this._private.data.id;

        return eles._private.map.get(id).index;
      };

      elesfn.json = function (obj) {
        var ele = this.element();
        var cy = this.cy();

        if (ele == null && obj) {
          return this;
        } // can't set to no eles

        if (ele == null) {
          return undefined;
        } // can't get from no eles

        var p = ele._private;

        if (is.plainObject(obj)) {
          // set

          cy.startBatch();

          if (obj.data) {
            ele.data(obj.data);
          }

          if (obj.position) {
            ele.position(obj.position);
          }

          // ignore group -- immutable

          var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
            var obj_k = obj[k];

            if (obj_k != null && obj_k !== p[k]) {
              if (obj_k) {
                ele[trueFnName]();
              } else {
                ele[falseFnName]();
              }
            }
          };

          checkSwitch('removed', 'remove', 'restore');

          checkSwitch('selected', 'select', 'unselect');

          checkSwitch('selectable', 'selectify', 'unselectify');

          checkSwitch('locked', 'lock', 'unlock');

          checkSwitch('grabbable', 'grabify', 'ungrabify');

          if (obj.classes != null) {
            ele.classes(obj.classes);
          }

          cy.endBatch();

          return this;
        } else if (obj === undefined) {
          // get

          var json = {
            data: util.copy(p.data),
            position: util.copy(p.position),
            group: p.group,
            removed: p.removed,
            selected: p.selected,
            selectable: p.selectable,
            locked: p.locked,
            grabbable: p.grabbable,
            classes: null
          };

          json.classes = '';

          var i = 0;
          p.classes.forEach(function (cls) {
            return json.classes += i++ === 0 ? cls : ' ' + cls;
          });

          return json;
        }
      };

      elesfn.jsons = function () {
        var jsons = [];

        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var json = ele.json();

          jsons.push(json);
        }

        return jsons;
      };

      elesfn.clone = function () {
        var cy = this.cy();
        var elesArr = [];

        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var json = ele.json();
          var clone = new Element(cy, json, false); // NB no restore

          elesArr.push(clone);
        }

        return new Collection(cy, elesArr);
      };
      elesfn.copy = elesfn.clone;

      elesfn.restore = function (notifyRenderer) {
        var self = this;
        var cy = self.cy();
        var cy_p = cy._private;

        if (notifyRenderer === undefined) {
          notifyRenderer = true;
        }

        // create arrays of nodes and edges, since we need to
        // restore the nodes first
        var nodes = [];
        var edges = [];
        var elements = void 0;
        for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
          var ele = self[_i2];

          if (!ele.removed()) {
            // don't need to handle this ele
            continue;
          }

          // keep nodes first in the array and edges after
          if (ele.isNode()) {
            // put to front of array if node
            nodes.push(ele);
          } else {
            // put to end of array if edge
            edges.push(ele);
          }
        }

        elements = nodes.concat(edges);

        var i = void 0;
        var removeFromElements = function removeFromElements() {
          elements.splice(i, 1);
          i--;
        };

        // now, restore each element
        for (i = 0; i < elements.length; i++) {
          var _ele = elements[i];

          var _private = _ele._private;
          var data = _private.data;

          // the traversal cache should start fresh when ele is added
          _ele.clearTraversalCache();

          // set id and validate
          if (data.id === undefined) {
            data.id = idFactory.generate(cy, _ele);
          } else if (is.number(data.id)) {
            data.id = '' + data.id; // now it's a string
          } else if (is.emptyString(data.id) || !is.string(data.id)) {
            util.error('Can not create element with invalid string ID `' + data.id + '`');

            // can't create element if it has empty string as id or non-string id
            removeFromElements();
            continue;
          } else if (cy.hasElementWithId(data.id)) {
            util.error('Can not create second element with ID `' + data.id + '`');

            // can't create element if one already has that id
            removeFromElements();
            continue;
          }

          var id = data.id; // id is finalised, now let's keep a ref

          if (_ele.isNode()) {
            // extra checks for nodes
            var pos = _private.position;

            // make sure the nodes have a defined position

            if (pos.x == null) {
              pos.x = 0;
            }

            if (pos.y == null) {
              pos.y = 0;
            }
          }

          if (_ele.isEdge()) {
            // extra checks for edges

            var edge = _ele;
            var fields = ['source', 'target'];
            var fieldsLength = fields.length;
            var badSourceOrTarget = false;
            for (var j = 0; j < fieldsLength; j++) {

              var field = fields[j];
              var val = data[field];

              if (is.number(val)) {
                val = data[field] = '' + data[field]; // now string
              }

              if (val == null || val === '') {
                // can't create if source or target is not defined properly
                util.error('Can not create edge `' + id + '` with unspecified ' + field);
                badSourceOrTarget = true;
              } else if (!cy.hasElementWithId(val)) {
                // can't create edge if one of its nodes doesn't exist
                util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
                badSourceOrTarget = true;
              }
            }

            if (badSourceOrTarget) {
              removeFromElements();continue;
            } // can't create this

            var src = cy.getElementById(data.source);
            var tgt = cy.getElementById(data.target);

            src._private.edges.push(edge);
            tgt._private.edges.push(edge);

            edge._private.source = src;
            edge._private.target = tgt;
          } // if is edge

          // create mock ids / indexes maps for element so it can be used like collections
          _private.map = new Map();
          _private.map.set(id, { ele: _ele, index: 0 });

          _private.removed = false;
          cy.addToPool(_ele);
        } // for each element

        // do compound node sanity checks
        for (var _i3 = 0; _i3 < nodes.length; _i3++) {
          // each node
          var node = nodes[_i3];
          var _data = node._private.data;

          if (is.number(_data.parent)) {
            // then automake string
            _data.parent = '' + _data.parent;
          }

          var parentId = _data.parent;

          var specifiedParent = parentId != null;

          if (specifiedParent) {
            var parent = cy.getElementById(parentId);

            if (parent.empty()) {
              // non-existant parent; just remove it
              _data.parent = undefined;
            } else {
              var selfAsParent = false;
              var ancestor = parent;
              while (!ancestor.empty()) {
                if (node.same(ancestor)) {
                  // mark self as parent and remove from data
                  selfAsParent = true;
                  _data.parent = undefined; // remove parent reference

                  // exit or we loop forever
                  break;
                }

                ancestor = ancestor.parent();
              }

              if (!selfAsParent) {
                // connect with children
                parent[0]._private.children.push(node);
                node._private.parent = parent[0];

                // let the core know we have a compound graph
                cy_p.hasCompoundNodes = true;
              }
            } // else
          } // if specified parent
        } // for each node

        if (elements.length > 0) {
          var restored = new Collection(cy, elements);

          for (var _i4 = 0; _i4 < restored.length; _i4++) {
            var _ele2 = restored[_i4];

            if (_ele2.isNode()) {
              continue;
            }

            // adding an edge invalidates the traversal caches for the parallel edges
            _ele2.parallelEdges().clearTraversalCache();

            // adding an edge invalidates the traversal cache for the connected nodes
            _ele2.source().clearTraversalCache();
            _ele2.target().clearTraversalCache();
          }

          var toUpdateStyle = void 0;

          if (cy_p.hasCompoundNodes) {
            toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
          } else {
            toUpdateStyle = restored;
          }

          toUpdateStyle.dirtyCompoundBoundsCache().updateStyle(notifyRenderer);

          if (notifyRenderer) {
            restored.emitAndNotify('add');
          } else {
            restored.emit('add');
          }
        }

        return self; // chainability
      };

      elesfn.removed = function () {
        var ele = this[0];
        return ele && ele._private.removed;
      };

      elesfn.inside = function () {
        var ele = this[0];
        return ele && !ele._private.removed;
      };

      elesfn.remove = function (notifyRenderer) {
        var self = this;
        var removed = [];
        var elesToRemove = [];
        var elesToRemoveIds = {};
        var cy = self._private.cy;

        if (notifyRenderer === undefined) {
          notifyRenderer = true;
        }

        // add connected edges
        function addConnectedEdges(node) {
          var edges = node._private.edges;
          for (var i = 0; i < edges.length; i++) {
            add(edges[i]);
          }
        }

        // add descendant nodes
        function addChildren(node) {
          var children = node._private.children;

          for (var i = 0; i < children.length; i++) {
            add(children[i]);
          }
        }

        function add(ele) {
          var alreadyAdded = elesToRemoveIds[ele.id()];
          if (ele.removed() || alreadyAdded) {
            return;
          } else {
            elesToRemoveIds[ele.id()] = true;
          }

          if (ele.isNode()) {
            elesToRemove.push(ele); // nodes are removed last

            addConnectedEdges(ele);
            addChildren(ele);
          } else {
            elesToRemove.unshift(ele); // edges are removed first
          }
        }

        // make the list of elements to remove
        // (may be removing more than specified due to connected edges etc)

        for (var i = 0, l = self.length; i < l; i++) {
          var ele = self[i];

          add(ele);
        }

        function removeEdgeRef(node, edge) {
          var connectedEdges = node._private.edges;

          util.removeFromArray(connectedEdges, edge);

          // removing an edges invalidates the traversal cache for its nodes
          node.clearTraversalCache();
        }

        function removeParallelRefs(edge) {
          // removing an edge invalidates the traversal caches for the parallel edges
          edge.parallelEdges().clearTraversalCache();
        }

        var alteredParents = [];
        alteredParents.ids = {};

        function removeChildRef(parent, ele) {
          ele = ele[0];
          parent = parent[0];

          var children = parent._private.children;
          var pid = parent.id();

          util.removeFromArray(children, ele);

          if (!alteredParents.ids[pid]) {
            alteredParents.ids[pid] = true;
            alteredParents.push(parent);
          }
        }

        self.dirtyCompoundBoundsCache();

        cy.removeFromPool(elesToRemove); // remove from core pool

        for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
          var _ele3 = elesToRemove[_i5];

          // mark as removed
          _ele3._private.removed = true;

          // add to list of removed elements
          removed.push(_ele3);

          if (_ele3.isEdge()) {
            // remove references to this edge in its connected nodes
            var src = _ele3.source()[0];
            var tgt = _ele3.target()[0];

            removeEdgeRef(src, _ele3);
            removeEdgeRef(tgt, _ele3);
            removeParallelRefs(_ele3);
          } else {
            // remove reference to parent
            var parent = _ele3.parent();

            if (parent.length !== 0) {
              removeChildRef(parent, _ele3);
            }
          }
        }

        // check to see if we have a compound graph or not
        var elesStillInside = cy._private.elements;
        cy._private.hasCompoundNodes = false;
        for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
          var _ele4 = elesStillInside[_i6];

          if (_ele4.isParent()) {
            cy._private.hasCompoundNodes = true;
            break;
          }
        }

        var removedElements = new Collection(this.cy(), removed);
        if (removedElements.size() > 0) {
          // must manually notify since trigger won't do this automatically once removed

          if (notifyRenderer) {
            this.cy().notify({
              type: 'remove',
              eles: removedElements
            });
          }

          removedElements.emit('remove');
        }

        // the parents who were modified by the removal need their style updated
        for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
          var _ele5 = alteredParents[_i7];

          if (!_ele5.removed()) {
            _ele5.updateStyle();
          }
        }

        return new Collection(cy, removed);
      };

      elesfn.move = function (struct) {
        var cy = this._private.cy;

        if (struct.source !== undefined || struct.target !== undefined) {
          var srcId = struct.source;
          var tgtId = struct.target;
          var srcExists = cy.hasElementWithId(srcId);
          var tgtExists = cy.hasElementWithId(tgtId);

          if (srcExists || tgtExists) {
            var jsons = this.jsons();

            this.remove();

            for (var i = 0; i < jsons.length; i++) {
              var json = jsons[i];
              var ele = this[i];

              if (json.group === 'edges') {
                if (srcExists) {
                  json.data.source = srcId;
                }

                if (tgtExists) {
                  json.data.target = tgtId;
                }

                json.scratch = ele._private.scratch;
              }
            }

            return cy.add(jsons);
          }
        } else if (struct.parent !== undefined) {
          // move node to new parent
          var parentId = struct.parent;
          var parentExists = parentId === null || cy.hasElementWithId(parentId);

          if (parentExists) {
            var _jsons = this.jsons();
            var descs = this.descendants();
            var descsEtcJsons = descs.union(descs.union(this).connectedEdges()).jsons();

            this.remove(); // NB: also removes descendants and their connected edges

            for (var _i8 = 0; _i8 < _jsons.length; _i8++) {
              var _json = _jsons[_i8];
              var _ele6 = this[_i8];

              if (_json.group === 'nodes') {
                _json.data.parent = parentId === null ? undefined : parentId;

                _json.scratch = _ele6._private.scratch;
              }
            }

            return cy.add(_jsons.concat(descsEtcJsons));
          }
        }

        return this; // if nothing done
      };

      [__webpack_require__(29), __webpack_require__(43), __webpack_require__(48), __webpack_require__(49), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(62), __webpack_require__(63), __webpack_require__(64), __webpack_require__(7), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69)].forEach(function (props) {
        util.extend(elesfn, props);
      });

      module.exports = Collection;

      /***/
    },
    /* 8 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /* global Set */

      var undef = true ? 'undefined' : _typeof(undefined);

      var ObjectSet = function () {
        function ObjectSet(arrayOrObjectSet) {
          _classCallCheck(this, ObjectSet);

          this._obj = Object.create(null);

          if (arrayOrObjectSet != null) {
            var arr = void 0;

            if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
              arr = arrayOrObjectSet.toArray();
            } else {
              arr = arrayOrObjectSet;
            }

            for (var i = 0; i < arr.length; i++) {
              this.add(arr[i]);
            }
          }
        }

        _createClass(ObjectSet, [{
          key: 'instanceString',
          value: function instanceString() {
            return 'set';
          }
        }, {
          key: 'add',
          value: function add(val) {
            this._obj[val] = 1;
          }
        }, {
          key: 'delete',
          value: function _delete(val) {
            this._obj[val] = 0;
          }
        }, {
          key: 'clear',
          value: function clear() {
            this._obj = Object.create(null);
          }
        }, {
          key: 'has',
          value: function has(val) {
            return this._obj[val] === 1;
          }
        }, {
          key: 'toArray',
          value: function toArray() {
            var _this = this;

            return Object.keys(this._obj).filter(function (key) {
              return _this.has(key);
            });
          }
        }, {
          key: 'forEach',
          value: function forEach(callback, thisArg) {
            return this.toArray().forEach(callback, thisArg);
          }
        }, {
          key: 'size',
          get: function get() {
            return this.toArray().length;
          }
        }]);

        return ObjectSet;
      }();

      // TODO use the stdlib Set in future...
      // module.exports = typeof Set !== undef ? Set : ObjectSet;


      module.exports = ObjectSet;

      /***/
    },
    /* 9 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = __webpack_require__(32);

      /***/
    },
    /* 10 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      // storage for parsed queries

      var newQuery = function newQuery() {
        return {
          classes: [],
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      module.exports = newQuery;

      /***/
    },
    /* 11 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Event = __webpack_require__(16);

      var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")
      var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

      var defaults = {
        qualifierCompare: function qualifierCompare(q1, q2) {
          return q1 === q2;
        },
        eventMatches: function eventMatches() /*context, listener, eventObj*/{
          return true;
        },
        eventFields: function eventFields() /*context*/{
          return {};
        },
        callbackContext: function callbackContext(context /*, listener, eventObj*/) {
          return context;
        },
        beforeEmit: function beforeEmit() /* context, listener, eventObj */{},
        afterEmit: function afterEmit() /* context, listener, eventObj */{},
        bubble: function bubble() /*context*/{
          return false;
        },
        parent: function parent() /*context*/{
          return null;
        },
        context: undefined
      };

      function Emitter(opts) {
        util.assign(this, defaults, opts);

        this.listeners = [];
        this.emitting = 0;
      }

      var p = Emitter.prototype;

      var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
        if (is.fn(qualifier)) {
          callback = qualifier;
          qualifier = null;
        }

        if (confOverrides) {
          if (conf == null) {
            conf = confOverrides;
          } else {
            conf = util.assign({}, conf, confOverrides);
          }
        }

        var eventList = events.split(/\s+/);

        for (var i = 0; i < eventList.length; i++) {
          var evt = eventList[i];

          if (is.emptyString(evt)) {
            continue;
          }

          var match = evt.match(eventRegex); // type[.namespace]

          if (match) {
            var type = match[1];
            var namespace = match[2] ? match[2] : null;
            var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

            if (ret === false) {
              break;
            } // allow exiting early
          }
        }
      };

      var makeEventObj = function makeEventObj(self, obj) {
        return new Event(obj.type, util.assign(obj, self.eventFields(self.context)));
      };

      var forEachEventObj = function forEachEventObj(self, handler, events) {
        if (is.event(events)) {
          handler(self, events);

          return;
        } else if (is.plainObject(events)) {
          handler(self, makeEventObj(self, events));

          return;
        }

        var eventList = events.split(/\s+/);

        for (var i = 0; i < eventList.length; i++) {
          var evt = eventList[i];

          if (is.emptyString(evt)) {
            continue;
          }

          var match = evt.match(eventRegex); // type[.namespace]

          if (match) {
            var type = match[1];
            var namespace = match[2] ? match[2] : null;
            var eventObj = makeEventObj(self, {
              type: type,
              namespace: namespace,
              target: self.context
            });

            handler(self, eventObj);
          }
        }
      };

      p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
        forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
          if (is.fn(callback)) {
            self.listeners.push({
              event: event, // full event string
              callback: callback, // callback to run
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              qualifier: qualifier, // a restriction on whether to match this emitter
              conf: conf // additional configuration
            });
          }
        }, events, qualifier, callback, conf, confOverrides);

        return this;
      };

      p.one = function (events, qualifier, callback, conf) {
        return this.on(events, qualifier, callback, conf, { one: true });
      };

      p.removeListener = p.off = function (events, qualifier, callback, conf) {
        var _this = this;

        if (this.emitting !== 0) {
          this.listeners = util.copyArray(this.listeners);
        }

        var listeners = this.listeners;

        var _loop = function _loop(i) {
          var listener = listeners[i];

          forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {
            if (listener.type === type && (!namespace || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
              listeners.splice(i, 1);

              return false;
            }
          }, events, qualifier, callback, conf);
        };

        for (var i = listeners.length - 1; i >= 0; i--) {
          _loop(i);
        }

        return this;
      };

      p.emit = p.trigger = function (events, extraParams, manualCallback) {
        var listeners = this.listeners;
        var numListenersBeforeEmit = listeners.length;

        this.emitting++;

        if (!is.array(extraParams)) {
          extraParams = [extraParams];
        }

        forEachEventObj(this, function (self, eventObj) {
          if (manualCallback != null) {
            listeners = [{
              event: eventObj.event,
              type: eventObj.type,
              namespace: eventObj.namespace,
              callback: manualCallback
            }];

            numListenersBeforeEmit = listeners.length;
          }

          var _loop2 = function _loop2(i) {
            var listener = listeners[i];

            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
              var args = [eventObj];

              if (extraParams != null) {
                util.push(args, extraParams);
              }

              self.beforeEmit(self.context, listener, eventObj);

              if (listener.conf && listener.conf.one) {
                self.listeners = self.listeners.filter(function (l) {
                  return l !== listener;
                });
              }

              var context = self.callbackContext(self.context, listener, eventObj);
              var ret = listener.callback.apply(context, args);

              self.afterEmit(self.context, listener, eventObj);

              if (ret === false) {
                eventObj.stopPropagation();
                eventObj.preventDefault();
              }
            } // if listener matches
          };

          for (var i = 0; i < numListenersBeforeEmit; i++) {
            _loop2(i);
          } // for listener

          if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
            self.parent(self.context).emit(eventObj, extraParams);
          }
        }, events);

        this.emitting--;

        return this;
      };

      module.exports = Emitter;

      /***/
    },
    /* 12 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);
      var util = __webpack_require__(1);
      var Collection = __webpack_require__(7);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);
      var define = __webpack_require__(4);

      var Core = function Core(opts) {
        var cy = this;

        opts = util.extend({}, opts);

        var container = opts.container;

        // allow for passing a wrapped jquery object
        // e.g. cytoscape({ container: $('#cy') })
        if (container && !is.htmlElement(container) && is.htmlElement(container[0])) {
          container = container[0];
        }

        var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
        reg = reg || {};

        if (reg && reg.cy) {
          reg.cy.destroy();

          reg = {}; // old instance => replace reg completely
        }

        var readies = reg.readies = reg.readies || [];

        if (container) {
          container._cyreg = reg;
        } // make sure container assoc'd reg points to this cy
        reg.cy = cy;

        var head = window !== undefined && container !== undefined && !opts.headless;
        var options = opts;
        options.layout = util.extend({ name: head ? 'grid' : 'null' }, options.layout);
        options.renderer = util.extend({ name: head ? 'canvas' : 'null' }, options.renderer);

        var defVal = function defVal(def, val, altVal) {
          if (val !== undefined) {
            return val;
          } else if (altVal !== undefined) {
            return altVal;
          } else {
            return def;
          }
        };

        var _p = this._private = {
          container: container, // html dom ele container
          ready: false, // whether ready has been triggered
          options: options, // cached options
          elements: new Collection(this), // elements in the graph
          listeners: [], // list of listeners
          aniEles: new Collection(this), // elements being animated
          scratch: {}, // scratch object for core
          layout: null,
          renderer: null,
          destroyed: false, // whether destroy was called
          notificationsEnabled: true, // whether notifications are sent to the renderer
          minZoom: 1e-50,
          maxZoom: 1e50,
          zoomingEnabled: defVal(true, options.zoomingEnabled),
          userZoomingEnabled: defVal(true, options.userZoomingEnabled),
          panningEnabled: defVal(true, options.panningEnabled),
          userPanningEnabled: defVal(true, options.userPanningEnabled),
          boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
          autolock: defVal(false, options.autolock, options.autolockNodes),
          autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
          autounselectify: defVal(false, options.autounselectify),
          styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
          zoom: is.number(options.zoom) ? options.zoom : 1,
          pan: {
            x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
            y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
          },
          animation: { // object for currently-running animations
            current: [],
            queue: []
          },
          hasCompoundNodes: false
        };

        this.createEmitter();

        // set selection type
        var selType = options.selectionType;
        if (selType === undefined || selType !== 'additive' && selType !== 'single') {
          // then set default

          _p.selectionType = 'single';
        } else {
          _p.selectionType = selType;
        }

        // init zoom bounds
        if (is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom) {
          _p.minZoom = options.minZoom;
          _p.maxZoom = options.maxZoom;
        } else if (is.number(options.minZoom) && options.maxZoom === undefined) {
          _p.minZoom = options.minZoom;
        } else if (is.number(options.maxZoom) && options.minZoom === undefined) {
          _p.maxZoom = options.maxZoom;
        }

        var loadExtData = function loadExtData(extData, next) {
          var anyIsPromise = extData.some(is.promise);

          if (anyIsPromise) {
            return Promise.all(extData).then(next); // load all data asynchronously, then exec rest of init
          } else {
            next(extData); // exec synchronously for convenience
          }
        };

        // start with the default stylesheet so we have something before loading an external stylesheet
        if (_p.styleEnabled) {
          cy.setStyle([]);
        }

        // create the renderer
        cy.initRenderer(util.extend({
          hideEdgesOnViewport: options.hideEdgesOnViewport,
          textureOnViewport: options.textureOnViewport,
          wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
          motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
          motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
          pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
          desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
          touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
        }, options.renderer));

        var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
          cy.notifications(false);

          // remove old elements
          var oldEles = cy.mutableElements();
          if (oldEles.length > 0) {
            oldEles.remove();
          }

          if (elements != null) {
            if (is.plainObject(elements) || is.array(elements)) {
              cy.add(elements);
            }
          }

          cy.one('layoutready', function (e) {
            cy.notifications(true);
            cy.emit(e); // we missed this event by turning notifications off, so pass it on

            cy.notify({
              type: 'load',
              eles: cy.mutableElements()
            });

            cy.one('load', onload);
            cy.emit('load');
          }).one('layoutstop', function () {
            cy.one('done', ondone);
            cy.emit('done');
          });

          var layoutOpts = util.extend({}, cy._private.options.layout);
          layoutOpts.eles = cy.elements();

          cy.layout(layoutOpts).run();
        };

        loadExtData([options.style, options.elements], function (thens) {
          var initStyle = thens[0];
          var initEles = thens[1];

          // init style
          if (_p.styleEnabled) {
            cy.style().append(initStyle);
          }

          // initial load
          setElesAndLayout(initEles, function () {
            // onready
            cy.startAnimationLoop();
            _p.ready = true;

            // if a ready callback is specified as an option, the bind it
            if (is.fn(options.ready)) {
              cy.on('ready', options.ready);
            }

            // bind all the ready handlers registered before creating this instance
            for (var i = 0; i < readies.length; i++) {
              var fn = readies[i];
              cy.on('ready', fn);
            }
            if (reg) {
              reg.readies = [];
            } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

            cy.emit('ready');
          }, options.done);
        });
      };

      var corefn = Core.prototype; // short alias

      util.extend(corefn, {
        instanceString: function instanceString() {
          return 'core';
        },

        isReady: function isReady() {
          return this._private.ready;
        },

        isDestroyed: function isDestroyed() {
          return this._private.destroyed;
        },

        ready: function ready(fn) {
          if (this.isReady()) {
            this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
          } else {
            this.on('ready', fn);
          }

          return this;
        },

        destroy: function destroy() {
          var cy = this;
          if (cy.isDestroyed()) return;

          cy.stopAnimationLoop();

          cy.destroyRenderer();

          this.emit('destroy');

          cy._private.destroyed = true;

          return cy;
        },

        hasElementWithId: function hasElementWithId(id) {
          return this._private.elements.hasElementWithId(id);
        },

        getElementById: function getElementById(id) {
          return this._private.elements.getElementById(id);
        },

        selectionType: function selectionType() {
          return this._private.selectionType;
        },

        hasCompoundNodes: function hasCompoundNodes() {
          return this._private.hasCompoundNodes;
        },

        headless: function headless() {
          return this._private.options.renderer.name === 'null';
        },

        styleEnabled: function styleEnabled() {
          return this._private.styleEnabled;
        },

        addToPool: function addToPool(eles) {
          this._private.elements.merge(eles);

          return this; // chaining
        },

        removeFromPool: function removeFromPool(eles) {
          this._private.elements.unmerge(eles);

          return this;
        },

        container: function container() {
          return this._private.container;
        },

        options: function options() {
          return util.copy(this._private.options);
        },

        json: function json(obj) {
          var cy = this;
          var _p = cy._private;
          var eles = cy.mutableElements();

          if (is.plainObject(obj)) {
            // set

            cy.startBatch();

            if (obj.elements) {
              var idInJson = {};

              var updateEles = function updateEles(jsons, gr) {
                for (var i = 0; i < jsons.length; i++) {
                  var json = jsons[i];
                  var id = json.data.id;
                  var ele = cy.getElementById(id);

                  idInJson[id] = true;

                  if (ele.length !== 0) {
                    // existing element should be updated
                    ele.json(json);
                  } else {
                    // otherwise should be added
                    if (gr) {
                      cy.add(util.extend({ group: gr }, json));
                    } else {
                      cy.add(json);
                    }
                  }
                }
              };

              if (is.array(obj.elements)) {
                // elements: []
                updateEles(obj.elements);
              } else {
                // elements: { nodes: [], edges: [] }
                var grs = ['nodes', 'edges'];
                for (var i = 0; i < grs.length; i++) {
                  var gr = grs[i];
                  var elements = obj.elements[gr];

                  if (is.array(elements)) {
                    updateEles(elements, gr);
                  }
                }
              }

              // elements not specified in json should be removed
              eles.stdFilter(function (ele) {
                return !idInJson[ele.id()];
              }).remove();
            }

            if (obj.style) {
              cy.style(obj.style);
            }

            if (obj.zoom != null && obj.zoom !== _p.zoom) {
              cy.zoom(obj.zoom);
            }

            if (obj.pan) {
              if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
                cy.pan(obj.pan);
              }
            }

            var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

            for (var _i = 0; _i < fields.length; _i++) {
              var f = fields[_i];

              if (obj[f] != null) {
                cy[f](obj[f]);
              }
            }

            cy.endBatch();

            return this; // chaining
          } else if (obj === undefined) {
            // get
            var json = {};

            json.elements = {};
            eles.forEach(function (ele) {
              var group = ele.group();

              if (!json.elements[group]) {
                json.elements[group] = [];
              }

              json.elements[group].push(ele.json());
            });

            if (this._private.styleEnabled) {
              json.style = cy.style().json();
            }

            json.zoomingEnabled = cy._private.zoomingEnabled;
            json.userZoomingEnabled = cy._private.userZoomingEnabled;
            json.zoom = cy._private.zoom;
            json.minZoom = cy._private.minZoom;
            json.maxZoom = cy._private.maxZoom;
            json.panningEnabled = cy._private.panningEnabled;
            json.userPanningEnabled = cy._private.userPanningEnabled;
            json.pan = util.copy(cy._private.pan);
            json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
            json.renderer = util.copy(cy._private.options.renderer);
            json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
            json.textureOnViewport = cy._private.options.textureOnViewport;
            json.wheelSensitivity = cy._private.options.wheelSensitivity;
            json.motionBlur = cy._private.options.motionBlur;

            return json;
          }
        },

        scratch: define.data({
          field: 'scratch',
          bindingEvent: 'scratch',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'scratch',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true
        }),

        removeScratch: define.removeData({
          field: 'scratch',
          event: 'scratch',
          triggerFnName: 'trigger',
          triggerEvent: true
        })

      });

      corefn.$id = corefn.getElementById;

      [__webpack_require__(70), __webpack_require__(71), __webpack_require__(79), __webpack_require__(80), __webpack_require__(81), __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(85), __webpack_require__(94)].forEach(function (props) {
        util.extend(corefn, props);
      });

      module.exports = Core;

      /***/
    },
    /* 13 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = function memoize(fn, keyFn) {
        if (!keyFn) {
          keyFn = function keyFn() {
            if (arguments.length === 1) {
              return arguments[0];
            } else if (arguments.length === 0) {
              return 'undefined';
            }

            var args = [];

            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }

            return args.join('$');
          };
        }

        var memoizedFn = function memoizedFn() {
          var self = this;
          var args = arguments;
          var ret = void 0;
          var k = keyFn.apply(self, args);
          var cache = memoizedFn.cache;

          if (!(ret = cache[k])) {
            ret = cache[k] = fn.apply(self, args);
          }

          return ret;
        };

        memoizedFn.cache = {};

        return memoizedFn;
      };

      /***/
    },
    /* 14 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Set = __webpack_require__(8);

      // represents a node or an edge
      var Element = function Element(cy, params, restore) {
        restore = restore === undefined || restore ? true : false;

        if (cy === undefined || params === undefined || !is.core(cy)) {
          util.error('An element must have a core reference and parameters set');
          return;
        }

        var group = params.group;

        // try to automatically infer the group if unspecified
        if (group == null) {
          if (params.data && params.data.source != null && params.data.target != null) {
            group = 'edges';
          } else {
            group = 'nodes';
          }
        }

        // validate group
        if (group !== 'nodes' && group !== 'edges') {
          util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
          return;
        }

        // make the element array-like, just like a collection
        this.length = 1;
        this[0] = this;

        // NOTE: when something is added here, add also to ele.json()
        var _p = this._private = {
          cy: cy,
          single: true, // indicates this is an element
          data: params.data || {}, // data object
          position: params.position || {}, // (x, y) position pair
          autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
          autoHeight: undefined,
          autoPadding: undefined,
          compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read
          listeners: [], // array of bound listeners
          group: group, // string; 'nodes' or 'edges'
          style: {}, // properties as set by the style
          rstyle: {}, // properties for style sent from the renderer to the core
          styleCxts: [], // applied style contexts from the styler
          removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
          selected: params.selected ? true : false, // whether it's selected
          selectable: params.selectable === undefined ? true : params.selectable ? true : false, // whether it's selectable
          locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
          grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
          grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false, // whether the element can be grabbed
          active: false, // whether the element is active from user interaction
          classes: new Set(), // map ( className => true )
          animation: { // object for currently-running animations
            current: [],
            queue: []
          },
          rscratch: {}, // object in which the renderer can store information
          scratch: params.scratch || {}, // scratch objects
          edges: [], // array of connected edges
          children: [], // array of children
          parent: null, // parent ref
          traversalCache: {}, // cache of output of traversal functions
          backgrounding: false // whether background images are loading
        };

        // renderedPosition overrides if specified
        if (params.renderedPosition) {
          var rpos = params.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          _p.position = {
            x: (rpos.x - pan.x) / zoom,
            y: (rpos.y - pan.y) / zoom
          };
        }

        if (is.string(params.classes)) {
          var classes = params.classes.split(/\s+/);
          for (var i = 0, l = classes.length; i < l; i++) {
            var cls = classes[i];
            if (!cls || cls === '') {
              continue;
            }

            _p.classes.add(cls);
          }
        }

        if (params.style || params.css) {
          cy.style().applyBypass(this, params.style || params.css);
        }

        this.createEmitter();

        if (restore === undefined || restore) {
          this.restore();
        }
      };

      module.exports = Element;

      /***/
    },
    /* 15 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var stateSelectors = [{
        selector: ':selected',
        matches: function matches(ele) {
          return ele.selected();
        }
      }, {
        selector: ':unselected',
        matches: function matches(ele) {
          return !ele.selected();
        }
      }, {
        selector: ':selectable',
        matches: function matches(ele) {
          return ele.selectable();
        }
      }, {
        selector: ':unselectable',
        matches: function matches(ele) {
          return !ele.selectable();
        }
      }, {
        selector: ':locked',
        matches: function matches(ele) {
          return ele.locked();
        }
      }, {
        selector: ':unlocked',
        matches: function matches(ele) {
          return !ele.locked();
        }
      }, {
        selector: ':visible',
        matches: function matches(ele) {
          return ele.visible();
        }
      }, {
        selector: ':hidden',
        matches: function matches(ele) {
          return !ele.visible();
        }
      }, {
        selector: ':transparent',
        matches: function matches(ele) {
          return ele.transparent();
        }
      }, {
        selector: ':grabbed',
        matches: function matches(ele) {
          return ele.grabbed();
        }
      }, {
        selector: ':free',
        matches: function matches(ele) {
          return !ele.grabbed();
        }
      }, {
        selector: ':removed',
        matches: function matches(ele) {
          return ele.removed();
        }
      }, {
        selector: ':inside',
        matches: function matches(ele) {
          return !ele.removed();
        }
      }, {
        selector: ':grabbable',
        matches: function matches(ele) {
          return ele.grabbable();
        }
      }, {
        selector: ':ungrabbable',
        matches: function matches(ele) {
          return !ele.grabbable();
        }
      }, {
        selector: ':animated',
        matches: function matches(ele) {
          return ele.animated();
        }
      }, {
        selector: ':unanimated',
        matches: function matches(ele) {
          return !ele.animated();
        }
      }, {
        selector: ':parent',
        matches: function matches(ele) {
          return ele.isParent();
        }
      }, {
        selector: ':childless',
        matches: function matches(ele) {
          return ele.isChildless();
        }
      }, {
        selector: ':child',
        matches: function matches(ele) {
          return ele.isChild();
        }
      }, {
        selector: ':orphan',
        matches: function matches(ele) {
          return ele.isOrphan();
        }
      }, {
        selector: ':nonorphan',
        matches: function matches(ele) {
          return ele.isChild();
        }
      }, {
        selector: ':loop',
        matches: function matches(ele) {
          return ele.isLoop();
        }
      }, {
        selector: ':simple',
        matches: function matches(ele) {
          return ele.isSimple();
        }
      }, {
        selector: ':active',
        matches: function matches(ele) {
          return ele.active();
        }
      }, {
        selector: ':inactive',
        matches: function matches(ele) {
          return !ele.active();
        }
      }, {
        selector: ':backgrounding',
        matches: function matches(ele) {
          return ele.backgrounding();
        }
      }, {
        selector: ':nonbackgrounding',
        matches: function matches(ele) {
          return !ele.backgrounding();
        }
      }].sort(function (a, b) {
        // n.b. selectors that are starting substrings of others must have the longer ones first
        return util.sort.descending(a.selector, b.selector);
      });

      var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
        var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || function () {
          var selToFn = {};
          var s = void 0;

          for (var i = 0; i < stateSelectors.length; i++) {
            s = stateSelectors[i];

            selToFn[s.selector] = s.matches;
          }

          return selToFn;
        }();

        return lookup[sel](ele);
      };

      var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
        return s.selector;
      }).join('|') + ')';

      module.exports = { stateSelectors: stateSelectors, stateSelectorMatches: stateSelectorMatches, stateSelectorRegex: stateSelectorRegex };

      /***/
    },
    /* 16 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*!
      Event object based on jQuery events, MIT license
      
      https://jquery.org/license/
      https://tldrlegal.com/license/mit-license
      https://github.com/jquery/jquery/blob/master/src/event.js
      */

      var Event = function Event(src, props) {
        this.recycle(src, props);
      };

      function returnFalse() {
        return false;
      }

      function returnTrue() {
        return true;
      }

      // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
      Event.prototype = {
        instanceString: function instanceString() {
          return 'event';
        },

        recycle: function recycle(src, props) {
          this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

          if (src != null && src.preventDefault) {
            // Browser Event object
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
          } else if (src != null && src.type) {
            // Plain object containing all event details
            props = src;
          } else {
            // Event string
            this.type = src;
          }

          // Put explicitly provided properties onto the event object
          if (props != null) {
            // more efficient to manually copy fields we use
            this.originalEvent = props.originalEvent;
            this.type = props.type != null ? props.type : this.type;
            this.cy = props.cy;
            this.target = props.target;
            this.position = props.position;
            this.renderedPosition = props.renderedPosition;
            this.namespace = props.namespace;
            this.layout = props.layout;
          }

          if (this.cy != null && this.position != null && this.renderedPosition == null) {
            // create a rendered position based on the passed position
            var pos = this.position;
            var zoom = this.cy.zoom();
            var pan = this.cy.pan();

            this.renderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          // Create a timestamp if incoming event doesn't have one
          this.timeStamp = src && src.timeStamp || Date.now();
        },

        preventDefault: function preventDefault() {
          this.isDefaultPrevented = returnTrue;

          var e = this.originalEvent;
          if (!e) {
            return;
          }

          // if preventDefault exists run it on the original event
          if (e.preventDefault) {
            e.preventDefault();
          }
        },

        stopPropagation: function stopPropagation() {
          this.isPropagationStopped = returnTrue;

          var e = this.originalEvent;
          if (!e) {
            return;
          }

          // if stopPropagation exists run it on the original event
          if (e.stopPropagation) {
            e.stopPropagation();
          }
        },

        stopImmediatePropagation: function stopImmediatePropagation() {
          this.isImmediatePropagationStopped = returnTrue;
          this.stopPropagation();
        },

        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
      };

      module.exports = Event;

      /***/
    },
    /* 17 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
       *  and z-index (low to high).  These styles affect how this applies:
       *
       *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
       *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
       *      root to leaves of the compound graph.  The last drawn is `top`.
       *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
       *      `manual` ignores this convention and draws based on the `z-index` value setting.
       *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
       *      `z-index` will be drawn on top of an element with a lower `z-index`.
       */

      var util = __webpack_require__(1);

      var zIndexSort = function zIndexSort(a, b) {
        var cy = a.cy();
        var hasCompoundNodes = cy.hasCompoundNodes();

        function getDepth(ele) {
          var style = ele.pstyle('z-compound-depth');
          if (style.value === 'auto') {
            return hasCompoundNodes ? ele.zDepth() : 0;
          } else if (style.value === 'bottom') {
            return -1;
          } else if (style.value === 'top') {
            return util.MAX_INT;
          }
          // 'orphan'
          return 0;
        }
        var depthDiff = getDepth(a) - getDepth(b);
        if (depthDiff !== 0) {
          return depthDiff;
        }

        function getEleDepth(ele) {
          var style = ele.pstyle('z-index-compare');
          if (style.value === 'auto') {
            return ele.isNode() ? 1 : 0;
          }
          // 'manual'
          return 0;
        }
        var eleDiff = getEleDepth(a) - getEleDepth(b);
        if (eleDiff !== 0) {
          return eleDiff;
        }

        var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;
        if (zDiff !== 0) {
          return zDiff;
        }
        // compare indices in the core (order added to graph w/ last on top)
        return a.poolIndex() - b.poolIndex();
      };

      module.exports = zIndexSort;

      /***/
    },
    /* 18 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var Style = function Style(cy) {

        if (!(this instanceof Style)) {
          return new Style(cy);
        }

        if (!is.core(cy)) {
          util.error('A style must have a core reference');
          return;
        }

        this._private = {
          cy: cy,
          coreStyle: {}
        };

        this.length = 0;

        this.resetToDefault();
      };

      var styfn = Style.prototype;

      styfn.instanceString = function () {
        return 'style';
      };

      // remove all contexts
      styfn.clear = function () {
        for (var i = 0; i < this.length; i++) {
          this[i] = undefined;
        }
        this.length = 0;

        var _p = this._private;

        _p.newStyle = true;

        return this; // chaining
      };

      styfn.resetToDefault = function () {
        this.clear();
        this.addDefaultStylesheet();

        return this;
      };

      // builds a style object for the 'core' selector
      styfn.core = function () {
        return this._private.coreStyle;
      };

      // create a new context from the specified selector string and switch to that context
      styfn.selector = function (selectorStr) {
        // 'core' is a special case and does not need a selector
        var selector = selectorStr === 'core' ? null : new Selector(selectorStr);

        var i = this.length++; // new context means new index
        this[i] = {
          selector: selector,
          properties: [],
          mappedProperties: [],
          index: i
        };

        return this; // chaining
      };

      // add one or many css rules to the current context
      styfn.css = function () {
        var self = this;
        var args = arguments;

        switch (args.length) {
          case 1:
            var map = args[0];

            for (var i = 0; i < self.properties.length; i++) {
              var prop = self.properties[i];
              var mapVal = map[prop.name];

              if (mapVal === undefined) {
                mapVal = map[util.dash2camel(prop.name)];
              }

              if (mapVal !== undefined) {
                this.cssRule(prop.name, mapVal);
              }
            }

            break;

          case 2:
            this.cssRule(args[0], args[1]);
            break;

          default:
            break; // do nothing if args are invalid
        }

        return this; // chaining
      };
      styfn.style = styfn.css;

      // add a single css rule to the current context
      styfn.cssRule = function (name, value) {
        // name-value pair
        var property = this.parse(name, value);

        // add property to current context if valid
        if (property) {
          var i = this.length - 1;
          this[i].properties.push(property);
          this[i].properties[property.name] = property; // allow access by name as well

          if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
            this._private.hasPie = true;
          }

          if (property.mapped) {
            this[i].mappedProperties.push(property);
          }

          // add to core style if necessary
          var currentSelectorIsCore = !this[i].selector;
          if (currentSelectorIsCore) {
            this._private.coreStyle[property.name] = property;
          }
        }

        return this; // chaining
      };

      styfn.append = function (style) {
        if (is.stylesheet(style)) {
          style.appendToStyle(this);
        } else if (is.array(style)) {
          this.appendFromJson(style);
        } else if (is.string(style)) {
          this.appendFromString(style);
        } // you probably wouldn't want to append a Style, since you'd duplicate the default parts

        return this;
      };

      // static function
      Style.fromJson = function (cy, json) {
        var style = new Style(cy);

        style.fromJson(json);

        return style;
      };

      Style.fromString = function (cy, string) {
        return new Style(cy).fromString(string);
      };

      [__webpack_require__(86), __webpack_require__(87), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(91), __webpack_require__(92), __webpack_require__(93)].forEach(function (props) {
        util.extend(styfn, props);
      });

      Style.types = styfn.types;
      Style.properties = styfn.properties;

      module.exports = Style;

      /***/
    },
    /* 19 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var fullFpsTime = 1000 / 60; // assume 60 frames per second

      module.exports = {
        setupDequeueing: function setupDequeueing(opts) {
          return function setupDequeueingImpl() {
            var self = this;
            var r = this.renderer;

            if (self.dequeueingSetup) {
              return;
            } else {
              self.dequeueingSetup = true;
            }

            var queueRedraw = util.debounce(function () {
              r.redrawHint('eles', true);
              r.redrawHint('drag', true);

              r.redraw();
            }, opts.deqRedrawThreshold);

            var dequeue = function dequeue(willDraw, frameStartTime) {
              var startTime = util.performanceNow();
              var avgRenderTime = r.averageRedrawTime;
              var renderTime = r.lastRedrawTime;
              var deqd = [];
              var extent = r.cy.extent();
              var pixelRatio = r.getPixelRatio();

              while (true) {
                var now = util.performanceNow();
                var duration = now - startTime;
                var frameDuration = now - frameStartTime;

                if (renderTime < fullFpsTime) {
                  // if we're rendering faster than the ideal fps, then do dequeueing
                  // during all of the remaining frame time

                  var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

                  if (frameDuration >= opts.deqFastCost * timeAvailable) {
                    break;
                  }
                } else {
                  if (willDraw) {
                    if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                      break;
                    }
                  } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
                    break;
                  }
                }

                var thisDeqd = opts.deq(self, pixelRatio, extent);

                if (thisDeqd.length > 0) {
                  for (var i = 0; i < thisDeqd.length; i++) {
                    deqd.push(thisDeqd[i]);
                  }
                } else {
                  break;
                }
              }

              // callbacks on dequeue
              if (deqd.length > 0) {
                opts.onDeqd(self, deqd);

                if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
                  queueRedraw();
                }
              }
            };

            var priority = opts.priority || util.noop;

            r.beforeRender(dequeue, priority(self));
          };
        }
      };

      /***/
    },
    /* 20 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Core = __webpack_require__(12);
      var extension = __webpack_require__(95);
      var Stylesheet = __webpack_require__(138);

      var cytoscape = function cytoscape(options) {
        // jshint ignore:line
        // if no options specified, use default
        if (options === undefined) {
          options = {};
        }

        // create instance
        if (is.plainObject(options)) {
          return new Core(options);
        }

        // allow for registration of extensions
        else if (is.string(options)) {
            return extension.apply(extension, arguments);
          }
      };

      // e.g. cytoscape.use( require('cytoscape-foo'), bar )
      cytoscape.use = function (ext) {
        var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

        args.unshift(cytoscape); // cytoscape is first arg to ext

        ext.apply(null, args);

        return this;
      };

      // replaced by build system
      cytoscape.version = __webpack_require__(139);

      // expose public apis (mostly for extensions)
      cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

      module.exports = cytoscape;

      /***/
    },
    /* 21 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      module.exports = {
        // get [r, g, b] from #abc or #aabbcc
        hex2tuple: function hex2tuple(hex) {
          if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
            return;
          }

          var shortHex = hex.length === 4;
          var r = void 0,
              g = void 0,
              b = void 0;
          var base = 16;

          if (shortHex) {
            r = parseInt(hex[1] + hex[1], base);
            g = parseInt(hex[2] + hex[2], base);
            b = parseInt(hex[3] + hex[3], base);
          } else {
            r = parseInt(hex[1] + hex[2], base);
            g = parseInt(hex[3] + hex[4], base);
            b = parseInt(hex[5] + hex[6], base);
          }

          return [r, g, b];
        },

        // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
        hsl2tuple: function hsl2tuple(hsl) {
          var ret = void 0;
          var h = void 0,
              s = void 0,
              l = void 0,
              a = void 0,
              r = void 0,
              g = void 0,
              b = void 0;
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }

          var m = new RegExp('^' + this.regex.hsla + '$').exec(hsl);
          if (m) {

            // get hue
            h = parseInt(m[1]);
            if (h < 0) {
              h = (360 - -1 * h % 360) % 360;
            } else if (h > 360) {
              h = h % 360;
            }
            h /= 360; // normalise on [0, 1]

            s = parseFloat(m[2]);
            if (s < 0 || s > 100) {
              return;
            } // saturation is [0, 100]
            s = s / 100; // normalise on [0, 1]

            l = parseFloat(m[3]);
            if (l < 0 || l > 100) {
              return;
            } // lightness is [0, 100]
            l = l / 100; // normalise on [0, 1]

            a = m[4];
            if (a !== undefined) {
              a = parseFloat(a);

              if (a < 0 || a > 1) {
                return;
              } // alpha is [0, 1]
            }

            // now, convert to rgb
            // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
            if (s === 0) {
              r = g = b = Math.round(l * 255); // achromatic
            } else {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p = 2 * l - q;
              r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
              g = Math.round(255 * hue2rgb(p, q, h));
              b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
            }

            ret = [r, g, b, a];
          }

          return ret;
        },

        // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
        rgb2tuple: function rgb2tuple(rgb) {
          var ret = void 0;

          var m = new RegExp('^' + this.regex.rgba + '$').exec(rgb);
          if (m) {
            ret = [];

            var isPct = [];
            for (var i = 1; i <= 3; i++) {
              var channel = m[i];

              if (channel[channel.length - 1] === '%') {
                isPct[i] = true;
              }
              channel = parseFloat(channel);

              if (isPct[i]) {
                channel = channel / 100 * 255; // normalise to [0, 255]
              }

              if (channel < 0 || channel > 255) {
                return;
              } // invalid channel value

              ret.push(Math.floor(channel));
            }

            var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
            var allArePct = isPct[1] && isPct[2] && isPct[3];
            if (atLeastOneIsPct && !allArePct) {
              return;
            } // must all be percent values if one is

            var alpha = m[4];
            if (alpha !== undefined) {
              alpha = parseFloat(alpha);

              if (alpha < 0 || alpha > 1) {
                return;
              } // invalid alpha value

              ret.push(alpha);
            }
          }

          return ret;
        },

        colorname2tuple: function colorname2tuple(color) {
          return this.colors[color.toLowerCase()];
        },

        color2tuple: function color2tuple(color) {
          return (is.array(color) ? color : null) || this.colorname2tuple(color) || this.hex2tuple(color) || this.rgb2tuple(color) || this.hsl2tuple(color);
        },

        colors: {
          // special colour names
          transparent: [0, 0, 0, 0], // NB alpha === 0

          // regular colours
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          grey: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        }
      };

      /***/
    },
    /* 22 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      module.exports = {
        // has anything been set in the map
        mapEmpty: function mapEmpty(map) {
          var empty = true;

          if (map != null) {
            return Object.keys(map).length === 0;
          }

          return empty;
        },

        // pushes to the array at the end of a map (map may not be built)
        pushMap: function pushMap(options) {
          var array = this.getMap(options);

          if (array == null) {
            // if empty, put initial array
            this.setMap(this.extend({}, options, {
              value: [options.value]
            }));
          } else {
            array.push(options.value);
          }
        },

        // sets the value in a map (map may not be built)
        setMap: function setMap(options) {
          var obj = options.map;
          var key = void 0;
          var keys = options.keys;
          var l = keys.length;

          for (var i = 0; i < l; i++) {
            var _key = keys[i];

            if (is.plainObject(_key)) {
              this.error('Tried to set map with object key');
            }

            if (i < keys.length - 1) {

              // extend the map if necessary
              if (obj[_key] == null) {
                obj[_key] = {};
              }

              obj = obj[_key];
            } else {
              // set the value
              obj[_key] = options.value;
            }
          }
        },

        // gets the value in a map even if it's not built in places
        getMap: function getMap(options) {
          var obj = options.map;
          var keys = options.keys;
          var l = keys.length;

          for (var i = 0; i < l; i++) {
            var key = keys[i];

            if (is.plainObject(key)) {
              this.error('Tried to get map with object key');
            }

            obj = obj[key];

            if (obj == null) {
              return obj;
            }
          }

          return obj;
        },

        // deletes the entry in the map
        deleteMap: function deleteMap(options) {
          var obj = options.map;
          var keys = options.keys;
          var l = keys.length;
          var keepChildren = options.keepChildren;

          for (var i = 0; i < l; i++) {
            var key = keys[i];

            if (is.plainObject(key)) {
              this.error('Tried to delete map with object key');
            }

            var lastKey = i === options.keys.length - 1;
            if (lastKey) {

              if (keepChildren) {
                // then only delete child fields not in keepChildren
                var children = Object.keys(obj);

                for (var j = 0; j < children.length; j++) {
                  var child = children[j];

                  if (!keepChildren[child]) {
                    obj[child] = undefined;
                  }
                }
              } else {
                obj[key] = undefined;
              }
            } else {
              obj = obj[key];
            }
          }
        }
      };

      /***/
    },
    /* 23 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

      var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
      var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

      var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
      var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

      var hex3 = '\\#[0-9a-fA-F]{3}';
      var hex6 = '\\#[0-9a-fA-F]{6}';

      module.exports = {
        regex: {
          number: number,
          rgba: rgba,
          rgbaNoBackRefs: rgbaNoBackRefs,
          hsla: hsla,
          hslaNoBackRefs: hslaNoBackRefs,
          hex3: hex3,
          hex6: hex6
        }
      };

      /***/
    },
    /* 24 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var memoize = __webpack_require__(13);
      var is = __webpack_require__(0);

      module.exports = {

        camel2dash: memoize(function (str) {
          return str.replace(/([A-Z])/g, function (v) {
            return '-' + v.toLowerCase();
          });
        }),

        dash2camel: memoize(function (str) {
          return str.replace(/(-\w)/g, function (v) {
            return v[1].toUpperCase();
          });
        }),

        prependCamel: memoize(function (prefix, str) {
          return prefix + str[0].toUpperCase() + str.substring(1);
        }, function (prefix, str) {
          return prefix + '$' + str;
        }),

        capitalize: function capitalize(str) {
          if (is.emptyString(str)) {
            return str;
          }

          return str.charAt(0).toUpperCase() + str.substring(1);
        }

      };

      /***/
    },
    /* 25 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);
      var performance = window ? window.performance : null;

      var util = {};

      var pnow = performance && performance.now ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };

      var raf = function () {
        if (window) {
          if (window.requestAnimationFrame) {
            return function (fn) {
              window.requestAnimationFrame(fn);
            };
          } else if (window.mozRequestAnimationFrame) {
            return function (fn) {
              window.mozRequestAnimationFrame(fn);
            };
          } else if (window.webkitRequestAnimationFrame) {
            return function (fn) {
              window.webkitRequestAnimationFrame(fn);
            };
          } else if (window.msRequestAnimationFrame) {
            return function (fn) {
              window.msRequestAnimationFrame(fn);
            };
          }
        }

        return function (fn) {
          if (fn) {
            setTimeout(function () {
              fn(pnow());
            }, 1000 / 60);
          }
        };
      }();

      util.requestAnimationFrame = function (fn) {
        raf(fn);
      };

      util.performanceNow = pnow;

      util.debounce = __webpack_require__(26);

      util.now = function () {
        return Date.now();
      };

      module.exports = util;

      /***/
    },
    /* 26 */
    /***/function (module, exports) {

      /**
       * lodash (Custom Build) <https://lodash.com/>
       * Build: `lodash modularize exports="npm" -o ./`
       * Copyright jQuery Foundation and other contributors <https://jquery.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */

      /** Used as the `TypeError` message for "Functions" methods. */
      var FUNC_ERROR_TEXT = 'Expected a function';

      /** Used as references for various `Number` constants. */
      var NAN = 0 / 0;

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]';

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Built-in method references without a dependency on `root`. */
      var freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof2(global)) == 'object' && global && global.Object === Object && global;

      /** Detect free variable `self`. */
      var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof2(self)) == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var objectToString = objectProto.toString;

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max,
          nativeMin = Math.min;

      /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */
      var now = function now() {
        return root.Date.now();
      };

      /**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */
      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          // Reset any `maxWait` timer.
          lastInvokeTime = time;
          // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
          // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              result = wait - timeSinceLastCall;

          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.
          return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }

        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              // Handle invocations in a tight loop.
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
        return !!value && (type == 'object' || type == 'function');
      }

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object';
      }

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }

      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }

      module.exports = debounce;

      /***/
    },
    /* 27 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function ascending(a, b) {
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      }

      function descending(a, b) {
        return -1 * ascending(a, b);
      }

      module.exports = {
        sort: {
          ascending: ascending,
          descending: descending
        }
      };

      /***/
    },
    /* 28 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function ObjectMap() {
        this._obj = {};
      }

      var p = ObjectMap.prototype;

      p.set = function (key, val) {
        this._obj[key] = val;
      };

      p.delete = function (key) {
        this._obj[key] = null;
      };

      p.has = function (key) {
        return this._obj[key] != null;
      };

      p.get = function (key) {
        return this._obj[key];
      };

      // TODO use the stdlib Map in future...
      // module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;
      module.exports = ObjectMap;

      /***/
    },
    /* 29 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var elesfn = {};

      [__webpack_require__(30), __webpack_require__(31), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), __webpack_require__(42)].forEach(function (props) {
        util.extend(elesfn, props);
      });

      module.exports = elesfn;

      /***/
    },
    /* 30 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var defineSearch = function defineSearch(params) {
        params = {
          bfs: params.bfs || !params.dfs,
          dfs: params.dfs || !params.bfs
        };

        // from pseudocode on wikipedia
        return function searchFn(roots, fn, directed) {
          var options;
          if (is.plainObject(roots) && !is.elementOrCollection(roots)) {
            options = roots;
            roots = options.roots || options.root;
            fn = options.visit;
            directed = options.directed;
          }

          directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
          fn = is.fn(fn) ? fn : function () {};

          var cy = this._private.cy;
          var v = roots = is.string(roots) ? this.filter(roots) : roots;
          var Q = [];
          var connectedNodes = [];
          var connectedBy = {};
          var id2depth = {};
          var V = {};
          var j = 0;
          var found;
          var nodes = this.nodes();
          var edges = this.edges();

          // enqueue v
          for (var i = 0; i < v.length; i++) {
            if (v[i].isNode()) {
              Q.unshift(v[i]);

              if (params.bfs) {
                V[v[i].id()] = true;

                connectedNodes.push(v[i]);
              }

              id2depth[v[i].id()] = 0;
            }
          }

          while (Q.length !== 0) {
            var v = params.bfs ? Q.shift() : Q.pop();

            if (params.dfs) {
              if (V[v.id()]) {
                continue;
              }

              V[v.id()] = true;

              connectedNodes.push(v);
            }

            var depth = id2depth[v.id()];
            var prevEdge = connectedBy[v.id()];
            var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not(v)[0];
            var ret;

            ret = fn(v, prevEdge, prevNode, j++, depth);

            if (ret === true) {
              found = v;
              break;
            }

            if (ret === false) {
              break;
            }

            var vwEdges = v.connectedEdges(directed ? function (ele) {
              return ele.data('source') === v.id();
            } : undefined).intersect(edges);
            for (var i = 0; i < vwEdges.length; i++) {
              var e = vwEdges[i];
              var w = e.connectedNodes(function (n) {
                return n.id() !== v.id();
              }).intersect(nodes);

              if (w.length !== 0 && !V[w.id()]) {
                w = w[0];

                Q.push(w);

                if (params.bfs) {
                  V[w.id()] = true;

                  connectedNodes.push(w);
                }

                connectedBy[w.id()] = e;

                id2depth[w.id()] = id2depth[v.id()] + 1;
              }
            }
          }

          var connectedEles = [];

          for (var i = 0; i < connectedNodes.length; i++) {
            var node = connectedNodes[i];
            var edge = connectedBy[node.id()];

            if (edge) {
              connectedEles.push(edge);
            }

            connectedEles.push(node);
          }

          return {
            path: cy.collection(connectedEles, { unique: true }),
            found: cy.collection(found)
          };
        };
      };

      // search, spanning trees, etc
      var elesfn = {
        breadthFirstSearch: defineSearch({ bfs: true }),
        depthFirstSearch: defineSearch({ dfs: true })
      };

      // nice, short mathemathical alias
      elesfn.bfs = elesfn.breadthFirstSearch;
      elesfn.dfs = elesfn.depthFirstSearch;

      module.exports = elesfn;

      /***/
    },
    /* 31 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Heap = __webpack_require__(9);

      var elesfn = {

        dijkstra: function dijkstra(root, weightFn, directed) {
          var options;
          if (is.plainObject(root) && !is.elementOrCollection(root)) {
            options = root;
            root = options.root;
            weightFn = options.weight;
            directed = options.directed;
          }

          var cy = this._private.cy;
          weightFn = is.fn(weightFn) ? weightFn : function () {
            return 1;
          }; // if not specified, assume each edge has equal weight (1)

          var source = is.string(root) ? this.filter(root)[0] : root[0];
          var dist = {};
          var prev = {};
          var knownDist = {};

          var edges = this.edges().filter(function (ele) {
            return !ele.isLoop();
          });
          var nodes = this.nodes();

          var getDist = function getDist(node) {
            return dist[node.id()];
          };

          var setDist = function setDist(node, d) {
            dist[node.id()] = d;

            Q.updateItem(node);
          };

          var Q = new Heap(function (a, b) {
            return getDist(a) - getDist(b);
          });

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            dist[node.id()] = node.same(source) ? 0 : Infinity;
            Q.push(node);
          }

          var distBetween = function distBetween(u, v) {
            var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
            var smallestDistance = Infinity;
            var smallestEdge;

            for (var i = 0; i < uvs.length; i++) {
              var edge = uvs[i];
              var weight = weightFn(edge);

              if (weight < smallestDistance || !smallestEdge) {
                smallestDistance = weight;
                smallestEdge = edge;
              }
            }

            return {
              edge: smallestEdge,
              dist: smallestDistance
            };
          };

          while (Q.size() > 0) {
            var u = Q.pop();
            var smalletsDist = getDist(u);
            var uid = u.id();

            knownDist[uid] = smalletsDist;

            if (smalletsDist === Infinity) {
              continue;
            }

            var neighbors = u.neighborhood().intersect(nodes);
            for (var i = 0; i < neighbors.length; i++) {
              var v = neighbors[i];
              var vid = v.id();
              var vDist = distBetween(u, v);

              var alt = smalletsDist + vDist.dist;

              if (alt < getDist(v)) {
                setDist(v, alt);

                prev[vid] = {
                  node: u,
                  edge: vDist.edge
                };
              }
            } // for
          } // while

          return {
            distanceTo: function distanceTo(node) {
              var target = is.string(node) ? nodes.filter(node)[0] : node[0];

              return knownDist[target.id()];
            },

            pathTo: function pathTo(node) {
              var target = is.string(node) ? nodes.filter(node)[0] : node[0];
              var S = [];
              var u = target;

              if (target.length > 0) {
                S.unshift(target);

                while (prev[u.id()]) {
                  var p = prev[u.id()];

                  S.unshift(p.edge);
                  S.unshift(p.node);

                  u = p.node;
                }
              }

              return cy.collection(S);
            }
          };
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 32 */
    /***/function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(33);

      /***/
    },
    /* 33 */
    /***/function (module, exports, __webpack_require__) {

      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Generated by CoffeeScript 1.8.0
      (function () {
        var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

        floor = Math.floor, min = Math.min;

        /*
        Default comparison function to be used
         */

        defaultCmp = function defaultCmp(x, y) {
          if (x < y) {
            return -1;
          }
          if (x > y) {
            return 1;
          }
          return 0;
        };

        /*
        Insert item x in list a, and keep it sorted assuming a is sorted.
        
        If x is already in a, insert it to the right of the rightmost x.
        
        Optional args lo (default 0) and hi (default a.length) bound the slice
        of a to be searched.
         */

        insort = function insort(a, x, lo, hi, cmp) {
          var mid;
          if (lo == null) {
            lo = 0;
          }
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (lo < 0) {
            throw new Error('lo must be non-negative');
          }
          if (hi == null) {
            hi = a.length;
          }
          while (lo < hi) {
            mid = floor((lo + hi) / 2);
            if (cmp(x, a[mid]) < 0) {
              hi = mid;
            } else {
              lo = mid + 1;
            }
          }
          return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
        };

        /*
        Push item onto heap, maintaining the heap invariant.
         */

        heappush = function heappush(array, item, cmp) {
          if (cmp == null) {
            cmp = defaultCmp;
          }
          array.push(item);
          return _siftdown(array, 0, array.length - 1, cmp);
        };

        /*
        Pop the smallest item off the heap, maintaining the heap invariant.
         */

        heappop = function heappop(array, cmp) {
          var lastelt, returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          lastelt = array.pop();
          if (array.length) {
            returnitem = array[0];
            array[0] = lastelt;
            _siftup(array, 0, cmp);
          } else {
            returnitem = lastelt;
          }
          return returnitem;
        };

        /*
        Pop and return the current smallest value, and add the new item.
        
        This is more efficient than heappop() followed by heappush(), and can be
        more appropriate when using a fixed size heap. Note that the value
        returned may be larger than item! That constrains reasonable use of
        this routine unless written as part of a conditional replacement:
            if item > array[0]
              item = heapreplace(array, item)
         */

        heapreplace = function heapreplace(array, item, cmp) {
          var returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          returnitem = array[0];
          array[0] = item;
          _siftup(array, 0, cmp);
          return returnitem;
        };

        /*
        Fast version of a heappush followed by a heappop.
         */

        heappushpop = function heappushpop(array, item, cmp) {
          var _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (array.length && cmp(array[0], item) < 0) {
            _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
            _siftup(array, 0, cmp);
          }
          return item;
        };

        /*
        Transform list into a heap, in-place, in O(array.length) time.
         */

        heapify = function heapify(array, cmp) {
          var i, _i, _j, _len, _ref, _ref1, _results, _results1;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          _ref1 = function () {
            _results1 = [];
            for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
              _results1.push(_j);
            }
            return _results1;
          }.apply(this).reverse();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            i = _ref1[_i];
            _results.push(_siftup(array, i, cmp));
          }
          return _results;
        };

        /*
        Update the position of the given item in the heap.
        This function should be called every time the item is being modified.
         */

        updateItem = function updateItem(array, item, cmp) {
          var pos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          pos = array.indexOf(item);
          if (pos === -1) {
            return;
          }
          _siftdown(array, 0, pos, cmp);
          return _siftup(array, pos, cmp);
        };

        /*
        Find the n largest elements in a dataset.
         */

        nlargest = function nlargest(array, n, cmp) {
          var elem, result, _i, _len, _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          result = array.slice(0, n);
          if (!result.length) {
            return result;
          }
          heapify(result, cmp);
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            heappushpop(result, elem, cmp);
          }
          return result.sort(cmp).reverse();
        };

        /*
        Find the n smallest elements in a dataset.
         */

        nsmallest = function nsmallest(array, n, cmp) {
          var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (n * 10 <= array.length) {
            result = array.slice(0, n).sort(cmp);
            if (!result.length) {
              return result;
            }
            los = result[result.length - 1];
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem = _ref[_i];
              if (cmp(elem, los) < 0) {
                insort(result, elem, 0, null, cmp);
                result.pop();
                los = result[result.length - 1];
              }
            }
            return result;
          }
          heapify(array, cmp);
          _results = [];
          for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(heappop(array, cmp));
          }
          return _results;
        };

        _siftdown = function _siftdown(array, startpos, pos, cmp) {
          var newitem, parent, parentpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          newitem = array[pos];
          while (pos > startpos) {
            parentpos = pos - 1 >> 1;
            parent = array[parentpos];
            if (cmp(newitem, parent) < 0) {
              array[pos] = parent;
              pos = parentpos;
              continue;
            }
            break;
          }
          return array[pos] = newitem;
        };

        _siftup = function _siftup(array, pos, cmp) {
          var childpos, endpos, newitem, rightpos, startpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          endpos = array.length;
          startpos = pos;
          newitem = array[pos];
          childpos = 2 * pos + 1;
          while (childpos < endpos) {
            rightpos = childpos + 1;
            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
              childpos = rightpos;
            }
            array[pos] = array[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
          }
          array[pos] = newitem;
          return _siftdown(array, startpos, pos, cmp);
        };

        Heap = function () {
          Heap.push = heappush;

          Heap.pop = heappop;

          Heap.replace = heapreplace;

          Heap.pushpop = heappushpop;

          Heap.heapify = heapify;

          Heap.updateItem = updateItem;

          Heap.nlargest = nlargest;

          Heap.nsmallest = nsmallest;

          function Heap(cmp) {
            this.cmp = cmp != null ? cmp : defaultCmp;
            this.nodes = [];
          }

          Heap.prototype.push = function (x) {
            return heappush(this.nodes, x, this.cmp);
          };

          Heap.prototype.pop = function () {
            return heappop(this.nodes, this.cmp);
          };

          Heap.prototype.peek = function () {
            return this.nodes[0];
          };

          Heap.prototype.contains = function (x) {
            return this.nodes.indexOf(x) !== -1;
          };

          Heap.prototype.replace = function (x) {
            return heapreplace(this.nodes, x, this.cmp);
          };

          Heap.prototype.pushpop = function (x) {
            return heappushpop(this.nodes, x, this.cmp);
          };

          Heap.prototype.heapify = function () {
            return heapify(this.nodes, this.cmp);
          };

          Heap.prototype.updateItem = function (x) {
            return updateItem(this.nodes, x, this.cmp);
          };

          Heap.prototype.clear = function () {
            return this.nodes = [];
          };

          Heap.prototype.empty = function () {
            return this.nodes.length === 0;
          };

          Heap.prototype.size = function () {
            return this.nodes.length;
          };

          Heap.prototype.clone = function () {
            var heap;
            heap = new Heap();
            heap.nodes = this.nodes.slice(0);
            return heap;
          };

          Heap.prototype.toArray = function () {
            return this.nodes.slice(0);
          };

          Heap.prototype.insert = Heap.prototype.push;

          Heap.prototype.top = Heap.prototype.peek;

          Heap.prototype.front = Heap.prototype.peek;

          Heap.prototype.has = Heap.prototype.contains;

          Heap.prototype.copy = Heap.prototype.clone;

          return Heap;
        }();

        (function (root, factory) {
          if (true) {
            return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') {
            return module.exports = factory();
          } else {
            return root.Heap = factory();
          }
        })(this, function () {
          return Heap;
        });
      }).call(this);

      /***/
    },
    /* 34 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      // search, spanning trees, etc
      var elesfn = {

        // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
        // implemented from pseudocode from wikipedia
        kruskal: function kruskal(weightFn) {
          var cy = this.cy();

          weightFn = is.fn(weightFn) ? weightFn : function () {
            return 1;
          }; // if not specified, assume each edge has equal weight (1)

          function findSet(ele) {
            for (var i = 0; i < forest.length; i++) {
              var eles = forest[i];

              if (eles.anySame(ele)) {
                return {
                  eles: eles,
                  index: i
                };
              }
            }
          }

          var A = cy.collection(cy, []);
          var forest = [];
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            forest.push(nodes[i].collection());
          }

          var edges = this.edges();
          var S = edges.toArray().sort(function (a, b) {
            var weightA = weightFn(a);
            var weightB = weightFn(b);

            return weightA - weightB;
          });

          for (var i = 0; i < S.length; i++) {
            var edge = S[i];
            var u = edge.source()[0];
            var v = edge.target()[0];
            var setU = findSet(u);
            var setV = findSet(v);

            if (setU.index !== setV.index) {
              A = A.add(edge);

              // combine forests for u and v
              forest[setU.index] = setU.eles.add(setV.eles);
              forest.splice(setV.index, 1);
            }
          }

          return nodes.add(A);
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 35 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        // Implemented from pseudocode from wikipedia
        aStar: function aStar(options) {
          var eles = this;

          options = options || {};

          // Reconstructs the path from Start to End, acumulating the result in pathAcum
          var reconstructPath = function reconstructPath(start, end, cameFromMap, pathAcum) {
            // Base case
            if (start == end) {
              pathAcum.unshift(cy.getElementById(end));
              return pathAcum;
            }

            if (end in cameFromMap) {
              // We know which node is before the last one
              var previous = cameFromMap[end];
              var previousEdge = cameFromEdge[end];

              pathAcum.unshift(cy.getElementById(previousEdge));
              pathAcum.unshift(cy.getElementById(end));

              return reconstructPath(start, previous, cameFromMap, pathAcum);
            }

            // We should not reach here!
            return undefined;
          };

          // Returns the index of the element in openSet which has minimum fScore
          var findMin = function findMin(openSet, fScore) {
            if (openSet.length === 0) {
              // Should never be the case
              return undefined;
            }
            var minPos = 0;
            var tempScore = fScore[openSet[0]];
            for (var i = 1; i < openSet.length; i++) {
              var s = fScore[openSet[i]];
              if (s < tempScore) {
                tempScore = s;
                minPos = i;
              }
            }
            return minPos;
          };

          var cy = this._private.cy;

          // root - mandatory!
          if (options != null && options.root != null) {
            var source = is.string(options.root) ?
            // use it as a selector, e.g. "#rootID
            this.filter(options.root)[0] : options.root[0];
          } else {
            return undefined;
          }

          // goal - mandatory!
          if (options.goal != null) {
            var target = is.string(options.goal) ?
            // use it as a selector, e.g. "#goalID
            this.filter(options.goal)[0] : options.goal[0];
          } else {
            return undefined;
          }

          // Heuristic function - optional
          if (options.heuristic != null && is.fn(options.heuristic)) {
            var heuristic = options.heuristic;
          } else {
            var heuristic = function heuristic() {
              return 0;
            }; // use constant if unspecified
          }

          // Weight function - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var sid = source.id();
          var tid = target.id();

          var closedSet = [];
          var openSet = [sid];
          var cameFrom = {};
          var cameFromEdge = {};
          var gScore = {};
          var fScore = {};

          gScore[sid] = 0;
          fScore[sid] = heuristic(source);

          // Counter
          var steps = 0;

          // Main loop
          while (openSet.length > 0) {
            var minPos = findMin(openSet, fScore);
            var cMin = cy.getElementById(openSet[minPos]);
            var cMinId = cMin.id();
            steps++;

            // If we've found our goal, then we are done
            if (cMinId == tid) {
              var rPath = reconstructPath(sid, tid, cameFrom, []);

              return {
                found: true,
                distance: gScore[cMinId],
                path: eles.spawn(rPath),
                steps: steps
              };
            }

            // Add cMin to processed nodes
            closedSet.push(cMinId);
            // Remove cMin from boundary nodes
            openSet.splice(minPos, 1);

            // Update scores for neighbors of cMin
            // Take into account if graph is directed or not
            var vwEdges = cMin._private.edges;

            for (var i = 0; i < vwEdges.length; i++) {
              var e = vwEdges[i];

              // edge must be in set of calling eles
              if (!this.hasElementWithId(e.id())) {
                continue;
              }

              // cMin must be the source of edge if directed
              if (directed && e.data('source') !== cMinId) {
                continue;
              }

              var wSrc = e.source();
              var wTgt = e.target();

              var w = wSrc.id() !== cMinId ? wSrc : wTgt;
              var wid = w.id();

              // node must be in set of calling eles
              if (!this.hasElementWithId(wid)) {
                continue;
              }

              // if node is in closedSet, ignore it
              if (closedSet.indexOf(wid) != -1) {
                continue;
              }

              // New tentative score for node w
              var tempScore = gScore[cMinId] + weightFn(e);

              // Update gScore for node w if:
              //   w not present in openSet
              // OR
              //   tentative gScore is less than previous value

              // w not in openSet
              if (openSet.indexOf(wid) == -1) {
                gScore[wid] = tempScore;
                fScore[wid] = tempScore + heuristic(w);
                openSet.push(wid); // Add node to openSet
                cameFrom[wid] = cMinId;
                cameFromEdge[wid] = e.id();
                continue;
              }
              // w already in openSet, but with greater gScore
              if (tempScore < gScore[wid]) {
                gScore[wid] = tempScore;
                fScore[wid] = tempScore + heuristic(w);
                cameFrom[wid] = cMinId;
              }
            } // End of neighbors update
          } // End of main loop

          // If we've reached here, then we've not reached our goal
          return {
            found: false,
            distance: undefined,
            path: undefined,
            steps: steps
          };
        }

      }; // elesfn


      module.exports = elesfn;

      /***/
    },
    /* 36 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        // Implemented from pseudocode from wikipedia
        floydWarshall: function floydWarshall(options) {
          options = options || {};

          var cy = this.cy();

          // Weight function - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;

          // mapping: node id -> position in nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Initialize distance matrix
          var dist = [];
          for (var i = 0; i < numNodes; i++) {
            var newRow = new Array(numNodes);
            for (var j = 0; j < numNodes; j++) {
              if (i == j) {
                newRow[j] = 0;
              } else {
                newRow[j] = Infinity;
              }
            }
            dist.push(newRow);
          }

          // Initialize matrix used for path reconstruction
          // Initialize distance matrix
          var next = [];
          var edgeNext = [];

          var initMatrix = function initMatrix(next) {
            for (var i = 0; i < numNodes; i++) {
              var newRow = new Array(numNodes);
              for (var j = 0; j < numNodes; j++) {
                newRow[j] = undefined;
              }
              next.push(newRow);
            }
          };

          initMatrix(next);
          initMatrix(edgeNext);

          // Process edges
          for (var i = 0; i < edges.length; i++) {
            var sourceIndex = id2position[edges[i].source().id()];
            var targetIndex = id2position[edges[i].target().id()];
            var weight = weightFn(edges[i]);

            // Check if already process another edge between same 2 nodes
            if (dist[sourceIndex][targetIndex] > weight) {
              dist[sourceIndex][targetIndex] = weight;
              next[sourceIndex][targetIndex] = targetIndex;
              edgeNext[sourceIndex][targetIndex] = edges[i];
            }
          }

          // If undirected graph, process 'reversed' edges
          if (!directed) {
            for (var i = 0; i < edges.length; i++) {
              var sourceIndex = id2position[edges[i].target().id()];
              var targetIndex = id2position[edges[i].source().id()];
              var weight = weightFn(edges[i]);

              // Check if already process another edge between same 2 nodes
              if (dist[sourceIndex][targetIndex] > weight) {
                dist[sourceIndex][targetIndex] = weight;
                next[sourceIndex][targetIndex] = targetIndex;
                edgeNext[sourceIndex][targetIndex] = edges[i];
              }
            }
          }

          // Main loop
          for (var k = 0; k < numNodes; k++) {
            for (var i = 0; i < numNodes; i++) {
              for (var j = 0; j < numNodes; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                  dist[i][j] = dist[i][k] + dist[k][j];
                  next[i][j] = next[i][k];
                }
              }
            }
          }

          // Build result object
          var position2id = [];
          for (var i = 0; i < numNodes; i++) {
            position2id.push(nodes[i].id());
          }

          var res = {
            distance: function distance(from, to) {
              if (is.string(from)) {
                // from is a selector string
                var fromId = cy.filter(from)[0].id();
              } else {
                // from is a node
                var fromId = from.id();
              }

              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }

              return dist[id2position[fromId]][id2position[toId]];
            },

            path: function path(from, to) {
              var reconstructPathAux = function reconstructPathAux(from, to, next, position2id, edgeNext) {
                if (from === to) {
                  return cy.getElementById(position2id[from]);
                }
                if (next[from][to] === undefined) {
                  return undefined;
                }

                var path = [cy.getElementById(position2id[from])];
                var prev = from;
                while (from !== to) {
                  prev = from;
                  from = next[from][to];

                  var edge = edgeNext[prev][from];
                  path.push(edge);

                  path.push(cy.getElementById(position2id[from]));
                }
                return path;
              };

              if (is.string(from)) {
                // from is a selector string
                var fromId = cy.filter(from)[0].id();
              } else {
                // from is a node
                var fromId = from.id();
              }

              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }

              var pathArr = reconstructPathAux(id2position[fromId], id2position[toId], next, position2id, edgeNext);

              return cy.collection(pathArr);
            }
          };

          return res;
        } // floydWarshall

      }; // elesfn

      module.exports = elesfn;

      /***/
    },
    /* 37 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var elesfn = {

        // Implemented from pseudocode from wikipedia
        bellmanFord: function bellmanFord(options) {
          var eles = this;

          options = options || {};

          // Weight function - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          // root - mandatory!
          if (options.root != null) {
            if (is.string(options.root)) {
              // use it as a selector, e.g. "#rootID
              var source = this.filter(options.root)[0];
            } else {
              var source = options.root[0];
            }
          } else {
            return undefined;
          }

          var cy = this._private.cy;
          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;

          // mapping: node id -> position in nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Initializations
          var cost = [];
          var predecessor = [];
          var predEdge = [];

          for (var i = 0; i < numNodes; i++) {
            if (nodes[i].id() === source.id()) {
              cost[i] = 0;
            } else {
              cost[i] = Infinity;
            }
            predecessor[i] = undefined;
          }

          // Edges relaxation
          var flag = false;
          for (var i = 1; i < numNodes; i++) {
            flag = false;
            for (var e = 0; e < edges.length; e++) {
              var sourceIndex = id2position[edges[e].source().id()];
              var targetIndex = id2position[edges[e].target().id()];
              var weight = weightFn(edges[e]);

              var temp = cost[sourceIndex] + weight;
              if (temp < cost[targetIndex]) {
                cost[targetIndex] = temp;
                predecessor[targetIndex] = sourceIndex;
                predEdge[targetIndex] = edges[e];
                flag = true;
              }

              // If undirected graph, we need to take into account the 'reverse' edge
              if (!directed) {
                var temp = cost[targetIndex] + weight;
                if (temp < cost[sourceIndex]) {
                  cost[sourceIndex] = temp;
                  predecessor[sourceIndex] = targetIndex;
                  predEdge[sourceIndex] = edges[e];
                  flag = true;
                }
              }
            }

            if (!flag) {
              break;
            }
          }

          if (flag) {
            // Check for negative weight cycles
            for (var e = 0; e < edges.length; e++) {
              var sourceIndex = id2position[edges[e].source().id()];
              var targetIndex = id2position[edges[e].target().id()];
              var weight = weightFn(edges[e]);

              if (cost[sourceIndex] + weight < cost[targetIndex]) {
                util.error('Graph contains a negative weight cycle for Bellman-Ford');
                return { pathTo: undefined,
                  distanceTo: undefined,
                  hasNegativeWeightCycle: true };
              }
            }
          }

          // Build result object
          var position2id = [];
          for (var i = 0; i < numNodes; i++) {
            position2id.push(nodes[i].id());
          }

          var res = {
            distanceTo: function distanceTo(to) {
              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }

              return cost[id2position[toId]];
            },

            pathTo: function pathTo(to) {

              var reconstructPathAux = function reconstructPathAux(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
                for (;;) {
                  // Add toId to path
                  acumPath.push(cy.getElementById(position2id[toPos]));
                  acumPath.push(predEdge[toPos]);

                  if (fromPos === toPos) {
                    // reached starting node
                    return acumPath;
                  }

                  // If no path exists, discart acumulated path and return undefined
                  var predPos = predecessor[toPos];
                  if (typeof predPos === 'undefined') {
                    return undefined;
                  }

                  toPos = predPos;
                }
              };

              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }
              var path = [];

              // This returns a reversed path
              var res = reconstructPathAux(predecessor, id2position[source.id()], id2position[toId], position2id, path, predEdge);

              // Get it in the correct order and return it
              if (res != null) {
                res.reverse();
              }

              return eles.spawn(res);
            },

            hasNegativeWeightCycle: false
          };

          return res;
        } // bellmanFord

      }; // elesfn

      module.exports = elesfn;

      /***/
    },
    /* 38 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var elesfn = {

        // Computes the minimum cut of an undirected graph
        // Returns the correct answer with high probability
        kargerStein: function kargerStein(options) {
          var eles = this;

          options = options || {};

          // Function which colapses 2 (meta) nodes into one
          // Updates the remaining edge lists
          // Receives as a paramater the edge which causes the collapse
          var colapse = function colapse(edgeIndex, nodeMap, remainingEdges) {
            var edgeInfo = remainingEdges[edgeIndex];
            var sourceIn = edgeInfo[1];
            var targetIn = edgeInfo[2];
            var partition1 = nodeMap[sourceIn];
            var partition2 = nodeMap[targetIn];

            // Delete all edges between partition1 and partition2
            var newEdges = remainingEdges.filter(function (edge) {
              if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
                return false;
              }
              if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
                return false;
              }
              return true;
            });

            // All edges pointing to partition2 should now point to partition1
            for (var i = 0; i < newEdges.length; i++) {
              var edge = newEdges[i];
              if (edge[1] === partition2) {
                // Check source
                newEdges[i] = edge.slice(0);
                newEdges[i][1] = partition1;
              } else if (edge[2] === partition2) {
                // Check target
                newEdges[i] = edge.slice(0);
                newEdges[i][2] = partition1;
              }
            }

            // Move all nodes from partition2 to partition1
            for (var i = 0; i < nodeMap.length; i++) {
              if (nodeMap[i] === partition2) {
                nodeMap[i] = partition1;
              }
            }

            return newEdges;
          };

          // Contracts a graph until we reach a certain number of meta nodes
          var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
            // Stop condition
            if (size <= sizeLimit) {
              return remainingEdges;
            }

            // Choose an edge randomly
            var edgeIndex = Math.floor(Math.random() * remainingEdges.length);

            // Colapse graph based on edge
            var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);

            return contractUntil(metaNodeMap, newEdges, size - 1, sizeLimit);
          };

          var cy = this._private.cy;
          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;
          var numEdges = edges.length;
          var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
          var stopSize = Math.floor(numNodes / Math.sqrt(2));

          if (numNodes < 2) {
            util.error('At least 2 nodes are required for Karger-Stein algorithm');
            return undefined;
          }

          // Create numerical identifiers for each node
          // mapping: node id -> position in nodes array
          // for reverse mapping, simply use nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Now store edge destination as indexes
          // Format for each edge (edge index, source node index, target node index)
          var edgeIndexes = [];
          for (var i = 0; i < numEdges; i++) {
            var e = edges[i];
            edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
          }

          // We will store the best cut found here
          var minCutSize = Infinity;
          var minCut;

          // Initial meta node partition
          var originalMetaNode = [];
          for (var i = 0; i < numNodes; i++) {
            originalMetaNode.push(i);
          }

          // Main loop
          for (var iter = 0; iter <= numIter; iter++) {
            // Create new meta node partition
            var metaNodeMap = originalMetaNode.slice(0);

            // Contract until stop point (stopSize nodes)
            var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);

            // Create a copy of the colapsed nodes state
            var metaNodeMap2 = metaNodeMap.slice(0);

            // Run 2 iterations starting in the stop state
            var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
            var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

            // Is any of the 2 results the best cut so far?
            if (res1.length <= res2.length && res1.length < minCutSize) {
              minCutSize = res1.length;
              minCut = [res1, metaNodeMap];
            } else if (res2.length <= res1.length && res2.length < minCutSize) {
              minCutSize = res2.length;
              minCut = [res2, metaNodeMap2];
            }
          } // end of main loop


          // Construct result
          var resEdges = minCut[0].map(function (e) {
            return edges[e[0]];
          });
          var partition1 = [];
          var partition2 = [];

          // traverse metaNodeMap for best cut
          var witnessNodePartition = minCut[1][0];
          for (var i = 0; i < minCut[1].length; i++) {
            var partitionId = minCut[1][i];
            if (partitionId === witnessNodePartition) {
              partition1.push(nodes[i]);
            } else {
              partition2.push(nodes[i]);
            }
          }

          var ret = {
            cut: eles.spawn(cy, resEdges),
            partition1: eles.spawn(partition1),
            partition2: eles.spawn(partition2)
          };

          return ret;
        }
      }; // elesfn


      module.exports = elesfn;

      /***/
    },
    /* 39 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        pageRank: function pageRank(options) {
          options = options || {};

          var normalizeVector = function normalizeVector(vector) {
            var length = vector.length;

            // First, get sum of all elements
            var total = 0;
            for (var i = 0; i < length; i++) {
              total += vector[i];
            }

            // Now, divide each by the sum of all elements
            for (var i = 0; i < length; i++) {
              vector[i] = vector[i] / total;
            }
          };

          // dampingFactor - optional
          if (options != null && options.dampingFactor != null) {
            var dampingFactor = options.dampingFactor;
          } else {
            var dampingFactor = 0.8; // Default damping factor
          }

          // desired precision - optional
          if (options != null && options.precision != null) {
            var epsilon = options.precision;
          } else {
            var epsilon = 0.000001; // Default precision
          }

          // Max number of iterations - optional
          if (options != null && options.iterations != null) {
            var numIter = options.iterations;
          } else {
            var numIter = 200; // Default number of iterations
          }

          // Weight function - optional
          if (options != null && options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          var cy = this._private.cy;
          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;
          var numEdges = edges.length;

          // Create numerical identifiers for each node
          // mapping: node id -> position in nodes array
          // for reverse mapping, simply use nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Construct transposed adjacency matrix
          // First lets have a zeroed matrix of the right size
          // We'll also keep track of the sum of each column
          var matrix = [];
          var columnSum = [];
          var additionalProb = (1 - dampingFactor) / numNodes;

          // Create null matric
          for (var i = 0; i < numNodes; i++) {
            var newRow = [];
            for (var j = 0; j < numNodes; j++) {
              newRow.push(0.0);
            }
            matrix.push(newRow);
            columnSum.push(0.0);
          }

          // Now, process edges
          for (var i = 0; i < numEdges; i++) {
            var edge = edges[i];
            var s = id2position[edge.source().id()];
            var t = id2position[edge.target().id()];
            var w = weightFn(edge);

            // Update matrix
            matrix[t][s] += w;

            // Update column sum
            columnSum[s] += w;
          }

          // Add additional probability based on damping factor
          // Also, take into account columns that have sum = 0
          var p = 1.0 / numNodes + additionalProb; // Shorthand
          // Traverse matrix, column by column
          for (var j = 0; j < numNodes; j++) {
            if (columnSum[j] === 0) {
              // No 'links' out from node jth, assume equal probability for each possible node
              for (var i = 0; i < numNodes; i++) {
                matrix[i][j] = p;
              }
            } else {
              // Node jth has outgoing link, compute normalized probabilities
              for (var i = 0; i < numNodes; i++) {
                matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
              }
            }
          }

          // Compute dominant eigenvector using power method
          var eigenvector = [];
          var nullVector = [];
          var previous;

          // Start with a vector of all 1's
          // Also, initialize a null vector which will be used as shorthand
          for (var i = 0; i < numNodes; i++) {
            eigenvector.push(1.0);
            nullVector.push(0.0);
          }

          for (var iter = 0; iter < numIter; iter++) {
            // New array with all 0's
            var temp = nullVector.slice(0);

            // Multiply matrix with previous result
            for (var i = 0; i < numNodes; i++) {
              for (var j = 0; j < numNodes; j++) {
                temp[i] += matrix[i][j] * eigenvector[j];
              }
            }

            normalizeVector(temp);
            previous = eigenvector;
            eigenvector = temp;

            var diff = 0;
            // Compute difference (squared module) of both vectors
            for (var i = 0; i < numNodes; i++) {
              diff += Math.pow(previous[i] - eigenvector[i], 2);
            }

            // If difference is less than the desired threshold, stop iterating
            if (diff < epsilon) {
              break;
            }
          }

          // Construct result
          var res = {
            rank: function rank(node) {
              if (is.string(node)) {
                // is a selector string
                var nodeId = cy.filter(node)[0].id();
              } else {
                // is a node object
                var nodeId = node.id();
              }
              return eigenvector[id2position[nodeId]];
            }
          };

          return res;
        } // pageRank

      }; // elesfn

      module.exports = elesfn;

      /***/
    },
    /* 40 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var elesfn = {

        degreeCentralityNormalized: function degreeCentralityNormalized(options) {
          options = options || {};

          var cy = this.cy();

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var nodes = this.nodes();
          var numNodes = nodes.length;

          if (!directed) {
            var degrees = {};
            var maxDegree = 0;

            for (var i = 0; i < numNodes; i++) {
              var node = nodes[i];
              // add current node to the current options object and call degreeCentrality
              var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));
              if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;

              degrees[node.id()] = currDegree.degree;
            }

            return {
              degree: function degree(node) {
                if (maxDegree == 0) return 0;

                if (is.string(node)) {
                  // from is a selector string
                  var node = cy.filter(node)[0].id();
                } else {
                  // from is a node
                  var node = node.id();
                }

                return degrees[node] / maxDegree;
              }
            };
          } else {
            var indegrees = {};
            var outdegrees = {};
            var maxIndegree = 0;
            var maxOutdegree = 0;

            for (var i = 0; i < numNodes; i++) {
              var node = nodes[i];
              // add current node to the current options object and call degreeCentrality
              var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));

              if (maxIndegree < currDegree.indegree) maxIndegree = currDegree.indegree;

              if (maxOutdegree < currDegree.outdegree) maxOutdegree = currDegree.outdegree;

              indegrees[node.id()] = currDegree.indegree;
              outdegrees[node.id()] = currDegree.outdegree;
            }

            return {
              indegree: function indegree(node) {
                if (maxIndegree == 0) return 0;

                if (is.string(node)) {
                  // from is a selector string
                  var node = cy.filter(node)[0].id();
                } else {
                  // from is a node
                  var node = node.id();
                }

                return indegrees[node] / maxIndegree;
              },
              outdegree: function outdegree(node) {
                if (maxOutdegree == 0) return 0;

                if (is.string(node)) {
                  // from is a selector string
                  var node = cy.filter(node)[0].id();
                } else {
                  // from is a node
                  var node = node.id();
                }

                return outdegrees[node] / maxOutdegree;
              }

            };
          }
        }, // degreeCentralityNormalized

        // Implemented from the algorithm in Opsahl's paper
        // "Node centrality in weighted networks: Generalizing degree and shortest paths"
        // check the heading 2 "Degree"
        degreeCentrality: function degreeCentrality(options) {
          options = options || {};

          var callingEles = this;

          // root - mandatory!
          if (options != null && options.root != null) {
            var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
          } else {
            return undefined;
          }

          // weight - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          // alpha - optional
          if (options.alpha != null && is.number(options.alpha)) {
            var alpha = options.alpha;
          } else {
            alpha = 0;
          }

          if (!directed) {
            var connEdges = root.connectedEdges().intersection(callingEles);
            var k = connEdges.length;
            var s = 0;

            // Now, sum edge weights
            for (var i = 0; i < connEdges.length; i++) {
              var edge = connEdges[i];
              s += weightFn(edge);
            }

            return {
              degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
            };
          } else {
            var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection(callingEles);
            var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection(callingEles);
            var k_in = incoming.length;
            var k_out = outgoing.length;
            var s_in = 0;
            var s_out = 0;

            // Now, sum incoming edge weights
            for (var i = 0; i < incoming.length; i++) {
              var edge = incoming[i];
              s_in += weightFn(edge);
            }

            // Now, sum outgoing edge weights
            for (var i = 0; i < outgoing.length; i++) {
              var edge = outgoing[i];
              s_out += weightFn(edge);
            }

            return {
              indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
              outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
            };
          }
        } // degreeCentrality

      }; // elesfn

      // nice, short mathemathical alias
      elesfn.dc = elesfn.degreeCentrality;
      elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

      module.exports = elesfn;

      /***/
    },
    /* 41 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        closenessCentralityNormalized: function closenessCentralityNormalized(options) {
          options = options || {};

          var cy = this.cy();

          var harmonic = options.harmonic;
          if (harmonic === undefined) {
            harmonic = true;
          }

          var closenesses = {};
          var maxCloseness = 0;
          var nodes = this.nodes();
          var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

          // Compute closeness for every node and find the maximum closeness
          for (var i = 0; i < nodes.length; i++) {
            var currCloseness = 0;
            for (var j = 0; j < nodes.length; j++) {
              if (i != j) {
                var d = fw.distance(nodes[i], nodes[j]);

                if (harmonic) {
                  currCloseness += 1 / d;
                } else {
                  currCloseness += d;
                }
              }
            }

            if (!harmonic) {
              currCloseness = 1 / currCloseness;
            }

            if (maxCloseness < currCloseness) {
              maxCloseness = currCloseness;
            }

            closenesses[nodes[i].id()] = currCloseness;
          }

          return {
            closeness: function closeness(node) {
              if (maxCloseness == 0) {
                return 0;
              }

              if (is.string(node)) {
                // from is a selector string
                var node = cy.filter(node)[0].id();
              } else {
                // from is a node
                var node = node.id();
              }

              return closenesses[node] / maxCloseness;
            }
          };
        },

        // Implemented from pseudocode from wikipedia
        closenessCentrality: function closenessCentrality(options) {
          options = options || {};

          // root - mandatory!
          if (options.root != null) {
            if (is.string(options.root)) {
              // use it as a selector, e.g. "#rootID
              var root = this.filter(options.root)[0];
            } else {
              var root = options.root[0];
            }
          } else {
            return undefined;
          }

          // weight - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weight = options.weight;
          } else {
            var weight = function weight() {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null && is.bool(options.directed)) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var harmonic = options.harmonic;
          if (harmonic === undefined) {
            harmonic = true;
          }

          // we need distance from this node to every other node
          var dijkstra = this.dijkstra({
            root: root,
            weight: weight,
            directed: directed
          });
          var totalDistance = 0;

          var nodes = this.nodes();
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].id() != root.id()) {
              var d = dijkstra.distanceTo(nodes[i]);

              if (harmonic) {
                totalDistance += 1 / d;
              } else {
                totalDistance += d;
              }
            }
          }

          return harmonic ? totalDistance : 1 / totalDistance;
        } // closenessCentrality

      }; // elesfn

      // nice, short mathemathical alias
      elesfn.cc = elesfn.closenessCentrality;
      elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

      module.exports = elesfn;

      /***/
    },
    /* 42 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Heap = __webpack_require__(9);

      var elesfn = {

        // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
        betweennessCentrality: function betweennessCentrality(options) {
          options = options || {};

          // Weight - optional
          var weighted, weightFn;
          if (is.fn(options.weight)) {
            weightFn = options.weight;
            weighted = true;
          } else {
            weighted = false;
          }

          // Directed - default false
          var directed = options.directed != null ? options.directed : false;

          var cy = this._private.cy;

          // starting
          var V = this.nodes();
          var A = {};
          var _C = {};
          var max = 0;
          var C = {
            set: function set(key, val) {
              _C[key] = val;

              if (val > max) {
                max = val;
              }
            },

            get: function get(key) {
              return _C[key];
            }
          };

          // A contains the neighborhoods of every node
          for (var i = 0; i < V.length; i++) {
            var v = V[i];
            var vid = v.id();

            if (directed) {
              A[vid] = v.outgoers().nodes(); // get outgoers of every node
            } else {
              A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
            }

            C.set(vid, 0);
          }

          for (var s = 0; s < V.length; s++) {
            var sid = V[s].id();
            var S = []; // stack
            var P = {};
            var g = {};
            var d = {};
            var Q = new Heap(function (a, b) {
              return d[a] - d[b];
            }); // queue

            // init dictionaries
            for (var i = 0; i < V.length; i++) {
              var vid = V[i].id();

              P[vid] = [];
              g[vid] = 0;
              d[vid] = Infinity;
            }

            g[sid] = 1; // sigma
            d[sid] = 0; // distance to s

            Q.push(sid);

            while (!Q.empty()) {
              var v = Q.pop();

              S.push(v);

              if (weighted) {
                for (var j = 0; j < A[v].length; j++) {
                  var w = A[v][j];
                  var vEle = cy.getElementById(v);

                  var edge;
                  if (vEle.edgesTo(w).length > 0) {
                    edge = vEle.edgesTo(w)[0];
                  } else {
                    edge = w.edgesTo(vEle)[0];
                  }

                  var edgeWeight = weightFn(edge);

                  w = w.id();

                  if (d[w] > d[v] + edgeWeight) {
                    d[w] = d[v] + edgeWeight;

                    if (Q.nodes.indexOf(w) < 0) {
                      //if w is not in Q
                      Q.push(w);
                    } else {
                      // update position if w is in Q
                      Q.updateItem(w);
                    }

                    g[w] = 0;
                    P[w] = [];
                  }

                  if (d[w] == d[v] + edgeWeight) {
                    g[w] = g[w] + g[v];
                    P[w].push(v);
                  }
                }
              } else {
                for (var j = 0; j < A[v].length; j++) {
                  var w = A[v][j].id();

                  if (d[w] == Infinity) {
                    Q.push(w);

                    d[w] = d[v] + 1;
                  }

                  if (d[w] == d[v] + 1) {
                    g[w] = g[w] + g[v];
                    P[w].push(v);
                  }
                }
              }
            }

            var e = {};
            for (var i = 0; i < V.length; i++) {
              e[V[i].id()] = 0;
            }

            while (S.length > 0) {
              var w = S.pop();

              for (var j = 0; j < P[w].length; j++) {
                var v = P[w][j];

                e[v] = e[v] + g[v] / g[w] * (1 + e[w]);

                if (w != V[s].id()) {
                  C.set(w, C.get(w) + e[w]);
                }
              }
            }
          }

          var ret = {
            betweenness: function betweenness(node) {
              if (is.string(node)) {
                var node = cy.filter(node).id();
              } else {
                var node = node.id();
              }

              return C.get(node);
            },

            betweennessNormalized: function betweennessNormalized(node) {
              if (max == 0) return 0;

              if (is.string(node)) {
                var node = cy.filter(node).id();
              } else {
                var node = node.id();
              }

              return C.get(node) / max;
            }
          };

          // alias
          ret.betweennessNormalised = ret.betweennessNormalized;

          return ret;
        } // betweennessCentrality

      }; // elesfn

      // nice, short mathemathical alias
      elesfn.bc = elesfn.betweennessCentrality;

      module.exports = elesfn;

      /***/
    },
    /* 43 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);

      var elesfn = {
        animate: define.animate(),
        animation: define.animation(),
        animated: define.animated(),
        clearQueue: define.clearQueue(),
        delay: define.delay(),
        delayAnimation: define.delayAnimation(),
        stop: define.stop()
      };

      module.exports = elesfn;

      /***/
    },
    /* 44 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var Animation = __webpack_require__(45);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var define = {

        animated: function animated() {
          return function animatedImpl() {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return false;
            }

            var ele = all[0];

            if (ele) {
              return ele._private.animation.current.length > 0;
            }
          };
        }, // animated

        clearQueue: function clearQueue() {
          return function clearQueueImpl() {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            for (var i = 0; i < all.length; i++) {
              var ele = all[i];
              ele._private.animation.queue = [];
            }

            return this;
          };
        }, // clearQueue

        delay: function delay() {
          return function delayImpl(time, complete) {
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            return this.animate({
              delay: time,
              duration: time,
              complete: complete
            });
          };
        }, // delay

        delayAnimation: function delayAnimation() {
          return function delayAnimationImpl(time, complete) {
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            return this.animation({
              delay: time,
              duration: time,
              complete: complete
            });
          };
        }, // delay

        animation: function animation() {
          return function animationImpl(properties, params) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;
            var isCore = !selfIsArrayLike;
            var isEles = !isCore;

            if (!cy.styleEnabled()) {
              return this;
            }

            var style = cy.style();

            properties = util.assign({}, properties, params);

            var propertiesEmpty = Object.keys(properties).length === 0;

            if (propertiesEmpty) {
              return new Animation(all[0], properties); // nothing to animate
            }

            if (properties.duration === undefined) {
              properties.duration = 400;
            }

            switch (properties.duration) {
              case 'slow':
                properties.duration = 600;
                break;
              case 'fast':
                properties.duration = 200;
                break;
            }

            if (isEles) {
              properties.style = style.getPropsList(properties.style || properties.css);

              properties.css = undefined;
            }

            if (isEles && properties.renderedPosition != null) {
              var rpos = properties.renderedPosition;
              var pan = cy.pan();
              var zoom = cy.zoom();

              properties.position = math.renderedToModelPosition(rpos, zoom, pan);
            }

            // override pan w/ panBy if set
            if (isCore && properties.panBy != null) {
              var panBy = properties.panBy;
              var cyPan = cy.pan();

              properties.pan = {
                x: cyPan.x + panBy.x,
                y: cyPan.y + panBy.y
              };
            }

            // override pan w/ center if set
            var center = properties.center || properties.centre;
            if (isCore && center != null) {
              var centerPan = cy.getCenterPan(center.eles, properties.zoom);

              if (centerPan != null) {
                properties.pan = centerPan;
              }
            }

            // override pan & zoom w/ fit if set
            if (isCore && properties.fit != null) {
              var fit = properties.fit;
              var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

              if (fitVp != null) {
                properties.pan = fitVp.pan;
                properties.zoom = fitVp.zoom;
              }
            }

            // override zoom (& potentially pan) w/ zoom obj if set
            if (isCore && is.plainObject(properties.zoom)) {
              var vp = cy.getZoomedViewport(properties.zoom);

              if (vp != null) {
                if (vp.zoomed) {
                  properties.zoom = vp.zoom;
                }

                if (vp.panned) {
                  properties.pan = vp.pan;
                }
              }
            }

            return new Animation(all[0], properties);
          };
        }, // animate

        animate: function animate() {
          return function animateImpl(properties, params) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            if (params) {
              properties = util.extend({}, properties, params);
            }

            // manually hook and run the animation
            for (var i = 0; i < all.length; i++) {
              var ele = all[i];
              var queue = ele.animated() && (properties.queue === undefined || properties.queue);

              var ani = ele.animation(properties, queue ? { queue: true } : undefined);

              ani.play();
            }

            return this; // chaining
          };
        }, // animate

        stop: function stop() {
          return function stopImpl(clearQueue, jumpToEnd) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            for (var i = 0; i < all.length; i++) {
              var ele = all[i];
              var _p = ele._private;
              var anis = _p.animation.current;

              for (var j = 0; j < anis.length; j++) {
                var ani = anis[j];
                var ani_p = ani._private;

                if (jumpToEnd) {
                  // next iteration of the animation loop, the animation
                  // will go straight to the end and be removed
                  ani_p.duration = 0;
                }
              }

              // clear the queue of future animations
              if (clearQueue) {
                _p.animation.queue = [];
              }

              if (!jumpToEnd) {
                _p.animation.current = [];
              }
            }

            // we have to notify (the animation loop doesn't do it for us on `stop`)
            cy.notify({
              eles: this,
              type: 'draw'
            });

            return this;
          };
        } // stop

      }; // define

      module.exports = define;

      /***/
    },
    /* 45 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);

      var Animation = function Animation(target, opts, opts2) {
        var _p = this._private = util.extend({
          duration: 1000
        }, opts, opts2);

        _p.target = target;
        _p.style = _p.style || _p.css;
        _p.started = false;
        _p.playing = false;
        _p.hooked = false;
        _p.applying = false;
        _p.progress = 0;
        _p.completes = [];
        _p.frames = [];

        if (_p.complete && is.fn(_p.complete)) {
          _p.completes.push(_p.complete);
        }

        // for future timeline/animations impl
        this.length = 1;
        this[0] = this;
      };

      var anifn = Animation.prototype;

      util.extend(anifn, {

        instanceString: function instanceString() {
          return 'animation';
        },

        hook: function hook() {
          var _p = this._private;

          if (!_p.hooked) {
            // add to target's animation queue
            var q = void 0;
            var tAni = _p.target._private.animation;
            if (_p.queue) {
              q = tAni.queue;
            } else {
              q = tAni.current;
            }
            q.push(this);

            // add to the animation loop pool
            if (is.elementOrCollection(_p.target)) {
              _p.target.cy().addToAnimationPool(_p.target);
            }

            _p.hooked = true;
          }

          return this;
        },

        play: function play() {
          var _p = this._private;

          // autorewind
          if (_p.progress === 1) {
            _p.progress = 0;
          }

          _p.playing = true;
          _p.started = false; // needs to be started by animation loop
          _p.stopped = false;

          this.hook();

          // the animation loop will start the animation...

          return this;
        },

        playing: function playing() {
          return this._private.playing;
        },

        apply: function apply() {
          var _p = this._private;

          _p.applying = true;
          _p.started = false; // needs to be started by animation loop
          _p.stopped = false;

          this.hook();

          // the animation loop will apply the animation at this progress

          return this;
        },

        applying: function applying() {
          return this._private.applying;
        },

        pause: function pause() {
          var _p = this._private;

          _p.playing = false;
          _p.started = false;

          return this;
        },

        stop: function stop() {
          var _p = this._private;

          _p.playing = false;
          _p.started = false;
          _p.stopped = true; // to be removed from animation queues

          return this;
        },

        rewind: function rewind() {
          return this.progress(0);
        },

        fastforward: function fastforward() {
          return this.progress(1);
        },

        time: function time(t) {
          var _p = this._private;

          if (t === undefined) {
            return _p.progress * _p.duration;
          } else {
            return this.progress(t / _p.duration);
          }
        },

        progress: function progress(p) {
          var _p = this._private;
          var wasPlaying = _p.playing;

          if (p === undefined) {
            return _p.progress;
          } else {
            if (wasPlaying) {
              this.pause();
            }

            _p.progress = p;
            _p.started = false;

            if (wasPlaying) {
              this.play();
            }
          }

          return this;
        },

        completed: function completed() {
          return this._private.progress === 1;
        },

        reverse: function reverse() {
          var _p = this._private;
          var wasPlaying = _p.playing;

          if (wasPlaying) {
            this.pause();
          }

          _p.progress = 1 - _p.progress;
          _p.started = false;

          var swap = function swap(a, b) {
            var _pa = _p[a];

            if (_pa == null) {
              return;
            }

            _p[a] = _p[b];
            _p[b] = _pa;
          };

          swap('zoom', 'startZoom');
          swap('pan', 'startPan');
          swap('position', 'startPosition');

          // swap styles
          if (_p.style) {
            for (var i = 0; i < _p.style.length; i++) {
              var prop = _p.style[i];
              var name = prop.name;
              var startStyleProp = _p.startStyle[name];

              _p.startStyle[name] = prop;
              _p.style[i] = startStyleProp;
            }
          }

          if (wasPlaying) {
            this.play();
          }

          return this;
        },

        promise: function promise(type) {
          var _p = this._private;

          var arr = void 0;

          switch (type) {
            case 'frame':
              arr = _p.frames;
              break;
            default:
            case 'complete':
            case 'completed':
              arr = _p.completes;
          }

          return new Promise(function (resolve, reject) {
            arr.push(function () {
              resolve();
            });
          });
        }

      });

      anifn.complete = anifn.completed;

      module.exports = Animation;

      /***/
    },
    /* 46 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }return obj;
      }

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var define = {

        // access data field
        data: function data(params) {
          var defaults = {
            field: 'data',
            bindingEvent: 'data',
            allowBinding: false,
            allowSetting: false,
            allowGetting: false,
            settingEvent: 'data',
            settingTriggersEvent: false,
            triggerFnName: 'trigger',
            immutableKeys: {}, // key => true if immutable
            updateStyle: false,
            beforeGet: function beforeGet(self) {},
            beforeSet: function beforeSet(self, obj) {},
            onSet: function onSet(self) {},
            canSet: function canSet(self) {
              return true;
            }
          };
          params = util.extend({}, defaults, params);

          return function dataImpl(name, value) {
            var p = params;
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var single = selfIsArrayLike ? self[0] : self;

            // .data('foo', ...)
            if (is.string(name)) {
              // set or get property

              // .data('foo')
              if (p.allowGetting && value === undefined) {
                // get

                var ret = void 0;
                if (single) {
                  p.beforeGet(single);

                  ret = single._private[p.field][name];
                }
                return ret;

                // .data('foo', 'bar')
              } else if (p.allowSetting && value !== undefined) {
                // set
                var valid = !p.immutableKeys[name];
                if (valid) {
                  var change = _defineProperty({}, name, value);

                  p.beforeSet(self, change);

                  for (var i = 0, l = all.length; i < l; i++) {
                    var ele = all[i];

                    if (p.canSet(ele)) {
                      ele._private[p.field][name] = value;
                    }
                  }

                  // update mappers if asked
                  if (p.updateStyle) {
                    self.updateStyle();
                  }

                  // call onSet callback
                  p.onSet(self);

                  if (p.settingTriggersEvent) {
                    self[p.triggerFnName](p.settingEvent);
                  }
                }
              }

              // .data({ 'foo': 'bar' })
            } else if (p.allowSetting && is.plainObject(name)) {
              // extend
              var obj = name;
              var k = void 0,
                  v = void 0;
              var keys = Object.keys(obj);

              p.beforeSet(self, obj);

              for (var _i = 0; _i < keys.length; _i++) {
                k = keys[_i];
                v = obj[k];

                var _valid = !p.immutableKeys[k];
                if (_valid) {
                  for (var j = 0; j < all.length; j++) {
                    var _ele = all[j];

                    if (p.canSet(_ele)) {
                      _ele._private[p.field][k] = v;
                    }
                  }
                }
              }

              // update mappers if asked
              if (p.updateStyle) {
                self.updateStyle();
              }

              // call onSet callback
              p.onSet(self);

              if (p.settingTriggersEvent) {
                self[p.triggerFnName](p.settingEvent);
              }

              // .data(function(){ ... })
            } else if (p.allowBinding && is.fn(name)) {
              // bind to event
              var fn = name;
              self.on(p.bindingEvent, fn);

              // .data()
            } else if (p.allowGetting && name === undefined) {
              // get whole object
              var _ret = void 0;
              if (single) {
                p.beforeGet(single);

                _ret = single._private[p.field];
              }
              return _ret;
            }

            return self; // maintain chainability
          }; // function
        }, // data

        // remove data field
        removeData: function removeData(params) {
          var defaults = {
            field: 'data',
            event: 'data',
            triggerFnName: 'trigger',
            triggerEvent: false,
            immutableKeys: {} // key => true if immutable
          };
          params = util.extend({}, defaults, params);

          return function removeDataImpl(names) {
            var p = params;
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            // .removeData('foo bar')
            if (is.string(names)) {
              // then get the list of keys, and delete them
              var keys = names.split(/\s+/);
              var l = keys.length;

              for (var i = 0; i < l; i++) {
                // delete each non-empty key
                var key = keys[i];
                if (is.emptyString(key)) {
                  continue;
                }

                var valid = !p.immutableKeys[key]; // not valid if immutable
                if (valid) {
                  for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
                    all[i_a]._private[p.field][key] = undefined;
                  }
                }
              }

              if (p.triggerEvent) {
                self[p.triggerFnName](p.event);
              }

              // .removeData()
            } else if (names === undefined) {
              // then delete all keys

              for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
                var _privateFields = all[_i_a]._private[p.field];
                var _keys = Object.keys(_privateFields);

                for (var _i2 = 0; _i2 < _keys.length; _i2++) {
                  var _key = _keys[_i2];
                  var validKeyToDelete = !p.immutableKeys[_key];

                  if (validKeyToDelete) {
                    _privateFields[_key] = undefined;
                  }
                }
              }

              if (p.triggerEvent) {
                self[p.triggerFnName](p.event);
              }
            }

            return self; // maintain chaining
          }; // function
        } // removeData
      }; // define

      module.exports = define;

      /***/
    },
    /* 47 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Promise = __webpack_require__(5);

      var define = {

        eventAliasesOn: function eventAliasesOn(proto) {
          var p = proto;

          p.addListener = p.listen = p.bind = p.on;
          p.unlisten = p.unbind = p.off = p.removeListener;
          p.trigger = p.emit;

          // this is just a wrapper alias of .on()
          p.pon = p.promiseOn = function (events, selector) {
            var self = this;
            var args = Array.prototype.slice.call(arguments, 0);

            return new Promise(function (resolve, reject) {
              var callback = function callback(e) {
                self.off.apply(self, offArgs);

                resolve(e);
              };

              var onArgs = args.concat([callback]);
              var offArgs = onArgs.concat([]);

              self.on.apply(self, onArgs);
            });
          };
        }

      }; // define

      module.exports = define;

      /***/
    },
    /* 48 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Set = __webpack_require__(8);

      var elesfn = {
        classes: function classes(_classes) {
          _classes = (_classes || '').match(/\S+/g) || [];
          var self = this;
          var changed = [];
          var classesMap = new Set(_classes);

          // check and update each ele

          var _loop = function _loop(j) {
            var ele = self[j];
            var _p = ele._private;
            var eleClasses = _p.classes;
            var changedEle = false;

            // check if ele has all of the passed classes
            classesMap.forEach(function (cls) {
              var eleHasClass = eleClasses.has(cls);

              if (!eleHasClass) {
                changedEle = true;
              }
            });

            // check if ele has classes outside of those passed
            if (!changedEle) {
              eleClasses.forEach(function (eleCls) {
                var specdClass = classesMap.has(eleCls);

                if (!specdClass) {
                  changedEle = true;
                }
              });
            }

            if (changedEle) {
              _p.classes = new Set(classesMap);

              changed.push(ele);
            }
          };

          for (var j = 0; j < self.length; j++) {
            _loop(j);
          }

          // trigger update style on those eles that had class changes
          if (changed.length > 0) {
            this.spawn(changed).updateStyle().emit('class');
          }

          return self;
        },

        addClass: function addClass(classes) {
          return this.toggleClass(classes, true);
        },

        hasClass: function hasClass(className) {
          var ele = this[0];
          return ele != null && ele._private.classes.has(className);
        },

        toggleClass: function toggleClass(classesStr, toggle) {
          var classes = classesStr.match(/\S+/g) || [];
          var self = this;
          var changed = []; // eles who had classes changed

          for (var i = 0, il = self.length; i < il; i++) {
            var _ele = self[i];
            var _changedEle = false;

            for (var j = 0; j < classes.length; j++) {
              var cls = classes[j];
              var _eleClasses = _ele._private.classes;
              var hasClass = _eleClasses.has(cls);
              var shouldAdd = toggle || toggle === undefined && !hasClass;

              if (shouldAdd) {
                _eleClasses.add(cls);

                if (!hasClass && !_changedEle) {
                  changed.push(_ele);
                  _changedEle = true;
                }
              } else {
                // then remove
                _eleClasses.delete(cls);

                if (hasClass && !_changedEle) {
                  changed.push(_ele);
                  _changedEle = true;
                }
              }
            } // for j classes
          } // for i eles

          // trigger update style on those eles that had class changes
          if (changed.length > 0) {
            this.spawn(changed).updateStyle().emit('class');
          }

          return self;
        },

        removeClass: function removeClass(classes) {
          return this.toggleClass(classes, false);
        },

        flashClass: function flashClass(classes, duration) {
          var self = this;

          if (duration == null) {
            duration = 250;
          } else if (duration === 0) {
            return self; // nothing to do really
          }

          self.addClass(classes);
          setTimeout(function () {
            self.removeClass(classes);
          }, duration);

          return self;
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 49 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Selector = __webpack_require__(6);

      var elesfn = {
        allAre: function allAre(selector) {
          var selObj = new Selector(selector);

          return this.every(function (ele) {
            return selObj.matches(ele);
          });
        },

        is: function is(selector) {
          var selObj = new Selector(selector);

          return this.some(function (ele) {
            return selObj.matches(ele);
          });
        },

        some: function some(fn, thisArg) {
          for (var i = 0; i < this.length; i++) {
            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

            if (ret) {
              return true;
            }
          }

          return false;
        },

        every: function every(fn, thisArg) {
          for (var i = 0; i < this.length; i++) {
            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

            if (!ret) {
              return false;
            }
          }

          return true;
        },

        same: function same(collection) {
          collection = this.cy().collection(collection);

          // cheap extra check
          if (this.length !== collection.length) {
            return false;
          }

          return this.every(function (ele) {
            return collection.hasElementWithId(ele.id());
          });
        },

        anySame: function anySame(collection) {
          collection = this.cy().collection(collection);

          return this.some(function (ele) {
            return collection.hasElementWithId(ele.id());
          });
        },

        allAreNeighbors: function allAreNeighbors(collection) {
          collection = this.cy().collection(collection);

          var nhood = this.neighborhood();

          return collection.every(function (ele) {
            return nhood.hasElementWithId(ele.id());
          });
        },

        contains: function contains(collection) {
          collection = this.cy().collection(collection);

          var self = this;

          return collection.every(function (ele) {
            return self.hasElementWithId(ele.id());
          });
        }
      };

      elesfn.allAreNeighbours = elesfn.allAreNeighbors;
      elesfn.has = elesfn.contains;

      module.exports = elesfn;

      /***/
    },
    /* 50 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var exprs = __webpack_require__(51);
      var newQuery = __webpack_require__(10);

      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function consumeExpr(remaining) {
        var expr = void 0;
        var match = void 0;
        var name = void 0;

        for (var j = 0; j < exprs.length; j++) {
          var e = exprs[j];
          var n = e.name;

          var m = remaining.match(e.regexObj);

          if (m != null) {
            match = m;
            expr = e;
            name = n;

            var consumed = m[0];
            remaining = remaining.substring(consumed.length);

            break; // we've consumed one expr, so we can return now
          }
        }

        return {
          expr: expr,
          match: match,
          name: name,
          remaining: remaining
        };
      };

      // consume all leading whitespace
      var consumeWhitespace = function consumeWhitespace(remaining) {
        var match = remaining.match(/^\s+/);

        if (match) {
          var consumed = match[0];
          remaining = remaining.substring(consumed.length);
        }

        return remaining;
      };

      var parse = function parse(selector) {
        var self = this;

        var remaining = self._private.selectorText = selector;

        var currentQuery = self[0] = newQuery();
        self.length = 1;

        remaining = consumeWhitespace(remaining); // get rid of leading whitespace

        for (;;) {
          var check = consumeExpr(remaining);

          if (check.expr == null) {
            util.error('The selector `' + selector + '`is invalid');
            return false;
          } else {
            var args = check.match.slice(1);

            // let the token populate the selector object in currentQuery
            var ret = check.expr.populate(self, currentQuery, args);

            if (ret === false) {
              return false; // exit if population failed
            } else if (ret != null) {
              currentQuery = ret; // change the current query to be filled if the expr specifies
            }
          }

          remaining = check.remaining;

          // we're done when there's nothing left to parse
          if (remaining.match(/^\s*$/)) {
            break;
          }
        }

        // adjust references for subject
        for (var j = 0; j < self.length; j++) {
          var query = self[j];

          if (query.subject != null) {
            // go up the tree until we reach the subject
            for (;;) {
              if (query.subject === query) {
                break;
              } // done if subject is self

              if (query.parent != null) {
                // swap parent/child reference
                var parent = query.parent;
                var child = query;

                child.parent = null;
                parent.child = child;

                query = parent; // go up the tree
              } else if (query.ancestor != null) {
                // swap ancestor/descendant
                var ancestor = query.ancestor;
                var descendant = query;

                descendant.ancestor = null;
                ancestor.descendant = descendant;

                query = ancestor; // go up the tree
              } else if (query.source || query.target || query.connectedNodes) {
                util.error('The selector `' + self.text() + '` can not contain a subject selector that applies to the source or target of an edge selector');
                return false;
              } else {
                util.error('When adjusting references for the selector `' + self.text() + '`, neither parent nor ancestor was found');
                return false;
              }
            } // for

            self[j] = query.subject; // subject should be the root query
          } // if
        } // for

        return true; // success
      };

      module.exports = { parse: parse };

      /***/
    },
    /* 51 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _require = __webpack_require__(15),
          stateSelectorRegex = _require.stateSelectorRegex;

      var tokens = __webpack_require__(52);
      var util = __webpack_require__(1);
      var newQuery = __webpack_require__(10);

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function cleanMetaChars(str) {
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
          return $1;
        });
      };

      var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
        if (examiningQuery === selector[selector.length - 1]) {
          selector[selector.length - 1] = replacementQuery;
        }
      };

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in selector[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = [{
        name: 'group',
        query: true,
        regex: '(' + tokens.group + ')',
        populate: function populate(selector, query, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              group = _ref2[0];

          query.group = group === '*' ? group : group + 's';
        }
      }, {
        name: 'state',
        query: true,
        regex: stateSelectorRegex,
        populate: function populate(selector, query, _ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              state = _ref4[0];

          query.colonSelectors.push(state);
        }
      }, {
        name: 'id',
        query: true,
        regex: '\\#(' + tokens.id + ')',
        populate: function populate(selector, query, _ref5) {
          var _ref6 = _slicedToArray(_ref5, 1),
              id = _ref6[0];

          query.ids.push(cleanMetaChars(id));
        }
      }, {
        name: 'className',
        query: true,
        regex: '\\.(' + tokens.className + ')',
        populate: function populate(selector, query, _ref7) {
          var _ref8 = _slicedToArray(_ref7, 1),
              className = _ref8[0];

          query.classes.push(cleanMetaChars(className));
        }
      }, {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function populate(selector, query, _ref9) {
          var _ref10 = _slicedToArray(_ref9, 1),
              variable = _ref10[0];

          query.data.push({
            field: cleanMetaChars(variable)
          });
        }
      }, {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
        populate: function populate(selector, query, _ref11) {
          var _ref12 = _slicedToArray(_ref11, 3),
              variable = _ref12[0],
              comparatorOp = _ref12[1],
              value = _ref12[2];

          var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

          if (valueIsString) {
            value = value.substring(1, value.length - 1);
          } else {
            value = parseFloat(value);
          }

          query.data.push({
            field: cleanMetaChars(variable),
            operator: comparatorOp,
            value: value
          });
        }
      }, {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function populate(selector, query, _ref13) {
          var _ref14 = _slicedToArray(_ref13, 2),
              boolOp = _ref14[0],
              variable = _ref14[1];

          query.data.push({
            field: cleanMetaChars(variable),
            operator: boolOp
          });
        }
      }, {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
        populate: function populate(selector, query, _ref15) {
          var _ref16 = _slicedToArray(_ref15, 3),
              meta = _ref16[0],
              comparatorOp = _ref16[1],
              number = _ref16[2];

          query.meta.push({
            field: cleanMetaChars(meta),
            operator: comparatorOp,
            value: parseFloat(number)
          });
        }
      }, {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function populate(selector) {
          // go on to next query
          var nextQuery = selector[selector.length++] = newQuery();
          selector.currentSubject = null;

          return nextQuery;
        }
      }, {
        name: 'directedEdge',
        separator: true,
        regex: tokens.directedEdge,
        populate: function populate(selector, query) {
          var edgeQuery = newQuery();
          var source = query;
          var target = newQuery();

          edgeQuery.group = 'edges';
          edgeQuery.target = target;
          edgeQuery.source = source;
          edgeQuery.subject = selector.currentSubject;

          // the query in the selector should be the edge rather than the source
          replaceLastQuery(selector, query, edgeQuery);

          // we're now populating the target query with expressions that follow
          return target;
        }
      }, {
        name: 'undirectedEdge',
        separator: true,
        regex: tokens.undirectedEdge,
        populate: function populate(selector, query) {
          var edgeQuery = newQuery();
          var source = query;
          var target = newQuery();

          edgeQuery.group = 'edges';
          edgeQuery.connectedNodes = [source, target];
          edgeQuery.subject = selector.currentSubject;

          // the query in the selector should be the edge rather than the source
          replaceLastQuery(selector, query, edgeQuery);

          // we're now populating the target query with expressions that follow
          return target;
        }
      }, {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function populate(selector, query) {
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = query;
          childQuery.subject = selector.currentSubject;

          // it's cheaper to compare children first and go up so replace the parent
          replaceLastQuery(selector, query, childQuery);

          // we're now populating the child query with expressions that follow
          return childQuery;
        }
      }, {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function populate(selector, query) {
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = query;
          descendantQuery.subject = selector.currentSubject;

          // it's cheaper to compare descendants first and go up so replace the ancestor
          replaceLastQuery(selector, query, descendantQuery);

          // we're now populating the descendant query with expressions that follow
          return descendantQuery;
        }
      }, {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function populate(selector, query) {
          if (selector.currentSubject != null && query.subject != query) {
            util.error('Redefinition of subject in selector `' + selector.toString() + '`');
            return false;
          }

          selector.currentSubject = query;
          query.subject = query;
          selector[selector.length - 1].subject = query;
        }
      }];

      exprs.forEach(function (e) {
        return e.regexObj = new RegExp('^' + e.regex);
      });

      module.exports = exprs;

      /***/
    },
    /* 52 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in let names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$',
        group: 'node|edge|\\*',
        directedEdge: '\\s+->\\s+',
        undirectedEdge: '\\s+<->\\s+'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      (function () {
        var ops = void 0,
            op = void 0,
            i = void 0;

        // add @ variants to comparatorOp
        ops = tokens.comparatorOp.split('|');
        for (i = 0; i < ops.length; i++) {
          op = ops[i];
          tokens.comparatorOp += '|@' + op;
        }

        // add ! variants to comparatorOp
        ops = tokens.comparatorOp.split('|');
        for (i = 0; i < ops.length; i++) {
          op = ops[i];

          if (op.indexOf('!') >= 0) {
            continue;
          } // skip ops that explicitly contain !
          if (op === '=') {
            continue;
          } // skip = b/c != is explicitly defined

          tokens.comparatorOp += '|\\!' + op;
        }
      })();

      module.exports = tokens;

      /***/
    },
    /* 53 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _require = __webpack_require__(15),
          stateSelectorMatches = _require.stateSelectorMatches;

      var is = __webpack_require__(0);

      // generic checking for data/metadata
      var operandsMatch = function operandsMatch(query, params) {
        var allDataMatches = true;
        for (var k = 0; k < query[params.name].length; k++) {
          var data = query[params.name][k];
          var operator = data.operator;
          var value = data.value;
          var field = data.field;
          var _matches = void 0;
          var fieldVal = params.fieldValue(field);

          if (operator != null && value != null) {
            var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
            var valStr = '' + value;

            var caseInsensitive = false;
            if (operator.indexOf('@') >= 0) {
              fieldStr = fieldStr.toLowerCase();
              valStr = valStr.toLowerCase();

              operator = operator.replace('@', '');
              caseInsensitive = true;
            }

            var notExpr = false;
            if (operator.indexOf('!') >= 0) {
              operator = operator.replace('!', '');
              notExpr = true;
            }

            // if we're doing a case insensitive comparison, then we're using a STRING comparison
            // even if we're comparing numbers
            if (caseInsensitive) {
              value = valStr.toLowerCase();
              fieldVal = fieldStr.toLowerCase();
            }

            var isIneqCmp = false;

            switch (operator) {
              case '*=':
                _matches = fieldStr.indexOf(valStr) >= 0;
                break;
              case '$=':
                _matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
                break;
              case '^=':
                _matches = fieldStr.indexOf(valStr) === 0;
                break;
              case '=':
                _matches = fieldVal === value;
                break;
              case '>':
                isIneqCmp = true;
                _matches = fieldVal > value;
                break;
              case '>=':
                isIneqCmp = true;
                _matches = fieldVal >= value;
                break;
              case '<':
                isIneqCmp = true;
                _matches = fieldVal < value;
                break;
              case '<=':
                isIneqCmp = true;
                _matches = fieldVal <= value;
                break;
              default:
                _matches = false;
                break;
            }

            // apply the not op, but null vals for inequalities should always stay non-matching
            if (notExpr && (fieldVal != null || !isIneqCmp)) {
              _matches = !_matches;
            }
          } else if (operator != null) {
            switch (operator) {
              case '?':
                _matches = fieldVal ? true : false;
                break;
              case '!':
                _matches = fieldVal ? false : true;
                break;
              case '^':
                _matches = fieldVal === undefined;
                break;
            }
          } else {
            _matches = fieldVal !== undefined;
          }

          if (!_matches) {
            allDataMatches = false;
            break;
          }
        } // for

        return allDataMatches;
      }; // operandsMatch

      // check parent/child relations
      var confirmRelations = function confirmRelations(query, isNecessary, eles) {
        if (query != null) {
          var _matches2 = false;

          if (!isNecessary) {
            return false;
          }

          eles = eles(); // save cycles if query == null

          // query must match for at least one element (may be recursive)
          for (var i = 0; i < eles.length; i++) {
            if (queryMatches(query, eles[i])) {
              _matches2 = true;
              break;
            }
          }

          return _matches2;
        } else {
          return true;
        }
      };

      var queryMatches = function queryMatches(query, ele) {
        // make single group-only selectors really cheap to check since they're the most common ones
        if (query.groupOnly) {
          return query.group === '*' || query.group === ele.group();
        }

        // check group
        if (query.group != null && query.group != '*' && query.group != ele.group()) {
          return false;
        }

        var cy = ele.cy();
        var k = void 0;

        // check colon selectors
        var allColonSelectorsMatch = true;
        for (k = 0; k < query.colonSelectors.length; k++) {
          var sel = query.colonSelectors[k];

          allColonSelectorsMatch = stateSelectorMatches(sel, ele);

          if (!allColonSelectorsMatch) break;
        }
        if (!allColonSelectorsMatch) return false;

        // check id
        var allIdsMatch = true;
        for (k = 0; k < query.ids.length; k++) {
          var id = query.ids[k];
          var actualId = ele.id();

          allIdsMatch = allIdsMatch && id == actualId;

          if (!allIdsMatch) break;
        }
        if (!allIdsMatch) return false;

        // check classes
        var allClassesMatch = true;
        for (k = 0; k < query.classes.length; k++) {
          var cls = query.classes[k];

          allClassesMatch = allClassesMatch && ele.hasClass(cls);

          if (!allClassesMatch) break;
        }
        if (!allClassesMatch) return false;

        // check data matches
        var allDataMatches = operandsMatch(query, {
          name: 'data',
          fieldValue: function fieldValue(field) {
            return ele.data(field);
          }
        });

        if (!allDataMatches) {
          return false;
        }

        // check metadata matches
        var allMetaMatches = operandsMatch(query, {
          name: 'meta',
          fieldValue: function fieldValue(field) {
            return ele[field]();
          }
        });

        if (!allMetaMatches) {
          return false;
        }

        // check collection
        if (query.collection != null) {
          var matchesAny = query.collection.hasElementWithId(ele.id());

          if (!matchesAny) {
            return false;
          }
        }

        // check filter function
        if (query.filter != null && ele.collection().some(query.filter)) {
          return false;
        }

        var isCompound = cy.hasCompoundNodes();
        var getSource = function getSource() {
          return ele.source();
        };
        var getTarget = function getTarget() {
          return ele.target();
        };

        if (!confirmRelations(query.parent, isCompound, function () {
          return ele.parent();
        })) {
          return false;
        }

        if (!confirmRelations(query.ancestor, isCompound, function () {
          return ele.parents();
        })) {
          return false;
        }

        if (!confirmRelations(query.child, isCompound, function () {
          return ele.children();
        })) {
          return false;
        }

        if (!confirmRelations(query.descendant, isCompound, function () {
          return ele.descendants();
        })) {
          return false;
        }

        if (!confirmRelations(query.source, true, getSource)) {
          return false;
        }

        if (!confirmRelations(query.target, true, getTarget)) {
          return false;
        }

        if (query.connectedNodes) {
          var q0 = query.connectedNodes[0];
          var q1 = query.connectedNodes[1];

          if (confirmRelations(q0, true, getSource) && confirmRelations(q1, true, getTarget)) {
            // match
          } else if (confirmRelations(q0, true, getTarget) && confirmRelations(q1, true, getSource)) {
            // match
          } else {
            return false;
          }
        }

        // we've reached the end, so we've matched everything for this query
        return true;
      }; // queryMatches

      // filter an existing collection
      var filter = function filter(collection) {
        var self = this;
        var cy = collection.cy();

        // don't bother trying if it's invalid
        if (self.invalid()) {
          return cy.collection();
        }

        // for 1 id #foo queries, just get the element
        if (self.length === 1 && self[0].length === 1 && self[0].ids.length === 1) {
          return collection.getElementById(self[0].ids[0]).collection();
        }

        var selectorFunction = function selectorFunction(element) {
          for (var j = 0; j < self.length; j++) {
            var query = self[j];

            if (queryMatches(query, element)) {
              return true;
            }
          }

          return false;
        };

        if (self.text() == null) {
          selectorFunction = function selectorFunction() {
            return true;
          };
        }

        var filteredCollection = collection.filter(selectorFunction);

        return filteredCollection;
      }; // filter

      // does selector match a single element?
      var matches = function matches(ele) {
        var self = this;

        // don't bother trying if it's invalid
        if (self.invalid()) {
          return false;
        }

        for (var j = 0; j < self.length; j++) {
          var query = self[j];

          if (queryMatches(query, ele)) {
            return true;
          }
        }

        return false;
      }; // filter

      module.exports = { matches: matches, filter: filter };

      /***/
    },
    /* 54 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Set = __webpack_require__(8);

      var elesfn = {
        parent: function parent(selector) {
          var parents = [];

          // optimisation for single ele call
          if (this.length === 1) {
            var parent = this[0]._private.parent;

            if (parent) {
              return parent;
            }
          }

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var _parent = ele._private.parent;

            if (_parent) {
              parents.push(_parent);
            }
          }

          return this.spawn(parents, { unique: true }).filter(selector);
        },

        parents: function parents(selector) {
          var parents = [];

          var eles = this.parent();
          while (eles.nonempty()) {
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              parents.push(ele);
            }

            eles = eles.parent();
          }

          return this.spawn(parents, { unique: true }).filter(selector);
        },

        commonAncestors: function commonAncestors(selector) {
          var ancestors = void 0;

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var parents = ele.parents();

            ancestors = ancestors || parents;

            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
          }

          return ancestors.filter(selector);
        },

        orphans: function orphans(selector) {
          return this.stdFilter(function (ele) {
            return ele.isOrphan();
          }).filter(selector);
        },

        nonorphans: function nonorphans(selector) {
          return this.stdFilter(function (ele) {
            return ele.isChild();
          }).filter(selector);
        },

        children: function children(selector) {
          var children = [];

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            children = children.concat(ele._private.children);
          }

          return this.spawn(children, { unique: true }).filter(selector);
        },

        siblings: function siblings(selector) {
          return this.parent().children().not(this).filter(selector);
        },

        isParent: function isParent() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.children.length !== 0;
          }
        },

        isChildless: function isChildless() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.children.length === 0;
          }
        },

        isChild: function isChild() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.parent != null;
          }
        },

        isOrphan: function isOrphan() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.parent == null;
          }
        },

        descendants: function descendants(selector) {
          var elements = [];

          function add(eles) {
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];

              elements.push(ele);

              if (ele.children().nonempty()) {
                add(ele.children());
              }
            }
          }

          add(this.children());

          return this.spawn(elements, { unique: true }).filter(selector);
        }
      };

      function forEachCompound(eles, fn, includeSelf, recursiveStep) {
        var q = [];
        var did = new Set();
        var cy = eles.cy();
        var hasCompounds = cy.hasCompoundNodes();

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (includeSelf) {
            q.push(ele);
          } else if (hasCompounds) {
            recursiveStep(q, did, ele);
          }
        }

        while (q.length > 0) {
          var _ele = q.shift();

          fn(_ele);

          did.add(_ele.id());

          if (hasCompounds) {
            recursiveStep(q, did, _ele);
          }
        }

        return eles;
      }

      function addChildren(q, did, ele) {
        if (ele.isParent()) {
          var children = ele._private.children;

          for (var i = 0; i < children.length; i++) {
            var child = children[i];

            if (!did.has(child.id())) {
              q.push(child);
            }
          }
        }
      }

      // very efficient version of eles.add( eles.descendants() ).forEach()
      // for internal use
      elesfn.forEachDown = function (fn) {
        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return forEachCompound(this, fn, includeSelf, addChildren);
      };

      function addParent(q, did, ele) {
        if (ele.isChild()) {
          var parent = ele._private.parent;

          if (!did.has(parent.id())) {
            q.push(parent);
          }
        }
      }

      elesfn.forEachUp = function (fn) {
        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return forEachCompound(this, fn, includeSelf, addParent);
      };

      function addParentAndChildren(q, did, ele) {
        addParent(q, did, ele);
        addChildren(q, did, ele);
      }

      elesfn.forEachUpAndDown = function (fn) {
        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return forEachCompound(this, fn, includeSelf, addParentAndChildren);
      };

      // aliases
      elesfn.ancestors = elesfn.parents;

      module.exports = elesfn;

      /***/
    },
    /* 55 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);
      var fn = void 0,
          elesfn = void 0;

      fn = elesfn = {

        data: define.data({
          field: 'data',
          bindingEvent: 'data',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'data',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          immutableKeys: {
            'id': true,
            'source': true,
            'target': true,
            'parent': true
          },
          updateStyle: true
        }),

        removeData: define.removeData({
          field: 'data',
          event: 'data',
          triggerFnName: 'trigger',
          triggerEvent: true,
          immutableKeys: {
            'id': true,
            'source': true,
            'target': true,
            'parent': true
          },
          updateStyle: true
        }),

        scratch: define.data({
          field: 'scratch',
          bindingEvent: 'scratch',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'scratch',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          updateStyle: true
        }),

        removeScratch: define.removeData({
          field: 'scratch',
          event: 'scratch',
          triggerFnName: 'trigger',
          triggerEvent: true,
          updateStyle: true
        }),

        rscratch: define.data({
          field: 'rscratch',
          allowBinding: false,
          allowSetting: true,
          settingTriggersEvent: false,
          allowGetting: true
        }),

        removeRscratch: define.removeData({
          field: 'rscratch',
          triggerEvent: false
        }),

        id: function id() {
          var ele = this[0];

          if (ele) {
            return ele._private.data.id;
          }
        }

      };

      // aliases
      fn.attr = fn.data;
      fn.removeAttr = fn.removeData;

      module.exports = elesfn;

      /***/
    },
    /* 56 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var elesfn = {};

      function defineDegreeFunction(callback) {
        return function (includeLoops) {
          var self = this;

          if (includeLoops === undefined) {
            includeLoops = true;
          }

          if (self.length === 0) {
            return;
          }

          if (self.isNode() && !self.removed()) {
            var degree = 0;
            var node = self[0];
            var connectedEdges = node._private.edges;

            for (var i = 0; i < connectedEdges.length; i++) {
              var edge = connectedEdges[i];

              if (!includeLoops && edge.isLoop()) {
                continue;
              }

              degree += callback(node, edge);
            }

            return degree;
          } else {
            return;
          }
        };
      }

      util.extend(elesfn, {
        degree: defineDegreeFunction(function (node, edge) {
          if (edge.source().same(edge.target())) {
            return 2;
          } else {
            return 1;
          }
        }),

        indegree: defineDegreeFunction(function (node, edge) {
          if (edge.target().same(node)) {
            return 1;
          } else {
            return 0;
          }
        }),

        outdegree: defineDegreeFunction(function (node, edge) {
          if (edge.source().same(node)) {
            return 1;
          } else {
            return 0;
          }
        })
      });

      function defineDegreeBoundsFunction(degreeFn, callback) {
        return function (includeLoops) {
          var ret = void 0;
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            var ele = nodes[i];
            var degree = ele[degreeFn](includeLoops);
            if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
              ret = degree;
            }
          }

          return ret;
        };
      }

      util.extend(elesfn, {
        minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
          return degree < min;
        }),

        maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
          return degree > max;
        }),

        minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
          return degree < min;
        }),

        maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
          return degree > max;
        }),

        minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
          return degree < min;
        }),

        maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
          return degree > max;
        })
      });

      util.extend(elesfn, {
        totalDegree: function totalDegree(includeLoops) {
          var total = 0;
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            total += nodes[i].degree(includeLoops);
          }

          return total;
        }
      });

      module.exports = elesfn;

      /***/
    },
    /* 57 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var position = __webpack_require__(58);
      var bounds = __webpack_require__(59);
      var widthHeight = __webpack_require__(60);
      var edgePoints = __webpack_require__(61);

      module.exports = util.assign({}, position, bounds, widthHeight, edgePoints);

      /***/
    },
    /* 58 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);
      var is = __webpack_require__(0);
      var math = __webpack_require__(2);
      var fn = void 0,
          elesfn = void 0;

      var beforePositionSet = function beforePositionSet(eles, newPos) {
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (ele.isParent() && !ele.locked()) {
            var oldPos = ele._private.position;
            var delta = {
              x: newPos.x - oldPos.x,
              y: newPos.y - oldPos.y
            };

            eles.children().shift(delta);
          }
        }
      };

      fn = elesfn = {

        position: define.data({
          field: 'position',
          bindingEvent: 'position',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'position',
          settingTriggersEvent: true,
          triggerFnName: 'emitAndNotify',
          allowGetting: true,
          validKeys: ['x', 'y'],
          beforeGet: function beforeGet(ele) {
            ele.updateCompoundBounds();
          },
          beforeSet: beforePositionSet,
          onSet: function onSet(eles) {
            eles.dirtyCompoundBoundsCache();
          },
          canSet: function canSet(ele) {
            return !ele.locked();
          }
        }),

        // position but no notification to renderer
        silentPosition: define.data({
          field: 'position',
          bindingEvent: 'position',
          allowBinding: false,
          allowSetting: true,
          settingEvent: 'position',
          settingTriggersEvent: false,
          triggerFnName: 'trigger',
          allowGetting: false,
          validKeys: ['x', 'y'],
          beforeSet: beforePositionSet,
          onSet: function onSet(eles) {
            eles.dirtyCompoundBoundsCache();
          },
          canSet: function canSet(ele) {
            return !ele.locked();
          }
        }),

        positions: function positions(pos, silent) {
          if (is.plainObject(pos)) {
            if (silent) {
              this.silentPosition(pos);
            } else {
              this.position(pos);
            }
          } else if (is.fn(pos)) {
            var _fn = pos;
            var cy = this.cy();

            cy.startBatch();

            for (var i = 0; i < this.length; i++) {
              var ele = this[i];
              var _pos = void 0;

              if (_pos = _fn(ele, i)) {
                if (silent) {
                  ele.silentPosition(_pos);
                } else {
                  ele.position(_pos);
                }
              }
            }

            cy.endBatch();
          }

          return this; // chaining
        },

        silentPositions: function silentPositions(pos) {
          return this.positions(pos, true);
        },

        shift: function shift(dim, val) {
          var delta = void 0;

          if (is.plainObject(dim)) {
            delta = dim;
          } else if (is.string(dim) && is.number(val)) {
            delta = { x: 0, y: 0 };

            delta[dim] = val;
          }

          if (delta != null) {
            for (var i = 0; i < this.length; i++) {
              var ele = this[i];
              var pos = ele.position();

              ele.position({
                x: pos.x + delta.x,
                y: pos.y + delta.y
              });
            }
          }

          return this;
        },

        // get/set the rendered (i.e. on screen) positon of the element
        renderedPosition: function renderedPosition(dim, val) {
          var ele = this[0];
          var cy = this.cy();
          var zoom = cy.zoom();
          var pan = cy.pan();
          var rpos = is.plainObject(dim) ? dim : undefined;
          var setting = rpos !== undefined || val !== undefined && is.string(dim);

          if (ele && ele.isNode()) {
            // must have an element and must be a node to return position
            if (setting) {
              for (var i = 0; i < this.length; i++) {
                var _ele = this[i];

                if (val !== undefined) {
                  // set one dimension
                  _ele.position(dim, (val - pan[dim]) / zoom);
                } else if (rpos !== undefined) {
                  // set whole position
                  _ele.position(math.renderedToModelPosition(rpos, zoom, pan));
                }
              }
            } else {
              // getting
              var pos = ele.position();
              rpos = math.modelToRenderedPosition(pos, zoom, pan);

              if (dim === undefined) {
                // then return the whole rendered position
                return rpos;
              } else {
                // then return the specified dimension
                return rpos[dim];
              }
            }
          } else if (!setting) {
            return undefined; // for empty collection case
          }

          return this; // chaining
        },

        // get/set the position relative to the parent
        relativePosition: function relativePosition(dim, val) {
          var ele = this[0];
          var cy = this.cy();
          var ppos = is.plainObject(dim) ? dim : undefined;
          var setting = ppos !== undefined || val !== undefined && is.string(dim);
          var hasCompoundNodes = cy.hasCompoundNodes();

          if (ele && ele.isNode()) {
            // must have an element and must be a node to return position
            if (setting) {
              for (var i = 0; i < this.length; i++) {
                var _ele2 = this[i];
                var parent = hasCompoundNodes ? _ele2.parent() : null;
                var hasParent = parent && parent.length > 0;
                var relativeToParent = hasParent;

                if (hasParent) {
                  parent = parent[0];
                }

                var origin = relativeToParent ? parent.position() : { x: 0, y: 0 };

                if (val !== undefined) {
                  // set one dimension
                  _ele2.position(dim, val + origin[dim]);
                } else if (ppos !== undefined) {
                  // set whole position
                  _ele2.position({
                    x: ppos.x + origin.x,
                    y: ppos.y + origin.y
                  });
                }
              }
            } else {
              // getting
              var pos = ele.position();
              var _parent = hasCompoundNodes ? ele.parent() : null;
              var _hasParent = _parent && _parent.length > 0;
              var _relativeToParent = _hasParent;

              if (_hasParent) {
                _parent = _parent[0];
              }

              var _origin = _relativeToParent ? _parent.position() : { x: 0, y: 0 };

              ppos = {
                x: pos.x - _origin.x,
                y: pos.y - _origin.y
              };

              if (dim === undefined) {
                // then return the whole rendered position
                return ppos;
              } else {
                // then return the specified dimension
                return ppos[dim];
              }
            }
          } else if (!setting) {
            return undefined; // for empty collection case
          }

          return this; // chaining
        }
      };

      // aliases
      fn.modelPosition = fn.point = fn.position;
      fn.modelPositions = fn.points = fn.positions;
      fn.renderedPoint = fn.renderedPosition;
      fn.relativePoint = fn.relativePosition;

      module.exports = elesfn;

      /***/
    },
    /* 59 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var fn = void 0,
          elesfn = void 0;

      fn = elesfn = {};

      elesfn.renderedBoundingBox = function (options) {
        var bb = this.boundingBox(options);
        var cy = this.cy();
        var zoom = cy.zoom();
        var pan = cy.pan();

        var x1 = bb.x1 * zoom + pan.x;
        var x2 = bb.x2 * zoom + pan.x;
        var y1 = bb.y1 * zoom + pan.y;
        var y2 = bb.y2 * zoom + pan.y;

        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          w: x2 - x1,
          h: y2 - y1
        };
      };

      elesfn.dirtyCompoundBoundsCache = function () {
        var cy = this.cy();

        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
          return this;
        }

        this.forEachUp(function (ele) {
          ele._private.compoundBoundsClean = false;

          if (ele.isParent()) {
            ele.emit('bounds');
          }
        });

        return this;
      };

      elesfn.updateCompoundBounds = function () {
        var cy = this.cy();

        // save cycles for non compound graphs or when style disabled
        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
          return this;
        }

        // save cycles when batching -- but bounds will be stale (or not exist yet)
        if (cy.batching()) {
          return this;
        }

        var updated = [];

        function update(parent) {
          if (!parent.isParent()) {
            return;
          }

          var _p = parent._private;
          var children = parent.children();
          var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';

          var min = {
            width: {
              val: parent.pstyle('min-width').pfValue,
              left: parent.pstyle('min-width-bias-left'),
              right: parent.pstyle('min-width-bias-right')
            },
            height: {
              val: parent.pstyle('min-height').pfValue,
              top: parent.pstyle('min-height-bias-top'),
              bottom: parent.pstyle('min-height-bias-bottom')
            }
          };

          var bb = children.boundingBox({
            includeLabels: includeLabels,
            includeOverlays: false,

            // updating the compound bounds happens outside of the regular
            // cache cycle (i.e. before fired events)
            useCache: false
          });
          var pos = _p.position;

          // if children take up zero area then keep position and fall back on stylesheet w/h
          if (bb.w === 0 || bb.h === 0) {
            bb = {
              w: parent.pstyle('width').pfValue,
              h: parent.pstyle('height').pfValue
            };

            bb.x1 = pos.x - bb.w / 2;
            bb.x2 = pos.x + bb.w / 2;
            bb.y1 = pos.y - bb.h / 2;
            bb.y2 = pos.y + bb.h / 2;
          }

          function computeBiasValues(propDiff, propBias, propBiasComplement) {
            var biasDiff = 0;
            var biasComplementDiff = 0;
            var biasTotal = propBias + propBiasComplement;

            if (propDiff > 0 && biasTotal > 0) {
              biasDiff = propBias / biasTotal * propDiff;
              biasComplementDiff = propBiasComplement / biasTotal * propDiff;
            }
            return {
              biasDiff: biasDiff,
              biasComplementDiff: biasComplementDiff
            };
          }

          function computePaddingValues(width, height, paddingObject, relativeTo) {
            // Assuming percentage is number from 0 to 1
            if (paddingObject.units === '%') {
              switch (relativeTo) {
                case 'width':
                  return width > 0 ? paddingObject.pfValue * width : 0;
                case 'height':
                  return height > 0 ? paddingObject.pfValue * height : 0;
                case 'average':
                  return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;
                case 'min':
                  return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;
                case 'max':
                  return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;
                default:
                  return 0;
              }
            } else if (paddingObject.units === 'px') {
              return paddingObject.pfValue;
            } else {
              return 0;
            }
          }

          var leftVal = min.width.left.value;
          if (min.width.left.units === 'px' && min.width.val > 0) {
            leftVal = leftVal * 100 / min.width.val;
          }
          var rightVal = min.width.right.value;
          if (min.width.right.units === 'px' && min.width.val > 0) {
            rightVal = rightVal * 100 / min.width.val;
          }

          var topVal = min.height.top.value;
          if (min.height.top.units === 'px' && min.height.val > 0) {
            topVal = topVal * 100 / min.height.val;
          }

          var bottomVal = min.height.bottom.value;
          if (min.height.bottom.units === 'px' && min.height.val > 0) {
            bottomVal = bottomVal * 100 / min.height.val;
          }

          var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
          var diffLeft = widthBiasDiffs.biasDiff;
          var diffRight = widthBiasDiffs.biasComplementDiff;

          var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
          var diffTop = heightBiasDiffs.biasDiff;
          var diffBottom = heightBiasDiffs.biasComplementDiff;

          _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);

          _p.autoWidth = Math.max(bb.w, min.width.val);
          pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

          _p.autoHeight = Math.max(bb.h, min.height.val);
          pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;

          updated.push(parent);
        }

        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var _p = ele._private;

          if (!_p.compoundBoundsClean) {
            update(ele);

            if (!cy._private.batchingStyle) {
              _p.compoundBoundsClean = true;
            }
          }
        }

        return this;
      };

      var noninf = function noninf(x) {
        if (x === Infinity || x === -Infinity) {
          return 0;
        }

        return x;
      };

      var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
        // don't update with zero area boxes
        if (x2 - x1 === 0 || y2 - y1 === 0) {
          return;
        }

        // don't update with null dim
        if (x1 == null || y1 == null || x2 == null || y2 == null) {
          return;
        }

        b.x1 = x1 < b.x1 ? x1 : b.x1;
        b.x2 = x2 > b.x2 ? x2 : b.x2;
        b.y1 = y1 < b.y1 ? y1 : b.y1;
        b.y2 = y2 > b.y2 ? y2 : b.y2;
      };

      var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
        return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
      };

      var prefixedProperty = function prefixedProperty(obj, field, prefix) {
        return util.getPrefixedProperty(obj, field, prefix);
      };

      var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
        if (ele.cy().headless()) {
          return;
        }

        var _p = ele._private;
        var rstyle = _p.rstyle;
        var halfArW = rstyle.arrowWidth / 2;
        var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
        var x = void 0;
        var y = void 0;

        if (arrowType !== 'none') {
          if (prefix === 'source') {
            x = rstyle.srcX;
            y = rstyle.srcY;
          } else if (prefix === 'target') {
            x = rstyle.tgtX;
            y = rstyle.tgtY;
          } else {
            x = rstyle.midX;
            y = rstyle.midY;
          }

          updateBounds(bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW);
        }
      };

      var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
        if (ele.cy().headless()) {
          return;
        }

        var prefixDash = void 0;

        if (prefix) {
          prefixDash = prefix + '-';
        } else {
          prefixDash = '';
        }

        var _p = ele._private;
        var rstyle = _p.rstyle;
        var label = ele.pstyle(prefixDash + 'label').strValue;

        if (label) {
          var halign = ele.pstyle('text-halign');
          var valign = ele.pstyle('text-valign');
          var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
          var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
          var labelX = prefixedProperty(rstyle, 'labelX', prefix);
          var labelY = prefixedProperty(rstyle, 'labelY', prefix);
          var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
          var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
          var isEdge = ele.isEdge();
          var rotation = ele.pstyle(prefixDash + 'text-rotation');
          var outlineWidth = ele.pstyle('text-outline-width').pfValue;
          var borderWidth = ele.pstyle('text-border-width').pfValue;
          var halfBorderWidth = borderWidth / 2;
          var padding = ele.pstyle('text-background-padding').pfValue;

          var lh = labelHeight + 2 * padding;
          var lw = labelWidth + 2 * padding;
          var lw_2 = lw / 2;
          var lh_2 = lh / 2;
          var lx1 = void 0,
              lx2 = void 0,
              ly1 = void 0,
              ly2 = void 0;

          if (isEdge) {
            lx1 = labelX - lw_2;
            lx2 = labelX + lw_2;
            ly1 = labelY - lh_2;
            ly2 = labelY + lh_2;
          } else {
            switch (halign.value) {
              case 'left':
                lx1 = labelX - lw;
                lx2 = labelX;
                break;

              case 'center':
                lx1 = labelX - lw_2;
                lx2 = labelX + lw_2;
                break;

              case 'right':
                lx1 = labelX;
                lx2 = labelX + lw;
                break;
            }

            switch (valign.value) {
              case 'top':
                ly1 = labelY - lh;
                ly2 = labelY;
                break;

              case 'center':
                ly1 = labelY - lh_2;
                ly2 = labelY + lh_2;
                break;

              case 'bottom':
                ly1 = labelY;
                ly2 = labelY + lh;
                break;
            }
          }

          var isAutorotate = isEdge && rotation.strValue === 'autorotate';
          var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

          if (isAutorotate || isPfValue) {
            var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);

            var rotate = function rotate(x, y) {
              x = x - labelX;
              y = y - labelY;

              return {
                x: x * cos - y * sin + labelX,
                y: x * sin + y * cos + labelY
              };
            };

            var px1y1 = rotate(lx1, ly1);
            var px1y2 = rotate(lx1, ly2);
            var px2y1 = rotate(lx2, ly1);
            var px2y2 = rotate(lx2, ly2);

            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
          }

          lx1 += marginX - Math.max(outlineWidth, halfBorderWidth);
          lx2 += marginX + Math.max(outlineWidth, halfBorderWidth);
          ly1 += marginY - Math.max(outlineWidth, halfBorderWidth);
          ly2 += marginY + Math.max(outlineWidth, halfBorderWidth);

          updateBounds(bounds, lx1, ly1, lx2, ly2);
        }

        return bounds;
      };

      // get the bounding box of the elements (in raw model position)
      var boundingBoxImpl = function boundingBoxImpl(ele, options) {
        var cy = ele._private.cy;
        var styleEnabled = cy.styleEnabled();
        var headless = cy.headless();

        var bounds = {
          x1: Infinity,
          y1: Infinity,
          x2: -Infinity,
          y2: -Infinity
        };

        var _p = ele._private;
        var display = styleEnabled ? ele.pstyle('display').value : 'element';
        var isNode = ele.isNode();
        var isEdge = ele.isEdge();
        var ex1 = void 0,
            ex2 = void 0,
            ey1 = void 0,
            ey2 = void 0; // extrema of body / lines
        var x = void 0,
            y = void 0; // node pos
        var displayed = display !== 'none';

        if (displayed) {
          var overlayOpacity = 0;
          var overlayPadding = 0;

          if (styleEnabled && options.includeOverlays) {
            overlayOpacity = ele.pstyle('overlay-opacity').value;

            if (overlayOpacity !== 0) {
              overlayPadding = ele.pstyle('overlay-padding').value;
            }
          }

          var w = 0;
          var wHalf = 0;

          if (styleEnabled) {
            w = ele.pstyle('width').pfValue;
            wHalf = w / 2;
          }

          if (isNode && options.includeNodes) {
            var pos = ele.position();
            x = pos.x;
            y = pos.y;
            var _w = ele.outerWidth();
            var halfW = _w / 2;
            var h = ele.outerHeight();
            var halfH = h / 2;

            // handle node dimensions
            /////////////////////////

            ex1 = x - halfW - overlayPadding;
            ex2 = x + halfW + overlayPadding;
            ey1 = y - halfH - overlayPadding;
            ey2 = y + halfH + overlayPadding;

            updateBounds(bounds, ex1, ey1, ex2, ey2);
          } else if (isEdge && options.includeEdges) {
            var rstyle = _p.rstyle || {};

            // handle edge dimensions (rough box estimate)
            //////////////////////////////////////////////
            if (styleEnabled && !headless) {
              ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
              ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
              ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
              ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);

              // take into account edge width
              ex1 -= wHalf;
              ex2 += wHalf;
              ey1 -= wHalf;
              ey2 += wHalf;

              updateBounds(bounds, ex1, ey1, ex2, ey2);
            }

            // precise haystacks
            ////////////////////
            if (styleEnabled && !headless && ele.pstyle('curve-style').strValue === 'haystack') {
              var hpts = rstyle.haystackPts || [];

              ex1 = hpts[0].x;
              ey1 = hpts[0].y;
              ex2 = hpts[1].x;
              ey2 = hpts[1].y;

              if (ex1 > ex2) {
                var temp = ex1;
                ex1 = ex2;
                ex2 = temp;
              }

              if (ey1 > ey2) {
                var _temp = ey1;
                ey1 = ey2;
                ey2 = _temp;
              }

              updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);

              // handle points along edge
              ///////////////////////////
            } else {
              var pts = rstyle.bezierPts || rstyle.linePts || [];

              for (var j = 0; j < pts.length; j++) {
                var pt = pts[j];

                ex1 = pt.x - wHalf;
                ex2 = pt.x + wHalf;
                ey1 = pt.y - wHalf;
                ey2 = pt.y + wHalf;

                updateBounds(bounds, ex1, ey1, ex2, ey2);
              }

              // fallback on source and target positions
              //////////////////////////////////////////
              if (pts.length === 0) {
                var n1 = ele.source();
                var n1pos = n1.position();

                var n2 = ele.target();
                var n2pos = n2.position();

                ex1 = n1pos.x;
                ex2 = n2pos.x;
                ey1 = n1pos.y;
                ey2 = n2pos.y;

                if (ex1 > ex2) {
                  var _temp2 = ex1;
                  ex1 = ex2;
                  ex2 = _temp2;
                }

                if (ey1 > ey2) {
                  var _temp3 = ey1;
                  ey1 = ey2;
                  ey2 = _temp3;
                }

                // take into account edge width
                ex1 -= wHalf;
                ex2 += wHalf;
                ey1 -= wHalf;
                ey2 += wHalf;

                updateBounds(bounds, ex1, ey1, ex2, ey2);
              }
            }
          } // edges


          // handle edge arrow size
          /////////////////////////

          if (styleEnabled && options.includeEdges && isEdge) {
            updateBoundsFromArrow(bounds, ele, 'mid-source', options);
            updateBoundsFromArrow(bounds, ele, 'mid-target', options);
            updateBoundsFromArrow(bounds, ele, 'source', options);
            updateBoundsFromArrow(bounds, ele, 'target', options);
          }

          // ghost
          ////////

          if (styleEnabled) {
            var ghost = ele.pstyle('ghost').value === 'yes';

            if (ghost) {
              var gx = ele.pstyle('ghost-offset-x').pfValue;
              var gy = ele.pstyle('ghost-offset-y').pfValue;

              updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
            }
          }

          // overlay
          //////////

          if (styleEnabled) {

            ex1 = bounds.x1;
            ex2 = bounds.x2;
            ey1 = bounds.y1;
            ey2 = bounds.y2;

            updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
          }

          // handle label dimensions
          //////////////////////////

          if (styleEnabled && options.includeLabels) {
            updateBoundsFromLabel(bounds, ele, null, options);

            if (isEdge) {
              updateBoundsFromLabel(bounds, ele, 'source', options);
              updateBoundsFromLabel(bounds, ele, 'target', options);
            }
          } // style enabled for labels
        } // if displayed

        bounds.x1 = noninf(bounds.x1);
        bounds.y1 = noninf(bounds.y1);
        bounds.x2 = noninf(bounds.x2);
        bounds.y2 = noninf(bounds.y2);
        bounds.w = noninf(bounds.x2 - bounds.x1);
        bounds.h = noninf(bounds.y2 - bounds.y1);

        // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
        if (bounds.w > 0 && bounds.h > 0 && displayed) {
          math.expandBoundingBox(bounds, 1);
        }

        return bounds;
      };

      var tf = function tf(val) {
        if (val) {
          return 't';
        } else {
          return 'f';
        }
      };

      var getKey = function getKey(opts) {
        var key = '';

        key += tf(opts.incudeNodes);
        key += tf(opts.includeEdges);
        key += tf(opts.includeLabels);
        key += tf(opts.includeOverlays);

        return key;
      };

      var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
        var _p = ele._private;
        var bb = void 0;
        var headless = ele.cy().headless();
        var key = opts === defBbOpts ? defBbOptsKey : getKey(opts);

        if (!opts.useCache || headless || !_p.bbCache || !_p.bbCache[key]) {
          bb = boundingBoxImpl(ele, opts);

          if (!headless) {
            _p.bbCache = _p.bbCache || {};
            _p.bbCache[key] = bb;
          }
        } else {
          bb = _p.bbCache[key];
        }

        return bb;
      };

      var defBbOpts = {
        includeNodes: true,
        includeEdges: true,
        includeLabels: true,
        includeOverlays: true,
        useCache: true
      };

      var defBbOptsKey = getKey(defBbOpts);

      function filledBbOpts(options) {
        return {
          includeNodes: util.default(options.includeNodes, defBbOpts.includeNodes),
          includeEdges: util.default(options.includeEdges, defBbOpts.includeEdges),
          includeLabels: util.default(options.includeLabels, defBbOpts.includeLabels),
          includeOverlays: util.default(options.includeOverlays, defBbOpts.includeOverlays),
          useCache: util.default(options.useCache, defBbOpts.useCache)
        };
      }

      elesfn.boundingBox = function (options) {
        // the main usecase is ele.boundingBox() for a single element with no/def options
        // specified s.t. the cache is used, so check for this case to make it faster by
        // avoiding the overhead of the rest of the function
        if (this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true)) {
          if (options === undefined) {
            options = defBbOpts;
          } else {
            options = filledBbOpts(options);
          }

          return cachedBoundingBoxImpl(this[0], options);
        }

        var bounds = {
          x1: Infinity,
          y1: Infinity,
          x2: -Infinity,
          y2: -Infinity
        };

        options = options || util.staticEmptyObject();

        var opts = filledBbOpts(options);

        var eles = this;
        var cy = eles.cy();
        var styleEnabled = cy.styleEnabled();

        if (styleEnabled) {
          this.recalculateRenderedStyle(opts.useCache);
        }

        this.updateCompoundBounds();

        var updatedEdge = {}; // use to avoid duplicated edge updates

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ele.id()]) {
            var edges = ele.parallelEdges();

            for (var j = 0; j < edges.length; j++) {
              // make all as updated
              updatedEdge[edges[j].id()] = true;
            }

            edges.recalculateRenderedStyle(opts.useCache); // n.b. ele.parallelEdges() single is cached
          }

          updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));
        }

        bounds.x1 = noninf(bounds.x1);
        bounds.y1 = noninf(bounds.y1);
        bounds.x2 = noninf(bounds.x2);
        bounds.y2 = noninf(bounds.y2);
        bounds.w = noninf(bounds.x2 - bounds.x1);
        bounds.h = noninf(bounds.y2 - bounds.y1);

        return bounds;
      };

      // private helper to get bounding box for custom node positions
      // - good for perf in certain cases but currently requires dirtying the rendered style
      // - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
      // - try to use for only things like discrete layouts where the node position would change anyway
      elesfn.boundingBoxAt = function (fn) {
        var nodes = this.nodes();

        if (is.plainObject(fn)) {
          var obj = fn;

          fn = function fn() {
            return obj;
          };
        }

        // save the current position and set the new one, per node
        for (var i = 0; i < nodes.length; i++) {
          var n = nodes[i];
          var _p = n._private;
          var pos = _p.position;
          var newPos = fn.call(n, n, i);

          _p.bbAtOldPos = { x: pos.x, y: pos.y };

          if (newPos) {
            pos.x = newPos.x;
            pos.y = newPos.y;
          }
        }

        this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

        nodes.dirtyCompoundBoundsCache().updateCompoundBounds();

        var bb = this.boundingBox({ useCache: false });

        // restore the original position, per node
        for (var _i = 0; _i < nodes.length; _i++) {
          var _n = nodes[_i];
          var _p2 = _n._private;
          var _pos = _n._private.position;
          var old = _p2.bbAtOldPos;

          _pos.x = old.x;
          _pos.y = old.y;
        }

        nodes.dirtyCompoundBoundsCache();

        this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

        return bb;
      };

      fn.boundingbox = fn.boundingBox;
      fn.renderedBoundingbox = fn.renderedBoundingBox;

      module.exports = elesfn;

      /***/
    },
    /* 60 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var fn = void 0,
          elesfn = void 0;

      fn = elesfn = {};

      var defineDimFns = function defineDimFns(opts) {
        opts.uppercaseName = util.capitalize(opts.name);
        opts.autoName = 'auto' + opts.uppercaseName;
        opts.labelName = 'label' + opts.uppercaseName;
        opts.outerName = 'outer' + opts.uppercaseName;
        opts.uppercaseOuterName = util.capitalize(opts.outerName);

        fn[opts.name] = function dimImpl() {
          var ele = this[0];
          var _p = ele._private;
          var cy = _p.cy;
          var styleEnabled = cy._private.styleEnabled;

          if (ele) {
            if (styleEnabled) {
              if (ele.isParent()) {
                ele.updateCompoundBounds();

                return _p[opts.autoName] || 0;
              }

              var d = ele.pstyle(opts.name);

              switch (d.strValue) {
                case 'label':
                  ele.recalculateRenderedStyle();

                  return _p.rstyle[opts.labelName] || 0;

                default:
                  return d.pfValue;
              }
            } else {
              return 1;
            }
          }
        };

        fn['outer' + opts.uppercaseName] = function outerDimImpl() {
          var ele = this[0];
          var _p = ele._private;
          var cy = _p.cy;
          var styleEnabled = cy._private.styleEnabled;

          if (ele) {
            if (styleEnabled) {
              var dim = ele[opts.name]();
              var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side
              var padding = 2 * ele.padding();

              return dim + border + padding;
            } else {
              return 1;
            }
          }
        };

        fn['rendered' + opts.uppercaseName] = function renderedDimImpl() {
          var ele = this[0];

          if (ele) {
            var d = ele[opts.name]();
            return d * this.cy().zoom();
          }
        };

        fn['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
          var ele = this[0];

          if (ele) {
            var od = ele[opts.outerName]();
            return od * this.cy().zoom();
          }
        };
      };

      defineDimFns({
        name: 'width'
      });

      defineDimFns({
        name: 'height'
      });

      elesfn.padding = function () {
        var ele = this[0];
        var _p = ele._private;
        if (ele.isParent()) {
          ele.updateCompoundBounds();

          if (_p.autoPadding !== undefined) {
            return _p.autoPadding;
          } else {
            return ele.pstyle('padding').pfValue;
          }
        } else {
          return ele.pstyle('padding').pfValue;
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 61 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var ifEdge = function ifEdge(self, then) {
        if (self.isEdge()) {
          return then(self.renderer());
        }
      };

      module.exports = {
        controlPoints: function controlPoints() {
          var _this = this;

          return ifEdge(this, function (renderer) {
            return renderer.getControlPoints(_this);
          });
        },
        segmentPoints: function segmentPoints() {
          var _this2 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getSegmentPoints(_this2);
          });
        },
        sourceEndpoint: function sourceEndpoint() {
          var _this3 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getSourceEndpoint(_this3);
          });
        },
        targetEndpoint: function targetEndpoint() {
          var _this4 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getTargetEndpoint(_this4);
          });
        },
        midpoint: function midpoint() {
          var _this5 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getEdgeMidpoint(_this5);
          });
        }
      };

      /***/
    },
    /* 62 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Emitter = __webpack_require__(11);
      var define = __webpack_require__(4);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var emitterOptions = {
        qualifierCompare: function qualifierCompare(selector1, selector2) {
          if (selector1 == null || selector2 == null) {
            return selector1 == null && selector2 == null;
          } else {
            return selector1.sameText(selector2);
          }
        },
        eventMatches: function eventMatches(ele, listener, eventObj) {
          var selector = listener.qualifier;

          if (selector != null) {
            return ele !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
          }

          return true;
        },
        eventFields: function eventFields(ele) {
          return {
            cy: ele.cy(),
            target: ele
          };
        },
        callbackContext: function callbackContext(ele, listener, eventObj) {
          return listener.qualifier != null ? eventObj.target : ele;
        },
        beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {
          if (listener.conf && listener.conf.once) {
            listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
          }
        },
        bubble: function bubble() {
          return true;
        },
        parent: function parent(ele) {
          return ele.isChild() ? ele.parent() : ele.cy();
        }
      };

      var argSelector = function argSelector(arg) {
        if (is.string(arg)) {
          return new Selector(arg);
        } else {
          return arg;
        }
      };

      var elesfn = {
        createEmitter: function createEmitter() {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var _p = ele._private;

            if (!_p.emitter) {
              _p.emitter = new Emitter(util.assign({
                context: ele
              }, emitterOptions));
            }
          }

          return this;
        },

        emitter: function emitter() {
          return this._private.emitter;
        },

        on: function on(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().on(events, argSelector(selector), callback);
          }

          return this;
        },

        removeListener: function removeListener(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().removeListener(events, argSelector(selector), callback);
          }

          return this;
        },

        one: function one(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().one(events, argSelector(selector), callback);
          }

          return this;
        },

        once: function once(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().on(events, argSelector(selector), callback, {
              once: true,
              onceCollection: this
            });
          }
        },

        emit: function emit(events, extraParams) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().emit(events, extraParams);
          }

          return this;
        },

        emitAndNotify: function emitAndNotify(event, extraParams) {
          // for internal use only
          if (this.length === 0) {
            return;
          } // empty collections don't need to notify anything

          // notify renderer
          this.cy().notify({
            type: event,
            eles: this
          });

          this.emit(event, extraParams);

          return this;
        }
      };

      define.eventAliasesOn(elesfn);

      module.exports = elesfn;

      /***/
    },
    /* 63 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Selector = __webpack_require__(6);

      var elesfn = {
        nodes: function nodes(selector) {
          return this.filter(function (ele) {
            return ele.isNode();
          }).filter(selector);
        },

        edges: function edges(selector) {
          return this.filter(function (ele) {
            return ele.isEdge();
          }).filter(selector);
        },

        filter: function filter(_filter, thisArg) {
          if (_filter === undefined) {
            // check this first b/c it's the most common/performant case
            return this;
          } else if (is.string(_filter) || is.elementOrCollection(_filter)) {
            return new Selector(_filter).filter(this);
          } else if (is.fn(_filter)) {
            var filterEles = this.spawn();
            var eles = this;

            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

              if (include) {
                filterEles.merge(ele);
              }
            }

            return filterEles;
          }

          return this.spawn(); // if not handled by above, give 'em an empty collection
        },

        not: function not(toRemove) {
          if (!toRemove) {
            return this;
          } else {

            if (is.string(toRemove)) {
              toRemove = this.filter(toRemove);
            }

            var elements = [];
            var rMap = toRemove._private.map;

            for (var i = 0; i < this.length; i++) {
              var element = this[i];

              var remove = rMap.has(element.id());
              if (!remove) {
                elements.push(element);
              }
            }

            return this.spawn(elements);
          }
        },

        absoluteComplement: function absoluteComplement() {
          var cy = this.cy();

          return cy.mutableElements().not(this);
        },

        intersect: function intersect(other) {
          // if a selector is specified, then filter by it instead
          if (is.string(other)) {
            var selector = other;
            return this.filter(selector);
          }

          var elements = [];
          var col1 = this;
          var col2 = other;
          var col1Smaller = this.length < other.length;
          var map2 = col1Smaller ? col2._private.map : col1._private.map;
          var col = col1Smaller ? col1 : col2;

          for (var i = 0; i < col.length; i++) {
            var id = col[i]._private.data.id;
            var entry = map2.get(id);

            if (entry) {
              elements.push(entry.ele);
            }
          }

          return this.spawn(elements);
        },

        xor: function xor(other) {
          var cy = this._private.cy;

          if (is.string(other)) {
            other = cy.$(other);
          }

          var elements = [];
          var col1 = this;
          var col2 = other;

          var add = function add(col, other) {
            for (var i = 0; i < col.length; i++) {
              var ele = col[i];
              var id = ele._private.data.id;
              var inOther = other.hasElementWithId(id);

              if (!inOther) {
                elements.push(ele);
              }
            }
          };

          add(col1, col2);
          add(col2, col1);

          return this.spawn(elements);
        },

        diff: function diff(other) {
          var cy = this._private.cy;

          if (is.string(other)) {
            other = cy.$(other);
          }

          var left = [];
          var right = [];
          var both = [];
          var col1 = this;
          var col2 = other;

          var add = function add(col, other, retEles) {

            for (var i = 0; i < col.length; i++) {
              var ele = col[i];
              var id = ele._private.data.id;
              var inOther = other.hasElementWithId(id);

              if (inOther) {
                both.push(ele);
              } else {
                retEles.push(ele);
              }
            }
          };

          add(col1, col2, left);
          add(col2, col1, right);

          return {
            left: this.spawn(left, { unique: true }),
            right: this.spawn(right, { unique: true }),
            both: this.spawn(both, { unique: true })
          };
        },

        add: function add(toAdd) {
          var cy = this._private.cy;

          if (!toAdd) {
            return this;
          }

          if (is.string(toAdd)) {
            var selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
          }

          var elements = [];

          for (var i = 0; i < this.length; i++) {
            elements.push(this[i]);
          }

          var map = this._private.map;

          for (var _i = 0; _i < toAdd.length; _i++) {

            var add = !map.has(toAdd[_i].id());
            if (add) {
              elements.push(toAdd[_i]);
            }
          }

          return this.spawn(elements);
        },

        // in place merge on calling collection
        merge: function merge(toAdd) {
          var _p = this._private;
          var cy = _p.cy;

          if (!toAdd) {
            return this;
          }

          if (toAdd && is.string(toAdd)) {
            var selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
          }

          var map = _p.map;

          for (var i = 0; i < toAdd.length; i++) {
            var toAddEle = toAdd[i];
            var id = toAddEle._private.data.id;
            var add = !map.has(id);

            if (add) {
              var index = this.length++;

              this[index] = toAddEle;

              map.set(id, { ele: toAddEle, index: index });
            } else {
              // replace
              var _index = map.get(id).index;

              this[_index] = toAddEle;
              map.set(id, { ele: toAddEle, index: _index });
            }
          }

          return this; // chaining
        },

        // remove single ele in place in calling collection
        unmergeOne: function unmergeOne(ele) {
          ele = ele[0];

          var _p = this._private;
          var id = ele._private.data.id;
          var map = _p.map;
          var entry = map.get(id);

          if (!entry) {
            return this; // no need to remove
          }

          var i = entry.index;

          // remove ele
          this[i] = undefined;
          map.delete(id);

          var unmergedLastEle = i === this.length - 1;

          // replace empty spot with last ele in collection
          if (this.length > 1 && !unmergedLastEle) {
            var lastEleI = this.length - 1;
            var lastEle = this[lastEleI];
            var lastEleId = lastEle._private.data.id;

            this[lastEleI] = undefined;
            this[i] = lastEle;
            map.set(lastEleId, { ele: lastEle, index: i });
          }

          // the collection is now 1 ele smaller
          this.length--;

          return this;
        },

        // remove eles in place on calling collection
        unmerge: function unmerge(toRemove) {
          var cy = this._private.cy;

          if (!toRemove) {
            return this;
          }

          if (toRemove && is.string(toRemove)) {
            var selector = toRemove;
            toRemove = cy.mutableElements().filter(selector);
          }

          for (var i = 0; i < toRemove.length; i++) {
            this.unmergeOne(toRemove[i]);
          }

          return this; // chaining
        },

        map: function map(mapFn, thisArg) {
          var arr = [];
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);

            arr.push(ret);
          }

          return arr;
        },

        reduce: function reduce(fn, initialValue) {
          var val = initialValue;
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            val = fn(val, eles[i], i, eles);
          }

          return val;
        },

        max: function max(valFn, thisArg) {
          var max = -Infinity;
          var maxEle = void 0;
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

            if (val > max) {
              max = val;
              maxEle = ele;
            }
          }

          return {
            value: max,
            ele: maxEle
          };
        },

        min: function min(valFn, thisArg) {
          var min = Infinity;
          var minEle = void 0;
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

            if (val < min) {
              min = val;
              minEle = ele;
            }
          }

          return {
            value: min,
            ele: minEle
          };
        }
      };

      // aliases
      var fn = elesfn;
      fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
      fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
      fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
      fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
      fn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;
      fn.complement = fn.abscomp = fn.absoluteComplement;

      module.exports = elesfn;

      /***/
    },
    /* 64 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var elesfn = {
        isNode: function isNode() {
          return this.group() === 'nodes';
        },

        isEdge: function isEdge() {
          return this.group() === 'edges';
        },

        isLoop: function isLoop() {
          return this.isEdge() && this.source().id() === this.target().id();
        },

        isSimple: function isSimple() {
          return this.isEdge() && this.source().id() !== this.target().id();
        },

        group: function group() {
          var ele = this[0];

          if (ele) {
            return ele._private.group;
          }
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 65 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var zIndexSort = __webpack_require__(17);
      var util = __webpack_require__(1);

      var elesfn = {
        forEach: function forEach(fn, thisArg) {
          if (is.fn(fn)) {

            for (var i = 0; i < this.length; i++) {
              var ele = this[i];
              var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);

              if (ret === false) {
                break;
              } // exit each early on return false
            }
          }

          return this;
        },

        toArray: function toArray() {
          var array = [];

          for (var i = 0; i < this.length; i++) {
            array.push(this[i]);
          }

          return array;
        },

        slice: function slice(start, end) {
          var array = [];
          var thisSize = this.length;

          if (end == null) {
            end = thisSize;
          }

          if (start == null) {
            start = 0;
          }

          if (start < 0) {
            start = thisSize + start;
          }

          if (end < 0) {
            end = thisSize + end;
          }

          for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
            array.push(this[i]);
          }

          return this.spawn(array);
        },

        size: function size() {
          return this.length;
        },

        eq: function eq(i) {
          return this[i] || this.spawn();
        },

        first: function first() {
          return this[0] || this.spawn();
        },

        last: function last() {
          return this[this.length - 1] || this.spawn();
        },

        empty: function empty() {
          return this.length === 0;
        },

        nonempty: function nonempty() {
          return !this.empty();
        },

        sort: function sort(sortFn) {
          if (!is.fn(sortFn)) {
            return this;
          }

          var sorted = this.toArray().sort(sortFn);

          return this.spawn(sorted);
        },

        sortByZIndex: function sortByZIndex() {
          return this.sort(zIndexSort);
        },

        zDepth: function zDepth() {
          var ele = this[0];
          if (!ele) {
            return undefined;
          }

          // let cy = ele.cy();
          var _p = ele._private;
          var group = _p.group;

          if (group === 'nodes') {
            var depth = _p.data.parent ? ele.parents().size() : 0;

            if (!ele.isParent()) {
              return util.MAX_INT - 1; // childless nodes always on top
            }

            return depth;
          } else {
            var src = _p.source;
            var tgt = _p.target;
            var srcDepth = src.zDepth();
            var tgtDepth = tgt.zDepth();

            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
          }
        }
      };

      elesfn.each = elesfn.forEach;

      module.exports = elesfn;

      /***/
    },
    /* 66 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Promise = __webpack_require__(5);
      var math = __webpack_require__(2);

      var elesfn = {
        // Calculates and returns node dimensions { x, y } based on options given
        layoutDimensions: function layoutDimensions(options) {
          options = util.assign({
            nodeDimensionsIncludeLabels: true
          }, options);

          if (options.nodeDimensionsIncludeLabels) {
            var bbDim = this.boundingBox();
            return {
              w: bbDim.w,
              h: bbDim.h
            };
          } else {
            return {
              w: this.outerWidth(),
              h: this.outerHeight()
            };
          }
        },

        // using standard layout options, apply position function (w/ or w/o animation)
        layoutPositions: function layoutPositions(layout, options, fn) {
          var nodes = this.nodes();
          var cy = this.cy();
          var layoutEles = options.eles; // nodes & edges
          var getMemoizeKey = function getMemoizeKey(node, i) {
            return node.id() + '$' + i;
          };
          var fnMem = util.memoize(fn, getMemoizeKey); // memoized version of position function

          layout.emit({ type: 'layoutstart', layout: layout });

          layout.animations = [];

          var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
            var center = {
              x: nodesBb.x1 + nodesBb.w / 2,
              y: nodesBb.y1 + nodesBb.h / 2
            };

            var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
              x: (pos.x - center.x) * spacing,
              y: (pos.y - center.y) * spacing
            };

            return {
              x: center.x + spacingVector.x,
              y: center.y + spacingVector.y
            };
          };

          var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

          var spacingBb = function spacingBb() {
            if (!useSpacingFactor) {
              return null;
            }

            var bb = math.makeBoundingBox();

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var pos = fnMem(node, i);

              math.expandBoundingBoxByPoint(bb, pos.x, pos.y);
            }

            return bb;
          };

          var bb = spacingBb();

          var getFinalPos = util.memoize(function (node, i) {
            var newPos = fnMem(node, i);
            var pos = node.position();

            if (!is.number(pos.x) || !is.number(pos.y)) {
              node.silentPosition({ x: 0, y: 0 });
            }

            if (useSpacingFactor) {
              var spacing = Math.abs(options.spacingFactor);

              newPos = calculateSpacing(spacing, bb, newPos);
            }

            if (options.transform != null) {
              newPos = options.transform(node, newPos);
            }

            return newPos;
          }, getMemoizeKey);

          if (options.animate) {
            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var newPos = getFinalPos(node, i);
              var animateNode = options.animateFilter == null || options.animateFilter(node, i);

              if (animateNode) {
                var ani = node.animation({
                  position: newPos,
                  duration: options.animationDuration,
                  easing: options.animationEasing
                });

                layout.animations.push(ani);

                ani.play();
              } else {
                node.position(newPos);
              }
            }

            if (options.fit) {
              var fitAni = cy.animation({
                fit: {
                  boundingBox: layoutEles.boundingBoxAt(getFinalPos),
                  padding: options.padding
                },
                duration: options.animationDuration,
                easing: options.animationEasing
              });

              layout.animations.push(fitAni);

              fitAni.play();
            } else if (options.zoom !== undefined && options.pan !== undefined) {
              var zoomPanAni = cy.animation({
                zoom: options.zoom,
                pan: options.pan,
                duration: options.animationDuration,
                easing: options.animationEasing
              });

              layout.animations.push(zoomPanAni);

              zoomPanAni.play();
            }

            layout.one('layoutready', options.ready);
            layout.emit({ type: 'layoutready', layout: layout });

            Promise.all(layout.animations.map(function (ani) {
              return ani.promise();
            })).then(function () {
              layout.one('layoutstop', options.stop);
              layout.emit({ type: 'layoutstop', layout: layout });
            });
          } else {

            nodes.positions(getFinalPos);

            if (options.fit) {
              cy.fit(options.eles, options.padding);
            }

            if (options.zoom != null) {
              cy.zoom(options.zoom);
            }

            if (options.pan) {
              cy.pan(options.pan);
            }

            layout.one('layoutready', options.ready);
            layout.emit({ type: 'layoutready', layout: layout });

            layout.one('layoutstop', options.stop);
            layout.emit({ type: 'layoutstop', layout: layout });
          }

          return this; // chaining
        },

        layout: function layout(options) {
          var cy = this.cy();

          return cy.makeLayout(util.extend({}, options, {
            eles: this
          }));
        }

      };

      // aliases:
      elesfn.createLayout = elesfn.makeLayout = elesfn.layout;

      module.exports = elesfn;

      /***/
    },
    /* 67 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      function styleCache(key, fn, ele) {
        var _p = ele._private;
        var cache = _p.styleCache = _p.styleCache || {};
        var val;

        if ((val = cache[key]) != null) {
          return val;
        } else {
          val = cache[key] = fn(ele);

          return val;
        }
      }

      function cacheStyleFunction(key, fn) {
        return function cachedStyleFunction(ele) {
          return styleCache(key, fn, ele);
        };
      }

      function cachePrototypeStyleFunction(key, fn) {
        var selfFn = function selfFn(ele) {
          return fn.call(ele);
        };

        return function cachedPrototypeStyleFunction() {
          var ele = this[0];

          if (ele) {
            return styleCache(key, selfFn, ele);
          }
        };
      }

      var elesfn = {

        recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
          var cy = this.cy();
          var renderer = cy.renderer();
          var styleEnabled = cy.styleEnabled();

          if (renderer && styleEnabled) {
            renderer.recalculateRenderedStyle(this, useCache);
          }

          return this;
        },

        dirtyStyleCache: function dirtyStyleCache() {
          var cy = this.cy();
          var dirty = function dirty(ele) {
            return ele._private.styleCache = {};
          };

          if (cy.hasCompoundNodes()) {
            var eles = void 0;

            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());

            eles.merge(eles.connectedEdges());

            eles.forEach(dirty);
          } else {
            this.forEach(function (ele) {
              dirty(ele);

              ele.connectedEdges().forEach(dirty);
            });
          }

          return this;
        },

        // fully updates (recalculates) the style for the elements
        updateStyle: function updateStyle(notifyRenderer) {
          var cy = this._private.cy;

          if (!cy.styleEnabled()) {
            return this;
          }

          if (cy._private.batchingStyle) {
            var bEles = cy._private.batchStyleEles;

            bEles.merge(this);

            return this; // chaining and exit early when batching
          }

          var hasCompounds = cy.hasCompoundNodes();
          var style = cy.style();
          var updatedEles = this;

          notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

          if (hasCompounds) {
            // then add everything up and down for compound selector checks
            updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
          }

          var changedEles = style.apply(updatedEles);

          changedEles.dirtyStyleCache();
          changedEles.dirtyCompoundBoundsCache();

          if (notifyRenderer) {
            changedEles.emitAndNotify('style'); // let renderer know we changed style
          } else {
            changedEles.emit('style'); // just fire the event
          }

          return this; // chaining
        },

        // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
        updateMappers: function updateMappers(notifyRenderer) {
          var cy = this._private.cy;
          var style = cy.style();
          notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

          if (!cy.styleEnabled()) {
            return this;
          }

          var changedEles = style.updateMappers(this);

          changedEles.dirtyStyleCache();
          changedEles.dirtyCompoundBoundsCache();

          if (notifyRenderer) {
            changedEles.emitAndNotify('style'); // let renderer know we changed style
          } else {
            changedEles.emit('style'); // just fire the event
          }
          return this; // chaining
        },

        // get the internal parsed style object for the specified property
        parsedStyle: function parsedStyle(property) {
          var ele = this[0];
          var cy = ele.cy();

          if (!cy.styleEnabled()) {
            return;
          }

          if (ele) {
            return ele._private.style[property] || cy.style().getDefaultProperty(property);
          }
        },

        numericStyle: function numericStyle(property) {
          var ele = this[0];

          if (!ele.cy().styleEnabled()) {
            return;
          }

          if (ele) {
            var pstyle = ele.pstyle(property);

            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
          }
        },

        numericStyleUnits: function numericStyleUnits(property) {
          var ele = this[0];

          if (!ele.cy().styleEnabled()) {
            return;
          }

          if (ele) {
            return ele.pstyle(property).units;
          }
        },

        // get the specified css property as a rendered value (i.e. on-screen value)
        // or get the whole rendered style if no property specified (NB doesn't allow setting)
        renderedStyle: function renderedStyle(property) {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return this;
          }

          var ele = this[0];

          if (ele) {
            return cy.style().getRenderedStyle(ele, property);
          }
        },

        // read the calculated css style of the element or override the style (via a bypass)
        style: function style(name, value) {
          var cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          var updateTransitions = false;
          var style = cy.style();

          if (is.plainObject(name)) {
            // then extend the bypass
            var props = name;
            style.applyBypass(this, props, updateTransitions);

            this.dirtyStyleCache();
            this.dirtyCompoundBoundsCache();

            this.emitAndNotify('style'); // let the renderer know we've updated style
          } else if (is.string(name)) {

            if (value === undefined) {
              // then get the property from the style
              var ele = this[0];

              if (ele) {
                return style.getStylePropertyValue(ele, name);
              } else {
                // empty collection => can't get any value
                return;
              }
            } else {
              // then set the bypass with the property value
              style.applyBypass(this, name, value, updateTransitions);

              this.dirtyStyleCache();
              this.dirtyCompoundBoundsCache();

              this.emitAndNotify('style'); // let the renderer know we've updated style
            }
          } else if (name === undefined) {
            var _ele = this[0];

            if (_ele) {
              return style.getRawStyle(_ele);
            } else {
              // empty collection => can't get any value
              return;
            }
          }

          return this; // chaining
        },

        removeStyle: function removeStyle(names) {
          var cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          var updateTransitions = false;
          var style = cy.style();
          var eles = this;

          if (names === undefined) {
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];

              style.removeAllBypasses(ele, updateTransitions);
            }
          } else {
            names = names.split(/\s+/);

            for (var _i = 0; _i < eles.length; _i++) {
              var _ele2 = eles[_i];

              style.removeBypasses(_ele2, names, updateTransitions);
            }
          }

          this.dirtyStyleCache();
          this.dirtyCompoundBoundsCache();

          this.emitAndNotify('style'); // let the renderer know we've updated style

          return this; // chaining
        },

        show: function show() {
          this.css('display', 'element');
          return this; // chaining
        },

        hide: function hide() {
          this.css('display', 'none');
          return this; // chaining
        },

        effectiveOpacity: function effectiveOpacity() {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return 1;
          }

          var hasCompoundNodes = cy.hasCompoundNodes();
          var ele = this[0];

          if (ele) {
            var _p = ele._private;
            var parentOpacity = ele.pstyle('opacity').value;

            if (!hasCompoundNodes) {
              return parentOpacity;
            }

            var parents = !_p.data.parent ? null : ele.parents();

            if (parents) {
              for (var i = 0; i < parents.length; i++) {
                var parent = parents[i];
                var opacity = parent.pstyle('opacity').value;

                parentOpacity = opacity * parentOpacity;
              }
            }

            return parentOpacity;
          }
        },

        transparent: function transparent() {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return false;
          }

          var ele = this[0];
          var hasCompoundNodes = ele.cy().hasCompoundNodes();

          if (ele) {
            if (!hasCompoundNodes) {
              return ele.pstyle('opacity').value === 0;
            } else {
              return ele.effectiveOpacity() === 0;
            }
          }
        },

        backgrounding: function backgrounding() {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return false;
          }

          var ele = this[0];

          return ele._private.backgrounding ? true : false;
        }

      };

      function checkCompound(ele, parentOk) {
        var _p = ele._private;
        var parents = _p.data.parent ? ele.parents() : null;

        if (parents) {
          for (var i = 0; i < parents.length; i++) {
            var parent = parents[i];

            if (!parentOk(parent)) {
              return false;
            }
          }
        }

        return true;
      }

      function defineDerivedStateFunction(specs) {
        var ok = specs.ok;
        var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
        var parentOk = specs.parentOk || specs.ok;

        return function () {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return true;
          }

          var ele = this[0];
          var hasCompoundNodes = cy.hasCompoundNodes();

          if (ele) {
            var _p = ele._private;

            if (!ok(ele)) {
              return false;
            }

            if (ele.isNode()) {
              return !hasCompoundNodes || checkCompound(ele, parentOk);
            } else {
              var src = _p.source;
              var tgt = _p.target;

              return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
            }
          }
        };
      }

      var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
        return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
      });

      elesfn.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
        ok: eleTakesUpSpace
      }));

      var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
        return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
      });

      var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
        return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
      });

      elesfn.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
        ok: eleInteractive,
        parentOk: parentInteractive,
        edgeOkViaNode: eleTakesUpSpace
      }));

      elesfn.noninteractive = function () {
        var ele = this[0];

        if (ele) {
          return !ele.interactive();
        }
      };

      var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
        return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
      });

      var edgeVisibleViaNode = eleTakesUpSpace;

      elesfn.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
        ok: eleVisible,
        edgeOkViaNode: edgeVisibleViaNode
      }));

      elesfn.hidden = function () {
        var ele = this[0];

        if (ele) {
          return !ele.visible();
        }
      };

      elesfn.bypass = elesfn.css = elesfn.style;
      elesfn.renderedCss = elesfn.renderedStyle;
      elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
      elesfn.pstyle = elesfn.parsedStyle;

      module.exports = elesfn;

      /***/
    },
    /* 68 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var elesfn = {};

      function defineSwitchFunction(params) {
        return function () {
          var args = arguments;
          var changedEles = [];

          // e.g. cy.nodes().select( data, handler )
          if (args.length === 2) {
            var data = args[0];
            var handler = args[1];
            this.on(params.event, data, handler);
          }

          // e.g. cy.nodes().select( handler )
          else if (args.length === 1) {
              var _handler = args[0];
              this.on(params.event, _handler);
            }

            // e.g. cy.nodes().select()
            else if (args.length === 0) {
                for (var i = 0; i < this.length; i++) {
                  var ele = this[i];
                  var able = !params.ableField || ele._private[params.ableField];
                  var changed = ele._private[params.field] != params.value;

                  if (params.overrideAble) {
                    var overrideAble = params.overrideAble(ele);

                    if (overrideAble !== undefined) {
                      able = overrideAble;

                      if (!overrideAble) {
                        return this;
                      } // to save cycles assume not able for all on override
                    }
                  }

                  if (able) {
                    ele._private[params.field] = params.value;

                    if (changed) {
                      changedEles.push(ele);
                    }
                  }
                }

                var changedColl = this.spawn(changedEles);
                changedColl.updateStyle(); // change of state => possible change of style
                changedColl.emit(params.event);
              }

          return this;
        };
      }

      function defineSwitchSet(params) {
        elesfn[params.field] = function () {
          var ele = this[0];

          if (ele) {
            if (params.overrideField) {
              var val = params.overrideField(ele);

              if (val !== undefined) {
                return val;
              }
            }

            return ele._private[params.field];
          }
        };

        elesfn[params.on] = defineSwitchFunction({
          event: params.on,
          field: params.field,
          ableField: params.ableField,
          overrideAble: params.overrideAble,
          value: true
        });

        elesfn[params.off] = defineSwitchFunction({
          event: params.off,
          field: params.field,
          ableField: params.ableField,
          overrideAble: params.overrideAble,
          value: false
        });
      }

      defineSwitchSet({
        field: 'locked',
        overrideField: function overrideField(ele) {
          return ele.cy().autolock() ? true : undefined;
        },
        on: 'lock',
        off: 'unlock'
      });

      defineSwitchSet({
        field: 'grabbable',
        overrideField: function overrideField(ele) {
          return ele.cy().autoungrabify() ? false : undefined;
        },
        on: 'grabify',
        off: 'ungrabify'
      });

      defineSwitchSet({
        field: 'selected',
        ableField: 'selectable',
        overrideAble: function overrideAble(ele) {
          return ele.cy().autounselectify() ? false : undefined;
        },
        on: 'select',
        off: 'unselect'
      });

      defineSwitchSet({
        field: 'selectable',
        overrideField: function overrideField(ele) {
          return ele.cy().autounselectify() ? false : undefined;
        },
        on: 'selectify',
        off: 'unselectify'
      });

      elesfn.deselect = elesfn.unselect;

      elesfn.grabbed = function () {
        var ele = this[0];
        if (ele) {
          return ele._private.grabbed;
        }
      };

      defineSwitchSet({
        field: 'active',
        on: 'activate',
        off: 'unactivate'
      });

      elesfn.inactive = function () {
        var ele = this[0];
        if (ele) {
          return !ele._private.active;
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 69 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var elesfn = {};

      var cache = function cache(fn, name) {
        return function traversalCache(arg1, arg2, arg3, arg4) {
          var selectorOrEles = arg1;
          var eles = this;
          var key = void 0;

          if (selectorOrEles == null) {
            key = 'null';
          } else if (is.elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
            key = '#' + selectorOrEles.id();
          }

          if (eles.length === 1 && key) {
            var _p = eles[0]._private;
            var tch = _p.traversalCache = _p.traversalCache || {};
            var ch = tch[name] = tch[name] || {};
            var cacheHit = ch[key];

            if (cacheHit) {
              return cacheHit;
            } else {
              return ch[key] = fn.call(eles, arg1, arg2, arg3, arg4);
            }
          } else {
            return fn.call(eles, arg1, arg2, arg3, arg4);
          }
        };
      };

      // DAG functions
      ////////////////

      var defineDagExtremity = function defineDagExtremity(params) {
        return function dagExtremityImpl(selector) {
          var eles = this;
          var ret = [];

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            if (!ele.isNode()) {
              continue;
            }

            var disqualified = false;
            var edges = ele.connectedEdges();

            for (var j = 0; j < edges.length; j++) {
              var edge = edges[j];
              var src = edge.source();
              var tgt = edge.target();

              if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
                disqualified = true;
                break;
              }
            }

            if (!disqualified) {
              ret.push(ele);
            }
          }

          return this.spawn(ret, { unique: true }).filter(selector);
        };
      };

      var defineDagOneHop = function defineDagOneHop(params) {
        return function (selector) {
          var eles = this;
          var oEles = [];

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];

            if (!ele.isNode()) {
              continue;
            }

            var edges = ele.connectedEdges();
            for (var j = 0; j < edges.length; j++) {
              var edge = edges[j];
              var src = edge.source();
              var tgt = edge.target();

              if (params.outgoing && src === ele) {
                oEles.push(edge);
                oEles.push(tgt);
              } else if (params.incoming && tgt === ele) {
                oEles.push(edge);
                oEles.push(src);
              }
            }
          }

          return this.spawn(oEles, { unique: true }).filter(selector);
        };
      };

      var defineDagAllHops = function defineDagAllHops(params) {
        return function (selector) {
          var eles = this;
          var sEles = [];
          var sElesIds = {};

          for (;;) {
            var next = params.outgoing ? eles.outgoers() : eles.incomers();

            if (next.length === 0) {
              break;
            } // done if none left

            var newNext = false;
            for (var i = 0; i < next.length; i++) {
              var n = next[i];
              var nid = n.id();

              if (!sElesIds[nid]) {
                sElesIds[nid] = true;
                sEles.push(n);
                newNext = true;
              }
            }

            if (!newNext) {
              break;
            } // done if touched all outgoers already

            eles = next;
          }

          return this.spawn(sEles, { unique: true }).filter(selector);
        };
      };

      elesfn.clearTraversalCache = function () {
        for (var i = 0; i < this.length; i++) {
          this[i]._private.traversalCache = null;
        }
      };

      util.extend(elesfn, {
        // get the root nodes in the DAG
        roots: defineDagExtremity({ noIncomingEdges: true }),

        // get the leaf nodes in the DAG
        leaves: defineDagExtremity({ noOutgoingEdges: true }),

        // normally called children in graph theory
        // these nodes =edges=> outgoing nodes
        outgoers: cache(defineDagOneHop({ outgoing: true }), 'outgoers'),

        // aka DAG descendants
        successors: defineDagAllHops({ outgoing: true }),

        // normally called parents in graph theory
        // these nodes <=edges= incoming nodes
        incomers: cache(defineDagOneHop({ incoming: true }), 'incomers'),

        // aka DAG ancestors
        predecessors: defineDagAllHops({ incoming: true })
      });

      // Neighbourhood functions
      //////////////////////////

      util.extend(elesfn, {
        neighborhood: cache(function (selector) {
          var elements = [];
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            // for all nodes
            var node = nodes[i];
            var connectedEdges = node.connectedEdges();

            // for each connected edge, add the edge and the other node
            for (var j = 0; j < connectedEdges.length; j++) {
              var edge = connectedEdges[j];
              var src = edge.source();
              var tgt = edge.target();
              var otherNode = node === src ? tgt : src;

              // need check in case of loop
              if (otherNode.length > 0) {
                elements.push(otherNode[0]); // add node 1 hop away
              }

              // add connected edge
              elements.push(edge[0]);
            }
          }

          return this.spawn(elements, { unique: true }).filter(selector);
        }, 'neighborhood'),

        closedNeighborhood: function closedNeighborhood(selector) {
          return this.neighborhood().add(this).filter(selector);
        },

        openNeighborhood: function openNeighborhood(selector) {
          return this.neighborhood(selector);
        }
      });

      // aliases
      elesfn.neighbourhood = elesfn.neighborhood;
      elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
      elesfn.openNeighbourhood = elesfn.openNeighborhood;

      // Edge functions
      /////////////////

      util.extend(elesfn, {
        source: cache(function sourceImpl(selector) {
          var ele = this[0];
          var src = void 0;

          if (ele) {
            src = ele._private.source || ele.cy().collection();
          }

          return src && selector ? src.filter(selector) : src;
        }, 'source'),

        target: cache(function targetImpl(selector) {
          var ele = this[0];
          var tgt = void 0;

          if (ele) {
            tgt = ele._private.target || ele.cy().collection();
          }

          return tgt && selector ? tgt.filter(selector) : tgt;
        }, 'target'),

        sources: defineSourceFunction({
          attr: 'source'
        }),

        targets: defineSourceFunction({
          attr: 'target'
        })
      });

      function defineSourceFunction(params) {
        return function sourceImpl(selector) {
          var sources = [];

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var src = ele._private[params.attr];

            if (src) {
              sources.push(src);
            }
          }

          return this.spawn(sources, { unique: true }).filter(selector);
        };
      }

      util.extend(elesfn, {
        edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),

        edgesTo: cache(defineEdgesWithFunction({
          thisIsSrc: true
        }), 'edgesTo')
      });

      function defineEdgesWithFunction(params) {

        return function edgesWithImpl(otherNodes) {
          var elements = [];
          var cy = this._private.cy;
          var p = params || {};

          // get elements if a selector is specified
          if (is.string(otherNodes)) {
            otherNodes = cy.$(otherNodes);
          }

          for (var h = 0; h < otherNodes.length; h++) {
            var edges = otherNodes[h]._private.edges;

            for (var i = 0; i < edges.length; i++) {
              var edge = edges[i];
              var edgeData = edge._private.data;
              var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
              var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
              var edgeConnectsThisAndOther = thisToOther || otherToThis;

              if (!edgeConnectsThisAndOther) {
                continue;
              }

              if (p.thisIsSrc || p.thisIsTgt) {
                if (p.thisIsSrc && !thisToOther) {
                  continue;
                }

                if (p.thisIsTgt && !otherToThis) {
                  continue;
                }
              }

              elements.push(edge);
            }
          }

          return this.spawn(elements, { unique: true });
        };
      }

      util.extend(elesfn, {
        connectedEdges: cache(function (selector) {
          var retEles = [];

          var eles = this;
          for (var i = 0; i < eles.length; i++) {
            var node = eles[i];
            if (!node.isNode()) {
              continue;
            }

            var edges = node._private.edges;

            for (var j = 0; j < edges.length; j++) {
              var edge = edges[j];
              retEles.push(edge);
            }
          }

          return this.spawn(retEles, { unique: true }).filter(selector);
        }, 'connectedEdges'),

        connectedNodes: cache(function (selector) {
          var retEles = [];

          var eles = this;
          for (var i = 0; i < eles.length; i++) {
            var edge = eles[i];
            if (!edge.isEdge()) {
              continue;
            }

            retEles.push(edge.source()[0]);
            retEles.push(edge.target()[0]);
          }

          return this.spawn(retEles, { unique: true }).filter(selector);
        }, 'connectedNodes'),

        parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),

        codirectedEdges: cache(defineParallelEdgesFunction({
          codirected: true
        }), 'codirectedEdges')
      });

      function defineParallelEdgesFunction(params) {
        var defaults = {
          codirected: false
        };
        params = util.extend({}, defaults, params);

        return function parallelEdgesImpl(selector) {
          // micro-optimised for renderer
          var elements = [];
          var edges = this.edges();
          var p = params;

          // look at all the edges in the collection
          for (var i = 0; i < edges.length; i++) {
            var edge1 = edges[i];
            var edge1_p = edge1._private;
            var src1 = edge1_p.source;
            var srcid1 = src1._private.data.id;
            var tgtid1 = edge1_p.data.target;
            var srcEdges1 = src1._private.edges;

            // look at edges connected to the src node of this edge
            for (var j = 0; j < srcEdges1.length; j++) {
              var edge2 = srcEdges1[j];
              var edge2data = edge2._private.data;
              var tgtid2 = edge2data.target;
              var srcid2 = edge2data.source;

              var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
              var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

              if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
                elements.push(edge2);
              }
            }
          }

          return this.spawn(elements, { unique: true }).filter(selector);
        };
      }

      // Misc functions
      /////////////////

      util.extend(elesfn, {
        components: function components() {
          var self = this;
          var cy = self.cy();
          var visited = self.spawn();
          var unvisited = self.nodes().spawnSelf();
          var components = [];

          var visitInComponent = function visitInComponent(node, component) {
            visited.merge(node);
            unvisited.unmerge(node);
            component.merge(node);
          };

          if (unvisited.empty()) {
            return self.spawn();
          }

          var _loop = function _loop() {
            var component = cy.collection();
            components.push(component);

            var root = unvisited[0];
            visitInComponent(root, component);

            self.bfs({
              directed: false,
              roots: root,
              visit: function visit(v, e, u, i, depth) {
                visitInComponent(v, component);
              }
            });
          };

          do {
            _loop();
          } while (unvisited.length > 0);

          return components.map(function (component) {
            var connectedEdges = component.connectedEdges().stdFilter(function (edge) {
              return component.anySame(edge.source()) && component.anySame(edge.target());
            });

            return component.union(connectedEdges);
          });
        }
      });

      module.exports = elesfn;

      /***/
    },
    /* 70 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Collection = __webpack_require__(7);
      var Element = __webpack_require__(14);

      var corefn = {
        add: function add(opts) {

          var elements = void 0;
          var cy = this;

          // add the elements
          if (is.elementOrCollection(opts)) {
            var eles = opts;

            if (eles._private.cy === cy) {
              // same instance => just restore
              elements = eles.restore();
            } else {
              // otherwise, copy from json
              var jsons = [];

              for (var i = 0; i < eles.length; i++) {
                var ele = eles[i];
                jsons.push(ele.json());
              }

              elements = new Collection(cy, jsons);
            }
          }

          // specify an array of options
          else if (is.array(opts)) {
              var _jsons = opts;

              elements = new Collection(cy, _jsons);
            }

            // specify via opts.nodes and opts.edges
            else if (is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges))) {
                var elesByGroup = opts;
                var _jsons2 = [];

                var grs = ['nodes', 'edges'];
                for (var _i = 0, il = grs.length; _i < il; _i++) {
                  var group = grs[_i];
                  var elesArray = elesByGroup[group];

                  if (is.array(elesArray)) {

                    for (var j = 0, jl = elesArray.length; j < jl; j++) {
                      var json = util.extend({ group: group }, elesArray[j]);

                      _jsons2.push(json);
                    }
                  }
                }

                elements = new Collection(cy, _jsons2);
              }

              // specify options for one element
              else {
                  var _json = opts;
                  elements = new Element(cy, _json).collection();
                }

          return elements;
        },

        remove: function remove(collection) {
          if (is.elementOrCollection(collection)) {
            // already have right ref
          } else if (is.string(collection)) {
            var selector = collection;
            collection = this.$(selector);
          }

          return collection.remove();
        }
      };

      module.exports = corefn;

      /***/
    },
    /* 71 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);
      var util = __webpack_require__(1);
      var stepAll = __webpack_require__(72);

      var corefn = {

        // pull in animation functions
        animate: define.animate(),
        animation: define.animation(),
        animated: define.animated(),
        clearQueue: define.clearQueue(),
        delay: define.delay(),
        delayAnimation: define.delayAnimation(),
        stop: define.stop(),

        addToAnimationPool: function addToAnimationPool(eles) {
          var cy = this;

          if (!cy.styleEnabled()) {
            return;
          } // save cycles when no style used

          cy._private.aniEles.merge(eles);
        },

        stopAnimationLoop: function stopAnimationLoop() {
          this._private.animationsRunning = false;
        },

        startAnimationLoop: function startAnimationLoop() {
          var cy = this;

          cy._private.animationsRunning = true;

          if (!cy.styleEnabled()) {
            return;
          } // save cycles when no style used

          // NB the animation loop will exec in headless environments if style enabled
          // and explicit cy.destroy() is necessary to stop the loop

          function headlessStep() {
            if (!cy._private.animationsRunning) {
              return;
            }

            util.requestAnimationFrame(function animationStep(now) {
              stepAll(now, cy);
              headlessStep();
            });
          }

          var renderer = cy.renderer();

          if (renderer && renderer.beforeRender) {
            // let the renderer schedule animations
            renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
              stepAll(now, cy);
            }, renderer.beforeRenderPriorities.animations);
          } else {
            // manage the animation loop ourselves
            headlessStep(); // first call
          }
        }

      };

      module.exports = corefn;

      /***/
    },
    /* 72 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var step = __webpack_require__(73);
      var startAnimation = __webpack_require__(78);

      function stepAll(now, cy) {
        var eles = cy._private.aniEles;
        var doneEles = [];

        function stepOne(ele, isCore) {
          var _p = ele._private;
          var current = _p.animation.current;
          var queue = _p.animation.queue;
          var ranAnis = false;

          // cancel all animations on display:none ele
          if (!isCore && ele.pstyle('display').value === 'none') {
            // put all current and queue animations in this tick's current list
            // and empty the lists for the element
            current = current.splice(0, current.length).concat(queue.splice(0, queue.length));

            // stop all animations
            for (var i = 0; i < current.length; i++) {
              current[i].stop();
            }
          }

          // if nothing currently animating, get something from the queue
          if (current.length === 0) {
            var next = queue.shift();

            if (next) {
              current.push(next);
            }
          }

          var callbacks = function callbacks(_callbacks) {
            for (var j = _callbacks.length - 1; j >= 0; j--) {
              var cb = _callbacks[j];

              cb();
            }

            _callbacks.splice(0, _callbacks.length);
          };

          // step and remove if done
          for (var _i = current.length - 1; _i >= 0; _i--) {
            var ani = current[_i];
            var ani_p = ani._private;

            if (ani_p.stopped) {
              current.splice(_i, 1);

              ani_p.hooked = false;
              ani_p.playing = false;
              ani_p.started = false;

              callbacks(ani_p.frames);

              continue;
            }

            if (!ani_p.playing && !ani_p.applying) {
              continue;
            }

            // an apply() while playing shouldn't do anything
            if (ani_p.playing && ani_p.applying) {
              ani_p.applying = false;
            }

            if (!ani_p.started) {
              startAnimation(ele, ani, now, isCore);
            }

            step(ele, ani, now, isCore);

            if (ani_p.applying) {
              ani_p.applying = false;
            }

            callbacks(ani_p.frames);

            if (ani.completed()) {
              current.splice(_i, 1);

              ani_p.hooked = false;
              ani_p.playing = false;
              ani_p.started = false;

              callbacks(ani_p.completes);
            }

            ranAnis = true;
          }

          if (!isCore && current.length === 0 && queue.length === 0) {
            doneEles.push(ele);
          }

          return ranAnis;
        } // stepElement

        // handle all eles
        var ranEleAni = false;
        for (var e = 0; e < eles.length; e++) {
          var ele = eles[e];
          var handledThisEle = stepOne(ele);

          ranEleAni = ranEleAni || handledThisEle;
        } // each element

        var ranCoreAni = stepOne(cy, true);

        // notify renderer
        if (ranEleAni || ranCoreAni) {
          if (eles.length > 0) {
            eles.dirtyCompoundBoundsCache();

            cy.notify({
              type: 'draw',
              eles: eles
            });
          } else {
            cy.notify({
              type: 'draw'
            });
          }
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge(doneEles);

        cy.emit('step');
      } // stepAll

      module.exports = stepAll;

      /***/
    },
    /* 73 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var easings = __webpack_require__(74);
      var ease = __webpack_require__(77);
      var is = __webpack_require__(0);

      function step(self, ani, now, isCore) {
        var isEles = !isCore;
        var _p = self._private;
        var ani_p = ani._private;
        var pEasing = ani_p.easing;
        var startTime = ani_p.startTime;
        var cy = isCore ? self : self.cy();
        var style = cy.style();

        if (!ani_p.easingImpl) {

          if (pEasing == null) {
            // use default
            ani_p.easingImpl = easings['linear'];
          } else {
            // then define w/ name
            var easingVals = void 0;

            if (is.string(pEasing)) {
              var easingProp = style.parse('transition-timing-function', pEasing);

              easingVals = easingProp.value;
            } else {
              // then assume preparsed array
              easingVals = pEasing;
            }

            var name = void 0,
                args = void 0;

            if (is.string(easingVals)) {
              name = easingVals;
              args = [];
            } else {
              name = easingVals[1];
              args = easingVals.slice(2).map(function (n) {
                return +n;
              });
            }

            if (args.length > 0) {
              // create with args
              if (name === 'spring') {
                args.push(ani_p.duration); // need duration to generate spring
              }

              ani_p.easingImpl = easings[name].apply(null, args);
            } else {
              // static impl by name
              ani_p.easingImpl = easings[name];
            }
          }
        }

        var easing = ani_p.easingImpl;
        var percent = void 0;

        if (ani_p.duration === 0) {
          percent = 1;
        } else {
          percent = (now - startTime) / ani_p.duration;
        }

        if (ani_p.applying) {
          percent = ani_p.progress;
        }

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (ani_p.delay == null) {
          // then update

          var startPos = ani_p.startPosition;
          var endPos = ani_p.position;

          if (endPos && isEles && !self.locked()) {
            var pos = self.position();

            if (valid(startPos.x, endPos.x)) {
              pos.x = ease(startPos.x, endPos.x, percent, easing);
            }

            if (valid(startPos.y, endPos.y)) {
              pos.y = ease(startPos.y, endPos.y, percent, easing);
            }

            self.emit('position');
          }

          var startPan = ani_p.startPan;
          var endPan = ani_p.pan;
          var pan = _p.pan;
          var animatingPan = endPan != null && isCore;
          if (animatingPan) {
            if (valid(startPan.x, endPan.x)) {
              pan.x = ease(startPan.x, endPan.x, percent, easing);
            }

            if (valid(startPan.y, endPan.y)) {
              pan.y = ease(startPan.y, endPan.y, percent, easing);
            }

            self.emit('pan');
          }

          var startZoom = ani_p.startZoom;
          var endZoom = ani_p.zoom;
          var animatingZoom = endZoom != null && isCore;
          if (animatingZoom) {
            if (valid(startZoom, endZoom)) {
              _p.zoom = ease(startZoom, endZoom, percent, easing);
            }

            self.emit('zoom');
          }

          if (animatingPan || animatingZoom) {
            self.emit('viewport');
          }

          var props = ani_p.style;
          if (props && props.length > 0 && isEles) {
            for (var i = 0; i < props.length; i++) {
              var prop = props[i];
              var _name = prop.name;
              var end = prop;
              var start = ani_p.startStyle[_name];
              var propSpec = style.properties[start.name];
              var easedVal = ease(start, end, percent, easing, propSpec);

              style.overrideBypass(self, _name, easedVal);
            } // for props

            self.emit('style');
          } // if
        }

        ani_p.progress = percent;

        return percent;
      }

      function valid(start, end) {
        if (start == null || end == null) {
          return false;
        }

        if (is.number(start) && is.number(end)) {
          return true;
        } else if (start && end) {
          return true;
        }

        return false;
      }

      module.exports = step;

      /***/
    },
    /* 74 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var generateCubicBezier = __webpack_require__(75);
      var generateSpringRK4 = __webpack_require__(76);

      var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
        var bezier = generateCubicBezier(t1, p1, t2, p2);

        return function (start, end, percent) {
          return start + (end - start) * bezier(percent);
        };
      };

      var easings = {
        'linear': function linear(start, end, percent) {
          return start + (end - start) * percent;
        },

        // default easings
        'ease': cubicBezier(0.25, 0.1, 0.25, 1),
        'ease-in': cubicBezier(0.42, 0, 1, 1),
        'ease-out': cubicBezier(0, 0, 0.58, 1),
        'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),

        // sine
        'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
        'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
        'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),

        // quad
        'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
        'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
        'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),

        // cubic
        'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
        'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
        'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),

        // quart
        'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
        'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
        'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),

        // quint
        'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
        'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
        'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),

        // expo
        'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
        'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
        'ease-in-out-expo': cubicBezier(1, 0, 0, 1),

        // circ
        'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
        'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
        'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),

        // user param easings...

        'spring': function spring(tension, friction, duration) {
          if (duration === 0) {
            // can't get a spring w/ duration 0
            return easings.linear; // duration 0 => jump to end so impl doesn't matter
          }

          var spring = generateSpringRK4(tension, friction, duration);

          return function (start, end, percent) {
            return start + (end - start) * spring(percent);
          };
        },

        'cubic-bezier': cubicBezier
      };

      module.exports = easings;

      /***/
    },
    /* 75 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /* global Float32Array */

      /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */

      function generateCubicBezier(mX1, mY1, mX2, mY2) {
        var NEWTON_ITERATIONS = 4,
            NEWTON_MIN_SLOPE = 0.001,
            SUBDIVISION_PRECISION = 0.0000001,
            SUBDIVISION_MAX_ITERATIONS = 10,
            kSplineTableSize = 11,
            kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
            float32ArraySupported = typeof Float32Array !== 'undefined';

        /* Must contain four arguments. */
        if (arguments.length !== 4) {
          return false;
        }

        /* Arguments must be numbers. */
        for (var i = 0; i < 4; ++i) {
          if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
            return false;
          }
        }

        /* X values must be in the [0, 1] range. */
        mX1 = Math.min(mX1, 1);
        mX2 = Math.min(mX2, 1);
        mX1 = Math.max(mX1, 0);
        mX2 = Math.max(mX2, 0);

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function A(aA1, aA2) {
          return 1.0 - 3.0 * aA2 + 3.0 * aA1;
        }

        function B(aA1, aA2) {
          return 3.0 * aA2 - 6.0 * aA1;
        }

        function C(aA1) {
          return 3.0 * aA1;
        }

        function calcBezier(aT, aA1, aA2) {
          return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        }

        function getSlope(aT, aA1, aA2) {
          return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }

        function newtonRaphsonIterate(aX, aGuessT) {
          for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);

            if (currentSlope === 0.0) {
              return aGuessT;
            }

            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }

          return aGuessT;
        }

        function calcSampleValues() {
          for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
            mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
          }
        }

        function binarySubdivide(aX, aA, aB) {
          var currentX = void 0,
              currentT = void 0,
              i = 0;

          do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

          return currentT;
        }

        function getTForX(aX) {
          var intervalStart = 0.0,
              currentSample = 1,
              lastSample = kSplineTableSize - 1;

          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }

          --currentSample;

          var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
              guessForT = intervalStart + dist * kSampleStepSize,
              initialSlope = getSlope(guessForT, mX1, mX2);

          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT);
          } else if (initialSlope === 0.0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
          }
        }

        var _precomputed = false;

        function precompute() {
          _precomputed = true;
          if (mX1 !== mY1 || mX2 !== mY2) {
            calcSampleValues();
          }
        }

        var f = function f(aX) {
          if (!_precomputed) {
            precompute();
          }
          if (mX1 === mY1 && mX2 === mY2) {
            return aX;
          }
          if (aX === 0) {
            return 0;
          }
          if (aX === 1) {
            return 1;
          }

          return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function () {
          return [{
            x: mX1,
            y: mY1
          }, {
            x: mX2,
            y: mY2
          }];
        };

        var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
        f.toString = function () {
          return str;
        };

        return f;
      }

      module.exports = generateCubicBezier;

      /***/
    },
    /* 76 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
      /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
         then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */

      var generateSpringRK4 = function () {
        function springAccelerationForState(state) {
          return -state.tension * state.x - state.friction * state.v;
        }

        function springEvaluateStateWithDerivative(initialState, dt, derivative) {
          var state = {
            x: initialState.x + derivative.dx * dt,
            v: initialState.v + derivative.dv * dt,
            tension: initialState.tension,
            friction: initialState.friction
          };

          return { dx: state.v, dv: springAccelerationForState(state) };
        }

        function springIntegrateState(state, dt) {
          var a = {
            dx: state.v,
            dv: springAccelerationForState(state)
          },
              b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
              c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
              d = springEvaluateStateWithDerivative(state, dt, c),
              dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
              dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

          state.x = state.x + dxdt * dt;
          state.v = state.v + dvdt * dt;

          return state;
        }

        return function springRK4Factory(tension, friction, duration) {

          var initState = {
            x: -1,
            v: 0,
            tension: null,
            friction: null
          },
              path = [0],
              time_lapsed = 0,
              tolerance = 1 / 10000,
              DT = 16 / 1000,
              have_duration = void 0,
              dt = void 0,
              last_state = void 0;

          tension = parseFloat(tension) || 500;
          friction = parseFloat(friction) || 20;
          duration = duration || null;

          initState.tension = tension;
          initState.friction = friction;

          have_duration = duration !== null;

          /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
          if (have_duration) {
            /* Run the simulation without a duration. */
            time_lapsed = springRK4Factory(tension, friction);
            /* Compute the adjusted time delta. */
            dt = time_lapsed / duration * DT;
          } else {
            dt = DT;
          }

          for (;;) {
            /* Next/step function .*/
            last_state = springIntegrateState(last_state || initState, dt);
            /* Store the position. */
            path.push(1 + last_state.x);
            time_lapsed += 16;
            /* If the change threshold is reached, break. */
            if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
              break;
            }
          }

          /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
             computed path and returns a snapshot of the position according to a given percentComplete. */
          return !have_duration ? time_lapsed : function (percentComplete) {
            return path[percentComplete * (path.length - 1) | 0];
          };
        };
      }();

      module.exports = generateSpringRK4;

      /***/
    },
    /* 77 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      function getEasedValue(type, start, end, percent, easingFn) {
        if (percent === 1) {
          return end;
        }

        var val = easingFn(start, end, percent);

        if (type == null) {
          return val;
        }

        if (type.roundValue || type.color) {
          val = Math.round(val);
        }

        if (type.min !== undefined) {
          val = Math.max(val, type.min);
        }

        if (type.max !== undefined) {
          val = Math.min(val, type.max);
        }

        return val;
      }

      function getValue(prop, spec) {
        if (prop.pfValue != null || prop.value != null) {
          if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
            return prop.pfValue;
          } else {
            return prop.value;
          }
        } else {
          return prop;
        }
      }

      function ease(startProp, endProp, percent, easingFn, propSpec) {
        var type = propSpec != null ? propSpec.type : null;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        var start = getValue(startProp, propSpec);
        var end = getValue(endProp, propSpec);

        if (is.number(start) && is.number(end)) {
          return getEasedValue(type, start, end, percent, easingFn);
        } else if (is.array(start) && is.array(end)) {
          var easedArr = [];

          for (var i = 0; i < end.length; i++) {
            var si = start[i];
            var ei = end[i];

            if (si != null && ei != null) {
              var val = getEasedValue(type, si, ei, percent, easingFn);

              easedArr.push(val);
            } else {
              easedArr.push(ei);
            }
          }

          return easedArr;
        }

        return undefined;
      }

      module.exports = ease;

      /***/
    },
    /* 78 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function startAnimation(self, ani, now, isCore) {
        var isEles = !isCore;
        var ele = self;
        var ani_p = ani._private;
        var cy = isCore ? self : self.cy();
        var style = cy.style();

        if (isEles) {
          var pos = ele.position();

          ani_p.startPosition = ani_p.startPosition || {
            x: pos.x,
            y: pos.y
          };

          ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle(ele, ani_p.style);
        }

        if (isCore) {
          var pan = cy._private.pan;

          ani_p.startPan = ani_p.startPan || {
            x: pan.x,
            y: pan.y
          };

          ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
        }

        ani_p.started = true;
        ani_p.startTime = now - ani_p.progress * ani_p.duration;
      }

      module.exports = startAnimation;

      /***/
    },
    /* 79 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Emitter = __webpack_require__(11);
      var define = __webpack_require__(4);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var emitterOptions = {
        qualifierCompare: function qualifierCompare(selector1, selector2) {
          if (selector1 == null || selector2 == null) {
            return selector1 == null && selector2 == null;
          } else {
            return selector1.sameText(selector2);
          }
        },
        eventMatches: function eventMatches(cy, listener, eventObj) {
          var selector = listener.qualifier;

          if (selector != null) {
            return cy !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
          }

          return true;
        },
        eventFields: function eventFields(cy) {
          return {
            cy: cy,
            target: cy
          };
        },
        callbackContext: function callbackContext(cy, listener, eventObj) {
          return listener.qualifier != null ? eventObj.target : cy;
        }
      };

      var argSelector = function argSelector(arg) {
        if (is.string(arg)) {
          return new Selector(arg);
        } else {
          return arg;
        }
      };

      var elesfn = {
        createEmitter: function createEmitter() {
          var _p = this._private;

          if (!_p.emitter) {
            _p.emitter = new Emitter(util.assign({
              context: this
            }, emitterOptions));
          }

          return this;
        },

        emitter: function emitter() {
          return this._private.emitter;
        },

        on: function on(events, selector, callback) {
          this.emitter().on(events, argSelector(selector), callback);

          return this;
        },

        removeListener: function removeListener(events, selector, callback) {
          this.emitter().removeListener(events, argSelector(selector), callback);

          return this;
        },

        one: function one(events, selector, callback) {
          this.emitter().one(events, argSelector(selector), callback);

          return this;
        },

        once: function once(events, selector, callback) {
          this.emitter().one(events, argSelector(selector), callback);

          return this;
        },

        emit: function emit(events, extraParams) {
          this.emitter().emit(events, extraParams);

          return this;
        }
      };

      define.eventAliasesOn(elesfn);

      module.exports = elesfn;

      /***/
    },
    /* 80 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var corefn = {

        png: function png(options) {
          var renderer = this._private.renderer;
          options = options || {};

          return renderer.png(options);
        },

        jpg: function jpg(options) {
          var renderer = this._private.renderer;
          options = options || {};

          options.bg = options.bg || '#fff';

          return renderer.jpg(options);
        }

      };

      corefn.jpeg = corefn.jpg;

      module.exports = corefn;

      /***/
    },
    /* 81 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var corefn = {

        layout: function layout(options) {
          var cy = this;

          if (options == null) {
            util.error('Layout options must be specified to make a layout');
            return;
          }

          if (options.name == null) {
            util.error('A `name` must be specified to make a layout');
            return;
          }

          var name = options.name;
          var Layout = cy.extension('layout', name);

          if (Layout == null) {
            util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
            return;
          }

          var eles = void 0;
          if (is.string(options.eles)) {
            eles = cy.$(options.eles);
          } else {
            eles = options.eles != null ? options.eles : cy.$();
          }

          var layout = new Layout(util.extend({}, options, {
            cy: cy,
            eles: eles
          }));

          return layout;
        }

      };

      corefn.createLayout = corefn.makeLayout = corefn.layout;

      module.exports = corefn;

      /***/
    },
    /* 82 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var corefn = {
        notify: function notify(params) {
          var _p = this._private;

          if (_p.batchingNotify) {
            var bEles = _p.batchNotifyEles;
            var bTypes = _p.batchNotifyTypes;

            if (params.eles) {
              bEles.merge(params.eles);
            }

            if (!bTypes.ids[params.type]) {
              bTypes.push(params.type);
              bTypes.ids[params.type] = true;
            }

            return; // notifications are disabled during batching
          }

          if (!_p.notificationsEnabled) {
            return;
          } // exit on disabled

          var renderer = this.renderer();

          // exit if destroy() called on core or renderer in between frames #1499 #1528
          if (this.isDestroyed() || !renderer) {
            return;
          }

          renderer.notify(params);
        },

        notifications: function notifications(bool) {
          var p = this._private;

          if (bool === undefined) {
            return p.notificationsEnabled;
          } else {
            p.notificationsEnabled = bool ? true : false;
          }
        },

        noNotifications: function noNotifications(callback) {
          this.notifications(false);
          callback();
          this.notifications(true);
        },

        batching: function batching() {
          return this._private.batchCount > 0;
        },

        startBatch: function startBatch() {
          var _p = this._private;

          if (_p.batchCount == null) {
            _p.batchCount = 0;
          }

          if (_p.batchCount === 0) {
            _p.batchingStyle = _p.batchingNotify = true;
            _p.batchStyleEles = this.collection();
            _p.batchNotifyEles = this.collection();
            _p.batchNotifyTypes = [];
            _p.batchNotifyTypes.ids = {};
          }

          _p.batchCount++;

          return this;
        },

        endBatch: function endBatch() {
          var _p = this._private;

          _p.batchCount--;

          if (_p.batchCount === 0) {
            // update style for dirty eles
            _p.batchingStyle = false;
            _p.batchStyleEles.updateStyle();

            // notify the renderer of queued eles and event types
            _p.batchingNotify = false;
            this.notify({
              type: _p.batchNotifyTypes,
              eles: _p.batchNotifyEles
            });
          }

          return this;
        },

        batch: function batch(callback) {
          this.startBatch();
          callback();
          this.endBatch();

          return this;
        },

        // for backwards compatibility
        batchData: function batchData(map) {
          var cy = this;

          return this.batch(function () {
            var ids = Object.keys(map);

            for (var i = 0; i < ids.length; i++) {
              var id = ids[i];
              var data = map[id];
              var ele = cy.getElementById(id);

              ele.data(data);
            }
          });
        }
      };

      module.exports = corefn;

      /***/
    },
    /* 83 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var corefn = {

        renderTo: function renderTo(context, zoom, pan, pxRatio) {
          var r = this._private.renderer;

          r.renderTo(context, zoom, pan, pxRatio);
          return this;
        },

        renderer: function renderer() {
          return this._private.renderer;
        },

        forceRender: function forceRender() {
          this.notify({
            type: 'draw'
          });

          return this;
        },

        resize: function resize() {
          this.invalidateSize();

          this.notify({
            type: 'resize'
          });

          this.emit('resize');

          return this;
        },

        initRenderer: function initRenderer(options) {
          var cy = this;

          var RendererProto = cy.extension('renderer', options.name);
          if (RendererProto == null) {
            util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
            return;
          }

          cy._private.renderer = new RendererProto(util.extend({}, options, { cy: cy }));

          this.notify({ type: 'init' });
        },

        destroyRenderer: function destroyRenderer() {
          var cy = this;

          cy.notify({ type: 'destroy' }); // destroy the renderer

          var domEle = cy.container();
          if (domEle) {
            domEle._cyreg = null;

            while (domEle.childNodes.length > 0) {
              domEle.removeChild(domEle.childNodes[0]);
            }
          }

          cy._private.renderer = null; // to be extra safe, remove the ref
        },

        onRender: function onRender(fn) {
          return this.on('render', fn);
        },

        offRender: function offRender(fn) {
          return this.off('render', fn);
        }

      };

      corefn.invalidateDimensions = corefn.resize;

      module.exports = corefn;

      /***/
    },
    /* 84 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Collection = __webpack_require__(7);

      var corefn = {

        // get a collection
        // - empty collection on no args
        // - collection of elements in the graph on selector arg
        // - guarantee a returned collection when elements or collection specified
        collection: function collection(eles, opts) {

          if (is.string(eles)) {
            return this.$(eles);
          } else if (is.elementOrCollection(eles)) {
            return eles.collection();
          } else if (is.array(eles)) {
            return new Collection(this, eles, opts);
          }

          return new Collection(this);
        },

        nodes: function nodes(selector) {
          var nodes = this.$(function (ele) {
            return ele.isNode();
          });

          if (selector) {
            return nodes.filter(selector);
          }

          return nodes;
        },

        edges: function edges(selector) {
          var edges = this.$(function (ele) {
            return ele.isEdge();
          });

          if (selector) {
            return edges.filter(selector);
          }

          return edges;
        },

        // search the graph like jQuery
        $: function $(selector) {
          var eles = this._private.elements;

          if (selector) {
            return eles.filter(selector);
          } else {
            return eles.spawnSelf();
          }
        },

        mutableElements: function mutableElements() {
          return this._private.elements;
        }

      };

      // aliases
      corefn.elements = corefn.filter = corefn.$;

      module.exports = corefn;

      /***/
    },
    /* 85 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Style = __webpack_require__(18);

      var corefn = {

        style: function style(newStyle) {
          if (newStyle) {
            var s = this.setStyle(newStyle);

            s.update();
          }

          return this._private.style;
        },

        setStyle: function setStyle(style) {
          var _p = this._private;

          if (is.stylesheet(style)) {
            _p.style = style.generateStyle(this);
          } else if (is.array(style)) {
            _p.style = Style.fromJson(this, style);
          } else if (is.string(style)) {
            _p.style = Style.fromString(this, style);
          } else {
            _p.style = Style(this);
          }

          return _p.style;
        }
      };

      module.exports = corefn;

      /***/
    },
    /* 86 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);

      var styfn = {};

      // (potentially expensive calculation)
      // apply the style to the element based on
      // - its bypass
      // - what selectors match it
      styfn.apply = function (eles) {
        var self = this;
        var _p = self._private;
        var cy = _p.cy;
        var updatedEles = cy.collection();

        if (_p.newStyle) {
          // clear style caches
          _p.contextStyles = {};
          _p.propDiffs = {};

          self.cleanElements(eles, true);
        }

        for (var ie = 0; ie < eles.length; ie++) {
          var ele = eles[ie];

          var cxtMeta = self.getContextMeta(ele);

          if (cxtMeta.empty) {
            continue;
          } else {
            updatedEles.merge(ele);
          }

          var cxtStyle = self.getContextStyle(cxtMeta);
          var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

          if (!_p.newStyle) {
            self.updateTransitions(ele, app.diffProps);
          }

          self.updateStyleHints(ele);
        } // for elements

        _p.newStyle = false;

        return updatedEles;
      };

      styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
        var self = this;
        var cache = self._private.propDiffs = self._private.propDiffs || {};
        var dualCxtKey = oldCxtKey + '-' + newCxtKey;
        var cachedVal = cache[dualCxtKey];

        if (cachedVal) {
          return cachedVal;
        }

        var diffProps = [];
        var addedProp = {};

        for (var i = 0; i < self.length; i++) {
          var cxt = self[i];
          var oldHasCxt = oldCxtKey[i] === 't';
          var newHasCxt = newCxtKey[i] === 't';
          var cxtHasDiffed = oldHasCxt !== newHasCxt;
          var cxtHasMappedProps = cxt.mappedProperties.length > 0;

          if (cxtHasDiffed || cxtHasMappedProps) {
            var props = void 0;

            if (cxtHasDiffed && cxtHasMappedProps) {
              props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
            } else if (cxtHasDiffed) {
              props = cxt.properties; // need to check them all
            } else if (cxtHasMappedProps) {
              props = cxt.mappedProperties; // only need to check mapped
            }

            for (var j = 0; j < props.length; j++) {
              var prop = props[j];
              var name = prop.name;

              // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
              // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
              // is cached)
              var laterCxtOverrides = false;
              for (var k = i + 1; k < self.length; k++) {
                var laterCxt = self[k];
                var hasLaterCxt = newCxtKey[k] === 't';

                if (!hasLaterCxt) {
                  continue;
                } // can't override unless the context is active

                laterCxtOverrides = laterCxt.properties[prop.name] != null;

                if (laterCxtOverrides) {
                  break;
                } // exit early as long as one later context overrides
              }

              if (!addedProp[name] && !laterCxtOverrides) {
                addedProp[name] = true;
                diffProps.push(name);
              }
            } // for props
          } // if
        } // for contexts

        cache[dualCxtKey] = diffProps;
        return diffProps;
      };

      styfn.getContextMeta = function (ele) {
        var self = this;
        var cxtKey = '';
        var diffProps = void 0;
        var prevKey = ele._private.styleCxtKey || '';

        if (self._private.newStyle) {
          prevKey = ''; // since we need to apply all style if a fresh stylesheet
        }

        // get the cxt key
        for (var i = 0; i < self.length; i++) {
          var context = self[i];
          var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

          if (contextSelectorMatches) {
            cxtKey += 't';
          } else {
            cxtKey += 'f';
          }
        } // for context

        diffProps = self.getPropertiesDiff(prevKey, cxtKey);

        ele._private.styleCxtKey = cxtKey;

        return {
          key: cxtKey,
          diffPropNames: diffProps,
          empty: diffProps.length === 0
        };
      };

      // gets a computed ele style object based on matched contexts
      styfn.getContextStyle = function (cxtMeta) {
        var cxtKey = cxtMeta.key;
        var self = this;
        var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

        // if already computed style, returned cached copy
        if (cxtStyles[cxtKey]) {
          return cxtStyles[cxtKey];
        }

        var style = {
          _private: {
            key: cxtKey
          }
        };

        for (var i = 0; i < self.length; i++) {
          var cxt = self[i];
          var hasCxt = cxtKey[i] === 't';

          if (!hasCxt) {
            continue;
          }

          for (var j = 0; j < cxt.properties.length; j++) {
            var prop = cxt.properties[j];

            style[prop.name] = prop;
          }
        }

        cxtStyles[cxtKey] = style;
        return style;
      };

      styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
        var self = this;
        var diffProps = cxtMeta.diffPropNames;
        var retDiffProps = {};

        for (var i = 0; i < diffProps.length; i++) {
          var diffPropName = diffProps[i];
          var cxtProp = cxtStyle[diffPropName];
          var eleProp = ele.pstyle(diffPropName);

          if (!cxtProp) {
            // no context prop means delete
            if (!eleProp) {
              continue; // no existing prop means nothing needs to be removed
              // nb affects initial application on mapped values like control-point-distances
            } else if (eleProp.bypass) {
              cxtProp = { name: diffPropName, deleteBypassed: true };
            } else {
              cxtProp = { name: diffPropName, delete: true };
            }
          }

          // save cycles when the context prop doesn't need to be applied
          if (eleProp === cxtProp) {
            continue;
          }

          var retDiffProp = retDiffProps[diffPropName] = {
            prev: eleProp
          };

          self.applyParsedProperty(ele, cxtProp);

          retDiffProp.next = ele.pstyle(diffPropName);

          if (retDiffProp.next && retDiffProp.next.bypass) {
            retDiffProp.next = retDiffProp.next.bypassed;
          }
        }

        return {
          diffProps: retDiffProps
        };
      };

      styfn.updateStyleHints = function (ele) {
        var _p = ele._private;
        var self = this;

        if (ele.removed()) {
          return;
        }

        // set whether has pie or not; for greater efficiency
        var hasPie = false;
        if (_p.group === 'nodes') {
          for (var i = 1; i <= self.pieBackgroundN; i++) {
            // 1..N
            var _size = ele.pstyle('pie-' + i + '-background-size').value;

            if (_size > 0) {
              hasPie = true;
              break;
            }
          }
        }

        _p.hasPie = hasPie;

        var transform = ele.pstyle('text-transform').strValue;
        var content = ele.pstyle('label').strValue;
        var srcContent = ele.pstyle('source-label').strValue;
        var tgtContent = ele.pstyle('target-label').strValue;
        var fStyle = ele.pstyle('font-style').strValue;
        var size = ele.pstyle('font-size').pfValue + 'px';
        var family = ele.pstyle('font-family').strValue;
        // let letiant = style['font-letiant'].strValue;
        var weight = ele.pstyle('font-weight').strValue;
        var valign = ele.pstyle('text-valign').strValue;
        var halign = ele.pstyle('text-valign').strValue;
        var oWidth = ele.pstyle('text-outline-width').pfValue;
        var wrap = ele.pstyle('text-wrap').strValue;
        var wrapW = ele.pstyle('text-max-width').pfValue;
        var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
        _p.labelStyleKey = labelStyleKey;
        _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
        _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
        _p.labelKey = labelStyleKey + '$' + content;
        _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

        _p.styleKey = Date.now();
      };

      // apply a property to the style (for internal use)
      // returns whether application was successful
      //
      // now, this function flattens the property, and here's how:
      //
      // for parsedProp:{ bypass: true, deleteBypass: true }
      // no property is generated, instead the bypass property in the
      // element's style is replaced by what's pointed to by the `bypassed`
      // field in the bypass property (i.e. restoring the property the
      // bypass was overriding)
      //
      // for parsedProp:{ mapped: truthy }
      // the generated flattenedProp:{ mapping: prop }
      //
      // for parsedProp:{ bypass: true }
      // the generated flattenedProp:{ bypassed: parsedProp }
      styfn.applyParsedProperty = function (ele, parsedProp) {
        var self = this;
        var prop = parsedProp;
        var style = ele._private.style;
        var fieldVal = void 0,
            flatProp = void 0;
        var types = self.types;
        var type = self.properties[prop.name].type;
        var propIsBypass = prop.bypass;
        var origProp = style[prop.name];
        var origPropIsBypass = origProp && origProp.bypass;
        var _p = ele._private;
        var flatPropMapping = 'mapping';

        var checkZOrder = function checkZOrder() {
          self.checkZOrderTrigger(ele, prop.name, origProp ? origProp.value : null, prop.value);
        };

        // edges connected to compound nodes can not be haystacks
        if (parsedProp.name === 'curve-style' && parsedProp.value === 'haystack' && ele.isEdge() && (ele.isLoop() || ele.source().isParent() || ele.target().isParent())) {
          prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
        }

        if (prop.delete) {
          // delete the property and use the default value on falsey value
          style[prop.name] = undefined;

          checkZOrder();

          return true;
        }

        if (prop.deleteBypassed) {
          // delete the property that the
          if (!origProp) {
            checkZOrder();

            return true; // can't delete if no prop
          } else if (origProp.bypass) {
            // delete bypassed
            origProp.bypassed = undefined;

            checkZOrder();

            return true;
          } else {
            return false; // we're unsuccessful deleting the bypassed
          }
        }

        // check if we need to delete the current bypass
        if (prop.deleteBypass) {
          // then this property is just here to indicate we need to delete
          if (!origProp) {
            checkZOrder();

            return true; // property is already not defined
          } else if (origProp.bypass) {
            // then replace the bypass property with the original
            // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
            style[prop.name] = origProp.bypassed;

            checkZOrder();

            return true;
          } else {
            return false; // we're unsuccessful deleting the bypass
          }
        }

        var printMappingErr = function printMappingErr() {
          util.error('Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
        };

        // put the property in the style objects
        switch (prop.mapped) {// flatten the property if mapped
          case types.mapData:
            {
              // flatten the field (e.g. data.foo.bar)
              var fields = prop.field.split('.');
              var _fieldVal = _p.data;

              for (var i = 0; i < fields.length && _fieldVal; i++) {
                var field = fields[i];
                _fieldVal = _fieldVal[field];
              }

              var percent = void 0;
              if (!is.number(_fieldVal)) {
                // then keep the mapping but assume 0% for now
                percent = 0;
              } else {
                percent = (_fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
              }

              // make sure to bound percent value
              if (percent < 0) {
                percent = 0;
              } else if (percent > 1) {
                percent = 1;
              }

              if (type.color) {
                var r1 = prop.valueMin[0];
                var r2 = prop.valueMax[0];
                var g1 = prop.valueMin[1];
                var g2 = prop.valueMax[1];
                var b1 = prop.valueMin[2];
                var b2 = prop.valueMax[2];
                var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
                var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

                var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];

                flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
                  bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
                  name: prop.name,
                  value: clr,
                  strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
                };
              } else if (type.number) {
                var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
                flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
              } else {
                return false; // can only map to colours and numbers
              }

              if (!flatProp) {
                // if we can't flatten the property, then use the origProp so we still keep the mapping itself
                flatProp = this.parse(prop.name, origProp.strValue, prop.bypass, flatPropMapping);
              }

              if (!flatProp) {
                printMappingErr();
              }
              flatProp.mapping = prop; // keep a reference to the mapping
              prop = flatProp; // the flattened (mapped) property is the one we want

              break;
            }

          // direct mapping
          case types.data:
            {
              // flatten the field (e.g. data.foo.bar)
              var _fields = prop.field.split('.');
              var _fieldVal2 = _p.data;

              if (_fieldVal2) {
                for (var _i = 0; _i < _fields.length; _i++) {
                  var _field = _fields[_i];
                  _fieldVal2 = _fieldVal2[_field];
                }
              }

              flatProp = this.parse(prop.name, _fieldVal2, prop.bypass, flatPropMapping);

              if (!flatProp) {
                // if we can't flatten the property, then use the origProp so we still keep the mapping itself
                var flatPropVal = origProp ? origProp.strValue : '';

                flatProp = this.parse(prop.name, flatPropVal, prop.bypass, flatPropMapping);
              }

              if (!flatProp) {
                printMappingErr();
              }
              flatProp.mapping = prop; // keep a reference to the mapping
              prop = flatProp; // the flattened (mapped) property is the one we want

              break;
            }

          case types.fn:
            {
              var fn = prop.value;
              var fnRetVal = fn(ele);

              flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);
              flatProp.mapping = prop; // keep a reference to the mapping
              prop = flatProp; // the flattened (mapped) property is the one we want

              break;
            }

          case undefined:
            break; // just set the property

          default:
            return false; // not a valid mapping
        }

        // if the property is a bypass property, then link the resultant property to the original one
        if (propIsBypass) {
          if (origPropIsBypass) {
            // then this bypass overrides the existing one
            prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
          } else {
            // then link the orig prop to the new bypass
            prop.bypassed = origProp;
          }

          style[prop.name] = prop; // and set
        } else {
          // prop is not bypass
          if (origPropIsBypass) {
            // then keep the orig prop (since it's a bypass) and link to the new prop
            origProp.bypassed = prop;
          } else {
            // then just replace the old prop with the new one
            style[prop.name] = prop;
          }
        }

        checkZOrder();

        return true;
      };

      styfn.cleanElements = function (eles, keepBypasses) {
        var self = this;
        var props = self.properties;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (!keepBypasses) {
            ele._private.style = {};
          } else {
            var style = ele._private.style;

            for (var j = 0; j < props.length; j++) {
              var prop = props[j];
              var eleProp = style[prop.name];

              if (eleProp) {
                if (eleProp.bypass) {
                  eleProp.bypassed = null;
                } else {
                  style[prop.name] = null;
                }
              }
            }
          }
        }
      };

      // updates the visual style for all elements (useful for manual style modification after init)
      styfn.update = function () {
        var cy = this._private.cy;
        var eles = cy.mutableElements();

        eles.updateStyle();
      };

      // just update the functional properties (i.e. mappings) in the elements'
      // styles (less expensive than recalculation)
      styfn.updateMappers = function (eles) {
        var self = this;
        var cy = this._private.cy;
        var updatedEles = cy.collection();

        for (var i = 0; i < eles.length; i++) {
          // for each ele
          var ele = eles[i];
          var style = ele._private.style;
          var updatedEle = false;

          for (var j = 0; j < self.properties.length; j++) {
            // for each prop
            var prop = self.properties[j];
            var propInStyle = style[prop.name];

            if (propInStyle && propInStyle.mapping) {
              var mapping = propInStyle.mapping;

              this.applyParsedProperty(ele, mapping); // reapply the mapping property

              updatedEle = true;
            }
          }

          if (updatedEle) {
            this.updateStyleHints(ele);

            updatedEles.merge(ele);
          }
        }

        return updatedEles;
      };

      // diffProps : { name => { prev, next } }
      styfn.updateTransitions = function (ele, diffProps, isBypass) {
        var self = this;
        var _p = ele._private;
        var props = ele.pstyle('transition-property').value;
        var duration = ele.pstyle('transition-duration').pfValue;
        var delay = ele.pstyle('transition-delay').pfValue;

        if (props.length > 0 && duration > 0) {

          var style = {};

          // build up the style to animate towards
          var anyPrev = false;
          for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            var styProp = ele.pstyle(prop);
            var diffProp = diffProps[prop];

            if (!diffProp) {
              continue;
            }

            var prevProp = diffProp.prev;
            var fromProp = prevProp;
            var toProp = diffProp.next != null ? diffProp.next : styProp;
            var diff = false;
            var initVal = void 0;
            var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

            if (!fromProp) {
              continue;
            }

            // consider px values
            if (is.number(fromProp.pfValue) && is.number(toProp.pfValue)) {
              diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
              initVal = fromProp.pfValue + initDt * diff;

              // consider numerical values
            } else if (is.number(fromProp.value) && is.number(toProp.value)) {
              diff = toProp.value - fromProp.value; // nonzero is truthy
              initVal = fromProp.value + initDt * diff;

              // consider colour values
            } else if (is.array(fromProp.value) && is.array(toProp.value)) {
              diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];

              initVal = fromProp.strValue;
            }

            // the previous value is good for an animation only if it's different
            if (diff) {
              style[prop] = toProp.strValue; // to val
              this.applyBypass(ele, prop, initVal); // from val
              anyPrev = true;
            }
          } // end if props allow ani

          // can't transition if there's nothing previous to transition from
          if (!anyPrev) {
            return;
          }

          _p.transitioning = true;

          new Promise(function (resolve) {
            if (delay > 0) {
              ele.delayAnimation(delay).play().promise().then(resolve);
            } else {
              resolve();
            }
          }).then(function () {
            return ele.animation({
              style: style,
              duration: duration,
              easing: ele.pstyle('transition-timing-function').value,
              queue: false
            }).play().promise();
          }).then(function () {
            // if( !isBypass ){
            self.removeBypasses(ele, props);
            ele.emitAndNotify('style');
            // }

            _p.transitioning = false;
          });
        } else if (_p.transitioning) {
          this.removeBypasses(ele, props);
          ele.emitAndNotify('style');

          _p.transitioning = false;
        }
      };

      styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
        var prop = this.properties[name];

        if (prop.triggersZOrder != null && (fromValue == null || prop.triggersZOrder(fromValue, toValue))) {
          this._private.cy.notify({
            type: 'zorder',
            eles: ele
          });
        }
      };

      module.exports = styfn;

      /***/
    },
    /* 87 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var styfn = {};

      // bypasses are applied to an existing style on an element, and just tacked on temporarily
      // returns true iff application was successful for at least 1 specified property
      styfn.applyBypass = function (eles, name, value, updateTransitions) {
        var self = this;
        var props = [];
        var isBypass = true;

        // put all the properties (can specify one or many) in an array after parsing them
        if (name === '*' || name === '**') {
          // apply to all property names

          if (value !== undefined) {
            for (var i = 0; i < self.properties.length; i++) {
              var prop = self.properties[i];
              var _name = prop.name;

              var parsedProp = this.parse(_name, value, true);

              if (parsedProp) {
                props.push(parsedProp);
              }
            }
          }
        } else if (is.string(name)) {
          // then parse the single property
          var _parsedProp = this.parse(name, value, true);

          if (_parsedProp) {
            props.push(_parsedProp);
          }
        } else if (is.plainObject(name)) {
          // then parse each property
          var specifiedProps = name;
          updateTransitions = value;

          var names = Object.keys(specifiedProps);

          for (var _i = 0; _i < names.length; _i++) {
            var _name2 = names[_i];
            var _prop = self.properties[_name2];
            var _value = specifiedProps[_name2];

            if (_value === undefined) {
              // try camel case name too
              _value = specifiedProps[util.dash2camel(_name2)];
            }

            if (_value !== undefined) {
              var _parsedProp2 = this.parse(_name2, _value, true);

              if (_parsedProp2) {
                props.push(_parsedProp2);
              }
            }
          }
        } else {
          // can't do anything without well defined properties
          return false;
        }

        // we've failed if there are no valid properties
        if (props.length === 0) {
          return false;
        }

        // now, apply the bypass properties on the elements
        var ret = false; // return true if at least one succesful bypass applied
        for (var _i2 = 0; _i2 < eles.length; _i2++) {
          // for each ele
          var ele = eles[_i2];
          var diffProps = {};
          var diffProp = void 0;

          for (var j = 0; j < props.length; j++) {
            // for each prop
            var _prop2 = props[j];

            if (updateTransitions) {
              var prevProp = ele.pstyle(_prop2.name);
              diffProp = diffProps[_prop2.name] = { prev: prevProp };
            }

            ret = this.applyParsedProperty(ele, _prop2) || ret;

            if (updateTransitions) {
              diffProp.next = ele.pstyle(_prop2.name);
            }
          } // for props

          if (ret) {
            this.updateStyleHints(ele);
          }

          if (updateTransitions) {
            this.updateTransitions(ele, diffProps, isBypass);
          }
        } // for eles

        return ret;
      };

      // only useful in specific cases like animation
      styfn.overrideBypass = function (eles, name, value) {
        name = util.camel2dash(name);

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var prop = ele._private.style[name];
          var type = this.properties[name].type;
          var isColor = type.color;
          var isMulti = type.mutiple;

          if (!prop || !prop.bypass) {
            // need a bypass if one doesn't exist
            this.applyBypass(ele, name, value);
            continue;
          }

          var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

          prop.value = value;

          if (prop.pfValue != null) {
            prop.pfValue = value;
          }

          if (isColor) {
            prop.strValue = 'rgb(' + value.join(',') + ')';
          } else if (isMulti) {
            prop.strValue = value.join(' ');
          } else {
            prop.strValue = '' + value;
          }

          this.checkZOrderTrigger(ele, name, oldValue, value);
        }
      };

      styfn.removeAllBypasses = function (eles, updateTransitions) {
        return this.removeBypasses(eles, this.propertyNames, updateTransitions);
      };

      styfn.removeBypasses = function (eles, props, updateTransitions) {
        var isBypass = true;

        for (var j = 0; j < eles.length; j++) {
          var ele = eles[j];
          var diffProps = {};

          for (var i = 0; i < props.length; i++) {
            var name = props[i];
            var prop = this.properties[name];
            var prevProp = ele.pstyle(prop.name);

            if (!prevProp || !prevProp.bypass) {
              // if a bypass doesn't exist for the prop, nothing needs to be removed
              continue;
            }

            var value = ''; // empty => remove bypass
            var parsedProp = this.parse(name, value, true);
            var diffProp = diffProps[prop.name] = { prev: prevProp };

            this.applyParsedProperty(ele, parsedProp);

            diffProp.next = ele.pstyle(prop.name);
          } // for props

          this.updateStyleHints(ele);

          if (updateTransitions) {
            this.updateTransitions(ele, diffProps, isBypass);
          }
        } // for eles
      };

      module.exports = styfn;

      /***/
    },
    /* 88 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);

      var styfn = {};

      // gets what an em size corresponds to in pixels relative to a dom element
      styfn.getEmSizeInPixels = function () {
        var px = this.containerCss('font-size');

        if (px != null) {
          return parseFloat(px);
        } else {
          return 1; // for headless
        }
      };

      // gets css property from the core container
      styfn.containerCss = function (propName) {
        var cy = this._private.cy;
        var domElement = cy.container();

        if (window && domElement && window.getComputedStyle) {
          return window.getComputedStyle(domElement).getPropertyValue(propName);
        }
      };

      module.exports = styfn;

      /***/
    },
    /* 89 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var styfn = {};

      // gets the rendered style for an element
      styfn.getRenderedStyle = function (ele, prop) {
        if (prop) {
          return this.getStylePropertyValue(ele, prop, true);
        } else {
          return this.getRawStyle(ele, true);
        }
      };

      // gets the raw style for an element
      styfn.getRawStyle = function (ele, isRenderedVal) {
        var self = this;

        ele = ele[0]; // insure it's an element

        if (ele) {
          var rstyle = {};

          for (var i = 0; i < self.properties.length; i++) {
            var prop = self.properties[i];
            var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

            if (val != null) {
              rstyle[prop.name] = val;
              rstyle[util.dash2camel(prop.name)] = val;
            }
          }

          return rstyle;
        }
      };

      styfn.getIndexedStyle = function (ele, property, subproperty, index) {
        var pstyle = ele.pstyle(property)[subproperty][index];
        return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
      };

      styfn.getStylePropertyValue = function (ele, propName, isRenderedVal) {
        var self = this;

        ele = ele[0]; // insure it's an element

        if (ele) {
          var prop = self.properties[propName];

          if (prop.alias) {
            prop = prop.pointsTo;
          }

          var type = prop.type;
          var styleProp = ele.pstyle(prop.name);
          var zoom = ele.cy().zoom();

          if (styleProp) {
            var units = styleProp.units ? type.implicitUnits || 'px' : null;
            var val = units ? [].concat(styleProp.pfValue).map(function (pfValue) {
              return pfValue * (isRenderedVal ? zoom : 1) + units;
            }).join(' ') : styleProp.strValue;

            return val;
          }
        }
      };

      styfn.getAnimationStartStyle = function (ele, aniProps) {
        var rstyle = {};

        for (var i = 0; i < aniProps.length; i++) {
          var aniProp = aniProps[i];
          var name = aniProp.name;

          var styleProp = ele.pstyle(name);

          if (styleProp !== undefined) {
            // then make a prop of it
            if (is.plainObject(styleProp)) {
              styleProp = this.parse(name, styleProp.strValue);
            } else {
              styleProp = this.parse(name, styleProp);
            }
          }

          if (styleProp) {
            rstyle[name] = styleProp;
          }
        }

        return rstyle;
      };

      styfn.getPropsList = function (propsObj) {
        var self = this;
        var rstyle = [];
        var style = propsObj;
        var props = self.properties;

        if (style) {
          var names = Object.keys(style);

          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            var val = style[name];
            var prop = props[name] || props[util.camel2dash(name)];
            var styleProp = this.parse(prop.name, val);

            if (styleProp) {
              rstyle.push(styleProp);
            }
          }
        }

        return rstyle;
      };

      module.exports = styfn;

      /***/
    },
    /* 90 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var styfn = {};

      styfn.appendFromJson = function (json) {
        var style = this;

        for (var i = 0; i < json.length; i++) {
          var context = json[i];
          var selector = context.selector;
          var props = context.style || context.css;
          var names = Object.keys(props);

          style.selector(selector); // apply selector

          for (var j = 0; j < names.length; j++) {
            var name = names[j];
            var value = props[name];

            style.css(name, value); // apply property
          }
        }

        return style;
      };

      // accessible cy.style() function
      styfn.fromJson = function (json) {
        var style = this;

        style.resetToDefault();
        style.appendFromJson(json);

        return style;
      };

      // get json from cy.style() api
      styfn.json = function () {
        var json = [];

        for (var i = this.defaultLength; i < this.length; i++) {
          var cxt = this[i];
          var selector = cxt.selector;
          var props = cxt.properties;
          var css = {};

          for (var j = 0; j < props.length; j++) {
            var prop = props[j];
            css[prop.name] = prop.strValue;
          }

          json.push({
            selector: !selector ? 'core' : selector.toString(),
            style: css
          });
        }

        return json;
      };

      module.exports = styfn;

      /***/
    },
    /* 91 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var styfn = {};

      styfn.appendFromString = function (string) {
        var self = this;
        var style = this;
        var remaining = '' + string;
        var selAndBlockStr = void 0;
        var blockRem = void 0;
        var propAndValStr = void 0;

        // remove comments from the style string
        remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

        function removeSelAndBlockFromRemaining() {
          // remove the parsed selector and block from the remaining text to parse
          if (remaining.length > selAndBlockStr.length) {
            remaining = remaining.substr(selAndBlockStr.length);
          } else {
            remaining = '';
          }
        }

        function removePropAndValFromRem() {
          // remove the parsed property and value from the remaining block text to parse
          if (blockRem.length > propAndValStr.length) {
            blockRem = blockRem.substr(propAndValStr.length);
          } else {
            blockRem = '';
          }
        }

        while (true) {
          var nothingLeftToParse = remaining.match(/^\s*$/);
          if (nothingLeftToParse) {
            break;
          }

          var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

          if (!selAndBlock) {
            util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
            break;
          }

          selAndBlockStr = selAndBlock[0];

          // parse the selector
          var selectorStr = selAndBlock[1];
          if (selectorStr !== 'core') {
            var selector = new Selector(selectorStr);
            if (selector._private.invalid) {
              util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

              // skip this selector and block
              removeSelAndBlockFromRemaining();
              continue;
            }
          }

          // parse the block of properties and values
          var blockStr = selAndBlock[2];
          var invalidBlock = false;
          blockRem = blockStr;
          var props = [];

          while (true) {
            var _nothingLeftToParse = blockRem.match(/^\s*$/);
            if (_nothingLeftToParse) {
              break;
            }

            var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

            if (!propAndVal) {
              util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
              invalidBlock = true;
              break;
            }

            propAndValStr = propAndVal[0];
            var propStr = propAndVal[1];
            var valStr = propAndVal[2];

            var prop = self.properties[propStr];
            if (!prop) {
              util.error('Skipping property: Invalid property name in: ' + propAndValStr);

              // skip this property in the block
              removePropAndValFromRem();
              continue;
            }

            var parsedProp = style.parse(propStr, valStr);

            if (!parsedProp) {
              util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

              // skip this property in the block
              removePropAndValFromRem();
              continue;
            }

            props.push({
              name: propStr,
              val: valStr
            });
            removePropAndValFromRem();
          }

          if (invalidBlock) {
            removeSelAndBlockFromRemaining();
            break;
          }

          // put the parsed block in the style
          style.selector(selectorStr);
          for (var i = 0; i < props.length; i++) {
            var _prop = props[i];
            style.css(_prop.name, _prop.val);
          }

          removeSelAndBlockFromRemaining();
        }

        return style;
      };

      styfn.fromString = function (string) {
        var style = this;

        style.resetToDefault();
        style.appendFromString(string);

        return style;
      };

      module.exports = styfn;

      /***/
    },
    /* 92 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var styfn = {};

      (function () {
        var number = util.regex.number;
        var rgba = util.regex.rgbaNoBackRefs;
        var hsla = util.regex.hslaNoBackRefs;
        var hex3 = util.regex.hex3;
        var hex6 = util.regex.hex6;
        var data = function data(prefix) {
          return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
        };
        var mapData = function mapData(prefix) {
          var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
          return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
        };
        var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$'];

        // each visual style property has a type and needs to be validated according to it
        styfn.types = {
          time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
          percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
          zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
          zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },
          nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
          nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
          position: { enums: ['parent', 'origin'] },
          nodeSize: { number: true, min: 0, enums: ['label'] },
          number: { number: true, unitless: true },
          numbers: { number: true, unitless: true, multiple: true },
          positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
          size: { number: true, min: 0 },
          bidirectionalSize: { number: true }, // allows negative
          bidirectionalSizes: { number: true, multiple: true }, // allows negative
          sizeMaybePercent: { number: true, min: 0, allowPercent: true },
          paddingRelativeTo: { enums: ['width', 'height', 'average', 'min', 'max'] },
          bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'], multiple: true },
          bgPos: { number: true, allowPercent: true, multiple: true },
          bgRelativeTo: { enums: ['inner', 'include-padding'], multiple: true },
          bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'], multiple: true },
          bgFit: { enums: ['none', 'contain', 'cover'], multiple: true },
          bgCrossOrigin: { enums: ['anonymous', 'use-credentials'], multiple: true },
          bgClip: { enums: ['none', 'node'] },
          color: { color: true },
          bool: { enums: ['yes', 'no'] },
          lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
          borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
          curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
          fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
          fontletiant: { enums: ['small-caps', 'normal'] },
          fontStyle: { enums: ['italic', 'normal', 'oblique'] },
          fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
          textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
          textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
          textWrap: { enums: ['none', 'wrap', 'ellipsis'] },
          textBackgroundShape: { enums: ['rectangle', 'roundrectangle'] },
          nodeShape: { enums: ['rectangle', 'roundrectangle', 'cutrectangle', 'bottomroundrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'concavehexagon', 'heptagon', 'octagon', 'tag', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
          compoundIncludeLabels: { enums: ['include', 'exclude'] },
          arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
          arrowFill: { enums: ['filled', 'hollow'] },
          display: { enums: ['element', 'none'] },
          visibility: { enums: ['hidden', 'visible'] },
          zCompoundDepth: { enums: ['bottom', 'orphan', 'auto', 'top'] },
          zIndexCompare: { enums: ['auto', 'manual'] },
          valign: { enums: ['top', 'center', 'bottom'] },
          halign: { enums: ['left', 'center', 'right'] },
          text: { string: true },
          data: { mapping: true, regex: data('data') },
          layoutData: { mapping: true, regex: data('layoutData') },
          scratch: { mapping: true, regex: data('scratch') },
          mapData: { mapping: true, regex: mapData('mapData') },
          mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
          mapScratch: { mapping: true, regex: mapData('mapScratch') },
          fn: { mapping: true, fn: true },
          url: { regexes: urlRegexes, singleRegexMatchValue: true },
          urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },
          propList: { propList: true },
          angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
          textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: ['none', 'autorotate'] },
          polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
          edgeDistances: { enums: ['intersection', 'node-position'] },
          edgeEndpoint: {
            number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
            enums: ['inside-to-node', 'outside-to-node', 'outside-to-line'], singleEnum: true,
            validate: function validate(valArr, unitsArr) {
              switch (valArr.length) {
                case 2:
                  // can be % or px only
                  return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
                case 1:
                  // can be enum, deg, or rad only
                  return is.string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
                default:
                  return false;
              }
            }
          },
          easing: {
            regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
            enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
          }
        };

        var zOrderDiff = {
          zeroNonZero: function zeroNonZero(val1, val2) {
            if (val1 === 0 && val2 !== 0) {
              return true;
            } else if (val1 !== 0 && val2 === 0) {
              return true;
            } else {
              return false;
            }
          },
          anyDiff: function anyDiff(val1, val2) {
            return val1 !== val2;
          }
        };

        var zd = zOrderDiff;

        // define visual style properties
        var t = styfn.types;
        var props = styfn.properties = [
        // main label
        { name: 'label', type: t.text }, { name: 'text-rotation', type: t.textRotation }, { name: 'text-margin-x', type: t.bidirectionalSize }, { name: 'text-margin-y', type: t.bidirectionalSize },

        // source label
        { name: 'source-label', type: t.text }, { name: 'source-text-rotation', type: t.textRotation }, { name: 'source-text-margin-x', type: t.bidirectionalSize }, { name: 'source-text-margin-y', type: t.bidirectionalSize }, { name: 'source-text-offset', type: t.size },

        // target label
        { name: 'target-label', type: t.text }, { name: 'target-text-rotation', type: t.textRotation }, { name: 'target-text-margin-x', type: t.bidirectionalSize }, { name: 'target-text-margin-y', type: t.bidirectionalSize }, { name: 'target-text-offset', type: t.size },

        // common label style
        { name: 'text-valign', type: t.valign }, { name: 'text-halign', type: t.halign }, { name: 'color', type: t.color }, { name: 'text-outline-color', type: t.color }, { name: 'text-outline-width', type: t.size }, { name: 'text-outline-opacity', type: t.zeroOneNumber }, { name: 'text-opacity', type: t.zeroOneNumber }, { name: 'text-background-color', type: t.color }, { name: 'text-background-opacity', type: t.zeroOneNumber }, { name: 'text-background-padding', type: t.size }, { name: 'text-border-opacity', type: t.zeroOneNumber }, { name: 'text-border-color', type: t.color }, { name: 'text-border-width', type: t.size }, { name: 'text-border-style', type: t.borderStyle }, { name: 'text-background-shape', type: t.textBackgroundShape },
        // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
        { name: 'text-transform', type: t.textTransform }, { name: 'text-wrap', type: t.textWrap }, { name: 'text-max-width', type: t.size }, { name: 'text-events', type: t.bool }, { name: 'font-family', type: t.fontFamily }, { name: 'font-style', type: t.fontStyle },
        // { name: 'font-letiant', type: t.fontletiant }, // not useful
        { name: 'font-weight', type: t.fontWeight }, { name: 'font-size', type: t.size }, { name: 'min-zoomed-font-size', type: t.size },

        // behaviour
        { name: 'events', type: t.bool },

        // visibility
        { name: 'display', type: t.display, triggersZOrder: zd.anyDiff }, { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff }, { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero }, { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff }, { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff }, { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

        // overlays
        { name: 'overlay-padding', type: t.size }, { name: 'overlay-color', type: t.color }, { name: 'overlay-opacity', type: t.zeroOneNumber },

        // transition anis
        { name: 'transition-property', type: t.propList }, { name: 'transition-duration', type: t.time }, { name: 'transition-delay', type: t.time }, { name: 'transition-timing-function', type: t.easing },

        // node body
        { name: 'height', type: t.nodeSize }, { name: 'width', type: t.nodeSize }, { name: 'shape', type: t.nodeShape }, { name: 'shape-polygon-points', type: t.polygonPointList }, { name: 'background-color', type: t.color }, { name: 'background-opacity', type: t.zeroOneNumber }, { name: 'background-blacken', type: t.nOneOneNumber }, { name: 'padding', type: t.sizeMaybePercent }, { name: 'padding-relative-to', type: t.paddingRelativeTo },

        // node border
        { name: 'border-color', type: t.color }, { name: 'border-opacity', type: t.zeroOneNumber }, { name: 'border-width', type: t.size }, { name: 'border-style', type: t.borderStyle },

        // node background images
        { name: 'background-image', type: t.urls }, { name: 'background-image-crossorigin', type: t.bgCrossOrigin }, { name: 'background-image-opacity', type: t.zeroOneNumbers }, { name: 'background-position-x', type: t.bgPos }, { name: 'background-position-y', type: t.bgPos }, { name: 'background-width-relative-to', type: t.bgRelativeTo }, { name: 'background-height-relative-to', type: t.bgRelativeTo }, { name: 'background-repeat', type: t.bgRepeat }, { name: 'background-fit', type: t.bgFit }, { name: 'background-clip', type: t.bgClip }, { name: 'background-width', type: t.bgWH }, { name: 'background-height', type: t.bgWH },

        // compound props
        { name: 'position', type: t.position }, { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels }, { name: 'min-width', type: t.size }, { name: 'min-width-bias-left', type: t.sizeMaybePercent }, { name: 'min-width-bias-right', type: t.sizeMaybePercent }, { name: 'min-height', type: t.size }, { name: 'min-height-bias-top', type: t.sizeMaybePercent }, { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

        // edge line
        { name: 'line-style', type: t.lineStyle }, { name: 'line-color', type: t.color }, { name: 'curve-style', type: t.curveStyle }, { name: 'haystack-radius', type: t.zeroOneNumber }, { name: 'source-endpoint', type: t.edgeEndpoint }, { name: 'target-endpoint', type: t.edgeEndpoint }, { name: 'control-point-step-size', type: t.size }, { name: 'control-point-distances', type: t.bidirectionalSizes }, { name: 'control-point-weights', type: t.numbers }, { name: 'segment-distances', type: t.bidirectionalSizes }, { name: 'segment-weights', type: t.numbers }, { name: 'edge-distances', type: t.edgeDistances }, { name: 'arrow-scale', type: t.positiveNumber }, { name: 'loop-direction', type: t.angle }, { name: 'loop-sweep', type: t.angle }, { name: 'source-distance-from-node', type: t.size }, { name: 'target-distance-from-node', type: t.size },

        // ghost properties
        { name: 'ghost', type: t.bool }, { name: 'ghost-offset-x', type: t.bidirectionalSize }, { name: 'ghost-offset-y', type: t.bidirectionalSize }, { name: 'ghost-opacity', type: t.zeroOneNumber },

        // these are just for the core
        { name: 'selection-box-color', type: t.color }, { name: 'selection-box-opacity', type: t.zeroOneNumber }, { name: 'selection-box-border-color', type: t.color }, { name: 'selection-box-border-width', type: t.size }, { name: 'active-bg-color', type: t.color }, { name: 'active-bg-opacity', type: t.zeroOneNumber }, { name: 'active-bg-size', type: t.size }, { name: 'outside-texture-bg-color', type: t.color }, { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }];

        // define aliases
        var aliases = styfn.aliases = [{ name: 'content', pointsTo: 'label' }, { name: 'control-point-distance', pointsTo: 'control-point-distances' }, { name: 'control-point-weight', pointsTo: 'control-point-weights' }, { name: 'edge-text-rotation', pointsTo: 'text-rotation' }, { name: 'padding-left', pointsTo: 'padding' }, { name: 'padding-right', pointsTo: 'padding' }, { name: 'padding-top', pointsTo: 'padding' }, { name: 'padding-bottom', pointsTo: 'padding' }];

        // pie backgrounds for nodes
        styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
        props.push({ name: 'pie-size', type: t.sizeMaybePercent });
        for (var i = 1; i <= styfn.pieBackgroundN; i++) {
          props.push({ name: 'pie-' + i + '-background-color', type: t.color });
          props.push({ name: 'pie-' + i + '-background-size', type: t.percent });
          props.push({ name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber });
        }

        // edge arrows
        var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
        [{ name: 'arrow-shape', type: t.arrowShape }, { name: 'arrow-color', type: t.color }, { name: 'arrow-fill', type: t.arrowFill }].forEach(function (prop) {
          arrowPrefixes.forEach(function (prefix) {
            var name = prefix + '-' + prop.name;
            var type = prop.type;

            props.push({ name: name, type: type });
          });
        }, {});

        // list of property names
        styfn.propertyNames = props.map(function (p) {
          return p.name;
        });

        // allow access of properties by name ( e.g. style.properties.height )
        for (var _i = 0; _i < props.length; _i++) {
          var prop = props[_i];

          props[prop.name] = prop; // allow lookup by name
        }

        // map aliases
        for (var _i2 = 0; _i2 < aliases.length; _i2++) {
          var alias = aliases[_i2];
          var pointsToProp = props[alias.pointsTo];
          var aliasProp = {
            name: alias.name,
            alias: true,
            pointsTo: pointsToProp
          };

          // add alias prop for parsing
          props.push(aliasProp);

          props[alias.name] = aliasProp; // allow lookup by name
        }
      })();

      styfn.getDefaultProperty = function (name) {
        return this.getDefaultProperties()[name];
      };

      styfn.getDefaultProperties = util.memoize(function () {
        var rawProps = util.extend({
          // common node/edge props
          'events': 'yes',
          'text-events': 'no',
          'text-valign': 'top',
          'text-halign': 'center',
          'color': '#000',
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': 'none',
          'text-wrap': 'none',
          'text-max-width': 9999,
          'text-background-color': '#000',
          'text-background-opacity': 0,
          'text-background-shape': 'rectangle',
          'text-background-padding': 0,
          'text-border-opacity': 0,
          'text-border-width': 0,
          'text-border-style': 'solid',
          'text-border-color': '#000',
          'font-family': 'Helvetica Neue, Helvetica, sans-serif',
          'font-style': 'normal',
          // 'font-letiant': fontletiant,
          'font-weight': 'normal',
          'font-size': 16,
          'min-zoomed-font-size': 0,
          'text-rotation': 'none',
          'source-text-rotation': 'none',
          'target-text-rotation': 'none',
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-compound-depth': 'auto',
          'z-index-compare': 'auto',
          'z-index': 0,
          'label': '',
          'text-margin-x': 0,
          'text-margin-y': 0,
          'source-label': '',
          'source-text-offset': 0,
          'source-text-margin-x': 0,
          'source-text-margin-y': 0,
          'target-label': '',
          'target-text-offset': 0,
          'target-text-margin-x': 0,
          'target-text-margin-y': 0,
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,
          'transition-timing-function': 'linear',

          // node props
          'background-blacken': 0,
          'background-color': '#999',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-crossorigin': 'anonymous',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-width-relative-to': 'include-padding',
          'background-height-relative-to': 'include-padding',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'background-width': 'auto',
          'background-height': 'auto',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',
          'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

          // ghost props
          'ghost': 'no',
          'ghost-offset-y': 0,
          'ghost-offset-x': 0,
          'ghost-opacity': 0,

          // compound props
          'padding': 0,
          'padding-relative-to': 'width',
          'position': 'origin',
          'compound-sizing-wrt-labels': 'include',
          'min-width': 0,
          'min-width-bias-left': 0,
          'min-width-bias-right': 0,
          'min-height': 0,
          'min-height-bias-top': 0,
          'min-height-bias-bottom': 0
        }, {
          // node pie bg
          'pie-size': '100%'
        }, [{ name: 'pie-{{i}}-background-color', value: 'black' }, { name: 'pie-{{i}}-background-size', value: '0%' }, { name: 'pie-{{i}}-background-opacity', value: 1 }].reduce(function (css, prop) {
          for (var i = 1; i <= styfn.pieBackgroundN; i++) {
            var name = prop.name.replace('{{i}}', i);
            var val = prop.value;

            css[name] = val;
          }

          return css;
        }, {}), {
          // edge props
          'line-style': 'solid',
          'line-color': '#999',
          'control-point-step-size': 40,
          'control-point-weights': 0.5,
          'segment-weights': 0.5,
          'segment-distances': 20,
          'edge-distances': 'intersection',
          'curve-style': 'bezier',
          'haystack-radius': 0,
          'arrow-scale': 1,
          'loop-direction': '-45deg',
          'loop-sweep': '-90deg',
          'source-distance-from-node': 0,
          'target-distance-from-node': 0,
          'source-endpoint': 'outside-to-node',
          'target-endpoint': 'outside-to-node'
        }, [{ name: 'arrow-shape', value: 'none' }, { name: 'arrow-color', value: '#999' }, { name: 'arrow-fill', value: 'filled' }].reduce(function (css, prop) {
          styfn.arrowPrefixes.forEach(function (prefix) {
            var name = prefix + '-' + prop.name;
            var val = prop.value;

            css[name] = val;
          });

          return css;
        }, {}));

        var parsedProps = {};

        for (var i = 0; i < this.properties.length; i++) {
          var prop = this.properties[i];

          if (prop.pointsTo) {
            continue;
          }

          var name = prop.name;
          var val = rawProps[name];
          var parsedProp = this.parse(name, val);

          parsedProps[name] = parsedProp;
        }

        return parsedProps;
      });

      styfn.addDefaultStylesheet = function () {
        this.selector('$node > node') // compound (parent) node properties
        .css({
          'shape': 'rectangle',
          'padding': 10,
          'background-color': '#eee',
          'border-color': '#ccc',
          'border-width': 1
        }).selector('edge') // just edge properties
        .css({
          'width': 3,
          'curve-style': 'haystack'
        }).selector(':parent <-> node').css({
          'curve-style': 'bezier',
          'source-endpoint': 'outside-to-line',
          'target-endpoint': 'outside-to-line'
        }).selector(':selected').css({
          'background-color': '#0169D9',
          'line-color': '#0169D9',
          'source-arrow-color': '#0169D9',
          'target-arrow-color': '#0169D9',
          'mid-source-arrow-color': '#0169D9',
          'mid-target-arrow-color': '#0169D9'
        }).selector('node:parent:selected').css({
          'background-color': '#CCE1F9',
          'border-color': '#aec8e5'
        }).selector(':active').css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        }).selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': 30,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        });

        this.defaultLength = this.length;
      };

      module.exports = styfn;

      /***/
    },
    /* 93 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var math = __webpack_require__(2);

      var styfn = {};

      // a caching layer for property parsing
      styfn.parse = function (name, value, propIsBypass, propIsFlat) {
        var self = this;

        // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
        if (is.fn(value)) {
          return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
        }

        var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
        var argHash = [name, value, propIsBypass, flatKey].join('$');
        var propCache = self.propCache = self.propCache || {};
        var ret = void 0;

        if (!(ret = propCache[argHash])) {
          ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
        }

        // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
        // - mappings can't be shared b/c mappings are per-element
        if (propIsBypass || propIsFlat === 'mapping') {
          // need a copy since props are mutated later in their lifecycles
          ret = util.copy(ret);

          if (ret) {
            ret.value = util.copy(ret.value); // because it could be an array, e.g. colour
          }
        }

        return ret;
      };

      styfn.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
        var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

        if (!prop && value != null) {
          util.error('The style property `%s: %s` is invalid', name, value);
        }

        return prop;
      };

      // parse a property; return null on invalid; return parsed property otherwise
      // fields :
      // - name : the name of the property
      // - value : the parsed, native-typed value of the property
      // - strValue : a string value that represents the property value in valid css
      // - bypass : true iff the property is a bypass property
      styfn.parseImpl = function (name, value, propIsBypass, propIsFlat) {
        var self = this;

        name = util.camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

        var property = self.properties[name];
        var passedValue = value;
        var types = self.types;

        if (!property) {
          return null;
        } // return null on property of unknown name
        if (value === undefined) {
          return null;
        } // can't assign undefined

        // the property may be an alias
        if (property.alias) {
          property = property.pointsTo;
          name = property.name;
        }

        var valueIsString = is.string(value);
        if (valueIsString) {
          // trim the value to make parsing easier
          value = value.trim();
        }

        var type = property.type;
        if (!type) {
          return null;
        } // no type, no luck

        // check if bypass is null or empty string (i.e. indication to delete bypass property)
        if (propIsBypass && (value === '' || value === null)) {
          return {
            name: name,
            value: value,
            bypass: true,
            deleteBypass: true
          };
        }

        // check if value is a function used as a mapper
        if (is.fn(value)) {
          return {
            name: name,
            value: value,
            strValue: 'fn',
            mapped: types.fn,
            bypass: propIsBypass
          };
        }

        // check if value is mapped
        var data = void 0,
            mapData = void 0;
        if (!valueIsString || propIsFlat) {
          // then don't bother to do the expensive regex checks

        } else if (data = new RegExp(types.data.regex).exec(value)) {
          if (propIsBypass) {
            return false;
          } // mappers not allowed in bypass

          var mapped = types.data;

          return {
            name: name,
            value: data,
            strValue: '' + value,
            mapped: mapped,
            field: data[1],
            bypass: propIsBypass
          };
        } else if (mapData = new RegExp(types.mapData.regex).exec(value)) {
          if (propIsBypass) {
            return false;
          } // mappers not allowed in bypass
          if (type.multiple) {
            return false;
          } // impossible to map to num

          var _mapped = types.mapData;

          // we can map only if the type is a colour or a number
          if (!(type.color || type.number)) {
            return false;
          }

          var valueMin = this.parse(name, mapData[4]); // parse to validate
          if (!valueMin || valueMin.mapped) {
            return false;
          } // can't be invalid or mapped

          var valueMax = this.parse(name, mapData[5]); // parse to validate
          if (!valueMax || valueMax.mapped) {
            return false;
          } // can't be invalid or mapped

          // check if valueMin and valueMax are the same
          if (valueMin.value === valueMax.value) {
            return false; // can't make much of a mapper without a range
          } else if (type.color) {
            var c1 = valueMin.value;
            var c2 = valueMax.value;

            var same = c1[0] === c2[0] // red
            && c1[1] === c2[1] // green
            && c1[2] === c2[2] // blue
            && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
            c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            );

            if (same) {
              return false;
            } // can't make a mapper without a range
          }

          return {
            name: name,
            value: mapData,
            strValue: '' + value,
            mapped: _mapped,
            field: mapData[1],
            fieldMin: parseFloat(mapData[2]), // min & max are numeric
            fieldMax: parseFloat(mapData[3]),
            valueMin: valueMin.value,
            valueMax: valueMax.value,
            bypass: propIsBypass
          };
        }

        if (type.multiple && propIsFlat !== 'multiple') {
          var vals = void 0;

          if (valueIsString) {
            vals = value.split(/\s+/);
          } else if (is.array(value)) {
            vals = value;
          } else {
            vals = [value];
          }

          if (type.evenMultiple && vals.length % 2 !== 0) {
            return null;
          }

          var valArr = [];
          var unitsArr = [];
          var pfValArr = [];
          var hasEnum = false;

          for (var i = 0; i < vals.length; i++) {
            var p = self.parse(name, vals[i], propIsBypass, 'multiple');

            hasEnum = hasEnum || is.string(p.value);

            valArr.push(p.value);
            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
            unitsArr.push(p.units);
          }

          if (type.validate && !type.validate(valArr, unitsArr)) {
            return null;
          }

          if (type.singleEnum && hasEnum) {
            if (valArr.length === 1 && is.string(valArr[0])) {
              return {
                name: name,
                value: valArr[0],
                strValue: valArr[0],
                bypass: propIsBypass
              };
            } else {
              return null;
            }
          }

          return {
            name: name,
            value: valArr,
            pfValue: pfValArr,
            strValue: valArr.map(function (val, i) {
              return val + (unitsArr[i] || '');
            }).join(' '),
            bypass: propIsBypass,
            units: unitsArr
          };
        }

        // several types also allow enums
        var checkEnums = function checkEnums() {
          for (var _i = 0; _i < type.enums.length; _i++) {
            var en = type.enums[_i];

            if (en === value) {
              return {
                name: name,
                value: value,
                strValue: '' + value,
                bypass: propIsBypass
              };
            }
          }

          return null;
        };

        // check the type and return the appropriate object
        if (type.number) {
          var units = void 0;
          var implicitUnits = 'px'; // not set => px

          if (type.units) {
            // use specified units if set
            units = type.units;
          }

          if (type.implicitUnits) {
            implicitUnits = type.implicitUnits;
          }

          if (!type.unitless) {
            if (valueIsString) {
              var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
              if (units) {
                unitsRegex = units;
              } // only allow explicit units if so set
              var match = value.match('^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$');

              if (match) {
                value = match[1];
                units = match[2] || implicitUnits;
              }
            } else if (!units || type.implicitUnits) {
              units = implicitUnits; // implicitly px if unspecified
            }
          }

          value = parseFloat(value);

          // if not a number and enums not allowed, then the value is invalid
          if (isNaN(value) && type.enums === undefined) {
            return null;
          }

          // check if this number type also accepts special keywords in place of numbers
          // (i.e. `left`, `auto`, etc)
          if (isNaN(value) && type.enums !== undefined) {
            value = passedValue;

            return checkEnums();
          }

          // check if value must be an integer
          if (type.integer && !is.integer(value)) {
            return null;
          }

          // check value is within range
          if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
            return null;
          }

          var ret = {
            name: name,
            value: value,
            strValue: '' + value + (units ? units : ''),
            units: units,
            bypass: propIsBypass
          };

          // normalise value in pixels
          if (type.unitless || units !== 'px' && units !== 'em') {
            ret.pfValue = value;
          } else {
            ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
          }

          // normalise value in ms
          if (units === 'ms' || units === 's') {
            ret.pfValue = units === 'ms' ? value : 1000 * value;
          }

          // normalise value in rad
          if (units === 'deg' || units === 'rad') {
            ret.pfValue = units === 'rad' ? value : math.deg2rad(value);
          }

          // normalize value in %
          if (units === '%') {
            ret.pfValue = value / 100;
          }

          return ret;
        } else if (type.propList) {

          var props = [];
          var propsStr = '' + value;

          if (propsStr === 'none') {
            // leave empty

          } else {
            // go over each prop

            var propsSplit = propsStr.split(',');
            for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
              var propName = propsSplit[_i2].trim();

              if (self.properties[propName]) {
                props.push(propName);
              }
            }

            if (props.length === 0) {
              return null;
            }
          }

          return {
            name: name,
            value: props,
            strValue: props.length === 0 ? 'none' : props.join(', '),
            bypass: propIsBypass
          };
        } else if (type.color) {
          var tuple = util.color2tuple(value);

          if (!tuple) {
            return null;
          }

          return {
            name: name,
            value: tuple,
            pfValue: tuple,
            strValue: '' + value,
            bypass: propIsBypass
          };
        } else if (type.regex || type.regexes) {

          // first check enums
          if (type.enums) {
            var enumProp = checkEnums();

            if (enumProp) {
              return enumProp;
            }
          }

          var regexes = type.regexes ? type.regexes : [type.regex];

          for (var _i3 = 0; _i3 < regexes.length; _i3++) {
            var regex = new RegExp(regexes[_i3]); // make a regex from the type string
            var m = regex.exec(value);

            if (m) {
              // regex matches
              return {
                name: name,
                value: type.singleRegexMatchValue ? m[1] : m,
                strValue: '' + value,
                bypass: propIsBypass
              };
            }
          }

          return null; // didn't match any
        } else if (type.string) {
          // just return
          return {
            name: name,
            value: '' + value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        } else if (type.enums) {
          // check enums last because it's a combo type in others
          return checkEnums();
        } else {
          return null; // not a type we can handle
        }
      };

      module.exports = styfn;

      /***/
    },
    /* 94 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var window = __webpack_require__(3);
      var math = __webpack_require__(2);

      var corefn = {

        autolock: function autolock(bool) {
          if (bool !== undefined) {
            this._private.autolock = bool ? true : false;
          } else {
            return this._private.autolock;
          }

          return this; // chaining
        },

        autoungrabify: function autoungrabify(bool) {
          if (bool !== undefined) {
            this._private.autoungrabify = bool ? true : false;
          } else {
            return this._private.autoungrabify;
          }

          return this; // chaining
        },

        autounselectify: function autounselectify(bool) {
          if (bool !== undefined) {
            this._private.autounselectify = bool ? true : false;
          } else {
            return this._private.autounselectify;
          }

          return this; // chaining
        },

        panningEnabled: function panningEnabled(bool) {
          if (bool !== undefined) {
            this._private.panningEnabled = bool ? true : false;
          } else {
            return this._private.panningEnabled;
          }

          return this; // chaining
        },

        userPanningEnabled: function userPanningEnabled(bool) {
          if (bool !== undefined) {
            this._private.userPanningEnabled = bool ? true : false;
          } else {
            return this._private.userPanningEnabled;
          }

          return this; // chaining
        },

        zoomingEnabled: function zoomingEnabled(bool) {
          if (bool !== undefined) {
            this._private.zoomingEnabled = bool ? true : false;
          } else {
            return this._private.zoomingEnabled;
          }

          return this; // chaining
        },

        userZoomingEnabled: function userZoomingEnabled(bool) {
          if (bool !== undefined) {
            this._private.userZoomingEnabled = bool ? true : false;
          } else {
            return this._private.userZoomingEnabled;
          }

          return this; // chaining
        },

        boxSelectionEnabled: function boxSelectionEnabled(bool) {
          if (bool !== undefined) {
            this._private.boxSelectionEnabled = bool ? true : false;
          } else {
            return this._private.boxSelectionEnabled;
          }

          return this; // chaining
        },

        pan: function pan() {
          var args = arguments;
          var pan = this._private.pan;
          var dim = void 0,
              val = void 0,
              dims = void 0,
              x = void 0,
              y = void 0;

          switch (args.length) {
            case 0:
              // .pan()
              return pan;

            case 1:

              if (is.string(args[0])) {
                // .pan('x')
                dim = args[0];
                return pan[dim];
              } else if (is.plainObject(args[0])) {
                // .pan({ x: 0, y: 100 })
                if (!this._private.panningEnabled) {
                  return this;
                }

                dims = args[0];
                x = dims.x;
                y = dims.y;

                if (is.number(x)) {
                  pan.x = x;
                }

                if (is.number(y)) {
                  pan.y = y;
                }

                this.emit('pan viewport');
              }
              break;

            case 2:
              // .pan('x', 100)
              if (!this._private.panningEnabled) {
                return this;
              }

              dim = args[0];
              val = args[1];

              if ((dim === 'x' || dim === 'y') && is.number(val)) {
                pan[dim] = val;
              }

              this.emit('pan viewport');
              break;

            default:
              break; // invalid
          }

          this.notify({ // notify the renderer that the viewport changed
            type: 'viewport'
          });

          return this; // chaining
        },

        panBy: function panBy(arg0, arg1) {
          var args = arguments;
          var pan = this._private.pan;
          var dim = void 0,
              val = void 0,
              dims = void 0,
              x = void 0,
              y = void 0;

          if (!this._private.panningEnabled) {
            return this;
          }

          switch (args.length) {
            case 1:

              if (is.plainObject(arg0)) {
                // .panBy({ x: 0, y: 100 })
                dims = args[0];
                x = dims.x;
                y = dims.y;

                if (is.number(x)) {
                  pan.x += x;
                }

                if (is.number(y)) {
                  pan.y += y;
                }

                this.emit('pan viewport');
              }
              break;

            case 2:
              // .panBy('x', 100)
              dim = arg0;
              val = arg1;

              if ((dim === 'x' || dim === 'y') && is.number(val)) {
                pan[dim] += val;
              }

              this.emit('pan viewport');
              break;

            default:
              break; // invalid
          }

          this.notify({ // notify the renderer that the viewport changed
            type: 'viewport'
          });

          return this; // chaining
        },

        fit: function fit(elements, padding) {
          var viewportState = this.getFitViewport(elements, padding);

          if (viewportState) {
            var _p = this._private;
            _p.zoom = viewportState.zoom;
            _p.pan = viewportState.pan;

            this.emit('pan zoom viewport');

            this.notify({ // notify the renderer that the viewport changed
              type: 'viewport'
            });
          }

          return this; // chaining
        },

        getFitViewport: function getFitViewport(elements, padding) {
          if (is.number(elements) && padding === undefined) {
            // elements is optional
            padding = elements;
            elements = undefined;
          }

          if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
            return;
          }

          var bb = void 0;

          if (is.string(elements)) {
            var sel = elements;
            elements = this.$(sel);
          } else if (is.boundingBox(elements)) {
            // assume bb
            var bbe = elements;
            bb = {
              x1: bbe.x1,
              y1: bbe.y1,
              x2: bbe.x2,
              y2: bbe.y2
            };

            bb.w = bb.x2 - bb.x1;
            bb.h = bb.y2 - bb.y1;
          } else if (!is.elementOrCollection(elements)) {
            elements = this.mutableElements();
          }

          if (is.elementOrCollection(elements) && elements.empty()) {
            return;
          } // can't fit to nothing

          bb = bb || elements.boundingBox();

          var w = this.width();
          var h = this.height();
          var zoom = void 0;
          padding = is.number(padding) ? padding : 0;

          if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);

            // crop zoom
            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

            var pan = { // now pan to middle
              x: (w - zoom * (bb.x1 + bb.x2)) / 2,
              y: (h - zoom * (bb.y1 + bb.y2)) / 2
            };

            return {
              zoom: zoom,
              pan: pan
            };
          }

          return;
        },

        minZoom: function minZoom(zoom) {
          if (zoom === undefined) {
            return this._private.minZoom;
          } else if (is.number(zoom)) {
            this._private.minZoom = zoom;
          }

          return this;
        },

        maxZoom: function maxZoom(zoom) {
          if (zoom === undefined) {
            return this._private.maxZoom;
          } else if (is.number(zoom)) {
            this._private.maxZoom = zoom;
          }

          return this;
        },

        getZoomedViewport: function getZoomedViewport(params) {
          var _p = this._private;
          var currentPan = _p.pan;
          var currentZoom = _p.zoom;
          var pos = void 0; // in rendered px
          var zoom = void 0;
          var bail = false;

          if (!_p.zoomingEnabled) {
            // zooming disabled
            bail = true;
          }

          if (is.number(params)) {
            // then set the zoom
            zoom = params;
          } else if (is.plainObject(params)) {
            // then zoom about a point
            zoom = params.level;

            if (params.position != null) {
              pos = math.modelToRenderedPosition(params.position, currentZoom, currentPan);
            } else if (params.renderedPosition != null) {
              pos = params.renderedPosition;
            }

            if (pos != null && !_p.panningEnabled) {
              // panning disabled
              bail = true;
            }
          }

          // crop zoom
          zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
          zoom = zoom < _p.minZoom ? _p.minZoom : zoom;

          // can't zoom with invalid params
          if (bail || !is.number(zoom) || zoom === currentZoom || pos != null && (!is.number(pos.x) || !is.number(pos.y))) {
            return null;
          }

          if (pos != null) {
            // set zoom about position
            var pan1 = currentPan;
            var zoom1 = currentZoom;
            var zoom2 = zoom;

            var pan2 = {
              x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
              y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
            };

            return {
              zoomed: true,
              panned: true,
              zoom: zoom2,
              pan: pan2
            };
          } else {
            // just set the zoom
            return {
              zoomed: true,
              panned: false,
              zoom: zoom,
              pan: currentPan
            };
          }
        },

        zoom: function zoom(params) {
          if (params === undefined) {
            // get
            return this._private.zoom;
          } else {
            // set
            var vp = this.getZoomedViewport(params);
            var _p = this._private;

            if (vp == null || !vp.zoomed) {
              return this;
            }

            _p.zoom = vp.zoom;

            if (vp.panned) {
              _p.pan.x = vp.pan.x;
              _p.pan.y = vp.pan.y;
            }

            this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');

            this.notify({ // notify the renderer that the viewport changed
              type: 'viewport'
            });

            return this; // chaining
          }
        },

        viewport: function viewport(opts) {
          var _p = this._private;
          var zoomDefd = true;
          var panDefd = true;
          var events = []; // to trigger
          var zoomFailed = false;
          var panFailed = false;

          if (!opts) {
            return this;
          }
          if (!is.number(opts.zoom)) {
            zoomDefd = false;
          }
          if (!is.plainObject(opts.pan)) {
            panDefd = false;
          }
          if (!zoomDefd && !panDefd) {
            return this;
          }

          if (zoomDefd) {
            var z = opts.zoom;

            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
              zoomFailed = true;
            } else {
              _p.zoom = z;

              events.push('zoom');
            }
          }

          if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
            var p = opts.pan;

            if (is.number(p.x)) {
              _p.pan.x = p.x;
              panFailed = false;
            }

            if (is.number(p.y)) {
              _p.pan.y = p.y;
              panFailed = false;
            }

            if (!panFailed) {
              events.push('pan');
            }
          }

          if (events.length > 0) {
            events.push('viewport');
            this.emit(events.join(' '));

            this.notify({
              type: 'viewport'
            });
          }

          return this; // chaining
        },

        center: function center(elements) {
          var pan = this.getCenterPan(elements);

          if (pan) {
            this._private.pan = pan;

            this.emit('pan viewport');

            this.notify({ // notify the renderer that the viewport changed
              type: 'viewport'
            });
          }

          return this; // chaining
        },

        getCenterPan: function getCenterPan(elements, zoom) {
          if (!this._private.panningEnabled) {
            return;
          }

          if (is.string(elements)) {
            var selector = elements;
            elements = this.mutableElements().filter(selector);
          } else if (!is.elementOrCollection(elements)) {
            elements = this.mutableElements();
          }

          if (elements.length === 0) {
            return;
          } // can't centre pan to nothing

          var bb = elements.boundingBox();
          var w = this.width();
          var h = this.height();
          zoom = zoom === undefined ? this._private.zoom : zoom;

          var pan = { // middle
            x: (w - zoom * (bb.x1 + bb.x2)) / 2,
            y: (h - zoom * (bb.y1 + bb.y2)) / 2
          };

          return pan;
        },

        reset: function reset() {
          if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
            return this;
          }

          this.viewport({
            pan: { x: 0, y: 0 },
            zoom: 1
          });

          return this; // chaining
        },

        invalidateSize: function invalidateSize() {
          this._private.sizeCache = null;
        },

        size: function size() {
          var _p = this._private;
          var container = _p.container;

          return _p.sizeCache = _p.sizeCache || (container ? function () {
            var style = window.getComputedStyle(container);
            var val = function val(name) {
              return parseFloat(style.getPropertyValue(name));
            };

            return {
              width: container.clientWidth - val('padding-left') - val('padding-right'),
              height: container.clientHeight - val('padding-top') - val('padding-bottom')
            };
          }() : { // fallback if no container (not 0 b/c can be used for dividing etc)
            width: 1,
            height: 1
          });
        },

        width: function width() {
          return this.size().width;
        },

        height: function height() {
          return this.size().height;
        },

        extent: function extent() {
          var pan = this._private.pan;
          var zoom = this._private.zoom;
          var rb = this.renderedExtent();

          var b = {
            x1: (rb.x1 - pan.x) / zoom,
            x2: (rb.x2 - pan.x) / zoom,
            y1: (rb.y1 - pan.y) / zoom,
            y2: (rb.y2 - pan.y) / zoom
          };

          b.w = b.x2 - b.x1;
          b.h = b.y2 - b.y1;

          return b;
        },

        renderedExtent: function renderedExtent() {
          var width = this.width();
          var height = this.height();

          return {
            x1: 0,
            y1: 0,
            x2: width,
            y2: height,
            w: width,
            h: height
          };
        }
      };

      // aliases
      corefn.centre = corefn.center;

      // backwards compatibility
      corefn.autolockNodes = corefn.autolock;
      corefn.autoungrabifyNodes = corefn.autoungrabify;

      module.exports = corefn;

      /***/
    },
    /* 95 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var define = __webpack_require__(4);
      var Collection = __webpack_require__(7);
      var Core = __webpack_require__(12);
      var incExts = __webpack_require__(96);
      var is = __webpack_require__(0);
      var Emitter = __webpack_require__(11);

      // registered extensions to cytoscape, indexed by name
      var extensions = {};

      // registered modules for extensions, indexed by name
      var modules = {};

      function setExtension(type, name, registrant) {

        var ext = registrant;

        var overrideErr = function overrideErr(field) {
          util.error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
        };

        if (type === 'core') {
          if (Core.prototype[name]) {
            return overrideErr(name);
          } else {
            Core.prototype[name] = registrant;
          }
        } else if (type === 'collection') {
          if (Collection.prototype[name]) {
            return overrideErr(name);
          } else {
            Collection.prototype[name] = registrant;
          }
        } else if (type === 'layout') {
          // fill in missing layout functions in the prototype

          var Layout = function Layout(options) {
            this.options = options;

            registrant.call(this, options);

            // make sure layout has _private for use w/ std apis like .on()
            if (!is.plainObject(this._private)) {
              this._private = {};
            }

            this._private.cy = options.cy;
            this._private.listeners = [];

            this.createEmitter();
          };

          var layoutProto = Layout.prototype = Object.create(registrant.prototype);

          var optLayoutFns = [];

          for (var i = 0; i < optLayoutFns.length; i++) {
            var fnName = optLayoutFns[i];

            layoutProto[fnName] = layoutProto[fnName] || function () {
              return this;
            };
          }

          // either .start() or .run() is defined, so autogen the other
          if (layoutProto.start && !layoutProto.run) {
            layoutProto.run = function () {
              this.start();return this;
            };
          } else if (!layoutProto.start && layoutProto.run) {
            layoutProto.start = function () {
              this.run();return this;
            };
          }

          var regStop = registrant.prototype.stop;
          layoutProto.stop = function () {
            var opts = this.options;

            if (opts && opts.animate) {
              var anis = this.animations;

              if (anis) {
                for (var _i = 0; _i < anis.length; _i++) {
                  anis[_i].stop();
                }
              }
            }

            if (regStop) {
              regStop.call(this);
            } else {
              this.emit('layoutstop');
            }

            return this;
          };

          if (!layoutProto.destroy) {
            layoutProto.destroy = function () {
              return this;
            };
          }

          layoutProto.cy = function () {
            return this._private.cy;
          };

          var getCy = function getCy(layout) {
            return layout._private.cy;
          };

          util.assign(layoutProto, {
            createEmitter: function createEmitter() {
              this._private.emitter = new Emitter({
                eventFields: function eventFields(layout) {
                  return {
                    layout: layout,
                    cy: getCy(layout),
                    target: layout
                  };
                },
                bubble: function bubble() {
                  return true;
                },
                parent: function parent(layout) {
                  return getCy(layout);
                },
                context: this
              });

              return this;
            },
            emitter: function emitter() {
              return this._private.emitter;
            },
            on: function on(evt, cb) {
              this.emitter().on(evt, cb);return this;
            },
            one: function one(evt, cb) {
              this.emitter().one(evt, cb);return this;
            },
            once: function once(evt, cb) {
              this.emitter().one(evt, cb);return this;
            },
            removeListener: function removeListener(evt, cb) {
              this.emitter().removeListener(evt, cb);return this;
            },
            emit: function emit(evt, params) {
              this.emitter().emit(evt, params);return this;
            }
          });

          define.eventAliasesOn(layoutProto);

          ext = Layout; // replace with our wrapped layout
        } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
          // user registered renderers inherit from base

          var BaseRenderer = getExtension('renderer', 'base');
          var bProto = BaseRenderer.prototype;
          var RegistrantRenderer = registrant;
          var rProto = registrant.prototype;

          var Renderer = function Renderer() {
            BaseRenderer.apply(this, arguments);
            RegistrantRenderer.apply(this, arguments);
          };

          var proto = Renderer.prototype;

          for (var pName in bProto) {
            var pVal = bProto[pName];
            var existsInR = rProto[pName] != null;

            if (existsInR) {
              return overrideErr(pName);
            }

            proto[pName] = pVal; // take impl from base
          }

          for (var _pName in rProto) {
            proto[_pName] = rProto[_pName]; // take impl from registrant
          }

          bProto.clientFunctions.forEach(function (name) {
            proto[name] = proto[name] || function () {
              util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
            };
          });

          ext = Renderer;
        }

        return util.setMap({
          map: extensions,
          keys: [type, name],
          value: ext
        });
      }

      function getExtension(type, name) {
        return util.getMap({
          map: extensions,
          keys: [type, name]
        });
      }

      function setModule(type, name, moduleType, moduleName, registrant) {
        return util.setMap({
          map: modules,
          keys: [type, name, moduleType, moduleName],
          value: registrant
        });
      }

      function getModule(type, name, moduleType, moduleName) {
        return util.getMap({
          map: modules,
          keys: [type, name, moduleType, moduleName]
        });
      }

      var extension = function extension() {
        // e.g. extension('renderer', 'svg')
        if (arguments.length === 2) {
          return getExtension.apply(null, arguments);
        }

        // e.g. extension('renderer', 'svg', { ... })
        else if (arguments.length === 3) {
            return setExtension.apply(null, arguments);
          }

          // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
          else if (arguments.length === 4) {
              return getModule.apply(null, arguments);
            }

            // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
            else if (arguments.length === 5) {
                return setModule.apply(null, arguments);
              } else {
                util.error('Invalid extension access syntax');
              }
      };

      // allows a core instance to access extensions internally
      Core.prototype.extension = extension;

      // included extensions
      incExts.forEach(function (group) {
        group.extensions.forEach(function (ext) {
          setExtension(group.type, ext.name, ext.impl);
        });
      });

      module.exports = extension;

      /***/
    },
    /* 96 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = [{
        type: 'layout',
        extensions: __webpack_require__(97)
      }, {
        type: 'renderer',
        extensions: __webpack_require__(107)
      }];

      /***/
    },
    /* 97 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = [{ name: 'breadthfirst', impl: __webpack_require__(98) }, { name: 'circle', impl: __webpack_require__(99) }, { name: 'concentric', impl: __webpack_require__(100) }, { name: 'cose', impl: __webpack_require__(101) }, { name: 'grid', impl: __webpack_require__(102) }, { name: 'null', impl: __webpack_require__(103) }, { name: 'preset', impl: __webpack_require__(104) }, { name: 'random', impl: __webpack_require__(105) }, { name: 'tree', impl: __webpack_require__(106) }];

      /***/
    },
    /* 98 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
        padding: 30, // padding on fit
        circle: false, // put depths in concentric circles if true, put depths top down if false
        spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        roots: undefined, // the roots of the trees
        maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled,
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts
      };

      function BreadthFirstLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      BreadthFirstLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');
        var graph = eles;

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var roots = void 0;
        if (is.elementOrCollection(options.roots)) {
          roots = options.roots;
        } else if (is.array(options.roots)) {
          var rootsArray = [];

          for (var i = 0; i < options.roots.length; i++) {
            var id = options.roots[i];
            var ele = cy.getElementById(id);
            rootsArray.push(ele);
          }

          roots = cy.collection(rootsArray);
        } else if (is.string(options.roots)) {
          roots = cy.$(options.roots);
        } else {
          if (options.directed) {
            roots = nodes.roots();
          } else {
            var components = [];
            var unhandledNodes = nodes;

            var _loop = function _loop() {
              var currComp = cy.collection();

              eles.bfs({
                roots: unhandledNodes[0],
                visit: function visit(node, edge, pNode, i, depth) {
                  currComp = currComp.add(node);
                },
                directed: false
              });

              unhandledNodes = unhandledNodes.not(currComp);
              components.push(currComp);
            };

            while (unhandledNodes.length > 0) {
              _loop();
            }

            roots = cy.collection();

            var _loop2 = function _loop2(_i) {
              var comp = components[_i];
              var maxDegree = comp.maxDegree(false);
              var compRoots = comp.filter(function (ele) {
                return ele.degree(false) === maxDegree;
              });

              roots = roots.add(compRoots);
            };

            for (var _i = 0; _i < components.length; _i++) {
              _loop2(_i);
            }
          }
        }

        var depths = [];
        var foundByBfs = {};
        var id2depth = {};
        var prevNode = {};
        var prevEdge = {};
        var successors = {};

        // find the depths of the nodes
        graph.bfs({
          roots: roots,
          directed: options.directed,
          visit: function visit(node, edge, pNode, i, depth) {
            var ele = node[0];
            var id = ele.id();

            if (!depths[depth]) {
              depths[depth] = [];
            }

            depths[depth].push(ele);
            foundByBfs[id] = true;
            id2depth[id] = depth;
            prevNode[id] = pNode;
            prevEdge[id] = edge;

            if (pNode) {
              var prevId = pNode.id();
              var succ = successors[prevId] = successors[prevId] || [];

              succ.push(node);
            }
          }
        });

        // check for nodes not found by bfs
        var orphanNodes = [];
        for (var _i2 = 0; _i2 < nodes.length; _i2++) {
          var _ele = nodes[_i2];

          if (foundByBfs[_ele.id()]) {
            continue;
          } else {
            orphanNodes.push(_ele);
          }
        }

        // assign orphan nodes a depth from their neighborhood
        var maxChecks = orphanNodes.length * 3;
        var checks = 0;
        while (orphanNodes.length !== 0 && checks < maxChecks) {
          var node = orphanNodes.shift();
          var neighbors = node.neighborhood().nodes();
          var assignedDepth = false;

          for (var _i3 = 0; _i3 < neighbors.length; _i3++) {
            var depth = id2depth[neighbors[_i3].id()];

            if (depth !== undefined) {
              depths[depth].push(node);
              assignedDepth = true;
              break;
            }
          }

          if (!assignedDepth) {
            orphanNodes.push(node);
          }

          checks++;
        }

        // assign orphan nodes that are still left to the depth of their subgraph
        while (orphanNodes.length !== 0) {
          var _node = orphanNodes.shift();
          //let subgraph = graph.bfs( node ).path;
          var _assignedDepth = false;

          // for( let i = 0; i < subgraph.length; i++ ){
          //   let depth = id2depth[ subgraph[i].id() ];

          //   if( depth !== undefined ){
          //     depths[depth].push( node );
          //     assignedDepth = true;
          //     break;
          //   }
          // }

          if (!_assignedDepth) {
            // worst case if the graph really isn't tree friendly, then just dump it in 0
            if (depths.length === 0) {
              depths.push([]);
            }

            depths[0].push(_node);
          }
        }

        // assign the nodes a depth and index
        var assignDepthsToEles = function assignDepthsToEles() {
          for (var _i4 = 0; _i4 < depths.length; _i4++) {
            var _eles = depths[_i4];

            for (var j = 0; j < _eles.length; j++) {
              var _ele2 = _eles[j];

              if (_ele2 == null) {
                _eles.splice(j, 1);
                j--;
                continue;
              }

              _ele2._private.scratch.breadthfirst = {
                depth: _i4,
                index: j
              };
            }
          }
        };
        assignDepthsToEles();

        var intersectsDepth = function intersectsDepth(node) {
          // returns true if has edges pointing in from a higher depth
          var edges = node.connectedEdges(function (ele) {
            return ele.data('target') === node.id();
          });
          var thisInfo = node._private.scratch.breadthfirst;
          var highestDepthOfOther = 0;
          var highestOther = void 0;
          for (var _i5 = 0; _i5 < edges.length; _i5++) {
            var edge = edges[_i5];
            var otherNode = edge.source()[0];
            var otherInfo = otherNode._private.scratch.breadthfirst;

            if (thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth) {
              highestDepthOfOther = otherInfo.depth;
              highestOther = otherNode;
            }
          }

          return highestOther;
        };

        // make maximal if so set by adjusting depths
        for (var adj = 0; adj < options.maximalAdjustments; adj++) {

          var nDepths = depths.length;
          var elesToMove = [];
          for (var _i6 = 0; _i6 < nDepths; _i6++) {
            var _depth = depths[_i6];

            var nDepth = _depth.length;
            for (var j = 0; j < nDepth; j++) {
              var _ele3 = _depth[j];
              var info = _ele3._private.scratch.breadthfirst;
              var intEle = intersectsDepth(_ele3);

              if (intEle) {
                info.intEle = intEle;
                elesToMove.push(_ele3);
              }
            }
          }

          for (var _i7 = 0; _i7 < elesToMove.length; _i7++) {
            var _ele4 = elesToMove[_i7];
            var _info = _ele4._private.scratch.breadthfirst;
            var _intEle = _info.intEle;
            var intInfo = _intEle._private.scratch.breadthfirst;

            depths[_info.depth][_info.index] = null; // remove from old depth & index (create hole to be cleaned)

            // add to end of new depth
            var newDepth = intInfo.depth + 1;
            while (newDepth > depths.length - 1) {
              depths.push([]);
            }
            depths[newDepth].push(_ele4);

            _info.depth = newDepth;
            _info.index = depths[newDepth].length - 1;
          }

          assignDepthsToEles();
        }

        // find min distance we need to leave between nodes
        var minDistance = 0;
        if (options.avoidOverlap) {
          for (var _i8 = 0; _i8 < nodes.length; _i8++) {
            var n = nodes[_i8];
            var nbb = n.layoutDimensions(options);
            var w = nbb.w;
            var h = nbb.h;

            minDistance = Math.max(minDistance, w, h);
          }
        }

        // get the weighted percent for an element based on its connectivity to other levels
        var cachedWeightedPercent = {};
        var getWeightedPercent = function getWeightedPercent(ele) {
          if (cachedWeightedPercent[ele.id()]) {
            return cachedWeightedPercent[ele.id()];
          }

          var eleDepth = ele._private.scratch.breadthfirst.depth;
          var neighbors = ele.neighborhood().nodes().not(':parent').intersection(nodes);
          var percent = 0;
          var samples = 0;

          for (var _i9 = 0; _i9 < neighbors.length; _i9++) {
            var neighbor = neighbors[_i9];
            var bf = neighbor._private.scratch.breadthfirst;
            var index = bf.index;
            var _depth2 = bf.depth;
            var _nDepth = depths[_depth2].length;

            if (eleDepth > _depth2 || eleDepth === 0) {
              // only get influenced by elements above
              percent += index / _nDepth;
              samples++;
            }
          }

          samples = Math.max(1, samples);
          percent = percent / samples;

          if (samples === 0) {
            // so lone nodes have a "don't care" state in sorting
            percent = undefined;
          }

          cachedWeightedPercent[ele.id()] = percent;
          return percent;
        };

        // rearrange the indices in each depth level based on connectivity

        var sortFn = function sortFn(a, b) {
          var apct = getWeightedPercent(a);
          var bpct = getWeightedPercent(b);

          return apct - bpct;
        };

        for (var times = 0; times < 3; times++) {
          // do it a few times b/c the depths are dynamic and we want a more stable result

          for (var _i10 = 0; _i10 < depths.length; _i10++) {
            depths[_i10] = depths[_i10].sort(sortFn);
          }
          assignDepthsToEles(); // and update
        }

        var biggestDepthSize = 0;
        for (var _i11 = 0; _i11 < depths.length; _i11++) {
          biggestDepthSize = Math.max(depths[_i11].length, biggestDepthSize);
        }

        var center = {
          x: bb.x1 + bb.w / 2,
          y: bb.x1 + bb.h / 2
        };

        var getPosition = function getPosition(ele, isBottomDepth) {
          var info = ele._private.scratch.breadthfirst;
          var depth = info.depth;
          var index = info.index;
          var depthSize = depths[depth].length;

          var distanceX = Math.max(bb.w / (depthSize + 1), minDistance);
          var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
          var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
          radiusStepSize = Math.max(radiusStepSize, minDistance);

          if (!options.circle) {

            var epos = {
              x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
              y: (depth + 1) * distanceY
            };

            if (isBottomDepth) {
              return epos;
            }

            // let succs = successors[ ele.id() ];
            // if( succs ){
            //   epos.x = 0;
            //
            //   for( let i = 0 ; i < succs.length; i++ ){
            //     let spos = pos[ succs[i].id() ];
            //
            //     epos.x += spos.x;
            //   }
            //
            //   epos.x /= succs.length;
            // } else {
            //   //debugger;
            // }

            return epos;
          } else {
            if (options.circle) {
              var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
              var theta = 2 * Math.PI / depths[depth].length * index;

              if (depth === 0 && depths[0].length === 1) {
                radius = 1;
              }

              return {
                x: center.x + radius * Math.cos(theta),
                y: center.y + radius * Math.sin(theta)
              };
            } else {
              return {
                x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
                y: (depth + 1) * distanceY
              };
            }
          }
        };

        // get positions in reverse depth order
        var pos = {};
        for (var _i12 = depths.length - 1; _i12 >= 0; _i12--) {
          var _depth3 = depths[_i12];

          for (var _j = 0; _j < _depth3.length; _j++) {
            var _node2 = _depth3[_j];

            pos[_node2.id()] = getPosition(_node2, _i12 === depths.length - 1);
          }
        }

        nodes.layoutPositions(this, options, function (node) {
          return pos[node.id()];
        });

        return this; // chaining
      };

      module.exports = BreadthFirstLayout;

      /***/
    },
    /* 99 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // the padding on fit
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        radius: undefined, // the radius of the circle
        startAngle: 3 / 2 * Math.PI, // where nodes start in radians
        sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
        clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
        sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 

      };

      function CircleLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      CircleLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;

        var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

        var nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var center = {
          x: bb.x1 + bb.w / 2,
          y: bb.y1 + bb.h / 2
        };

        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
        var dTheta = sweep / Math.max(1, nodes.length - 1);
        var r = void 0;

        var minDistance = 0;
        for (var i = 0; i < nodes.length; i++) {
          var n = nodes[i];
          var nbb = n.layoutDimensions(options);
          var w = nbb.w;
          var h = nbb.h;

          minDistance = Math.max(minDistance, w, h);
        }

        if (is.number(options.radius)) {
          r = options.radius;
        } else if (nodes.length <= 1) {
          r = 0;
        } else {
          r = Math.min(bb.h, bb.w) / 2 - minDistance;
        }

        // calculate the radius
        if (nodes.length > 1 && options.avoidOverlap) {
          // but only if more than one node (can't overlap)
          minDistance *= 1.75; // just to have some nice spacing

          var dcos = Math.cos(dTheta) - Math.cos(0);
          var dsin = Math.sin(dTheta) - Math.sin(0);
          var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
          r = Math.max(rMin, r);
        }

        var getPos = function getPos(ele, i) {
          var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);

          var rx = r * Math.cos(theta);
          var ry = r * Math.sin(theta);
          var pos = {
            x: center.x + rx,
            y: center.y + ry
          };

          return pos;
        };

        nodes.layoutPositions(this, options, getPos);

        return this; // chaining
      };

      module.exports = CircleLayout;

      /***/
    },
    /* 100 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // the padding on fit
        startAngle: 3 / 2 * Math.PI, // where nodes start in radians
        sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
        clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
        equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
        minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        height: undefined, // height of layout area (overrides container height)
        width: undefined, // width of layout area (overrides container width)
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        concentric: function concentric(node) {
          // returns numeric value for each node, placing higher nodes in levels towards the centre
          return node.degree();
        },
        levelWidth: function levelWidth(nodes) {
          // the letiation of concentric values in each level
          return nodes.maxDegree() / 4;
        },
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function ConcentricLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      ConcentricLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

        var cy = params.cy;

        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var center = {
          x: bb.x1 + bb.w / 2,
          y: bb.y1 + bb.h / 2
        };

        var nodeValues = []; // { node, value }
        var theta = options.startAngle;
        var maxNodeSize = 0;

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var value = void 0;

          // calculate the node value
          value = options.concentric(node);
          nodeValues.push({
            value: value,
            node: node
          });

          // for style mapping
          node._private.scratch.concentric = value;
        }

        // in case we used the `concentric` in style
        nodes.updateStyle();

        // calculate max size now based on potentially updated mappers
        for (var _i = 0; _i < nodes.length; _i++) {
          var _node = nodes[_i];
          var nbb = _node.layoutDimensions(options);

          maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
        }

        // sort node values in descreasing order
        nodeValues.sort(function (a, b) {
          return b.value - a.value;
        });

        var levelWidth = options.levelWidth(nodes);

        // put the values into levels
        var levels = [[]];
        var currentLevel = levels[0];
        for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
          var val = nodeValues[_i2];

          if (currentLevel.length > 0) {
            var diff = Math.abs(currentLevel[0].value - val.value);

            if (diff >= levelWidth) {
              currentLevel = [];
              levels.push(currentLevel);
            }
          }

          currentLevel.push(val);
        }

        // create positions from levels

        var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

        if (!options.avoidOverlap) {
          // then strictly constrain to bb
          var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
          var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
          var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);

          minDist = Math.min(minDist, rStep);
        }

        // find the metrics for each level
        var r = 0;
        for (var _i3 = 0; _i3 < levels.length; _i3++) {
          var level = levels[_i3];
          var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
          var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);

          // calculate the radius
          if (level.length > 1 && options.avoidOverlap) {
            // but only if more than one node (can't overlap)
            var dcos = Math.cos(dTheta) - Math.cos(0);
            var dsin = Math.sin(dTheta) - Math.sin(0);
            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

            r = Math.max(rMin, r);
          }

          level.r = r;

          r += minDist;
        }

        if (options.equidistant) {
          var rDeltaMax = 0;
          var _r = 0;

          for (var _i4 = 0; _i4 < levels.length; _i4++) {
            var _level = levels[_i4];
            var rDelta = _level.r - _r;

            rDeltaMax = Math.max(rDeltaMax, rDelta);
          }

          _r = 0;
          for (var _i5 = 0; _i5 < levels.length; _i5++) {
            var _level2 = levels[_i5];

            if (_i5 === 0) {
              _r = _level2.r;
            }

            _level2.r = _r;

            _r += rDeltaMax;
          }
        }

        // calculate the node positions
        var pos = {}; // id => position
        for (var _i6 = 0; _i6 < levels.length; _i6++) {
          var _level3 = levels[_i6];
          var _dTheta = _level3.dTheta;
          var _r2 = _level3.r;

          for (var j = 0; j < _level3.length; j++) {
            var _val = _level3[j];
            var _theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;

            var p = {
              x: center.x + _r2 * Math.cos(_theta),
              y: center.y + _r2 * Math.sin(_theta)
            };

            pos[_val.node.id()] = p;
          }
        }

        // position the nodes
        nodes.layoutPositions(this, options, function (ele) {
          var id = ele.id();

          return pos[id];
        });

        return this; // chaining
      };

      module.exports = ConcentricLayout;

      /***/
    },
    /* 101 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*
      The CoSE layout was written by Gerardo Huck.
      https://www.linkedin.com/in/gerardohuck/
      
      Based on the following article:
      http://dl.acm.org/citation.cfm?id=1498047
      
      Modifications tracked on Github.
      */

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);

      var DEBUG;

      /**
       * @brief :  default layout options
       */
      var defaults = {
        // Called on `layoutready`
        ready: function ready() {},

        // Called on `layoutstop`
        stop: function stop() {},

        // Whether to animate while running the layout
        // true : Animate continuously as the layout is running
        // false : Just show the end result
        // 'end' : Animate with the end result, from the initial positions to the end positions
        animate: true,

        // Easing of the animation for animate:'end'
        animationEasing: undefined,

        // The duration of the animation for animate:'end'
        animationDuration: undefined,

        // A function that determines whether the node should be animated
        // All nodes animated by default on animate enabled
        // Non-animated nodes are positioned immediately when the layout starts
        animateFilter: function animateFilter(node, i) {
          return true;
        },

        // The layout animates only after this many milliseconds for animate:true
        // (prevents flashing on fast runs)
        animationThreshold: 250,

        // Number of iterations between consecutive screen positions update
        // (0 -> only updated on the end)
        refresh: 20,

        // Whether to fit the network view after when done
        fit: true,

        // Padding on fit
        padding: 30,

        // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        boundingBox: undefined,

        // Excludes the label when calculating node bounding boxes for the layout algorithm
        nodeDimensionsIncludeLabels: false,

        // Randomize the initial positions of the nodes (true) or use existing positions (false)
        randomize: false,

        // Extra spacing between components in non-compound graphs
        componentSpacing: 40,

        // Node repulsion (non overlapping) multiplier
        nodeRepulsion: function nodeRepulsion(node) {
          return 2048;
        },

        // Node repulsion (overlapping) multiplier
        nodeOverlap: 4,

        // Ideal edge (non nested) length
        idealEdgeLength: function idealEdgeLength(edge) {
          return 32;
        },

        // Divisor to compute edge forces
        edgeElasticity: function edgeElasticity(edge) {
          return 32;
        },

        // Nesting factor (multiplier) to compute ideal edge length for nested edges
        nestingFactor: 1.2,

        // Gravity force (constant)
        gravity: 1,

        // Maximum number of iterations to perform
        numIter: 1000,

        // Initial temperature (maximum node displacement)
        initialTemp: 1000,

        // Cooling factor (how the temperature is reduced between consecutive iterations
        coolingFactor: 0.99,

        // Lower temperature threshold (below this point the layout will end)
        minTemp: 1.0,

        // Pass a reference to weaver to use threads for calculations
        weaver: false
      };

      /**
       * @brief       : constructor
       * @arg options : object containing layout options
       */
      function CoseLayout(options) {
        this.options = util.extend({}, defaults, options);

        this.options.layout = this;
      }

      /**
       * @brief : runs the layout
       */
      CoseLayout.prototype.run = function () {
        var options = this.options;
        var cy = options.cy;
        var layout = this;
        var thread = this.thread;
        var Thread = options.weaver ? options.weaver.Thread : null;

        var falseThread = { // use false thread as polyfill
          listeners: [],
          on: function on(e, cb) {
            this.listeners.push({ event: e, callback: cb });

            return this;
          },
          trigger: function trigger(e) {
            if (is.string(e)) {
              e = { type: e };
            }

            var matchesEvent = function matchesEvent(l) {
              return l.event === e.type;
            };
            var trigger = function trigger(l) {
              l.callback(e);
            };

            this.listeners.filter(matchesEvent).forEach(trigger);

            return this;
          },
          pass: function pass(data) {
            this.pass = data;

            return this;
          },
          run: function run(cb) {
            var pass = this.pass;

            return new Promise(function (resolve) {
              resolve(cb(pass));
            });
          },
          stop: function stop() {
            return this;
          },
          stopped: function stopped() {
            return true;
          }
        };

        function broadcast(message) {
          // for false thread
          var e = { type: 'message', message: message };

          falseThread.trigger(e);
        }

        if (!thread || thread.stopped()) {
          thread = this.thread = Thread ? new Thread() : falseThread;
        }

        layout.stopped = false;

        if (options.animate === true || options.animate === false) {
          layout.emit({ type: 'layoutstart', layout: layout });
        }

        // Set DEBUG - Global variable
        if (true === options.debug) {
          DEBUG = true;
        } else {
          DEBUG = false;
        }

        // Initialize layout info
        var layoutInfo = createLayoutInfo(cy, layout, options);

        // Show LayoutInfo contents if debugging
        if (DEBUG) {
          printLayoutInfo(layoutInfo);
        }

        // If required, randomize node positions
        if (options.randomize) {
          randomizePositions(layoutInfo, cy);
        }

        var startTime = Date.now();
        var refreshRequested = false;
        var refresh = function refresh(rOpts) {
          rOpts = rOpts || {};

          if (refreshRequested && !rOpts.next) {
            return;
          }

          if (!rOpts.force && Date.now() - startTime < options.animationThreshold) {
            return;
          }

          refreshRequested = true;

          util.requestAnimationFrame(function () {
            refreshPositions(layoutInfo, cy, options);

            // Fit the graph if necessary
            if (true === options.fit) {
              cy.fit(options.padding);
            }

            refreshRequested = false;

            if (rOpts.next) {
              rOpts.next();
            }
          });
        };

        thread.on('message', function (e) {
          var layoutNodes = e.message;

          layoutInfo.layoutNodes = layoutNodes;
          refresh();
        });

        thread.pass({
          layoutInfo: layoutInfo,
          options: {
            animate: options.animate,
            refresh: options.refresh,
            componentSpacing: options.componentSpacing,
            nodeOverlap: options.nodeOverlap,
            nestingFactor: options.nestingFactor,
            gravity: options.gravity,
            numIter: options.numIter,
            initialTemp: options.initialTemp,
            coolingFactor: options.coolingFactor,
            minTemp: options.minTemp
          }
        }).run(function (pass) {
          var layoutInfo = pass.layoutInfo;
          var options = pass.options;
          var stopped = false;

          /**
           * @brief          : Performs one iteration of the physical simulation
           * @arg layoutInfo : LayoutInfo object already initialized
           * @arg cy         : Cytoscape object
           * @arg options    : Layout options
           */
          var step = function step(layoutInfo, options, _step) {
            // var s = "\n\n###############################";
            // s += "\nSTEP: " + step;
            // s += "\n###############################\n";
            // logDebug(s);

            // Calculate node repulsions
            calculateNodeForces(layoutInfo, options);
            // Calculate edge forces
            calculateEdgeForces(layoutInfo, options);
            // Calculate gravity forces
            calculateGravityForces(layoutInfo, options);
            // Propagate forces from parent to child
            propagateForces(layoutInfo, options);
            // Update positions based on calculated forces
            updatePositions(layoutInfo, options);
          };

          /**
           * @brief : Computes the node repulsion forces
           */
          var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
            // Go through each of the graphs in graphSet
            // Nodes only repel each other if they belong to the same graph
            // var s = 'calculateNodeForces';
            // logDebug(s);
            for (var i = 0; i < layoutInfo.graphSet.length; i++) {
              var graph = layoutInfo.graphSet[i];
              var numNodes = graph.length;

              // s = "Set: " + graph.toString();
              // logDebug(s);

              // Now get all the pairs of nodes
              // Only get each pair once, (A, B) = (B, A)
              for (var j = 0; j < numNodes; j++) {
                var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

                for (var k = j + 1; k < numNodes; k++) {
                  var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];

                  nodeRepulsion(node1, node2, layoutInfo, options);
                }
              }
            }
          };

          var randomDistance = function randomDistance(max) {
            return -max + 2 * max * Math.random();
          };

          /**
           * @brief : Compute the node repulsion forces between a pair of nodes
           */
          var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
            // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

            var cmptId1 = node1.cmptId;
            var cmptId2 = node2.cmptId;

            if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
              return;
            }

            // Get direction of line connecting both node centers
            var directionX = node2.positionX - node1.positionX;
            var directionY = node2.positionY - node1.positionY;
            var maxRandDist = 1;
            // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

            // If both centers are the same, apply a random force
            if (0 === directionX && 0 === directionY) {
              directionX = randomDistance(maxRandDist);
              directionY = randomDistance(maxRandDist);
            }

            var overlap = nodesOverlap(node1, node2, directionX, directionY);

            if (overlap > 0) {
              // s += "\nNodes DO overlap.";
              // s += "\nOverlap: " + overlap;
              // If nodes overlap, repulsion force is proportional
              // to the overlap
              var force = options.nodeOverlap * overlap;

              // Compute the module and components of the force vector
              var distance = Math.sqrt(directionX * directionX + directionY * directionY);
              // s += "\nDistance: " + distance;
              var forceX = force * directionX / distance;
              var forceY = force * directionY / distance;
            } else {
              // s += "\nNodes do NOT overlap.";
              // If there's no overlap, force is inversely proportional
              // to squared distance

              // Get clipping points for both nodes
              var point1 = findClippingPoint(node1, directionX, directionY);
              var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

              // Use clipping points to compute distance
              var distanceX = point2.x - point1.x;
              var distanceY = point2.y - point1.y;
              var distanceSqr = distanceX * distanceX + distanceY * distanceY;
              var distance = Math.sqrt(distanceSqr);
              // s += "\nDistance: " + distance;

              // Compute the module and components of the force vector
              var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
              var forceX = force * distanceX / distance;
              var forceY = force * distanceY / distance;
            }

            // Apply force
            if (!node1.isLocked) {
              node1.offsetX -= forceX;
              node1.offsetY -= forceY;
            }

            if (!node2.isLocked) {
              node2.offsetX += forceX;
              node2.offsetY += forceY;
            }

            // s += "\nForceX: " + forceX + " ForceY: " + forceY;
            // logDebug(s);

            return;
          };

          /**
           * @brief  : Determines whether two nodes overlap or not
           * @return : Amount of overlapping (0 => no overlap)
           */
          var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {

            if (dX > 0) {
              var overlapX = node1.maxX - node2.minX;
            } else {
              var overlapX = node2.maxX - node1.minX;
            }

            if (dY > 0) {
              var overlapY = node1.maxY - node2.minY;
            } else {
              var overlapY = node2.maxY - node1.minY;
            }

            if (overlapX >= 0 && overlapY >= 0) {
              return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
            } else {
              return 0;
            }
          };

          /**
           * @brief : Finds the point in which an edge (direction dX, dY) intersects
           *          the rectangular bounding box of it's source/target node
           */
          var findClippingPoint = function findClippingPoint(node, dX, dY) {

            // Shorcuts
            var X = node.positionX;
            var Y = node.positionY;
            var H = node.height || 1;
            var W = node.width || 1;
            var dirSlope = dY / dX;
            var nodeSlope = H / W;

            // var s = 'Computing clipping point of node ' + node.id +
            //   " . Height:  " + H + ", Width: " + W +
            //   "\nDirection " + dX + ", " + dY;
            //
            // Compute intersection
            var res = {};

            // Case: Vertical direction (up)
            if (0 === dX && 0 < dY) {
              res.x = X;
              // s += "\nUp direction";
              res.y = Y + H / 2;

              return res;
            }

            // Case: Vertical direction (down)
            if (0 === dX && 0 > dY) {
              res.x = X;
              res.y = Y + H / 2;
              // s += "\nDown direction";

              return res;
            }

            // Case: Intersects the right border
            if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
              res.x = X + W / 2;
              res.y = Y + W * dY / 2 / dX;
              // s += "\nRightborder";

              return res;
            }

            // Case: Intersects the left border
            if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
              res.x = X - W / 2;
              res.y = Y - W * dY / 2 / dX;
              // s += "\nLeftborder";

              return res;
            }

            // Case: Intersects the top border
            if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
              res.x = X + H * dX / 2 / dY;
              res.y = Y + H / 2;
              // s += "\nTop border";

              return res;
            }

            // Case: Intersects the bottom border
            if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
              res.x = X - H * dX / 2 / dY;
              res.y = Y - H / 2;
              // s += "\nBottom border";

              return res;
            }

            // s += "\nClipping point found at " + res.x + ", " + res.y;
            // logDebug(s);
            return res;
          };

          /**
           * @brief : Calculates all edge forces
           */
          var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
            // Iterate over all edges
            for (var i = 0; i < layoutInfo.edgeSize; i++) {
              // Get edge, source & target nodes
              var edge = layoutInfo.layoutEdges[i];
              var sourceIx = layoutInfo.idToIndex[edge.sourceId];
              var source = layoutInfo.layoutNodes[sourceIx];
              var targetIx = layoutInfo.idToIndex[edge.targetId];
              var target = layoutInfo.layoutNodes[targetIx];

              // Get direction of line connecting both node centers
              var directionX = target.positionX - source.positionX;
              var directionY = target.positionY - source.positionY;

              // If both centers are the same, do nothing.
              // A random force has already been applied as node repulsion
              if (0 === directionX && 0 === directionY) {
                continue;
              }

              // Get clipping points for both nodes
              var point1 = findClippingPoint(source, directionX, directionY);
              var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);

              var lx = point2.x - point1.x;
              var ly = point2.y - point1.y;
              var l = Math.sqrt(lx * lx + ly * ly);

              var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

              if (0 !== l) {
                var forceX = force * lx / l;
                var forceY = force * ly / l;
              } else {
                var forceX = 0;
                var forceY = 0;
              }

              // Add this force to target and source nodes
              if (!source.isLocked) {
                source.offsetX += forceX;
                source.offsetY += forceY;
              }

              if (!target.isLocked) {
                target.offsetX -= forceX;
                target.offsetY -= forceY;
              }

              // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
              // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
              // logDebug(s);
            }
          };

          /**
           * @brief : Computes gravity forces for all nodes
           */
          var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
            var distThreshold = 1;

            // var s = 'calculateGravityForces';
            // logDebug(s);
            for (var i = 0; i < layoutInfo.graphSet.length; i++) {
              var graph = layoutInfo.graphSet[i];
              var numNodes = graph.length;

              // s = "Set: " + graph.toString();
              // logDebug(s);

              // Compute graph center
              if (0 === i) {
                var centerX = layoutInfo.clientHeight / 2;
                var centerY = layoutInfo.clientWidth / 2;
              } else {
                // Get Parent node for this graph, and use its position as center
                var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
                var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
                var centerX = parent.positionX;
                var centerY = parent.positionY;
              }
              // s = "Center found at: " + centerX + ", " + centerY;
              // logDebug(s);

              // Apply force to all nodes in graph
              for (var j = 0; j < numNodes; j++) {
                var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
                // s = "Node: " + node.id;

                if (node.isLocked) {
                  continue;
                }

                var dx = centerX - node.positionX;
                var dy = centerY - node.positionY;
                var d = Math.sqrt(dx * dx + dy * dy);
                if (d > distThreshold) {
                  var fx = options.gravity * dx / d;
                  var fy = options.gravity * dy / d;
                  node.offsetX += fx;
                  node.offsetY += fy;
                  // s += ": Applied force: " + fx + ", " + fy;
                } else {}
                // s += ": skypped since it's too close to center";

                // logDebug(s);
              }
            }
          };

          /**
           * @brief          : This function propagates the existing offsets from
           *                   parent nodes to its descendents.
           * @arg layoutInfo : layoutInfo Object
           * @arg cy         : cytoscape Object
           * @arg options    : Layout options
           */
          var propagateForces = function propagateForces(layoutInfo, options) {
            // Inline implementation of a queue, used for traversing the graph in BFS order
            var queue = [];
            var start = 0; // Points to the start the queue
            var end = -1; // Points to the end of the queue

            // logDebug('propagateForces');

            // Start by visiting the nodes in the root graph
            queue.push.apply(queue, layoutInfo.graphSet[0]);
            end += layoutInfo.graphSet[0].length;

            // Traverse the graph, level by level,
            while (start <= end) {
              // Get the node to visit and remove it from queue
              var nodeId = queue[start++];
              var nodeIndex = layoutInfo.idToIndex[nodeId];
              var node = layoutInfo.layoutNodes[nodeIndex];
              var children = node.children;

              // We only need to process the node if it's compound
              if (0 < children.length && !node.isLocked) {
                var offX = node.offsetX;
                var offY = node.offsetY;

                // var s = "Propagating offset from parent node : " + node.id +
                //   ". OffsetX: " + offX + ". OffsetY: " + offY;
                // s += "\n Children: " + children.toString();
                // logDebug(s);

                for (var i = 0; i < children.length; i++) {
                  var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
                  // Propagate offset
                  childNode.offsetX += offX;
                  childNode.offsetY += offY;
                  // Add children to queue to be visited
                  queue[++end] = children[i];
                }

                // Reset parent offsets
                node.offsetX = 0;
                node.offsetY = 0;
              }
            }
          };

          /**
           * @brief : Updates the layout model positions, based on
           *          the accumulated forces
           */
          var updatePositions = function updatePositions(layoutInfo, options) {
            // var s = 'Updating positions';
            // logDebug(s);

            // Reset boundaries for compound nodes
            for (var i = 0; i < layoutInfo.nodeSize; i++) {
              var n = layoutInfo.layoutNodes[i];
              if (0 < n.children.length) {
                // logDebug("Resetting boundaries of compound node: " + n.id);
                n.maxX = undefined;
                n.minX = undefined;
                n.maxY = undefined;
                n.minY = undefined;
              }
            }

            for (var i = 0; i < layoutInfo.nodeSize; i++) {
              var n = layoutInfo.layoutNodes[i];
              if (0 < n.children.length || n.isLocked) {
                // No need to set compound or locked node position
                // logDebug("Skipping position update of node: " + n.id);
                continue;
              }
              // s = "Node: " + n.id + " Previous position: (" +
              // n.positionX + ", " + n.positionY + ").";

              // Limit displacement in order to improve stability
              var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
              n.positionX += tempForce.x;
              n.positionY += tempForce.y;
              n.offsetX = 0;
              n.offsetY = 0;
              n.minX = n.positionX - n.width;
              n.maxX = n.positionX + n.width;
              n.minY = n.positionY - n.height;
              n.maxY = n.positionY + n.height;
              // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
              // logDebug(s);

              // Update ancestry boudaries
              updateAncestryBoundaries(n, layoutInfo);
            }

            // Update size, position of compund nodes
            for (var i = 0; i < layoutInfo.nodeSize; i++) {
              var n = layoutInfo.layoutNodes[i];
              if (0 < n.children.length && !n.isLocked) {
                n.positionX = (n.maxX + n.minX) / 2;
                n.positionY = (n.maxY + n.minY) / 2;
                n.width = n.maxX - n.minX;
                n.height = n.maxY - n.minY;
                // s = "Updating position, size of compound node " + n.id;
                // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
                // s += "\nWidth: " + n.width + ", Height: " + n.height;
                // logDebug(s);
              }
            }
          };

          /**
           * @brief : Limits a force (forceX, forceY) to be not
           *          greater (in modulo) than max.
           8          Preserves force direction.
           */
          var limitForce = function limitForce(forceX, forceY, max) {
            // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
            var force = Math.sqrt(forceX * forceX + forceY * forceY);

            if (force > max) {
              var res = {
                x: max * forceX / force,
                y: max * forceY / force
              };
            } else {
              var res = {
                x: forceX,
                y: forceY
              };
            }

            // s += ".\nResult: (" + res.x + ", " + res.y + ")";
            // logDebug(s);

            return res;
          };

          /**
           * @brief : Function used for keeping track of compound node
           *          sizes, since they should bound all their subnodes.
           */
          var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
            // var s = "Propagating new position/size of node " + node.id;
            var parentId = node.parentId;
            if (null == parentId) {
              // If there's no parent, we are done
              // s += ". No parent node.";
              // logDebug(s);
              return;
            }

            // Get Parent Node
            var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
            var flag = false;

            // MaxX
            if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
              p.maxX = node.maxX + p.padRight;
              flag = true;
              // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
            }

            // MinX
            if (null == p.minX || node.minX - p.padLeft < p.minX) {
              p.minX = node.minX - p.padLeft;
              flag = true;
              // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
            }

            // MaxY
            if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
              p.maxY = node.maxY + p.padBottom;
              flag = true;
              // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
            }

            // MinY
            if (null == p.minY || node.minY - p.padTop < p.minY) {
              p.minY = node.minY - p.padTop;
              flag = true;
              // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
            }

            // If updated boundaries, propagate changes upward
            if (flag) {
              // logDebug(s);
              return updateAncestryBoundaries(p, layoutInfo);
            }

            // s += ". No changes in boundaries/position of parent node " + p.id;
            // logDebug(s);
            return;
          };

          var separateComponents = function separateComponents(layutInfo, options) {
            var nodes = layoutInfo.layoutNodes;
            var components = [];

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var cid = node.cmptId;
              var component = components[cid] = components[cid] || [];

              component.push(node);
            }

            var totalA = 0;

            for (var i = 0; i < components.length; i++) {
              var c = components[i];

              if (!c) {
                continue;
              }

              c.x1 = Infinity;
              c.x2 = -Infinity;
              c.y1 = Infinity;
              c.y2 = -Infinity;

              for (var j = 0; j < c.length; j++) {
                var n = c[j];

                c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
                c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
                c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
                c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
              }

              c.w = c.x2 - c.x1;
              c.h = c.y2 - c.y1;

              totalA += c.w * c.h;
            }

            components.sort(function (c1, c2) {
              return c2.w * c2.h - c1.w * c1.h;
            });

            var x = 0;
            var y = 0;
            var usedW = 0;
            var rowH = 0;
            var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

            for (var i = 0; i < components.length; i++) {
              var c = components[i];

              if (!c) {
                continue;
              }

              for (var j = 0; j < c.length; j++) {
                var n = c[j];

                if (!n.isLocked) {
                  n.positionX += x;
                  n.positionY += y;
                }
              }

              x += c.w + options.componentSpacing;
              usedW += c.w + options.componentSpacing;
              rowH = Math.max(rowH, c.h);

              if (usedW > maxRowW) {
                y += rowH + options.componentSpacing;
                x = 0;
                usedW = 0;
                rowH = 0;
              }
            }
          };

          var mainLoop = function mainLoop(i) {
            if (stopped) {
              // logDebug("Layout manually stopped. Stopping computation in step " + i);
              return false;
            }

            // Do one step in the phisical simulation
            step(layoutInfo, options, i);

            // Update temperature
            layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
            // logDebug("New temperature: " + layoutInfo.temperature);

            if (layoutInfo.temperature < options.minTemp) {
              // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
              return false;
            }

            return true;
          };

          var i = 0;
          var loopRet;

          do {
            var f = 0;

            while (f < options.refresh && i < options.numIter) {
              var loopRet = mainLoop(i);
              if (!loopRet) {
                break;
              }

              f++;
              i++;
            }

            if (options.animate === true) {
              broadcast(layoutInfo.layoutNodes); // eslint-disable-line no-undef
            }
          } while (loopRet && i + 1 < options.numIter);

          separateComponents(layoutInfo, options);

          return layoutInfo;
        }).then(function (layoutInfoUpdated) {
          layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

          thread.stop();
          done();
        });

        var done = function done() {
          if (options.animate === true || options.animate === false) {
            refresh({
              force: true,
              next: function next() {
                // Layout has finished
                layout.one('layoutstop', options.stop);
                layout.emit({ type: 'layoutstop', layout: layout });
              }
            });
          } else {
            options.eles.nodes().layoutPositions(layout, options, function (node) {
              var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

              return { x: lnode.positionX, y: lnode.positionY };
            });
          }
        };

        return this; // chaining
      };

      /**
       * @brief : called on continuous layouts to stop them before they finish
       */
      CoseLayout.prototype.stop = function () {
        this.stopped = true;

        if (this.thread) {
          this.thread.stop();
        }

        this.emit('layoutstop');

        return this; // chaining
      };

      CoseLayout.prototype.destroy = function () {
        if (this.thread) {
          this.thread.stop();
        }

        return this; // chaining
      };

      /**
       * @brief     : Creates an object which is contains all the data
       *              used in the layout process
       * @arg cy    : cytoscape.js object
       * @return    : layoutInfo object initialized
       */
      var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
        // Shortcut
        var edges = options.eles.edges();
        var nodes = options.eles.nodes();

        var layoutInfo = {
          isCompound: cy.hasCompoundNodes(),
          layoutNodes: [],
          idToIndex: {},
          nodeSize: nodes.size(),
          graphSet: [],
          indexToGraph: [],
          layoutEdges: [],
          edgeSize: edges.size(),
          temperature: options.initialTemp,
          clientWidth: cy.width(),
          clientHeight: cy.width(),
          boundingBox: math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
            x1: 0, y1: 0, w: cy.width(), h: cy.height()
          })
        };

        var components = options.eles.components();
        var id2cmptId = {};

        for (var i = 0; i < components.length; i++) {
          var component = components[i];

          for (var j = 0; j < component.length; j++) {
            var node = component[j];

            id2cmptId[node.id()] = i;
          }
        }

        // Iterate over all nodes, creating layout nodes
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = nodes[i];
          var nbb = n.layoutDimensions(options);

          var tempNode = {};
          tempNode.isLocked = n.locked();
          tempNode.id = n.data('id');
          tempNode.parentId = n.data('parent');
          tempNode.cmptId = id2cmptId[n.id()];
          tempNode.children = [];
          tempNode.positionX = n.position('x');
          tempNode.positionY = n.position('y');
          tempNode.offsetX = 0;
          tempNode.offsetY = 0;
          tempNode.height = nbb.w;
          tempNode.width = nbb.h;
          tempNode.maxX = tempNode.positionX + tempNode.width / 2;
          tempNode.minX = tempNode.positionX - tempNode.width / 2;
          tempNode.maxY = tempNode.positionY + tempNode.height / 2;
          tempNode.minY = tempNode.positionY - tempNode.height / 2;
          tempNode.padLeft = parseFloat(n.style('padding'));
          tempNode.padRight = parseFloat(n.style('padding'));
          tempNode.padTop = parseFloat(n.style('padding'));
          tempNode.padBottom = parseFloat(n.style('padding'));

          // forces
          tempNode.nodeRepulsion = is.fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;

          // Add new node
          layoutInfo.layoutNodes.push(tempNode);
          // Add entry to id-index map
          layoutInfo.idToIndex[tempNode.id] = i;
        }

        // Inline implementation of a queue, used for traversing the graph in BFS order
        var queue = [];
        var start = 0; // Points to the start the queue
        var end = -1; // Points to the end of the queue

        var tempGraph = [];

        // Second pass to add child information and
        // initialize queue for hierarchical traversal
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];
          var p_id = n.parentId;
          // Check if node n has a parent node
          if (null != p_id) {
            // Add node Id to parent's list of children
            layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
          } else {
            // If a node doesn't have a parent, then it's in the root graph
            queue[++end] = n.id;
            tempGraph.push(n.id);
          }
        }

        // Add root graph to graphSet
        layoutInfo.graphSet.push(tempGraph);

        // Traverse the graph, level by level,
        while (start <= end) {
          // Get the node to visit and remove it from queue
          var node_id = queue[start++];
          var node_ix = layoutInfo.idToIndex[node_id];
          var node = layoutInfo.layoutNodes[node_ix];
          var children = node.children;
          if (children.length > 0) {
            // Add children nodes as a new graph to graph set
            layoutInfo.graphSet.push(children);
            // Add children to que queue to be visited
            for (var i = 0; i < children.length; i++) {
              queue[++end] = children[i];
            }
          }
        }

        // Create indexToGraph map
        for (var i = 0; i < layoutInfo.graphSet.length; i++) {
          var graph = layoutInfo.graphSet[i];
          for (var j = 0; j < graph.length; j++) {
            var index = layoutInfo.idToIndex[graph[j]];
            layoutInfo.indexToGraph[index] = i;
          }
        }

        // Iterate over all edges, creating Layout Edges
        for (var i = 0; i < layoutInfo.edgeSize; i++) {
          var e = edges[i];
          var tempEdge = {};
          tempEdge.id = e.data('id');
          tempEdge.sourceId = e.data('source');
          tempEdge.targetId = e.data('target');

          // Compute ideal length
          var idealLength = is.fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
          var elasticity = is.fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;

          // Check if it's an inter graph edge
          var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
          var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
          var sourceGraph = layoutInfo.indexToGraph[sourceIx];
          var targetGraph = layoutInfo.indexToGraph[targetIx];

          if (sourceGraph != targetGraph) {
            // Find lowest common graph ancestor
            var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

            // Compute sum of node depths, relative to lca graph
            var lcaGraph = layoutInfo.graphSet[lca];
            var depth = 0;

            // Source depth
            var tempNode = layoutInfo.layoutNodes[sourceIx];
            while (-1 === lcaGraph.indexOf(tempNode.id)) {
              tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
              depth++;
            }

            // Target depth
            tempNode = layoutInfo.layoutNodes[targetIx];
            while (-1 === lcaGraph.indexOf(tempNode.id)) {
              tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
              depth++;
            }

            // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
            //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
            //  ". Depth: " + depth);

            // Update idealLength
            idealLength *= depth * options.nestingFactor;
          }

          tempEdge.idealLength = idealLength;
          tempEdge.elasticity = elasticity;

          layoutInfo.layoutEdges.push(tempEdge);
        }

        // Finally, return layoutInfo object
        return layoutInfo;
      };

      /**
       * @brief : This function finds the index of the lowest common
       *          graph ancestor between 2 nodes in the subtree
       *          (from the graph hierarchy induced tree) whose
       *          root is graphIx
       *
       * @arg node1: node1's ID
       * @arg node2: node2's ID
       * @arg layoutInfo: layoutInfo object
       *
       */
      var findLCA = function findLCA(node1, node2, layoutInfo) {
        // Find their common ancester, starting from the root graph
        var res = findLCA_aux(node1, node2, 0, layoutInfo);
        if (2 > res.count) {
          // If aux function couldn't find the common ancester,
          // then it is the root graph
          return 0;
        } else {
          return res.graph;
        }
      };

      /**
       * @brief          : Auxiliary function used for LCA computation
       *
       * @arg node1      : node1's ID
       * @arg node2      : node2's ID
       * @arg graphIx    : subgraph index
       * @arg layoutInfo : layoutInfo object
       *
       * @return         : object of the form {count: X, graph: Y}, where:
       *                   X is the number of ancesters (max: 2) found in
       *                   graphIx (and it's subgraphs),
       *                   Y is the graph index of the lowest graph containing
       *                   all X nodes
       */
      var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
        var graph = layoutInfo.graphSet[graphIx];
        // If both nodes belongs to graphIx
        if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
          return { count: 2, graph: graphIx };
        }

        // Make recursive calls for all subgraphs
        var c = 0;
        for (var i = 0; i < graph.length; i++) {
          var nodeId = graph[i];
          var nodeIx = layoutInfo.idToIndex[nodeId];
          var children = layoutInfo.layoutNodes[nodeIx].children;

          // If the node has no child, skip it
          if (0 === children.length) {
            continue;
          }

          var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
          var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
          if (0 === result.count) {
            // Neither node1 nor node2 are present in this subgraph
            continue;
          } else if (1 === result.count) {
            // One of (node1, node2) is present in this subgraph
            c++;
            if (2 === c) {
              // We've already found both nodes, no need to keep searching
              break;
            }
          } else {
            // Both nodes are present in this subgraph
            return result;
          }
        }

        return { count: c, graph: graphIx };
      };

      /**
       * @brief: printsLayoutInfo into js console
       *         Only used for debbuging
       */
      var printLayoutInfo = function printLayoutInfo(layoutInfo) {
        /* eslint-disable */

        if (!DEBUG) {
          return;
        }
        console.debug('layoutNodes:');
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];
          var s = '\nindex: ' + i + '\nId: ' + n.id + '\nChildren: ' + n.children.toString() + '\nparentId: ' + n.parentId + '\npositionX: ' + n.positionX + '\npositionY: ' + n.positionY + '\nOffsetX: ' + n.offsetX + '\nOffsetY: ' + n.offsetY + '\npadLeft: ' + n.padLeft + '\npadRight: ' + n.padRight + '\npadTop: ' + n.padTop + '\npadBottom: ' + n.padBottom;

          console.debug(s);
        }

        console.debug('idToIndex');
        for (var i in layoutInfo.idToIndex) {
          console.debug('Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[i]);
        }

        console.debug('Graph Set');
        var set = layoutInfo.graphSet;
        for (var i = 0; i < set.length; i++) {
          console.debug('Set : ' + i + ': ' + set[i].toString());
        }

        var s = 'IndexToGraph';
        for (var i = 0; i < layoutInfo.indexToGraph.length; i++) {
          s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[i];
        }
        console.debug(s);

        s = 'Layout Edges';
        for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
          var e = layoutInfo.layoutEdges[i];
          s += '\nEdge Index: ' + i + ' ID: ' + e.id + ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId + ' Ideal Length: ' + e.idealLength;
        }
        console.debug(s);

        s = 'nodeSize: ' + layoutInfo.nodeSize;
        s += '\nedgeSize: ' + layoutInfo.edgeSize;
        s += '\ntemperature: ' + layoutInfo.temperature;
        console.debug(s);

        return;
        /* eslint-enable */
      };

      /**
       * @brief : Randomizes the position of all nodes
       */
      var randomizePositions = function randomizePositions(layoutInfo, cy) {
        var width = layoutInfo.clientWidth;
        var height = layoutInfo.clientHeight;

        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];

          // No need to randomize compound nodes or locked nodes
          if (0 === n.children.length && !n.isLocked) {
            n.positionX = Math.random() * width;
            n.positionY = Math.random() * height;
          }
        }
      };

      /**
       * @brief          : Updates the positions of nodes in the network
       * @arg layoutInfo : LayoutInfo object
       * @arg cy         : Cytoscape object
       * @arg options    : Layout options
       */
      var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
        // var s = 'Refreshing positions';
        // logDebug(s);

        var layout = options.layout;
        var nodes = options.eles.nodes();
        var bb = layoutInfo.boundingBox;
        var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

        if (options.boundingBox) {
          nodes.forEach(function (node) {
            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);

            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
          });

          coseBB.w = coseBB.x2 - coseBB.x1;
          coseBB.h = coseBB.y2 - coseBB.y1;
        }

        nodes.positions(function (ele, i) {
          var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
          // s = "Node: " + lnode.id + ". Refreshed position: (" +
          // lnode.positionX + ", " + lnode.positionY + ").";
          // logDebug(s);

          if (options.boundingBox) {
            // then add extra bounding box constraint
            var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
            var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

            return {
              x: bb.x1 + pctX * bb.w,
              y: bb.y1 + pctY * bb.h
            };
          } else {
            return {
              x: lnode.positionX,
              y: lnode.positionY
            };
          }
        });

        // Trigger layoutReady only on first call
        if (true !== layoutInfo.ready) {
          // s = 'Triggering layoutready';
          // logDebug(s);
          layoutInfo.ready = true;
          layout.one('layoutready', options.ready);
          layout.emit({ type: 'layoutready', layout: this });
        }
      };

      /**
       * @brief : Logs a debug message in JS console, if DEBUG is ON
       */
      // var logDebug = function(text) {
      //   if (DEBUG) {
      //     console.debug(text);
      //   }
      // };

      module.exports = CoseLayout;

      /***/
    },
    /* 102 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // padding used on fit
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        condense: false, // uses all available space on false, uses minimal space on true
        rows: undefined, // force num of rows in the grid
        cols: undefined, // force num of columns in the grid
        position: function position(node) {}, // returns { row, col } for element
        sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function GridLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      GridLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        if (bb.h === 0 || bb.w === 0) {
          nodes.layoutPositions(this, options, function (ele) {
            return { x: bb.x1, y: bb.y1 };
          });
        } else {

          // width/height * splits^2 = cells where splits is number of times to split width
          var cells = nodes.size();
          var splits = Math.sqrt(cells * bb.h / bb.w);
          var rows = Math.round(splits);
          var cols = Math.round(bb.w / bb.h * splits);

          var small = function small(val) {
            if (val == null) {
              return Math.min(rows, cols);
            } else {
              var min = Math.min(rows, cols);
              if (min == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var large = function large(val) {
            if (val == null) {
              return Math.max(rows, cols);
            } else {
              var max = Math.max(rows, cols);
              if (max == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var oRows = options.rows;
          var oCols = options.cols != null ? options.cols : options.columns;

          // if rows or columns were set in options, use those values
          if (oRows != null && oCols != null) {
            rows = oRows;
            cols = oCols;
          } else if (oRows != null && oCols == null) {
            rows = oRows;
            cols = Math.ceil(cells / rows);
          } else if (oRows == null && oCols != null) {
            cols = oCols;
            rows = Math.ceil(cells / cols);
          }

          // otherwise use the automatic values and adjust accordingly

          // if rounding was up, see if we can reduce rows or columns
          else if (cols * rows > cells) {
              var sm = small();
              var lg = large();

              // reducing the small side takes away the most cells, so try it first
              if ((sm - 1) * lg >= cells) {
                small(sm - 1);
              } else if ((lg - 1) * sm >= cells) {
                large(lg - 1);
              }
            } else {

              // if rounding was too low, add rows or columns
              while (cols * rows < cells) {
                var _sm = small();
                var _lg = large();

                // try to add to larger side first (adds less in multiplication)
                if ((_lg + 1) * _sm >= cells) {
                  large(_lg + 1);
                } else {
                  small(_sm + 1);
                }
              }
            }

          var cellWidth = bb.w / cols;
          var cellHeight = bb.h / rows;

          if (options.condense) {
            cellWidth = 0;
            cellHeight = 0;
          }

          if (options.avoidOverlap) {
            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var pos = node._private.position;

              if (pos.x == null || pos.y == null) {
                // for bb
                pos.x = 0;
                pos.y = 0;
              }

              var nbb = node.layoutDimensions(options);
              var p = options.avoidOverlapPadding;

              var w = nbb.w + p;
              var h = nbb.h + p;

              cellWidth = Math.max(cellWidth, w);
              cellHeight = Math.max(cellHeight, h);
            }
          }

          var cellUsed = {}; // e.g. 'c-0-2' => true

          var used = function used(row, col) {
            return cellUsed['c-' + row + '-' + col] ? true : false;
          };

          var use = function use(row, col) {
            cellUsed['c-' + row + '-' + col] = true;
          };

          // to keep track of current cell position
          var row = 0;
          var col = 0;
          var moveToNextCell = function moveToNextCell() {
            col++;
            if (col >= cols) {
              col = 0;
              row++;
            }
          };

          // get a cache of all the manual positions
          var id2manPos = {};
          for (var _i = 0; _i < nodes.length; _i++) {
            var _node = nodes[_i];
            var rcPos = options.position(_node);

            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
              // must have at least row or col def'd
              var _pos = {
                row: rcPos.row,
                col: rcPos.col
              };

              if (_pos.col === undefined) {
                // find unused col
                _pos.col = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.col++;
                }
              } else if (_pos.row === undefined) {
                // find unused row
                _pos.row = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.row++;
                }
              }

              id2manPos[_node.id()] = _pos;
              use(_pos.row, _pos.col);
            }
          }

          var getPos = function getPos(element, i) {
            var x = void 0,
                y = void 0;

            if (element.locked() || element.isParent()) {
              return false;
            }

            // see if we have a manual position set
            var rcPos = id2manPos[element.id()];
            if (rcPos) {
              x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
              y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
            } else {
              // otherwise set automatically

              while (used(row, col)) {
                moveToNextCell();
              }

              x = col * cellWidth + cellWidth / 2 + bb.x1;
              y = row * cellHeight + cellHeight / 2 + bb.y1;
              use(row, col);

              moveToNextCell();
            }

            return { x: x, y: y };
          };

          nodes.layoutPositions(this, options, getPos);
        }

        return this; // chaining
      };

      module.exports = GridLayout;

      /***/
    },
    /* 103 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      // default layout options
      var defaults = {
        ready: function ready() {}, // on layoutready
        stop: function stop() {} // on layoutstop
      };

      // constructor
      // options : object containing layout options
      function NullLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      // runs the layout
      NullLayout.prototype.run = function () {
        var options = this.options;
        var eles = options.eles; // elements to consider in the layout
        var layout = this;

        // cy is automatically populated for us in the constructor
        var cy = options.cy; // jshint ignore:line

        layout.emit('layoutstart');

        // puts all nodes at (0, 0)
        eles.nodes().positions(function () {
          return {
            x: 0,
            y: 0
          };
        });

        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.emit('layoutready');

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.emit('layoutstop');

        return this; // chaining
      };

      // called on continuous layouts to stop them before they finish
      NullLayout.prototype.stop = function () {
        return this; // chaining
      };

      module.exports = NullLayout;

      /***/
    },
    /* 104 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var defaults = {
        positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
        zoom: undefined, // the zoom level to set (prob want fit = false if set)
        pan: undefined, // the pan level to set (prob want fit = false if set)
        fit: true, // whether to fit to viewport
        padding: 30, // padding on fit
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function PresetLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      PresetLayout.prototype.run = function () {
        var options = this.options;
        var eles = options.eles;

        var nodes = eles.nodes();
        var posIsFn = is.fn(options.positions);

        function getPosition(node) {
          if (options.positions == null) {
            return null;
          }

          if (posIsFn) {
            return options.positions(node);
          }

          var pos = options.positions[node._private.data.id];

          if (pos == null) {
            return null;
          }

          return pos;
        }

        nodes.layoutPositions(this, options, function (node, i) {
          var position = getPosition(node);

          if (node.locked() || position == null) {
            return false;
          }

          return position;
        });

        return this; // chaining
      };

      module.exports = PresetLayout;

      /***/
    },
    /* 105 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit to viewport
        padding: 30, // fit padding
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function RandomLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      RandomLayout.prototype.run = function () {
        var options = this.options;
        var cy = options.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var getPos = function getPos(node, i) {
          return {
            x: bb.x1 + Math.round(Math.random() * bb.w),
            y: bb.y1 + Math.round(Math.random() * bb.h)
          };
        };

        nodes.layoutPositions(this, options, getPos);

        return this; // chaining
      };

      module.exports = RandomLayout;

      /***/
    },
    /* 106 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // padding used on fit
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        condense: true, // uses all available space on false, uses minimal space on true
        rows: undefined, // force num of rows in the grid
        cols: undefined, // force num of columns in the grid
        position: function position(node) {}, // returns { row, col } for element
        sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts
      };

      function TreeLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      TreeLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        if (bb.h === 0 || bb.w === 0) {
          nodes.layoutPositions(this, options, function (ele) {
            return { x: bb.x1, y: bb.y1 };
          });
        } else {

          // width/height * splits^2 = cells where splits is number of times to split width
          var cells = nodes.size();
          var splits = Math.sqrt(cells * bb.h / bb.w);
          var rows = Math.round(splits);
          var cols = Math.round(bb.w / bb.h * splits);

          var small = function small(val) {
            if (val == null) {
              return Math.min(rows, cols);
            } else {
              var min = Math.min(rows, cols);
              if (min == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var large = function large(val) {
            if (val == null) {
              return Math.max(rows, cols);
            } else {
              var max = Math.max(rows, cols);
              if (max == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var oRows = options.rows;
          var oCols = options.cols != null ? options.cols : options.columns;

          // if rows or columns were set in options, use those values
          if (oRows != null && oCols != null) {
            rows = oRows;
            cols = oCols;
          } else if (oRows != null && oCols == null) {
            rows = oRows;
            cols = Math.ceil(cells / rows);
          } else if (oRows == null && oCols != null) {
            cols = oCols;
            rows = Math.ceil(cells / cols);
          }

          // otherwise use the automatic values and adjust accordingly

          // if rounding was up, see if we can reduce rows or columns
          else if (cols * rows > cells) {
              var sm = small();
              var lg = large();

              // reducing the small side takes away the most cells, so try it first
              if ((sm - 1) * lg >= cells) {
                small(sm - 1);
              } else if ((lg - 1) * sm >= cells) {
                large(lg - 1);
              }
            } else {

              // if rounding was too low, add rows or columns
              while (cols * rows < cells) {
                var _sm = small();
                var _lg = large();

                // try to add to larger side first (adds less in multiplication)
                if ((_lg + 1) * _sm >= cells) {
                  large(_lg + 1);
                } else {
                  small(_sm + 1);
                }
              }
            }

          var cellWidth = bb.w / cols;
          var cellHeight = bb.h / rows;

          if (options.condense) {
            cellWidth = 0;
            cellHeight = 0;
          }

          var widthCoefs = [];
          var widths = [];
          for (var i = 0; i < nodes.length; i++) {
            widthCoefs.push(1.0);
          }

          var posWordMax = {};
          if (options.avoidOverlap) {
            // iterate through all the nodes and set the cellWidth and cellHeight
            // to the maximum width/height seen in the graph plus a padding value
            for (var _i = 0; _i < nodes.length; _i++) {
              var clumpId = parseInt(nodes[_i]._private.data.clump);
              posWordMax[clumpId] = 0;
            }
            for (var _i2 = 0; _i2 < nodes.length; _i2++) {
              // the current node
              var node = nodes[_i2];
              var pos = node._private.position;

              if (pos.x == null || pos.y == null) {
                // for bb
                pos.x = 0;
                pos.y = 0;
              }

              var nbb = node.layoutDimensions(options);
              var p = options.avoidOverlapPadding;

              var w = nbb.w + p;
              var h = nbb.h + p;

              widths[_i2] = w;

              //console.log('tree.js: [' + i + '] ' + node._private.data.label);
              //console.log('tree.js: [' + i + '] ' + node._private.data.id);
              var _clumpId = parseInt(node._private.data.clump);
              //console.log('tree.js: [' + i + '] ' + clumpId);
              posWordMax[_clumpId] = Math.max(posWordMax[_clumpId], nbb.w + p);
              //console.log('tree.js: [' + i + '] ' + posWordMax[clumpId]);
              //console.log('tree.js: [' + i + '] nbb.w|nbb.h|cellWidth|cellHeight = ' + nbb.w +'|'+ nbb.h +'|'+ cellWidth +'|'+ cellHeight);
              cellWidth = Math.max(cellWidth, w);
              cellHeight = Math.max(cellHeight, h);
            }
            //console.log('tree.js: ** ' + Object.entries(posWordMax));
            for (var _i3 = 0; _i3 < nodes.length; _i3++) {
              widthCoefs[_i3] = widths[_i3] / cellWidth;
              //console.log('tree.js: posWordMax  ' + posWordMax[i]);
              if (widthCoefs[_i3] < 0.7) {
                widthCoefs[_i3] = 0.7;
              }
            }
            //console.log('tree.js ' + widthCoefs);
          }

          var cellUsed = {}; // e.g. 'c-0-2' => true

          var used = function used(row, col) {
            return cellUsed['c-' + row + '-' + col] ? true : false;
          };

          var use = function use(row, col) {
            cellUsed['c-' + row + '-' + col] = true;
          };

          // to keep track of current cell position
          var row = 0;
          var col = 0;
          var moveToNextCell = function moveToNextCell() {
            col++;
            if (col >= cols) {
              col = 0;
              row++;
            }
          };

          // get a cache of all the manual positions
          var id2manPos = {};
          for (var _i4 = 0; _i4 < nodes.length; _i4++) {
            var _node = nodes[_i4];
            var rcPos = options.position(_node);

            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
              // must have at least row or col def'd
              var _pos = {
                row: rcPos.row,
                col: rcPos.col
              };

              if (_pos.col === undefined) {
                // find unused col
                _pos.col = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.col++;
                }
              } else if (_pos.row === undefined) {
                // find unused row
                _pos.row = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.row++;
                }
              }

              id2manPos[_node.id()] = _pos;
              use(_pos.row, _pos.col);
            }
          }

          var getPos = function getPos(element, i) {
            var x = void 0,
                y = void 0;

            if (element.locked() || element.isParent()) {
              return false;
            }

            // see if we have a manual position set
            var rcPos = id2manPos[element.id()];
            if (rcPos) {
              x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
              y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
            } else {
              // otherwise set automatically
              while (used(row, col)) {
                moveToNextCell();
              }

              var prevNodes = 0;
              for (var ii = 0; ii < col; ii++) {
                prevNodes += posWordMax[ii];
              }
              var pad = 2;
              // this is where we set the final position
              //x = (0.1*cellWidth) + newX + (cellWidth * widthCoefs[col]) / 2 + bb.x1;
              x = prevNodes + pad * 2 * col + posWordMax[col] / 2;
              //x = col * cellWidth + cellWidth / 2 + bb.x1;
              y = row * cellHeight + cellHeight / 2 + bb.y1;

              log.debug('tree.js [' + row + '][' + col + '] x,y = ' + x + ',' + y);

              use(row, col);

              moveToNextCell();
            }

            return { x: x, y: y };
          };

          nodes.layoutPositions(this, options, getPos);
        }

        return this; // chaining
      };

      module.exports = TreeLayout;

      /***/
    },
    /* 107 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = [{ name: 'null', impl: __webpack_require__(108) }, { name: 'base', impl: __webpack_require__(109) }, { name: 'canvas', impl: __webpack_require__(125) }];

      /***/
    },
    /* 108 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function NullRenderer(options) {
        this.options = options;
        this.notifications = 0; // for testing
      }

      var noop = function noop() {};

      NullRenderer.prototype = {
        recalculateRenderedStyle: noop,
        notify: function notify() {
          this.notifications++;
        },
        init: noop
      };

      module.exports = NullRenderer;

      /***/
    },
    /* 109 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var window = __webpack_require__(3);

      var BaseRenderer = function BaseRenderer(options) {
        this.init(options);
      };
      var BR = BaseRenderer;
      var BRp = BR.prototype;

      BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

      BRp.init = function (options) {
        var r = this;

        r.options = options;

        r.cy = options.cy;

        var ctr = r.container = options.cy.container();

        // prepend a stylesheet in the head such that
        if (window) {
          var document = window.document;
          var head = document.head;
          var stylesheetId = '__________cytoscape_stylesheet';
          var className = '__________cytoscape_container';
          var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

          if (ctr.className.indexOf(className) < 0) {
            ctr.className = (ctr.className || '') + ' ' + className;
          }

          if (!stylesheetAlreadyExists) {
            var stylesheet = document.createElement('style');

            stylesheet.id = stylesheetId;
            stylesheet.innerHTML = '.' + className + ' { position: relative; }';

            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
          }

          var computedStyle = window.getComputedStyle(ctr);
          var position = computedStyle.getPropertyValue('position');

          if (position === 'static') {
            util.error('A Cytoscape container has style position:static and so can not use UI extensions properly');
          }
        }

        r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

        r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];

        //--Pointer-related data
        r.hoverData = { down: null, last: null,
          downTime: null, triggerMode: null,
          dragging: false,
          initialPan: [null, null], capture: false };

        r.dragData = { possibleDragElements: [] };

        r.touchData = {
          start: null, capture: false,

          // These 3 fields related to tap, taphold events
          startPosition: [null, null, null, null, null, null],
          singleTouchStartTime: null,
          singleTouchMoved: true,

          now: [null, null, null, null, null, null],
          earlier: [null, null, null, null, null, null]
        };

        r.redraws = 0;
        r.showFps = options.showFps;
        r.debug = options.debug;

        r.hideEdgesOnViewport = options.hideEdgesOnViewport;
        r.hideLabelsOnViewport = options.hideLabelsOnViewport;
        r.textureOnViewport = options.textureOnViewport;
        r.wheelSensitivity = options.wheelSensitivity;
        r.motionBlurEnabled = options.motionBlur; // on by default
        r.forcedPixelRatio = options.pixelRatio;
        r.motionBlur = options.motionBlur; // for initial kick off
        r.motionBlurOpacity = options.motionBlurOpacity;
        r.motionBlurTransparency = 1 - r.motionBlurOpacity;
        r.motionBlurPxRatio = 1;
        r.mbPxRBlurry = 1; //0.8;
        r.minMbLowQualFrames = 4;
        r.fullQualityMb = false;
        r.clearedForMotionBlur = [];
        r.desktopTapThreshold = options.desktopTapThreshold;
        r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
        r.touchTapThreshold = options.touchTapThreshold;
        r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
        r.tapholdDuration = 500;

        r.bindings = [];
        r.beforeRenderCallbacks = [];
        r.beforeRenderPriorities = { // higher priority execs before lower one
          animations: 400,
          eleCalcs: 300,
          eleTxrDeq: 200,
          lyrTxrDeq: 100
        };

        r.registerNodeShapes();
        r.registerArrowShapes();
        r.registerCalculationListeners();
      };

      BRp.notify = function (params) {
        var types;
        var r = this;

        // the renderer can't be notified after it's destroyed
        if (this.destroyed) {
          return;
        }

        if (is.array(params.type)) {
          types = params.type;
        } else {
          types = [params.type];
        }

        var has = {};
        for (var i = 0; i < types.length; i++) {
          var type = types[i];

          has[type] = true;
        } // for

        if (has['init']) {
          r.load();
          return;
        }

        if (has['destroy']) {
          r.destroy();
          return;
        }

        if (has['add'] || has['remove'] || has['load'] || has['zorder']) {
          r.invalidateCachedZSortedEles();
        }

        if (has['viewport']) {
          r.redrawHint('select', true);
        }

        if (has['load'] || has['resize']) {
          r.invalidateContainerClientCoordsCache();
          r.matchCanvasSize(r.container);
        }

        r.redrawHint('eles', true);
        r.redrawHint('drag', true);

        this.startRenderLoop();

        this.redraw();
      };

      BRp.destroy = function () {
        var r = this;

        r.destroyed = true;

        r.cy.stopAnimationLoop();

        for (var i = 0; i < r.bindings.length; i++) {
          var binding = r.bindings[i];
          var b = binding;
          var tgt = b.target;

          (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
        }

        r.bindings = [];
        r.beforeRenderCallbacks = [];
        r.onUpdateEleCalcsFns = [];

        if (r.removeObserver) {
          r.removeObserver.disconnect();
        }

        if (r.styleObserver) {
          r.styleObserver.disconnect();
        }

        if (r.labelCalcDiv) {
          try {
            document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
          } catch (e) {
            // ie10 issue #1014
          }
        }
      };

      [__webpack_require__(110), __webpack_require__(111), __webpack_require__(121), __webpack_require__(122), __webpack_require__(123), __webpack_require__(124)].forEach(function (props) {
        util.extend(BRp, props);
      });

      module.exports = BR;

      /***/
    },
    /* 110 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var BRp = {};

      BRp.arrowShapeWidth = 0.3;

      BRp.registerArrowShapes = function () {
        var arrowShapes = this.arrowShapes = {};
        var renderer = this;

        // Contract for arrow shapes:
        // 0, 0 is arrow tip
        // (0, 1) is direction towards node
        // (1, 0) is right
        //
        // functional api:
        // collide: check x, y in shape
        // roughCollide: called before collide, no false negatives
        // draw: draw
        // spacing: dist(arrowTip, nodeBoundary)
        // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

        var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
          var x1 = translation.x - size / 2 - padding;
          var x2 = translation.x + size / 2 + padding;
          var y1 = translation.y - size / 2 - padding;
          var y2 = translation.y + size / 2 + padding;

          var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;

          return inside;
        };

        var transform = function transform(x, y, size, angle, translation) {
          var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
          var yRotated = x * Math.sin(angle) + y * Math.cos(angle);

          var xScaled = xRotated * size;
          var yScaled = yRotated * size;

          var xTranslated = xScaled + translation.x;
          var yTranslated = yScaled + translation.y;

          return {
            x: xTranslated,
            y: yTranslated
          };
        };

        var transformPoints = function transformPoints(pts, size, angle, translation) {
          var retPts = [];

          for (var i = 0; i < pts.length; i += 2) {
            var x = pts[i];
            var y = pts[i + 1];

            retPts.push(transform(x, y, size, angle, translation));
          }

          return retPts;
        };

        var pointsToArr = function pointsToArr(pts) {
          var ret = [];

          for (var i = 0; i < pts.length; i++) {
            var p = pts[i];

            ret.push(p.x, p.y);
          }

          return ret;
        };

        var standardGap = function standardGap(edge) {
          return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
        };

        var defineArrowShape = function defineArrowShape(name, defn) {
          if (is.string(defn)) {
            defn = arrowShapes[defn];
          }

          arrowShapes[name] = util.extend({
            name: name,

            points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],

            collide: function collide(x, y, size, angle, translation, padding) {
              var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
              var inside = math.pointInsidePolygonPoints(x, y, points);

              return inside;
            },

            roughCollide: bbCollide,

            draw: function draw(context, size, angle, translation) {
              var points = transformPoints(this.points, size, angle, translation);

              renderer.arrowShapeImpl('polygon')(context, points);
            },

            spacing: function spacing(edge) {
              return 0;
            },

            gap: standardGap
          }, defn);
        };

        defineArrowShape('none', {
          collide: util.falsify,

          roughCollide: util.falsify,

          draw: util.noop,

          spacing: util.zeroify,

          gap: util.zeroify
        });

        defineArrowShape('triangle', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
        });

        defineArrowShape('arrow', 'triangle');

        defineArrowShape('triangle-backcurve', {
          points: arrowShapes['triangle'].points,

          controlPoint: [0, -0.15],

          roughCollide: bbCollide,

          draw: function draw(context, size, angle, translation, edgeWidth) {
            var ptsTrans = transformPoints(this.points, size, angle, translation);
            var ctrlPt = this.controlPoint;
            var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);

            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
          },

          gap: function gap(edge) {
            return standardGap(edge) * 0.8;
          }
        });

        defineArrowShape('triangle-tee', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

          pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],

          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));

            var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

            return inside;
          },

          draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.points, size, angle, translation);
            var teePts = transformPoints(this.pointsTee, size, angle, translation);

            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
          }
        });

        defineArrowShape('triangle-cross', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

          baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
          -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
          0.15, -0.4],

          crossLinePts: function crossLinePts(size, edgeWidth) {
            // shift points so that the distance between the cross points matches edge width
            var p = this.baseCrossLinePts.slice();
            var shiftFactor = edgeWidth / size;
            var y0 = 3;
            var y1 = 5;

            p[y0] = p[y0] - shiftFactor;
            p[y1] = p[y1] - shiftFactor;

            return p;
          },

          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
            var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

            return inside;
          },

          draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.points, size, angle, translation);
            var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);

            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
          }
        });

        defineArrowShape('vee', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],

          gap: function gap(edge) {
            return standardGap(edge) * 0.525;
          }
        });

        defineArrowShape('circle', {
          radius: 0.15,

          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var t = translation;
            var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);

            return inside;
          },

          draw: function draw(context, size, angle, translation, edgeWidth) {
            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
          },

          spacing: function spacing(edge) {
            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
          }
        });

        defineArrowShape('tee', {
          points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],

          spacing: function spacing(edge) {
            return 1;
          },

          gap: function gap(edge) {
            return 1;
          }
        });

        defineArrowShape('square', {
          points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
        });

        defineArrowShape('diamond', {
          points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],

          gap: function gap(edge) {
            return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
          }
        });
      };

      module.exports = BRp;

      /***/
    },
    /* 111 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var BRp = {};

      [__webpack_require__(112), __webpack_require__(113), __webpack_require__(114), __webpack_require__(115), __webpack_require__(116), __webpack_require__(117), __webpack_require__(118), __webpack_require__(119), __webpack_require__(120)].forEach(function (props) {
        util.extend(BRp, props);
      });

      module.exports = BRp;

      /***/
    },
    /* 112 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);
      var math = __webpack_require__(2);
      var util = __webpack_require__(1);
      var window = __webpack_require__(3);

      var BRp = {};

      // Project mouse
      BRp.projectIntoViewport = function (clientX, clientY) {
        var cy = this.cy;
        var offsets = this.findContainerClientCoords();
        var offsetLeft = offsets[0];
        var offsetTop = offsets[1];
        var scale = offsets[4];
        var pan = cy.pan();
        var zoom = cy.zoom();

        var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
        var y = ((clientY - offsetTop) / scale - pan.y) / zoom;

        return [x, y];
      };

      BRp.findContainerClientCoords = function () {
        if (this.containerBB) {
          return this.containerBB;
        }

        var container = this.container;
        var rect = container.getBoundingClientRect();
        var style = window.getComputedStyle(container);
        var styleValue = function styleValue(name) {
          return parseFloat(style.getPropertyValue(name));
        };

        var padding = {
          left: styleValue('padding-left'),
          right: styleValue('padding-right'),
          top: styleValue('padding-top'),
          bottom: styleValue('padding-bottom')
        };

        var border = {
          left: styleValue('border-left-width'),
          right: styleValue('border-right-width'),
          top: styleValue('border-top-width'),
          bottom: styleValue('border-bottom-width')
        };

        var clientWidth = container.clientWidth;
        var clientHeight = container.clientHeight;

        var paddingHor = padding.left + padding.right;
        var paddingVer = padding.top + padding.bottom;

        var borderHor = border.left + border.right;
        var borderVer = border.top + border.bottom;

        var scale = rect.width / (clientWidth + borderHor);

        var unscaledW = clientWidth - paddingHor;
        var unscaledH = clientHeight - paddingVer;

        var scaledW = rect.width - (paddingHor + borderHor) * scale;
        var scaledH = rect.height - (paddingVer + borderVer) * scale;

        var left = rect.left + padding.left + border.left;
        var top = rect.top + padding.top + border.top;

        return this.containerBB = [left, top, unscaledW, unscaledH, scale];
      };

      BRp.invalidateContainerClientCoordsCache = function () {
        this.containerBB = null;
      };

      BRp.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
        return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
      };

      BRp.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
        var self = this;
        var r = this;
        var eles = r.getCachedZSortedEles();
        var near = []; // 1 node max, 1 edge max
        var zoom = r.cy.zoom();
        var hasCompounds = r.cy.hasCompoundNodes();
        var edgeThreshold = (isTouch ? 24 : 8) / zoom;
        var nodeThreshold = (isTouch ? 8 : 2) / zoom;
        var labelThreshold = (isTouch ? 8 : 2) / zoom;
        var minSqDist = Infinity;
        var nearEdge;
        var nearNode;

        if (interactiveElementsOnly) {
          eles = eles.interactive;
        }

        function addEle(ele, sqDist) {
          if (ele.isNode()) {
            if (nearNode) {
              return; // can't replace node
            } else {
              nearNode = ele;
              near.push(ele);
            }
          }

          if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
            if (nearEdge) {
              // then replace existing edge
              // can replace only if same z-index
              if (nearEdge.pstyle('z-index').value === ele.pstyle('z-index').value) {
                for (var i = 0; i < near.length; i++) {
                  if (near[i].isEdge()) {
                    near[i] = ele;
                    nearEdge = ele;
                    minSqDist = sqDist != null ? sqDist : minSqDist;
                    break;
                  }
                }
              }
            } else {
              near.push(ele);
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
            }
          }
        }

        function checkNode(node) {
          var width = node.outerWidth() + 2 * nodeThreshold;
          var height = node.outerHeight() + 2 * nodeThreshold;
          var hw = width / 2;
          var hh = height / 2;
          var pos = node.position();

          if (pos.x - hw <= x && x <= pos.x + hw // bb check x
          && pos.y - hh <= y && y <= pos.y + hh // bb check y
          ) {
              var shape = r.nodeShapes[self.getNodeShape(node)];

              if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
                addEle(node, 0);
                return true;
              }
            }
        }

        function checkEdge(edge) {
          var _p = edge._private;

          var rs = _p.rscratch;
          var styleWidth = edge.pstyle('width').pfValue;
          var scale = edge.pstyle('arrow-scale').value;
          var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
          var widthSq = width * width;
          var width2 = width * 2;
          var src = _p.source;
          var tgt = _p.target;
          var inEdgeBB = false;
          var sqDist;

          if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
            var pts = rs.allpts;

            for (var i = 0; i + 3 < pts.length; i += 2) {
              if ((inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2)) && widthSq > (sqDist = math.sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
                addEle(edge, sqDist);
                return true;
              }
            }
          } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
            var pts = rs.allpts;
            for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
              if ((inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2)) && widthSq > (sqDist = math.sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
                addEle(edge, sqDist);
                return true;
              }
            }
          }

          // if we're close to the edge but didn't hit it, maybe we hit its arrows

          var src = src || _p.source;
          var tgt = tgt || _p.target;

          var arSize = self.getArrowWidth(styleWidth, scale);

          var arrows = [{ name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle }, { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle }, { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle }, { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }];

          for (var i = 0; i < arrows.length; i++) {
            var ar = arrows[i];
            var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
            var edgeWidth = edge.pstyle('width').pfValue;
            if (shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold)) {
              addEle(edge);
              return true;
            }
          }

          // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
          if (hasCompounds && near.length > 0) {
            checkNode(src);
            checkNode(tgt);
          }
        }

        function preprop(obj, name, pre) {
          return util.getPrefixedProperty(obj, name, pre);
        }

        function checkLabel(ele, prefix) {
          var _p = ele._private;
          var th = labelThreshold;

          var prefixDash;
          if (prefix) {
            prefixDash = prefix + '-';
          } else {
            prefixDash = '';
          }

          var text = ele.pstyle(prefixDash + 'label').value;
          var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

          if (!eventsEnabled || !text) {
            return;
          }

          var rstyle = _p.rstyle;
          var bw = ele.pstyle('text-border-width').pfValue;
          var pw = ele.pstyle('text-background-padding').pfValue;
          var lw = preprop(rstyle, 'labelWidth', prefix) + bw + 2 * th + 2 * pw;
          var lh = preprop(rstyle, 'labelHeight', prefix) + bw + 2 * th + 2 * pw;
          var lx = preprop(rstyle, 'labelX', prefix);
          var ly = preprop(rstyle, 'labelY', prefix);

          var theta = preprop(_p.rscratch, 'labelAngle', prefix);

          var lx1 = lx - lw / 2;
          var lx2 = lx + lw / 2;
          var ly1 = ly - lh / 2;
          var ly2 = ly + lh / 2;

          if (theta) {
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);

            var rotate = function rotate(x, y) {
              x = x - lx;
              y = y - ly;

              return {
                x: x * cos - y * sin + lx,
                y: x * sin + y * cos + ly
              };
            };

            var px1y1 = rotate(lx1, ly1);
            var px1y2 = rotate(lx1, ly2);
            var px2y1 = rotate(lx2, ly1);
            var px2y2 = rotate(lx2, ly2);

            var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

            if (math.pointInsidePolygonPoints(x, y, points)) {
              addEle(ele);
              return true;
            }
          } else {
            // do a cheaper bb check
            var bb = {
              w: lw,
              h: lh,
              x1: lx1,
              x2: lx2,
              y1: ly1,
              y2: ly2
            };

            if (math.inBoundingBox(bb, x, y)) {
              addEle(ele);
              return true;
            }
          }
        }

        for (var i = eles.length - 1; i >= 0; i--) {
          // reverse order for precedence
          var ele = eles[i];

          if (ele.isNode()) {
            checkNode(ele) || checkLabel(ele);
          } else {
            // then edge
            checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
          }
        }

        return near;
      };

      // 'Give me everything from this box'
      BRp.getAllInBox = function (x1, y1, x2, y2) {
        var eles = this.getCachedZSortedEles().interactive;
        var box = [];

        var x1c = Math.min(x1, x2);
        var x2c = Math.max(x1, x2);
        var y1c = Math.min(y1, y2);
        var y2c = Math.max(y1, y2);

        x1 = x1c;
        x2 = x2c;
        y1 = y1c;
        y2 = y2c;

        var boxBb = math.makeBoundingBox({
          x1: x1, y1: y1,
          x2: x2, y2: y2
        });

        for (var e = 0; e < eles.length; e++) {
          var ele = eles[e];

          if (ele.isNode()) {
            var node = ele;
            var nodeBb = node.boundingBox({
              includeNodes: true,
              includeEdges: false,
              includeLabels: false
            });

            if (math.boundingBoxesIntersect(boxBb, nodeBb) && !math.boundingBoxInBoundingBox(nodeBb, boxBb)) {
              box.push(node);
            }
          } else {
            var edge = ele;
            var _p = edge._private;
            var rs = _p.rscratch;

            if (rs.startX != null && rs.startY != null && !math.inBoundingBox(boxBb, rs.startX, rs.startY)) {
              continue;
            }
            if (rs.endX != null && rs.endY != null && !math.inBoundingBox(boxBb, rs.endX, rs.endY)) {
              continue;
            }

            if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {

              var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
              var allInside = true;

              for (var i = 0; i < pts.length; i++) {
                if (!math.pointInBoundingBox(boxBb, pts[i])) {
                  allInside = false;
                  break;
                }
              }

              if (allInside) {
                box.push(edge);
              }
            } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
              box.push(edge);
            }
          }
        }

        return box;
      };

      module.exports = BRp;

      /***/
    },
    /* 113 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var BRp = {};

      BRp.calculateArrowAngles = function (edge) {
        var rs = edge._private.rscratch;
        var isHaystack = rs.edgeType === 'haystack';
        var isBezier = rs.edgeType === 'bezier';
        var isMultibezier = rs.edgeType === 'multibezier';
        var isSegments = rs.edgeType === 'segments';
        var isCompound = rs.edgeType === 'compound';
        var isSelf = rs.edgeType === 'self';

        // Displacement gives direction for arrowhead orientation
        var dispX, dispY;
        var startX, startY, endX, endY, midX, midY;

        if (isHaystack) {
          startX = rs.haystackPts[0];
          startY = rs.haystackPts[1];
          endX = rs.haystackPts[2];
          endY = rs.haystackPts[3];
        } else {
          startX = rs.arrowStartX;
          startY = rs.arrowStartY;
          endX = rs.arrowEndX;
          endY = rs.arrowEndY;
        }

        midX = rs.midX;
        midY = rs.midY;

        // source
        //

        if (isSegments) {
          dispX = startX - rs.segpts[0];
          dispY = startY - rs.segpts[1];
        } else if (isMultibezier || isCompound || isSelf || isBezier) {
          var pts = rs.allpts;
          var bX = math.qbezierAt(pts[0], pts[2], pts[4], 0.1);
          var bY = math.qbezierAt(pts[1], pts[3], pts[5], 0.1);

          dispX = startX - bX;
          dispY = startY - bY;
        } else {
          dispX = startX - midX;
          dispY = startY - midY;
        }

        rs.srcArrowAngle = math.getAngleFromDisp(dispX, dispY);

        // mid target
        //

        var midX = rs.midX;
        var midY = rs.midY;

        if (isHaystack) {
          midX = (startX + endX) / 2;
          midY = (startY + endY) / 2;
        }

        dispX = endX - startX;
        dispY = endY - startY;

        if (isSegments) {
          var pts = rs.allpts;

          if (pts.length / 2 % 2 === 0) {
            var i2 = pts.length / 2;
            var i1 = i2 - 2;

            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
          } else {
            var i2 = pts.length / 2 - 1;
            var i1 = i2 - 2;
            var i3 = i2 + 2;

            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
          }
        } else if (isMultibezier || isCompound || isSelf) {
          var pts = rs.allpts;
          var cpts = rs.ctrlpts;
          var bp0x, bp0y;
          var bp1x, bp1y;

          if (cpts.length / 2 % 2 === 0) {
            var p0 = pts.length / 2 - 1; // startpt
            var ic = p0 + 2;
            var p1 = ic + 2;

            bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
            bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);

            bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
            bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
          } else {
            var ic = pts.length / 2 - 1; // ctrpt
            var p0 = ic - 2; // startpt
            var p1 = ic + 2; // endpt

            bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
            bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);

            bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
            bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
          }

          dispX = bp1x - bp0x;
          dispY = bp1y - bp0y;
        }

        rs.midtgtArrowAngle = math.getAngleFromDisp(dispX, dispY);

        rs.midDispX = dispX;
        rs.midDispY = dispY;

        // mid source
        //

        dispX *= -1;
        dispY *= -1;

        if (isSegments) {
          var pts = rs.allpts;

          if (pts.length / 2 % 2 === 0) {
            // already ok
          } else {
            var i2 = pts.length / 2 - 1;
            var i3 = i2 + 2;

            dispX = -(pts[i3] - pts[i2]);
            dispY = -(pts[i3 + 1] - pts[i2 + 1]);
          }
        }

        rs.midsrcArrowAngle = math.getAngleFromDisp(dispX, dispY);

        // target
        //

        if (isSegments) {
          dispX = endX - rs.segpts[rs.segpts.length - 2];
          dispY = endY - rs.segpts[rs.segpts.length - 1];
        } else if (isMultibezier || isCompound || isSelf || isBezier) {
          var pts = rs.allpts;
          var l = pts.length;
          var bX = math.qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
          var bY = math.qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);

          dispX = endX - bX;
          dispY = endY - bY;
        } else {
          dispX = endX - midX;
          dispY = endY - midY;
        }

        rs.tgtArrowAngle = math.getAngleFromDisp(dispX, dispY);
      };

      BRp.getArrowWidth = BRp.getArrowHeight = function (edgeWidth, scale) {
        var cache = this.arrowWidthCache = this.arrowWidthCache || {};

        var cachedVal = cache[edgeWidth + ', ' + scale];
        if (cachedVal) {
          return cachedVal;
        }

        cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
        cache[edgeWidth + ', ' + scale] = cachedVal;

        return cachedVal;
      };

      module.exports = BRp;

      /***/
    },
    /* 114 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var BRp = {};

      BRp.findEdgeControlPoints = function (edges) {
        if (!edges || edges.length === 0) {
          return;
        }

        var r = this;
        var cy = r.cy;
        var hasCompounds = cy.hasCompoundNodes();
        var hashTable = {};
        var pairIds = [];
        var haystackEdges = [];

        // create a table of edge (src, tgt) => list of edges between them
        var pairId;
        for (var i = 0; i < edges.length; i++) {
          var edge = edges[i];
          var _p = edge._private;
          var data = _p.data;
          var curveStyle = edge.pstyle('curve-style').value;
          var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';
          var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';

          // ignore edges who are not to be displayed
          // they shouldn't take up space
          if (edge.pstyle('display').value === 'none') {
            continue;
          }

          if (curveStyle === 'haystack') {
            haystackEdges.push(edge);
            continue;
          }

          var srcId = data.source;
          var tgtId = data.target;

          pairId = srcId > tgtId ? tgtId + '$-$' + srcId : srcId + '$-$' + tgtId;

          if (edgeIsUnbundled) {
            pairId = 'unbundled' + '$-$' + data.id;
          }

          var tableEntry = hashTable[pairId];

          if (tableEntry == null) {
            tableEntry = hashTable[pairId] = [];
            pairIds.push(pairId);
          }

          tableEntry.push(edge);

          if (edgeIsUnbundled) {
            tableEntry.hasUnbundled = true;
          }

          if (edgeIsBezier) {
            tableEntry.hasBezier = true;
          }
        }

        var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
        var vectorNormInverse;
        var badBezier;

        // for each pair (src, tgt), create the ctrl pts
        // Nested for loop is OK; total number of iterations for both loops = edgeCount
        for (var p = 0; p < pairIds.length; p++) {
          pairId = pairIds[p];
          var pairEdges = hashTable[pairId];

          // for each pair id, the edges should be sorted by index
          pairEdges.sort(function (edge1, edge2) {
            return edge1.poolIndex() - edge2.poolIndex();
          });

          src = pairEdges[0]._private.source;
          tgt = pairEdges[0]._private.target;

          // make sure src/tgt distinction is consistent for bundled edges
          if (!pairEdges.hasUnbundled && src.id() > tgt.id()) {
            var temp = src;
            src = tgt;
            tgt = temp;
          }

          srcPos = src.position();
          tgtPos = tgt.position();

          srcW = src.outerWidth();
          srcH = src.outerHeight();

          tgtW = tgt.outerWidth();
          tgtH = tgt.outerHeight();

          srcShape = r.nodeShapes[this.getNodeShape(src)];
          tgtShape = r.nodeShapes[this.getNodeShape(tgt)];

          badBezier = false;

          var edge;
          var edge_p;
          var rs;

          var dirCounts = {
            'north': 0,
            'west': 0,
            'south': 0,
            'east': 0,
            'northwest': 0,
            'southwest': 0,
            'northeast': 0,
            'southeast': 0
          };

          var srcX2 = srcPos.x;
          var srcY2 = srcPos.y;
          var srcW2 = srcW;
          var srcH2 = srcH;

          var tgtX2 = tgtPos.x;
          var tgtY2 = tgtPos.y;
          var tgtW2 = tgtW;
          var tgtH2 = tgtH;

          var numEdges2 = pairEdges.length;

          for (var i = 0; i < pairEdges.length; i++) {
            edge = pairEdges[i];
            edge_p = edge._private;
            rs = edge_p.rscratch;

            var edgeIndex1 = rs.lastEdgeIndex;
            var edgeIndex2 = i;

            var numEdges1 = rs.lastNumEdges;

            var curveStyle = edge.pstyle('curve-style').value;

            var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

            // whether the normalised pair order is the reverse of the edge's src-tgt order
            var edgeIsSwapped = src.id() !== edge.source().id();

            var ctrlptDists = edge.pstyle('control-point-distances');
            var loopDir = edge.pstyle('loop-direction').pfValue;
            var loopSwp = edge.pstyle('loop-sweep').pfValue;
            var ctrlptWs = edge.pstyle('control-point-weights');
            var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
            var stepSize = edge.pstyle('control-point-step-size').pfValue;
            var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
            var ctrlptWeight = ctrlptWs.value[0];
            var edgeDistances = edge.pstyle('edge-distances').value;
            var segmentWs = edge.pstyle('segment-weights');
            var segmentDs = edge.pstyle('segment-distances');
            var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
            var srcEndpt = edge.pstyle('source-endpoint').value;
            var tgtEndpt = edge.pstyle('target-endpoint').value;
            var srcArrShape = edge.pstyle('source-arrow-shape').value;
            var tgtArrShape = edge.pstyle('target-arrow-shape').value;
            var arrowScale = edge.pstyle('arrow-scale').value;
            var lineWidth = edge.pstyle('width').pfValue;

            var srcX1 = rs.lastSrcCtlPtX;
            var srcY1 = rs.lastSrcCtlPtY;
            var srcW1 = rs.lastSrcCtlPtW;
            var srcH1 = rs.lastSrcCtlPtH;

            var tgtX1 = rs.lastTgtCtlPtX;
            var tgtY1 = rs.lastTgtCtlPtY;
            var tgtW1 = rs.lastTgtCtlPtW;
            var tgtH1 = rs.lastTgtCtlPtH;

            var curveStyle1 = rs.lastCurveStyle;
            var curveStyle2 = curveStyle;

            var ctrlptDists1 = rs.lastCtrlptDists;
            var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;

            var ctrlptWs1 = rs.lastCtrlptWs;
            var ctrlptWs2 = ctrlptWs.strValue;

            var segmentWs1 = rs.lastSegmentWs;
            var segmentWs2 = segmentWs.strValue;

            var segmentDs1 = rs.lastSegmentDs;
            var segmentDs2 = segmentDs.strValue;

            var stepSize1 = rs.lastStepSize;
            var stepSize2 = stepSize;

            var loopDir1 = rs.lastLoopDir;
            var loopDir2 = loopDir;

            var loopSwp1 = rs.lastLoopSwp;
            var loopSwp2 = loopSwp;

            var edgeDistances1 = rs.lastEdgeDistances;
            var edgeDistances2 = edgeDistances;

            var srcEndpt1 = rs.lastSrcEndpt;
            var srcEndpt2 = srcEndpt;

            var tgtEndpt1 = rs.lastTgtEndpt;
            var tgtEndpt2 = tgtEndpt;

            var srcArr1 = rs.lastSrcArr;
            var srcArr2 = srcArrShape;

            var tgtArr1 = rs.lastTgtArr;
            var tgtArr2 = tgtArrShape;

            var lineW1 = rs.lastLineW;
            var lineW2 = lineWidth;

            var arrScl1 = rs.lastArrScl;
            var arrScl2 = arrowScale;

            if (badBezier) {
              rs.badBezier = true;
            } else {
              rs.badBezier = false;
            }

            var ptCacheHit;

            if (srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2 && tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2 && curveStyle1 === curveStyle2 && ctrlptDists1 === ctrlptDists2 && ctrlptWs1 === ctrlptWs2 && segmentWs1 === segmentWs2 && segmentDs1 === segmentDs2 && stepSize1 === stepSize2 && loopDir1 === loopDir2 && loopSwp1 === loopSwp2 && edgeDistances1 === edgeDistances2 && srcEndpt1 === srcEndpt2 && tgtEndpt1 === tgtEndpt2 && srcArr1 === srcArr2 && tgtArr1 === tgtArr2 && lineW1 === lineW2 && arrScl1 === arrScl2 && (edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2 || edgeIsUnbundled)) {
              ptCacheHit = true; // then the control points haven't changed and we can skip calculating them
            } else {
              ptCacheHit = false;

              rs.lastSrcCtlPtX = srcX2;
              rs.lastSrcCtlPtY = srcY2;
              rs.lastSrcCtlPtW = srcW2;
              rs.lastSrcCtlPtH = srcH2;
              rs.lastTgtCtlPtX = tgtX2;
              rs.lastTgtCtlPtY = tgtY2;
              rs.lastTgtCtlPtW = tgtW2;
              rs.lastTgtCtlPtH = tgtH2;
              rs.lastEdgeIndex = edgeIndex2;
              rs.lastNumEdges = numEdges2;
              rs.lastCurveStyle = curveStyle2;
              rs.lastCtrlptDists = ctrlptDists2;
              rs.lastCtrlptWs = ctrlptWs2;
              rs.lastSegmentDs = segmentDs2;
              rs.lastSegmentWs = segmentWs2;
              rs.lastStepSize = stepSize2;
              rs.lastLoopDir = loopDir2;
              rs.lastLoopSwp = loopSwp2;
              rs.lastEdgeDistances = edgeDistances2;
              rs.lastSrcEndpt = srcEndpt2;
              rs.lastTgtEndpt = tgtEndpt2;
              rs.lastSrcArr = srcArr2;
              rs.lastTgtArr = tgtArr2;
              rs.lastLineW = lineW2;
              rs.lastArrScl = arrScl2;
            }

            if (!ptCacheHit) {

              if (!pairEdges.calculatedIntersection && src !== tgt && (pairEdges.hasBezier || pairEdges.hasUnbundled)) {

                pairEdges.calculatedIntersection = true;

                // pt outside src shape to calc distance/displacement from src to tgt
                var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);

                pairEdges.srcIntn = srcOutside;

                // pt outside tgt shape to calc distance/displacement from src to tgt
                var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);

                pairEdges.tgtIntn = tgtOutside;

                var midptSrcPts = {
                  x1: srcOutside[0],
                  x2: tgtOutside[0],
                  y1: srcOutside[1],
                  y2: tgtOutside[1]
                };

                var posPts = {
                  x1: srcPos.x,
                  x2: tgtPos.x,
                  y1: srcPos.y,
                  y2: tgtPos.y
                };

                var dy = tgtOutside[1] - srcOutside[1];
                var dx = tgtOutside[0] - srcOutside[0];
                var l = Math.sqrt(dx * dx + dy * dy);

                var vector = {
                  x: dx,
                  y: dy
                };

                var vectorNorm = {
                  x: vector.x / l,
                  y: vector.y / l
                };
                vectorNormInverse = {
                  x: -vectorNorm.y,
                  y: vectorNorm.x
                };

                // if node shapes overlap, then no ctrl pts to draw
                if (tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) && srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y)) {
                  vectorNormInverse = {};
                  badBezier = true;
                }
              }

              if (!edgeIsSwapped) {
                rs.srcIntn = pairEdges.srcIntn;
                rs.tgtIntn = pairEdges.tgtIntn;
              } else {
                // ensure that the per-edge cached value for intersections are correct for swapped bundled edges
                rs.srcIntn = pairEdges.tgtIntn;
                rs.tgtIntn = pairEdges.srcIntn;
              }

              if (src === tgt) {
                // Self-edge

                rs.edgeType = 'self';

                var j = i;
                var loopDist = stepSize;

                if (edgeIsUnbundled) {
                  j = 0;
                  loopDist = ctrlptDist;
                }

                var loopAngle = loopDir - Math.PI / 2;
                var outAngle = loopAngle - loopSwp / 2;
                var inAngle = loopAngle + loopSwp / 2;

                // increase by step size for overlapping loops, keyed on direction and sweep values
                var dc = String(loopDir + '_' + loopSwp);
                j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

                rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
              } else if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src))) {
                // Compound edge

                rs.edgeType = 'compound';

                // because the line approximation doesn't apply for compound beziers
                // (loop/self edges are already elided b/c of cheap src==tgt check)
                rs.badBezier = false;

                var j = i;
                var loopDist = stepSize;

                if (edgeIsUnbundled) {
                  j = 0;
                  loopDist = ctrlptDist;
                }

                var loopW = 50;

                var loopaPos = {
                  x: srcPos.x - srcW / 2,
                  y: srcPos.y - srcH / 2
                };

                var loopbPos = {
                  x: tgtPos.x - tgtW / 2,
                  y: tgtPos.y - tgtH / 2
                };

                var loopPos = {
                  x: Math.min(loopaPos.x, loopbPos.x),
                  y: Math.min(loopaPos.y, loopbPos.y)
                };

                // avoids cases with impossible beziers
                var minCompoundStretch = 0.5;
                var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
                var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));

                rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
              } else if (curveStyle === 'segments') {
                // Segments (multiple straight lines)

                rs.edgeType = 'segments';
                rs.segpts = [];

                for (var s = 0; s < segmentsN; s++) {
                  var w = segmentWs.pfValue[s];
                  var d = segmentDs.pfValue[s];

                  var w1 = 1 - w;
                  var w2 = w;

                  var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

                  var adjustedMidpt = {
                    x: midptPts.x1 * w1 + midptPts.x2 * w2,
                    y: midptPts.y1 * w1 + midptPts.y2 * w2
                  };

                  rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
                }

                // Straight edge
              } else if (pairEdges.length % 2 === 1 && i === Math.floor(pairEdges.length / 2) && !edgeIsUnbundled) {

                rs.edgeType = 'straight';
              } else {
                // (Multi)bezier

                var multi = edgeIsUnbundled;

                rs.edgeType = multi ? 'multibezier' : 'bezier';
                rs.ctrlpts = [];

                for (var b = 0; b < bezierN; b++) {
                  var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
                  var manctrlptDist;
                  var sign = math.signum(normctrlptDist);

                  if (multi) {
                    ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
                    ctrlptWeight = ctrlptWs.value[b];
                  }

                  if (edgeIsUnbundled) {
                    // multi or single unbundled
                    manctrlptDist = ctrlptDist;
                  } else {
                    manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
                  }

                  var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

                  var w1 = 1 - ctrlptWeight;
                  var w2 = ctrlptWeight;

                  if (edgeIsSwapped) {
                    var temp = w1;
                    w1 = w2;
                    w2 = temp;
                  }

                  var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

                  var adjustedMidpt = {
                    x: midptPts.x1 * w1 + midptPts.x2 * w2,
                    y: midptPts.y1 * w1 + midptPts.y2 * w2
                  };

                  rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
                }
              }

              // find endpts for edge
              this.findEndpoints(edge);

              var badStart = !is.number(rs.startX) || !is.number(rs.startY);
              var badAStart = !is.number(rs.arrowStartX) || !is.number(rs.arrowStartY);
              var badEnd = !is.number(rs.endX) || !is.number(rs.endY);
              var badAEnd = !is.number(rs.arrowEndX) || !is.number(rs.arrowEndY);

              var minCpADistFactor = 3;
              var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
              var minCpADist = minCpADistFactor * arrowW;

              if (rs.edgeType === 'bezier') {
                var startACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY });
                var closeStartACp = startACpDist < minCpADist;
                var endACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY });
                var closeEndACp = endACpDist < minCpADist;

                var overlapping = false;

                if (badStart || badAStart || closeStartACp) {
                  overlapping = true;

                  // project control point along line from src centre to outside the src shape
                  // (otherwise intersection will yield nothing)
                  var cpD = { // delta
                    x: rs.ctrlpts[0] - srcPos.x,
                    y: rs.ctrlpts[1] - srcPos.y
                  };
                  var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
                  var cpM = { // normalised delta
                    x: cpD.x / cpL,
                    y: cpD.y / cpL
                  };
                  var radius = Math.max(srcW, srcH);
                  var cpProj = { // *2 radius guarantees outside shape
                    x: rs.ctrlpts[0] + cpM.x * 2 * radius,
                    y: rs.ctrlpts[1] + cpM.y * 2 * radius
                  };

                  var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

                  if (closeStartACp) {
                    rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
                    rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
                  } else {
                    rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
                    rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
                  }
                }

                if (badEnd || badAEnd || closeEndACp) {
                  overlapping = true;

                  // project control point along line from tgt centre to outside the tgt shape
                  // (otherwise intersection will yield nothing)
                  var cpD = { // delta
                    x: rs.ctrlpts[0] - tgtPos.x,
                    y: rs.ctrlpts[1] - tgtPos.y
                  };
                  var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
                  var cpM = { // normalised delta
                    x: cpD.x / cpL,
                    y: cpD.y / cpL
                  };
                  var radius = Math.max(srcW, srcH);
                  var cpProj = { // *2 radius guarantees outside shape
                    x: rs.ctrlpts[0] + cpM.x * 2 * radius,
                    y: rs.ctrlpts[1] + cpM.y * 2 * radius
                  };

                  var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, cpProj.x, cpProj.y, 0);

                  if (closeEndACp) {
                    rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
                    rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
                  } else {
                    rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
                    rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
                  }
                }

                if (overlapping) {
                  // recalc endpts
                  this.findEndpoints(edge);
                }
              }

              if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
                rs.allpts = [];

                rs.allpts.push(rs.startX, rs.startY);

                for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
                  // ctrl pt itself
                  rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);

                  // the midpt between ctrlpts as intermediate destination pts
                  if (b + 3 < rs.ctrlpts.length) {
                    rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
                  }
                }

                rs.allpts.push(rs.endX, rs.endY);

                var m, mt;
                if (rs.ctrlpts.length / 2 % 2 === 0) {
                  m = rs.allpts.length / 2 - 1;

                  rs.midX = rs.allpts[m];
                  rs.midY = rs.allpts[m + 1];
                } else {
                  m = rs.allpts.length / 2 - 3;
                  mt = 0.5;

                  rs.midX = math.qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
                  rs.midY = math.qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
                }
              } else if (rs.edgeType === 'straight') {
                // need to calc these after endpts
                rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];

                // default midpt for labels etc
                rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
                rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
              } else if (rs.edgeType === 'segments') {
                rs.allpts = [];
                rs.allpts.push(rs.startX, rs.startY);
                rs.allpts.push.apply(rs.allpts, rs.segpts);
                rs.allpts.push(rs.endX, rs.endY);

                if (rs.segpts.length % 4 === 0) {
                  var i2 = rs.segpts.length / 2;
                  var i1 = i2 - 2;

                  rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
                  rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
                } else {
                  var i1 = rs.segpts.length / 2 - 1;

                  rs.midX = rs.segpts[i1];
                  rs.midY = rs.segpts[i1 + 1];
                }
              }

              this.storeEdgeProjections(edge);
              this.calculateArrowAngles(edge);
            } // if point cache miss

            this.recalculateEdgeLabelProjections(edge);
            this.calculateLabelAngles(edge);
          } // for pair edges
        } // for pair ids

        for (var i = 0; i < haystackEdges.length; i++) {
          var edge = haystackEdges[i];
          var _p = edge._private;
          var rscratch = _p.rscratch;
          var rs = rscratch;

          if (!rscratch.haystack) {
            var angle = Math.random() * 2 * Math.PI;

            rscratch.source = {
              x: Math.cos(angle),
              y: Math.sin(angle)
            };

            var angle = Math.random() * 2 * Math.PI;

            rscratch.target = {
              x: Math.cos(angle),
              y: Math.sin(angle)
            };
          }

          var src = _p.source;
          var tgt = _p.target;
          var srcPos = src.position();
          var tgtPos = tgt.position();
          var srcW = src.width();
          var tgtW = tgt.width();
          var srcH = src.height();
          var tgtH = tgt.height();
          var radius = edge.pstyle('haystack-radius').value;
          var halfRadius = radius / 2; // b/c have to half width/height

          rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];

          rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
          rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

          // always override as haystack in case set to different type previously
          rscratch.edgeType = rscratch.lastCurveStyle = 'haystack';
          rscratch.haystack = true;

          this.storeEdgeProjections(edge);
          this.calculateArrowAngles(edge);
          this.recalculateEdgeLabelProjections(edge);
          this.calculateLabelAngles(edge);
        }
      };

      function getPts(pts) {
        var retPts = [];

        if (pts == null) {
          return;
        }

        for (var i = 0; i < pts.length; i += 2) {
          var x = pts[i];
          var y = pts[i + 1];

          retPts.push({ x: x, y: y });
        }

        return retPts;
      }

      BRp.getSegmentPoints = function (edge) {
        var rs = edge[0]._private.rscratch;
        var type = rs.edgeType;

        if (type === 'segments') {
          return getPts(rs.segpts);
        }
      };

      BRp.getControlPoints = function (edge) {
        var rs = edge[0]._private.rscratch;
        var type = rs.edgeType;

        if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
          return getPts(rs.ctrlpts);
        }
      };

      BRp.getEdgeMidpoint = function (edge) {
        var rs = edge[0]._private.rscratch;

        return {
          x: rs.midX,
          y: rs.midY
        };
      };

      module.exports = BRp;

      /***/
    },
    /* 115 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var BRp = {};

      BRp.manualEndptToPx = function (node, prop) {
        var r = this;
        var npos = node.position();
        var w = node.outerWidth();
        var h = node.outerHeight();

        if (prop.value.length === 2) {
          var p = [prop.pfValue[0], prop.pfValue[1]];

          if (prop.units[0] === '%') {
            p[0] = p[0] * w;
          }

          if (prop.units[1] === '%') {
            p[1] = p[1] * h;
          }

          p[0] += npos.x;
          p[1] += npos.y;

          return p;
        } else {
          var angle = prop.pfValue[0];

          angle = -Math.PI / 2 + angle; // start at 12 o'clock

          var l = 2 * Math.max(w, h);

          var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];

          return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
        }
      };

      BRp.findEndpoints = function (edge) {
        var r = this;
        var intersect = void 0;

        var source = edge.source()[0];
        var target = edge.target()[0];

        var srcPos = source.position();
        var tgtPos = target.position();

        var tgtArShape = edge.pstyle('target-arrow-shape').value;
        var srcArShape = edge.pstyle('source-arrow-shape').value;

        var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
        var srcDist = edge.pstyle('source-distance-from-node').pfValue;

        var rs = edge._private.rscratch;

        var et = rs.edgeType;
        var self = et === 'self' || et === 'compound';
        var bezier = et === 'bezier' || et === 'multibezier' || self;
        var multi = et !== 'bezier';
        var lines = et === 'straight' || et === 'segments';
        var segments = et === 'segments';
        var hasEndpts = bezier || multi || lines;
        var srcManEndpt = edge.pstyle('source-endpoint');
        var srcManEndptVal = self ? 'outside-to-node' : srcManEndpt.value;
        var tgtManEndpt = edge.pstyle('target-endpoint');
        var tgtManEndptVal = self ? 'outside-to-node' : tgtManEndpt.value;

        rs.srcManEndpt = srcManEndpt;
        rs.tgtManEndpt = tgtManEndpt;

        var p1 = void 0; // last known point of edge on target side
        var p2 = void 0; // last known point of edge on source side

        var p1_i = void 0; // point to intersect with target shape
        var p2_i = void 0; // point to intersect with source shape

        if (bezier) {
          var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
          var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;

          p1 = cpEnd;
          p2 = cpStart;
        } else if (lines) {
          var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
          var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);

          p1 = tgtArrowFromPt;
          p2 = srcArrowFromPt;
        }

        if (tgtManEndptVal === 'inside-to-node') {
          intersect = [tgtPos.x, tgtPos.y];
        } else if (tgtManEndpt.units) {
          intersect = this.manualEndptToPx(target, tgtManEndpt);
        } else if (tgtManEndptVal === 'outside-to-line') {
          intersect = rs.tgtIntn; // use cached value from ctrlpt calc
        } else {
          if (tgtManEndptVal === 'outside-to-node') {
            p1_i = p1;
          } else if (tgtManEndptVal === 'outside-to-line') {
            p1_i = [srcPos.x, srcPos.y];
          }

          intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);
        }

        var arrowEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
        var edgeEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);

        rs.endX = edgeEnd[0];
        rs.endY = edgeEnd[1];

        rs.arrowEndX = arrowEnd[0];
        rs.arrowEndY = arrowEnd[1];

        if (srcManEndptVal === 'inside-to-node') {
          intersect = [srcPos.x, srcPos.y];
        } else if (srcManEndpt.units) {
          intersect = this.manualEndptToPx(source, srcManEndpt);
        } else if (srcManEndptVal === 'outside-to-line') {
          intersect = rs.srcIntn; // use cached value from ctrlpt calc
        } else {
          if (srcManEndptVal === 'outside-to-node') {
            p2_i = p2;
          } else if (srcManEndptVal === 'outside-to-line') {
            p2_i = [tgtPos.x, tgtPos.y];
          }

          intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);
        }

        var arrowStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
        var edgeStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);

        rs.startX = edgeStart[0];
        rs.startY = edgeStart[1];

        rs.arrowStartX = arrowStart[0];
        rs.arrowStartY = arrowStart[1];

        if (hasEndpts) {
          if (!is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY)) {
            rs.badLine = true;
          } else {
            rs.badLine = false;
          }
        }
      };

      BRp.getSourceEndpoint = function (edge) {
        var rs = edge[0]._private.rscratch;

        switch (rs.edgeType) {
          case 'haystack':
            return {
              x: rs.haystackPts[0],
              y: rs.haystackPts[1]
            };
          default:
            return {
              x: rs.arrowStartX,
              y: rs.arrowStartY
            };
        }
      };

      BRp.getTargetEndpoint = function (edge) {
        var rs = edge[0]._private.rscratch;

        switch (rs.edgeType) {
          case 'haystack':
            return {
              x: rs.haystackPts[2],
              y: rs.haystackPts[3]
            };
          default:
            return {
              x: rs.arrowEndX,
              y: rs.arrowEndY
            };
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 116 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var BRp = {};

      function pushBezierPts(r, edge, pts) {
        var qbezierAt = function qbezierAt(p1, p2, p3, t) {
          return math.qbezierAt(p1, p2, p3, t);
        };
        var _p = edge._private;
        var bpts = _p.rstyle.bezierPts;

        for (var i = 0; i < r.bezierProjPcts.length; i++) {
          var p = r.bezierProjPcts[i];

          bpts.push({
            x: qbezierAt(pts[0], pts[2], pts[4], p),
            y: qbezierAt(pts[1], pts[3], pts[5], p)
          });
        }
      }

      BRp.storeEdgeProjections = function (edge) {
        var _p = edge._private;
        var rs = _p.rscratch;
        var et = rs.edgeType;

        // clear the cached points state
        _p.rstyle.bezierPts = null;
        _p.rstyle.linePts = null;
        _p.rstyle.haystackPts = null;

        if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
          var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

          for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
            pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
          }
        } else if (et === 'segments') {
          var lpts = _p.rstyle.linePts = [];

          for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
            lpts.push({
              x: rs.allpts[i],
              y: rs.allpts[i + 1]
            });
          }
        } else if (et === 'haystack') {
          var hpts = rs.haystackPts;

          _p.rstyle.haystackPts = [{ x: hpts[0], y: hpts[1] }, { x: hpts[2], y: hpts[3] }];
        }

        _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
      };

      BRp.recalculateEdgeProjections = function (edges) {
        this.findEdgeControlPoints(edges);
      };

      module.exports = BRp;

      /***/
    },
    /* 117 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var BRp = {};

      BRp.recalculateNodeLabelProjection = function (node) {
        var content = node.pstyle('label').strValue;

        if (is.emptyString(content)) {
          return;
        }

        var textX, textY;
        var _p = node._private;
        var nodeWidth = node.width();
        var nodeHeight = node.height();
        var padding = node.padding();
        var nodePos = node.position();
        var textHalign = node.pstyle('text-halign').strValue;
        var textValign = node.pstyle('text-valign').strValue;
        var rs = _p.rscratch;
        var rstyle = _p.rstyle;

        switch (textHalign) {
          case 'left':
            textX = nodePos.x - nodeWidth / 2 - padding;
            break;

          case 'right':
            textX = nodePos.x + nodeWidth / 2 + padding;
            break;

          default:
            // e.g. center
            textX = nodePos.x;
        }

        switch (textValign) {
          case 'top':
            textY = nodePos.y - nodeHeight / 2 - padding;
            break;

          case 'bottom':
            textY = nodePos.y + nodeHeight / 2 + padding;
            break;

          default:
            // e.g. middle
            textY = nodePos.y;
        }

        rs.labelX = textX;
        rs.labelY = textY;
        rstyle.labelX = textX;
        rstyle.labelY = textY;

        this.applyLabelDimensions(node);
      };

      BRp.recalculateEdgeLabelProjections = function (edge) {
        var p;
        var _p = edge._private;
        var rs = _p.rscratch;
        var r = this;
        var content = {
          mid: edge.pstyle('label').strValue,
          source: edge.pstyle('source-label').strValue,
          target: edge.pstyle('target-label').strValue
        };

        if (content.mid || content.source || content.target) {
          // then we have to calculate...
        } else {
            return; // no labels => no calcs
          }

        // add center point to style so bounding box calculations can use it
        //
        p = {
          x: rs.midX,
          y: rs.midY
        };

        var setRs = function setRs(propName, prefix, value) {
          util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
          util.setPrefixedProperty(_p.rstyle, propName, prefix, value);
        };

        setRs('labelX', null, p.x);
        setRs('labelY', null, p.y);

        var createControlPointInfo = function createControlPointInfo() {
          if (createControlPointInfo.cache) {
            return createControlPointInfo.cache;
          } // use cache so only 1x per edge

          var ctrlpts = [];

          // store each ctrlpt info init
          for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
            var p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
            var p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] }; // ctrlpt
            var p2 = { x: rs.allpts[i + 4], y: rs.allpts[i + 5] };

            ctrlpts.push({
              p0: p0,
              p1: p1,
              p2: p2,
              startDist: 0,
              length: 0,
              segments: []
            });
          }

          var bpts = _p.rstyle.bezierPts;
          var nProjs = r.bezierProjPcts.length;

          function addSegment(cp, p0, p1, t0, t1) {
            var length = math.dist(p0, p1);
            var prevSegment = cp.segments[cp.segments.length - 1];
            var segment = {
              p0: p0,
              p1: p1,
              t0: t0,
              t1: t1,
              startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
              length: length
            };

            cp.segments.push(segment);

            cp.length += length;
          }

          // update each ctrlpt with segment info
          for (var i = 0; i < ctrlpts.length; i++) {
            var cp = ctrlpts[i];
            var prevCp = ctrlpts[i - 1];

            if (prevCp) {
              cp.startDist = prevCp.startDist + prevCp.length;
            }

            addSegment(cp, cp.p0, bpts[i * nProjs], 0, r.bezierProjPcts[0]); // first

            for (var j = 0; j < nProjs - 1; j++) {
              addSegment(cp, bpts[i * nProjs + j], bpts[i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
            }

            addSegment(cp, bpts[i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
          }

          return createControlPointInfo.cache = ctrlpts;
        };

        var calculateEndProjection = function calculateEndProjection(prefix) {
          var angle;
          var isSrc = prefix === 'source';

          if (!content[prefix]) {
            return;
          }

          var offset = edge.pstyle(prefix + '-text-offset').pfValue;

          var lineAngle = function lineAngle(p0, p1) {
            var dx = p1.x - p0.x;
            var dy = p1.y - p0.y;

            return Math.atan(dy / dx);
          };

          var bezierAngle = function bezierAngle(p0, p1, p2, t) {
            var t0 = math.bound(0, t - 0.001, 1);
            var t1 = math.bound(0, t + 0.001, 1);

            var lp0 = math.qbezierPtAt(p0, p1, p2, t0);
            var lp1 = math.qbezierPtAt(p0, p1, p2, t1);

            return lineAngle(lp0, lp1);
          };

          switch (rs.edgeType) {
            case 'self':
            case 'compound':
            case 'bezier':
            case 'multibezier':
              var cps = createControlPointInfo();
              var selected;
              var startDist = 0;
              var totalDist = 0;

              // find the segment we're on
              for (var i = 0; i < cps.length; i++) {
                var cp = cps[isSrc ? i : cps.length - 1 - i];

                for (var j = 0; j < cp.segments.length; j++) {
                  var seg = cp.segments[isSrc ? j : cp.segments.length - 1 - j];
                  var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

                  startDist = totalDist;
                  totalDist += seg.length;

                  if (totalDist >= offset || lastSeg) {
                    selected = { cp: cp, segment: seg };
                    break;
                  }
                }

                if (selected) {
                  break;
                }
              }

              var cp = selected.cp;
              var seg = selected.segment;
              var tSegment = (offset - startDist) / seg.length;
              var segDt = seg.t1 - seg.t0;
              var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

              t = math.bound(0, t, 1);
              p = math.qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
              angle = bezierAngle(cp.p0, cp.p1, cp.p2, t, p);

              break;

            case 'straight':
            case 'segments':
            case 'haystack':
              var d = 0,
                  di,
                  d0;
              var p0, p1;
              var l = rs.allpts.length;

              for (var i = 0; i + 3 < l; i += 2) {
                if (isSrc) {
                  p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
                  p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] };
                } else {
                  p0 = { x: rs.allpts[l - 2 - i], y: rs.allpts[l - 1 - i] };
                  p1 = { x: rs.allpts[l - 4 - i], y: rs.allpts[l - 3 - i] };
                }

                di = math.dist(p0, p1);
                d0 = d;
                d += di;

                if (d >= offset) {
                  break;
                }
              }

              var pD = offset - d0;
              var t = pD / di;

              t = math.bound(0, t, 1);
              p = math.lineAt(p0, p1, t);
              angle = lineAngle(p0, p1);

              break;
          }

          setRs('labelX', prefix, p.x);
          setRs('labelY', prefix, p.y);
          setRs('labelAutoAngle', prefix, angle);
        };

        calculateEndProjection('source');
        calculateEndProjection('target');

        this.applyLabelDimensions(edge);
      };

      BRp.applyLabelDimensions = function (ele) {
        this.applyPrefixedLabelDimensions(ele);

        if (ele.isEdge()) {
          this.applyPrefixedLabelDimensions(ele, 'source');
          this.applyPrefixedLabelDimensions(ele, 'target');
        }
      };

      BRp.applyPrefixedLabelDimensions = function (ele, prefix) {
        var _p = ele._private;

        var text = this.getLabelText(ele, prefix);
        var labelDims = this.calculateLabelDimensions(ele, text);

        util.setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, labelDims.width);
        util.setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, labelDims.width);

        util.setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, labelDims.height);
        util.setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, labelDims.height);
      };

      BRp.getLabelText = function (ele, prefix) {
        var _p = ele._private;
        var pfd = prefix ? prefix + '-' : '';
        var text = ele.pstyle(pfd + 'label').strValue;
        var textTransform = ele.pstyle('text-transform').value;
        var rscratch = function rscratch(propName, value) {
          if (value) {
            util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
            return value;
          } else {
            return util.getPrefixedProperty(_p.rscratch, propName, prefix);
          }
        };

        if (textTransform == 'none') {
          // passthrough
        } else if (textTransform == 'uppercase') {
          text = text.toUpperCase();
        } else if (textTransform == 'lowercase') {
          text = text.toLowerCase();
        }

        var wrapStyle = ele.pstyle('text-wrap').value;

        if (wrapStyle === 'wrap') {
          //console.log('wrap');

          var labelKey = rscratch('labelKey');

          // save recalc if the label is the same as before
          if (labelKey && rscratch('labelWrapKey') === labelKey) {
            // console.log('wrap cache hit');
            return rscratch('labelWrapCachedText');
          }
          // console.log('wrap cache miss');

          var lines = text.split('\n');
          var maxW = ele.pstyle('text-max-width').pfValue;
          var wrappedLines = [];

          for (var l = 0; l < lines.length; l++) {
            var line = lines[l];
            var lineDims = this.calculateLabelDimensions(ele, line, 'line=' + line);
            var lineW = lineDims.width;

            if (lineW > maxW) {
              // line is too long
              var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
              var subline = '';

              for (var w = 0; w < words.length; w++) {
                var word = words[w];
                var testLine = subline.length === 0 ? word : subline + ' ' + word;
                var testDims = this.calculateLabelDimensions(ele, testLine, 'testLine=' + testLine);
                var testW = testDims.width;

                if (testW <= maxW) {
                  // word fits on current line
                  subline += word + ' ';
                } else {
                  // word starts new line
                  wrappedLines.push(subline);
                  subline = word + ' ';
                }
              }

              // if there's remaining text, put it in a wrapped line
              if (!subline.match(/^\s+$/)) {
                wrappedLines.push(subline);
              }
            } else {
              // line is already short enough
              wrappedLines.push(line);
            }
          } // for

          rscratch('labelWrapCachedLines', wrappedLines);
          text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
          rscratch('labelWrapKey', labelKey);

          // console.log(text)
        } else if (wrapStyle === 'ellipsis') {
          var maxW = ele.pstyle('text-max-width').pfValue;
          var ellipsized = '';
          var ellipsis = '\u2026';
          var incLastCh = false;

          for (var i = 0; i < text.length; i++) {
            var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

            if (widthWithNextCh > maxW) {
              break;
            }

            ellipsized += text[i];

            if (i === text.length - 1) {
              incLastCh = true;
            }
          }

          if (!incLastCh) {
            ellipsized += ellipsis;
          }

          return ellipsized;
        } // if ellipsize

        return text;
      };

      BRp.calculateLabelDimensions = function (ele, text, extraKey) {
        var r = this;

        var cacheKey = ele._private.labelStyleKey + '$@$' + text;

        if (extraKey) {
          cacheKey += '$@$' + extraKey;
        }

        var cache = r.labelDimCache || (r.labelDimCache = {});

        if (cache[cacheKey]) {
          return cache[cacheKey];
        }

        var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
        var fStyle = ele.pstyle('font-style').strValue;
        var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
        var family = ele.pstyle('font-family').strValue;
        var weight = ele.pstyle('font-weight').strValue;

        var div = this.labelCalcDiv;

        if (!div) {
          div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef
          document.body.appendChild(div); // eslint-disable-line no-undef
        }

        var ds = div.style;

        // from ele style
        ds.fontFamily = family;
        ds.fontStyle = fStyle;
        ds.fontSize = size;
        ds.fontWeight = weight;

        // forced style
        ds.position = 'absolute';
        ds.left = '-9999px';
        ds.top = '-9999px';
        ds.zIndex = '-1';
        ds.visibility = 'hidden';
        ds.pointerEvents = 'none';
        ds.padding = '0';
        ds.lineHeight = '1';

        if (ele.pstyle('text-wrap').value === 'wrap') {
          ds.whiteSpace = 'pre'; // so newlines are taken into account
        } else {
          ds.whiteSpace = 'normal';
        }

        // put label content in div
        div.textContent = text;

        cache[cacheKey] = {
          width: Math.ceil(div.clientWidth / sizeMult),
          height: Math.ceil(div.clientHeight / sizeMult)
        };

        return cache[cacheKey];
      };

      BRp.calculateLabelAngles = function (ele) {
        var _p = ele._private;
        var rs = _p.rscratch;
        var isEdge = ele.isEdge();
        var rot = ele.pstyle('text-rotation');
        var rotStr = rot.strValue;

        if (rotStr === 'none') {
          rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
        } else if (isEdge && rotStr === 'autorotate') {
          rs.labelAngle = Math.atan(rs.midDispY / rs.midDispX);
          rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
          rs.targetLabelAngle = rs.targetLabelAutoAngle;
        } else if (rotStr === 'autorotate') {
          rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
        } else {
          rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 118 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var BRp = {};

      BRp.getNodeShape = function (node) {
        var r = this;
        var shape = node.pstyle('shape').value;

        if (node.isParent()) {
          if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
            return shape;
          } else {
            return 'rectangle';
          }
        }

        if (shape === 'polygon') {
          var points = node.pstyle('shape-polygon-points').value;

          return r.nodeShapes.makePolygon(points).name;
        }

        return shape;
      };

      module.exports = BRp;

      /***/
    },
    /* 119 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var BRp = {};

      BRp.registerCalculationListeners = function () {
        var cy = this.cy;
        var elesToUpdate = cy.collection();
        var r = this;

        var enqueue = function enqueue(eles, e) {
          var dirtyStyleCaches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          elesToUpdate.merge(eles);

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var _p = ele._private;
            var rstyle = _p.rstyle;

            if (dirtyStyleCaches) {
              rstyle.clean = false;
              _p.bbCache = null;
            }

            var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

            if (!evts[e.type]) {
              evts[e.type] = true;
              evts.length++;
            }
          }
        };

        r.binder(cy)
        // nodes

        .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode(e) {
          var node = e.target;

          enqueue(node, e);
          enqueue(node.connectedEdges(), e);
        }).on('add.*', 'node', function onDirtyAddNode(e) {
          var ele = e.target;

          enqueue(ele, e);
        }).on('background.*', 'node', function onDirtyBgNode(e) {
          var ele = e.target;

          enqueue(ele, e, false);
        })

        // edges

        .on('add.* style.*', 'edge', function onDirtyEdge(e) {
          var edge = e.target;

          enqueue(edge, e);
          enqueue(edge.parallelEdges(), e);
        }).on('remove.*', 'edge', function onDirtyRemoveEdge(e) {
          var edge = e.target;
          var pEdges = edge.parallelEdges();

          for (var i = 0; i < pEdges.length; i++) {
            var pEdge = pEdges[i];

            if (!pEdge.removed()) {
              enqueue(pEdge, e);
            }
          }
        })

        // manual dirtying

        .on('dirty.*', 'node', function onDirtyEle(e) {
          var ele = e.target;

          enqueue(ele, e);
        });

        var updateEleCalcs = function updateEleCalcs(willDraw) {
          if (willDraw) {
            var fns = r.onUpdateEleCalcsFns;

            if (fns) {
              for (var i = 0; i < fns.length; i++) {
                var fn = fns[i];

                fn(willDraw, elesToUpdate);
              }
            }

            r.recalculateRenderedStyle(elesToUpdate, false);

            for (var i = 0; i < elesToUpdate.length; i++) {
              elesToUpdate[i]._private.rstyle.dirtyEvents = null;
            }

            elesToUpdate = cy.collection();
          }
        };

        r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
      };

      BRp.onUpdateEleCalcs = function (fn) {
        var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

        fns.push(fn);
      };

      BRp.recalculateRenderedStyle = function (eles, useCache) {
        var edges = [];
        var nodes = [];

        // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
        if (this.destroyed) {
          return;
        }

        // use cache by default for perf
        if (useCache === undefined) {
          useCache = true;
        }

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _p = ele._private;
          var rstyle = _p.rstyle;

          // only update if dirty and in graph
          if (useCache && rstyle.clean || ele.removed()) {
            continue;
          }

          // only update if not display: none
          if (ele.pstyle('display').value === 'none') {
            continue;
          }

          if (_p.group === 'nodes') {
            nodes.push(ele);
          } else {
            // edges
            edges.push(ele);
          }

          rstyle.clean = true;
          // rstyle.dirtyEvents = null;
        }

        // update node data from projections
        for (var i = 0; i < nodes.length; i++) {
          var ele = nodes[i];
          var _p = ele._private;
          var rstyle = _p.rstyle;
          var pos = ele.position();

          this.recalculateNodeLabelProjection(ele);

          rstyle.nodeX = pos.x;
          rstyle.nodeY = pos.y;
          rstyle.nodeW = ele.pstyle('width').pfValue;
          rstyle.nodeH = ele.pstyle('height').pfValue;
        }

        this.recalculateEdgeProjections(edges);

        // update edge data from projections
        for (var i = 0; i < edges.length; i++) {
          var ele = edges[i];
          var _p = ele._private;
          var rstyle = _p.rstyle;
          var rs = _p.rscratch;

          this.recalculateEdgeLabelProjections(ele);

          // update rstyle positions
          rstyle.srcX = rs.arrowStartX;
          rstyle.srcY = rs.arrowStartY;
          rstyle.tgtX = rs.arrowEndX;
          rstyle.tgtY = rs.arrowEndY;
          rstyle.midX = rs.midX;
          rstyle.midY = rs.midY;
          rstyle.labelAngle = rs.labelAngle;
          rstyle.sourceLabelAngle = rs.sourceLabelAngle;
          rstyle.targetLabelAngle = rs.targetLabelAngle;
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 120 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var zIndexSort = __webpack_require__(17);

      var BRp = {};

      BRp.updateCachedGrabbedEles = function () {
        var eles = this.cachedZSortedEles;

        if (!eles) {
          // just let this be recalculated on the next z sort tick
          return;
        }

        eles.drag = [];
        eles.nondrag = [];

        var grabTargets = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var rs = ele._private.rscratch;

          if (ele.grabbed() && !ele.isParent()) {
            grabTargets.push(ele);
          } else if (rs.inDragLayer) {
            eles.drag.push(ele);
          } else {
            eles.nondrag.push(ele);
          }
        }

        // put the grab target nodes last so it's on top of its neighbourhood
        for (var i = 0; i < grabTargets.length; i++) {
          var ele = grabTargets[i];

          eles.drag.push(ele);
        }
      };

      BRp.invalidateCachedZSortedEles = function () {
        this.cachedZSortedEles = null;
      };

      BRp.getCachedZSortedEles = function (forceRecalc) {
        if (forceRecalc || !this.cachedZSortedEles) {
          //console.time('cachezorder')

          var eles = this.cy.mutableElements().toArray();

          eles.sort(zIndexSort);

          eles.interactive = eles.filter(function (ele) {
            return ele.interactive();
          });

          this.cachedZSortedEles = eles;

          this.updateCachedGrabbedEles();
        } else {
          eles = this.cachedZSortedEles;
        }

        return eles;
      };

      module.exports = BRp;

      /***/
    },
    /* 121 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var BRp = {};

      BRp.getCachedImage = function (url, crossOrigin, onLoad) {
        var r = this;
        var imageCache = r.imageCache = r.imageCache || {};
        var cache = imageCache[url];

        if (cache) {
          if (!cache.image.complete) {
            cache.image.addEventListener('load', onLoad);
          }

          return cache.image;
        } else {
          cache = imageCache[url] = imageCache[url] || {};

          var image = cache.image = new Image(); // eslint-disable-line no-undef

          image.addEventListener('load', onLoad);
          image.addEventListener('error', function () {
            image.error = true;
          });

          // #1582 safari doesn't load data uris with crossOrigin properly
          // https://bugs.webkit.org/show_bug.cgi?id=123978
          var dataUriPrefix = 'data:';
          var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
          if (!isDataUri) {
            image.crossOrigin = crossOrigin; // prevent tainted canvas
          }

          image.src = url;

          return image;
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 122 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var Event = __webpack_require__(16);

      var BRp = {};

      BRp.registerBinding = function (target, event, handler, useCapture) {
        var args = Array.prototype.slice.apply(arguments, [1]); // copy
        var b = this.binder(target);

        return b.on.apply(b, args);
      };

      BRp.binder = function (tgt) {
        var r = this;

        var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement(tgt);

        if (r.supportsPassiveEvents == null) {

          // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
          var supportsPassive = false;
          try {
            var opts = Object.defineProperty({}, 'passive', {
              get: function get() {
                supportsPassive = true;
              }
            });

            window.addEventListener('test', null, opts);
          } catch (err) {}

          r.supportsPassiveEvents = supportsPassive;
        }

        var on = function on(event, handler, useCapture) {
          var args = Array.prototype.slice.call(arguments);

          if (tgtIsDom && r.supportsPassiveEvents) {
            // replace useCapture w/ opts obj
            args[2] = {
              capture: useCapture != null ? useCapture : false,
              passive: false,
              once: false
            };
          }

          r.bindings.push({
            target: tgt,
            args: args
          });

          (tgt.addEventListener || tgt.on).apply(tgt, args);

          return this;
        };

        return {
          on: on,
          addEventListener: on,
          addListener: on,
          bind: on
        };
      };

      BRp.nodeIsDraggable = function (node) {
        return node && node.isNode() && !node.locked() && node.grabbable();
      };

      BRp.nodeIsGrabbable = function (node) {
        return this.nodeIsDraggable(node) && node.interactive();
      };

      BRp.load = function () {
        var r = this;

        var triggerEvents = function triggerEvents(target, names, e, props) {
          if (target == null) {
            target = r.cy;
          }

          for (var i = 0; i < names.length; i++) {
            var name = names[i];

            target.emit(util.extend({ originalEvent: e, type: name }, props));
          }
        };

        var isMultSelKeyDown = function isMultSelKeyDown(e) {
          return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
        };

        var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
          var allowPassthrough = true;

          if (r.cy.hasCompoundNodes() && down && down.isEdge()) {
            // a compound node below the edge => no passthrough panning
            for (var i = 0; downs && i < downs.length; i++) {
              var down = downs[i];

              if (down.isNode() && down.isParent()) {
                allowPassthrough = false;
                break;
              }
            }
          } else {
            allowPassthrough = true;
          }

          return allowPassthrough;
        };

        var getDragListIds = function getDragListIds(opts) {
          var listHasId;

          if (opts.addToList && r.cy.hasCompoundNodes()) {
            // only needed for compound graphs
            if (!opts.addToList.hasId) {
              // build ids lookup if doesn't already exist
              opts.addToList.hasId = {};

              for (var i = 0; i < opts.addToList.length; i++) {
                var ele = opts.addToList[i];

                opts.addToList.hasId[ele.id()] = true;
              }
            }

            listHasId = opts.addToList.hasId;
          }

          return listHasId || {};
        };

        var setGrabbed = function setGrabbed(ele) {
          ele[0]._private.grabbed = true;
        };

        var setFreed = function setFreed(ele) {
          ele[0]._private.grabbed = false;
        };

        var setInDragLayer = function setInDragLayer(ele) {
          ele[0]._private.rscratch.inDragLayer = true;
        };

        var setOutDragLayer = function setOutDragLayer(ele) {
          ele[0]._private.rscratch.inDragLayer = false;
        };

        var setGrabTarget = function setGrabTarget(ele) {
          ele[0]._private.rscratch.isGrabTarget = true;
        };

        var removeGrabTarget = function removeGrabTarget(ele) {
          ele[0]._private.rscratch.isGrabTarget = false;
        };

        var addToDragList = function addToDragList(ele, opts) {
          var listHasId = getDragListIds(opts);

          if (!listHasId[ele.id()]) {
            opts.addToList.push(ele);
            listHasId[ele.id()] = true;

            setGrabbed(ele);
          }
        };

        // helper function to determine which child nodes and inner edges
        // of a compound node to be dragged as well as the grabbed and selected nodes
        var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
          if (!node.cy().hasCompoundNodes()) {
            return;
          }

          if (opts.inDragLayer == null && opts.addToList == null) {
            return;
          } // nothing to do

          var innerNodes = node.descendants();

          if (opts.inDragLayer) {
            innerNodes.forEach(setInDragLayer);
            innerNodes.connectedEdges().forEach(setInDragLayer);
          }

          if (opts.addToList) {
            innerNodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }
        };

        // adds the given nodes and its neighbourhood to the drag layer
        var addNodesToDrag = function addNodesToDrag(nodes, opts) {
          opts = opts || {};

          var hasCompoundNodes = nodes.cy().hasCompoundNodes();

          if (opts.inDragLayer) {
            nodes.forEach(setInDragLayer);

            nodes.neighborhood().stdFilter(function (ele) {
              return !hasCompoundNodes || ele.isEdge();
            }).forEach(setInDragLayer);
          }

          if (opts.addToList) {
            nodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }

          addDescendantsToDrag(nodes, opts); // always add to drag

          // also add nodes and edges related to the topmost ancestor
          updateAncestorsInDragLayer(nodes, {
            inDragLayer: opts.inDragLayer
          });

          r.updateCachedGrabbedEles();
        };

        var addNodeToDrag = addNodesToDrag;

        var freeDraggedElements = function freeDraggedElements(grabbedEles) {
          if (!grabbedEles) {
            return;
          }

          grabbedEles.hasId = {}; // clear the id list

          // just go over all elements rather than doing a bunch of (possibly expensive) traversals
          r.getCachedZSortedEles().forEach(function (ele) {
            setFreed(ele);
            setOutDragLayer(ele);
            removeGrabTarget(ele);
          });

          r.updateCachedGrabbedEles();
        };

        // helper function to determine which ancestor nodes and edges should go
        // to the drag layer (or should be removed from drag layer).
        var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {

          if (opts.inDragLayer == null && opts.addToList == null) {
            return;
          } // nothing to do

          if (!node.cy().hasCompoundNodes()) {
            return;
          }

          // find top-level parent
          var parent = node.ancestors().orphans();

          // no parent node: no nodes to add to the drag layer
          if (parent.same(node)) {
            return;
          }

          var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());

          var edges = nodes.connectedEdges();

          if (opts.inDragLayer) {
            edges.forEach(setInDragLayer);
            nodes.forEach(setInDragLayer);
          }

          if (opts.addToList) {
            nodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }
        };

        var haveMutationsApi = typeof MutationObserver !== 'undefined';

        // watch for when the cy container is removed from the dom
        if (haveMutationsApi) {
          r.removeObserver = new MutationObserver(function (mutns) {
            // eslint-disable-line no-undef
            for (var i = 0; i < mutns.length; i++) {
              var mutn = mutns[i];
              var rNodes = mutn.removedNodes;

              if (rNodes) {
                for (var j = 0; j < rNodes.length; j++) {
                  var rNode = rNodes[j];

                  if (rNode === r.container) {
                    r.destroy();
                    break;
                  }
                }
              }
            }
          });

          if (r.container.parentNode) {
            r.removeObserver.observe(r.container.parentNode, { childList: true });
          }
        } else {
          r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
            r.destroy();
          });
        }

        var onResize = util.debounce(function () {
          r.cy.resize();
        }, 100);

        if (haveMutationsApi) {
          r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

          r.styleObserver.observe(r.container, { attributes: true });
        }

        // auto resize
        r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

        var forEachUp = function forEachUp(domEle, fn) {
          while (domEle != null) {
            fn(domEle);

            domEle = domEle.parentNode;
          }
        };

        var invalidateCoords = function invalidateCoords() {
          r.invalidateContainerClientCoordsCache();
        };

        forEachUp(r.container, function (domEle) {
          r.registerBinding(domEle, 'transitionend', invalidateCoords);
          r.registerBinding(domEle, 'animationend', invalidateCoords);
          r.registerBinding(domEle, 'scroll', invalidateCoords);
        });

        // stop right click menu from appearing on cy
        r.registerBinding(r.container, 'contextmenu', function (e) {
          e.preventDefault();
        });

        var inBoxSelection = function inBoxSelection() {
          return r.selection[4] !== 0;
        };

        var eventInContainer = function eventInContainer(e) {
          // save cycles if mouse events aren't to be captured
          var containerPageCoords = r.findContainerClientCoords();
          var x = containerPageCoords[0];
          var y = containerPageCoords[1];
          var width = containerPageCoords[2];
          var height = containerPageCoords[3];

          var positions = e.touches ? e.touches : [e];
          var atLeastOnePosInside = false;

          for (var i = 0; i < positions.length; i++) {
            var p = positions[i];

            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
              atLeastOnePosInside = true;
              break;
            }
          }

          if (!atLeastOnePosInside) {
            return false;
          }

          var container = r.container;
          var target = e.target;
          var tParent = target.parentNode;
          var containerIsTarget = false;

          while (tParent) {
            if (tParent === container) {
              containerIsTarget = true;
              break;
            }

            tParent = tParent.parentNode;
          }

          if (!containerIsTarget) {
            return false;
          } // if target is outisde cy container, then this event is not for us

          return true;
        };

        // Primary key
        r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
          if (!eventInContainer(e)) {
            return;
          }

          e.preventDefault();
          r.hoverData.capture = true;
          r.hoverData.which = e.which;

          var cy = r.cy;
          var gpos = [e.clientX, e.clientY];
          var pos = r.projectIntoViewport(gpos[0], gpos[1]);
          var select = r.selection;
          var nears = r.findNearestElements(pos[0], pos[1], true, false);
          var near = nears[0];
          var draggedElements = r.dragData.possibleDragElements;

          r.hoverData.mdownPos = pos;
          r.hoverData.mdownGPos = gpos;

          var checkForTaphold = function checkForTaphold() {
            r.hoverData.tapholdCancelled = false;

            clearTimeout(r.hoverData.tapholdTimeout);

            r.hoverData.tapholdTimeout = setTimeout(function () {

              if (r.hoverData.tapholdCancelled) {
                return;
              } else {
                var ele = r.hoverData.down;

                if (ele) {
                  ele.emit({
                    originalEvent: e,
                    type: 'taphold',
                    position: { x: pos[0], y: pos[1] }
                  });
                } else {
                  cy.emit({
                    originalEvent: e,
                    type: 'taphold',
                    position: { x: pos[0], y: pos[1] }
                  });
                }
              }
            }, r.tapholdDuration);
          };

          // Right click button
          if (e.which == 3) {

            r.hoverData.cxtStarted = true;

            var cxtEvt = {
              originalEvent: e,
              type: 'cxttapstart',
              position: { x: pos[0], y: pos[1] }
            };

            if (near) {
              near.activate();
              near.emit(cxtEvt);

              r.hoverData.down = near;
            } else {
              cy.emit(cxtEvt);
            }

            r.hoverData.downTime = new Date().getTime();
            r.hoverData.cxtDragged = false;

            // Primary button
          } else if (e.which == 1) {

            if (near) {
              near.activate();
            }

            // Element dragging
            {
              // If something is under the cursor and it is draggable, prepare to grab it
              if (near != null) {

                if (r.nodeIsGrabbable(near)) {

                  var makeEvent = function makeEvent(type) {
                    return {
                      originalEvent: e,
                      type: type,
                      position: { x: pos[0], y: pos[1] }
                    };
                  };

                  var triggerGrab = function triggerGrab(ele) {
                    ele.emit(makeEvent('grab'));
                  };

                  setGrabTarget(near);

                  if (!near.selected()) {

                    draggedElements = r.dragData.possibleDragElements = [];
                    addNodeToDrag(near, { addToList: draggedElements });

                    near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
                  } else {
                    draggedElements = r.dragData.possibleDragElements = [];

                    var selectedNodes = cy.$(function (ele) {
                      return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
                    });

                    addNodesToDrag(selectedNodes, { addToList: draggedElements });

                    near.emit(makeEvent('grabon'));

                    selectedNodes.forEach(triggerGrab);
                  }

                  r.redrawHint('eles', true);
                  r.redrawHint('drag', true);
                }
              }

              r.hoverData.down = near;
              r.hoverData.downs = nears;
              r.hoverData.downTime = new Date().getTime();
            }

            triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
              position: { x: pos[0], y: pos[1] }
            });

            if (near == null) {
              select[4] = 1;

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.redrawHint('select', true);

              r.redraw();
            } else if (near.isEdge()) {
              select[4] = 1; // for future pan
            }

            checkForTaphold();
          }

          // Initialize selection box coordinates
          select[0] = select[2] = pos[0];
          select[1] = select[3] = pos[1];
        }, false);

        r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
          // eslint-disable-line no-undef
          var capture = r.hoverData.capture;

          if (!capture && !eventInContainer(e)) {
            return;
          }

          var preventDefault = false;
          var cy = r.cy;
          var zoom = cy.zoom();
          var gpos = [e.clientX, e.clientY];
          var pos = r.projectIntoViewport(gpos[0], gpos[1]);
          var mdownPos = r.hoverData.mdownPos;
          var mdownGPos = r.hoverData.mdownGPos;
          var select = r.selection;

          var near = null;
          if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
            near = r.findNearestElement(pos[0], pos[1], true, false);
          }
          var last = r.hoverData.last;
          var down = r.hoverData.down;

          var disp = [pos[0] - select[2], pos[1] - select[3]];

          var draggedElements = r.dragData.possibleDragElements;

          var isOverThresholdDrag;

          if (mdownGPos) {
            var dx = gpos[0] - mdownGPos[0];
            var dx2 = dx * dx;
            var dy = gpos[1] - mdownGPos[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;

            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
          }

          var multSelKeyDown = isMultSelKeyDown(e);

          if (isOverThresholdDrag) {
            r.hoverData.tapholdCancelled = true;
          }

          var updateDragDelta = function updateDragDelta() {
            var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

            if (dragDelta.length === 0) {
              dragDelta.push(disp[0]);
              dragDelta.push(disp[1]);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          };

          preventDefault = true;

          triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
            position: { x: pos[0], y: pos[1] }
          });

          var goIntoBoxMode = function goIntoBoxMode() {
            r.data.bgActivePosistion = undefined;

            if (!r.hoverData.selecting) {
              cy.emit('boxstart');
            }

            select[4] = 1;
            r.hoverData.selecting = true;

            r.redrawHint('select', true);
            r.redraw();
          };

          // trigger context drag if rmouse down
          if (r.hoverData.which === 3) {
            // but only if over threshold
            if (isOverThresholdDrag) {
              var cxtEvt = {
                originalEvent: e,
                type: 'cxtdrag',
                position: { x: pos[0], y: pos[1] }
              };

              if (down) {
                down.emit(cxtEvt);
              } else {
                cy.emit(cxtEvt);
              }

              r.hoverData.cxtDragged = true;

              if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {

                if (r.hoverData.cxtOver) {
                  r.hoverData.cxtOver.emit({
                    originalEvent: e,
                    type: 'cxtdragout',
                    position: { x: pos[0], y: pos[1] }
                  });
                }

                r.hoverData.cxtOver = near;

                if (near) {
                  near.emit({
                    originalEvent: e,
                    type: 'cxtdragover',
                    position: { x: pos[0], y: pos[1] }
                  });
                }
              }
            }

            // Check if we are drag panning the entire graph
          } else if (r.hoverData.dragging) {
            preventDefault = true;

            if (cy.panningEnabled() && cy.userPanningEnabled()) {
              var deltaP;

              if (r.hoverData.justStartedPan) {
                var mdPos = r.hoverData.mdownPos;

                deltaP = {
                  x: (pos[0] - mdPos[0]) * zoom,
                  y: (pos[1] - mdPos[1]) * zoom
                };

                r.hoverData.justStartedPan = false;
              } else {
                deltaP = {
                  x: disp[0] * zoom,
                  y: disp[1] * zoom
                };
              }

              cy.panBy(deltaP);

              r.hoverData.dragged = true;
            }

            // Needs reproject due to pan changing viewport
            pos = r.projectIntoViewport(e.clientX, e.clientY);

            // Checks primary button down & out of time & mouse not moved much
          } else if (select[4] == 1 && (down == null || down.isEdge())) {

            if (isOverThresholdDrag) {

              if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
                goIntoBoxMode();
              } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
                var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

                if (allowPassthrough) {
                  r.hoverData.dragging = true;
                  r.hoverData.justStartedPan = true;
                  select[4] = 0;

                  r.data.bgActivePosistion = math.array2point(mdownPos);

                  r.redrawHint('select', true);
                  r.redraw();
                }
              }

              if (down && down.isEdge() && down.active()) {
                down.unactivate();
              }
            }
          } else {
            if (down && down.isEdge() && down.active()) {
              down.unactivate();
            }

            if ((!down || !down.grabbed()) && near != last) {

              if (last) {
                triggerEvents(last, ['mouseout', 'tapdragout'], e, {
                  position: { x: pos[0], y: pos[1] }
                });
              }

              if (near) {
                triggerEvents(near, ['mouseover', 'tapdragover'], e, {
                  position: { x: pos[0], y: pos[1] }
                });
              }

              r.hoverData.last = near;
            }

            if (down) {

              if (isOverThresholdDrag) {
                // then we can take action

                if (cy.boxSelectionEnabled() && multSelKeyDown) {
                  // then selection overrides
                  if (down && down.grabbed()) {
                    freeDraggedElements(draggedElements);

                    down.emit('free');
                  }

                  goIntoBoxMode();
                } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
                  // drag node
                  var justStartedDrag = !r.dragData.didDrag;

                  if (justStartedDrag) {
                    r.redrawHint('eles', true);
                  }

                  r.dragData.didDrag = true; // indicate that we actually did drag the node

                  var toTrigger = [];

                  // now, add the elements to the drag layer if not done already
                  if (!r.hoverData.draggingEles) {
                    addNodesToDrag(cy.collection(draggedElements), { inDragLayer: true });
                  }

                  for (var i = 0; i < draggedElements.length; i++) {
                    var dEle = draggedElements[i];

                    // Locked nodes not draggable, as well as non-visible nodes
                    if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                      var dPos = dEle.position();

                      toTrigger.push(dEle);

                      if (is.number(disp[0]) && is.number(disp[1])) {
                        dPos.x += disp[0];
                        dPos.y += disp[1];

                        if (justStartedDrag) {
                          var dragDelta = r.hoverData.dragDelta;

                          if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                            dPos.x += dragDelta[0];
                            dPos.y += dragDelta[1];
                          }
                        }
                      }
                    }
                  }

                  r.hoverData.draggingEles = true;

                  var tcol = cy.collection(toTrigger);

                  tcol.dirtyCompoundBoundsCache();
                  tcol.emit('position drag');

                  r.redrawHint('drag', true);
                  r.redraw();
                }
              } else {
                // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
                updateDragDelta();
              }
            }

            // prevent the dragging from triggering text selection on the page
            preventDefault = true;
          }

          select[2] = pos[0];select[3] = pos[1];

          if (preventDefault) {
            if (e.stopPropagation) e.stopPropagation();
            if (e.preventDefault) e.preventDefault();
            return false;
          }
        }, false);

        r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
          // eslint-disable-line no-undef
          var capture = r.hoverData.capture;
          if (!capture) {
            return;
          }
          r.hoverData.capture = false;

          var cy = r.cy;var pos = r.projectIntoViewport(e.clientX, e.clientY);var select = r.selection;
          var near = r.findNearestElement(pos[0], pos[1], true, false);
          var draggedElements = r.dragData.possibleDragElements;var down = r.hoverData.down;
          var multSelKeyDown = isMultSelKeyDown(e);

          if (r.data.bgActivePosistion) {
            r.redrawHint('select', true);
            r.redraw();
          }

          r.hoverData.tapholdCancelled = true;

          r.data.bgActivePosistion = undefined; // not active bg now

          if (down) {
            down.unactivate();
          }

          if (r.hoverData.which === 3) {
            var cxtEvt = {
              originalEvent: e,
              type: 'cxttapend',
              position: { x: pos[0], y: pos[1] }
            };

            if (down) {
              down.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }

            if (!r.hoverData.cxtDragged) {
              var cxtTap = {
                originalEvent: e,
                type: 'cxttap',
                position: { x: pos[0], y: pos[1] }
              };

              if (down) {
                down.emit(cxtTap);
              } else {
                cy.emit(cxtTap);
              }
            }

            r.hoverData.cxtDragged = false;
            r.hoverData.which = null;
          } else if (r.hoverData.which === 1) {

            // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
            if (down == null && // not mousedown on node
            !r.dragData.didDrag // didn't move the node around
            && !r.hoverData.selecting // not box selection
            && !r.hoverData.dragged // didn't pan
            && !isMultSelKeyDown(e)) {

              cy.$(function (ele) {
                return ele.selected();
              }).unselect();

              if (draggedElements.length > 0) {
                r.redrawHint('eles', true);
              }

              r.dragData.possibleDragElements = draggedElements = [];
            }

            triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
              position: { x: pos[0], y: pos[1] }
            });

            if (!r.dragData.didDrag // didn't move a node around
            && !r.hoverData.dragged // didn't pan
            && !r.hoverData.selecting // not box selection
            && !r.hoverData.isOverThresholdDrag // didn't move too much
            ) {
                triggerEvents(down, ['click', 'tap', 'vclick'], e, {
                  position: { x: pos[0], y: pos[1] }
                });
              }

            // Single selection
            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
              if (near != null && near._private.selectable) {

                if (r.hoverData.dragging) {
                  // if panning, don't change selection state
                } else if (cy.selectionType() === 'additive' || multSelKeyDown) {
                  if (near.selected()) {
                    near.unselect();
                  } else {
                    near.select();
                  }
                } else {
                  if (!multSelKeyDown) {
                    cy.$(':selected').unmerge(near).unselect();
                    near.select();
                  }
                }

                r.redrawHint('eles', true);
              }
            }

            if (r.hoverData.selecting) {
              var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

              r.redrawHint('select', true);

              if (box.length > 0) {
                r.redrawHint('eles', true);
              }

              cy.emit('boxend');

              var eleWouldBeSelected = function eleWouldBeSelected(ele) {
                return ele.selectable() && !ele.selected();
              };

              if (cy.selectionType() === 'additive') {
                box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
              } else {
                if (!multSelKeyDown) {
                  cy.$(':selected').unmerge(box).unselect();
                }

                box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
              }

              // always need redraw in case eles unselectable
              r.redraw();
            }

            // Cancel drag pan
            if (r.hoverData.dragging) {
              r.hoverData.dragging = false;

              r.redrawHint('select', true);
              r.redrawHint('eles', true);

              r.redraw();
            }

            if (!select[4]) {
              r.redrawHint('drag', true);
              r.redrawHint('eles', true);

              var downWasGrabbed = down && down.grabbed();

              freeDraggedElements(draggedElements);

              if (downWasGrabbed) {
                down.emit('free');
              }
            }
          } // else not right mouse

          select[4] = 0;r.hoverData.down = null;

          r.hoverData.cxtStarted = false;
          r.hoverData.draggingEles = false;
          r.hoverData.selecting = false;
          r.hoverData.isOverThresholdDrag = false;
          r.dragData.didDrag = false;
          r.hoverData.dragged = false;
          r.hoverData.dragDelta = [];
          r.hoverData.mdownPos = null;
          r.hoverData.mdownGPos = null;
        }, false);

        var wheelHandler = function wheelHandler(e) {

          if (r.scrollingPage) {
            return;
          } // while scrolling, ignore wheel-to-zoom

          var cy = r.cy;
          var pos = r.projectIntoViewport(e.clientX, e.clientY);
          var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

          if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
            // if pan dragging or cxt dragging, wheel movements make no zoom
            e.preventDefault();
            return;
          }

          if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
            e.preventDefault();

            r.data.wheelZooming = true;
            clearTimeout(r.data.wheelTimeout);
            r.data.wheelTimeout = setTimeout(function () {
              r.data.wheelZooming = false;

              r.redrawHint('eles', true);
              r.redraw();
            }, 150);

            var diff;

            if (e.deltaY != null) {
              diff = e.deltaY / -250;
            } else if (e.wheelDeltaY != null) {
              diff = e.wheelDeltaY / 1000;
            } else {
              diff = e.wheelDelta / 1000;
            }

            diff = diff * r.wheelSensitivity;

            var needsWheelFix = e.deltaMode === 1;
            if (needsWheelFix) {
              // fixes slow wheel events on ff/linux and ff/windows
              diff *= 33;
            }

            cy.zoom({
              level: cy.zoom() * Math.pow(10, diff),
              renderedPosition: { x: rpos[0], y: rpos[1] }
            });
          }
        };

        // Functions to help with whether mouse wheel should trigger zooming
        // --
        r.registerBinding(r.container, 'wheel', wheelHandler, true);

        // disable nonstandard wheel events
        // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
        // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
        // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

        r.registerBinding(window, 'scroll', function scrollHandler(e) {
          // eslint-disable-line no-undef
          r.scrollingPage = true;

          clearTimeout(r.scrollingPageTimeout);
          r.scrollingPageTimeout = setTimeout(function () {
            r.scrollingPage = false;
          }, 250);
        }, true);

        // Functions to help with handling mouseout/mouseover on the Cytoscape container
        // Handle mouseout on Cytoscape container
        r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
          var pos = r.projectIntoViewport(e.clientX, e.clientY);

          r.cy.emit({
            originalEvent: e,
            type: 'mouseout',
            position: { x: pos[0], y: pos[1] }
          });
        }, false);

        r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
          var pos = r.projectIntoViewport(e.clientX, e.clientY);

          r.cy.emit({
            originalEvent: e,
            type: 'mouseover',
            position: { x: pos[0], y: pos[1] }
          });
        }, false);

        var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
        var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
        var center1, modelCenter1; // center point on start pinch to zoom
        var offsetLeft, offsetTop;
        var containerWidth, containerHeight;
        var twoFingersStartInside;

        var distance = function distance(x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        };

        var distanceSq = function distanceSq(x1, y1, x2, y2) {
          return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        };

        var touchstartHandler;
        r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
          if (!eventInContainer(e)) {
            return;
          }

          r.touchData.capture = true;
          r.data.bgActivePosistion = undefined;

          var cy = r.cy;
          var now = r.touchData.now;
          var earlier = r.touchData.earlier;

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
          }
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
          }
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
          }

          // record starting points for pinch-to-zoom
          if (e.touches[1]) {

            freeDraggedElements(r.dragData.touchDragEles);

            var offsets = r.findContainerClientCoords();
            offsetLeft = offsets[0];
            offsetTop = offsets[1];
            containerWidth = offsets[2];
            containerHeight = offsets[3];

            f1x1 = e.touches[0].clientX - offsetLeft;
            f1y1 = e.touches[0].clientY - offsetTop;

            f2x1 = e.touches[1].clientX - offsetLeft;
            f2y1 = e.touches[1].clientY - offsetTop;

            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;

            var pan = cy.pan();
            var zoom = cy.zoom();

            distance1 = distance(f1x1, f1y1, f2x1, f2y1);
            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
            center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
            modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];

            // consider context tap
            var cxtDistThreshold = 200;
            var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {

              var near1 = r.findNearestElement(now[0], now[1], true, true);
              var near2 = r.findNearestElement(now[2], now[3], true, true);

              if (near1 && near1.isNode()) {
                near1.activate().emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: { x: now[0], y: now[1] }
                });
                r.touchData.start = near1;
              } else if (near2 && near2.isNode()) {
                near2.activate().emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: { x: now[0], y: now[1] }
                });
                r.touchData.start = near2;
              } else {
                cy.emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: { x: now[0], y: now[1] }
                });
              }

              if (r.touchData.start) {
                r.touchData.start._private.grabbed = false;
              }
              r.touchData.cxt = true;
              r.touchData.cxtDragged = false;
              r.data.bgActivePosistion = undefined;

              r.redraw();
              return;
            }
          }

          if (e.touches[2]) {
            // ignore
          } else if (e.touches[1]) {
            // ignore
          } else if (e.touches[0]) {
            var nears = r.findNearestElements(now[0], now[1], true, true);
            var near = nears[0];

            if (near != null) {
              near.activate();

              r.touchData.start = near;
              r.touchData.starts = nears;

              if (r.nodeIsGrabbable(near)) {

                var draggedEles = r.dragData.touchDragEles = [];
                var selectedNodes = null;

                r.redrawHint('eles', true);
                r.redrawHint('drag', true);

                if (near.selected()) {
                  // reset drag elements, since near will be added again

                  selectedNodes = cy.$(function (ele) {
                    return ele.selected() && r.nodeIsGrabbable(ele);
                  });

                  addNodesToDrag(selectedNodes, { addToList: draggedEles });
                } else {
                  addNodeToDrag(near, { addToList: draggedEles });
                }

                setGrabTarget(near);

                var makeEvent = function makeEvent(type) {
                  return {
                    originalEvent: e,
                    type: type,
                    position: { x: now[0], y: now[1] }
                  };
                };

                near.emit(makeEvent('grabon'));

                if (selectedNodes) {
                  selectedNodes.forEach(function (n) {
                    n.emit(makeEvent('grab'));
                  });
                } else {
                  near.emit(makeEvent('grab'));
                }
              }
            }

            triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
              position: { x: now[0], y: now[1] }
            });

            if (near == null) {
              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.redrawHint('select', true);
              r.redraw();
            }

            // Tap, taphold
            // -----

            r.touchData.singleTouchMoved = false;
            r.touchData.singleTouchStartTime = +new Date();

            clearTimeout(r.touchData.tapholdTimeout);
            r.touchData.tapholdTimeout = setTimeout(function () {
              if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
              && !r.touchData.selecting // box selection shouldn't allow taphold through
              ) {
                  triggerEvents(r.touchData.start, ['taphold'], e, {
                    position: { x: now[0], y: now[1] }
                  });

                  if (!r.touchData.start) {
                    cy.$(':selected').unselect();
                  }
                }
            }, r.tapholdDuration);
          }

          if (e.touches.length >= 1) {
            var sPos = r.touchData.startPosition = [];

            for (var i = 0; i < now.length; i++) {
              sPos[i] = earlier[i] = now[i];
            }

            var touch0 = e.touches[0];

            r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
          }
        }, false);

        var touchmoveHandler;
        r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
          // eslint-disable-line no-undef
          var capture = r.touchData.capture;

          if (!capture && !eventInContainer(e)) {
            return;
          }

          var select = r.selection;
          var cy = r.cy;
          var now = r.touchData.now;
          var earlier = r.touchData.earlier;
          var zoom = cy.zoom();

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
          }
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
          }
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
          }

          var startGPos = r.touchData.startGPosition;
          var isOverThresholdDrag;

          if (capture && e.touches[0] && startGPos) {
            var disp = [];for (var j = 0; j < now.length; j++) {
              disp[j] = now[j] - earlier[j];
            }
            var dx = e.touches[0].clientX - startGPos[0];
            var dx2 = dx * dx;
            var dy = e.touches[0].clientY - startGPos[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;

            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
          }

          // context swipe cancelling
          if (capture && r.touchData.cxt) {
            e.preventDefault();

            var f1x2 = e.touches[0].clientX - offsetLeft,
                f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft,
                f2y2 = e.touches[1].clientY - offsetTop;
            // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
            var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
            var factorSq = distance2Sq / distance1Sq;

            var distThreshold = 150;
            var distThresholdSq = distThreshold * distThreshold;
            var factorThreshold = 1.5;
            var factorThresholdSq = factorThreshold * factorThreshold;

            // cancel ctx gestures if the distance b/t the fingers increases
            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
              r.touchData.cxt = false;

              r.data.bgActivePosistion = undefined;

              r.redrawHint('select', true);

              var cxtEvt = {
                originalEvent: e,
                type: 'cxttapend',
                position: { x: now[0], y: now[1] }
              };

              if (r.touchData.start) {
                r.touchData.start.unactivate().emit(cxtEvt);

                r.touchData.start = null;
              } else {
                cy.emit(cxtEvt);
              }
            }
          }

          // context swipe
          if (capture && r.touchData.cxt) {
            var cxtEvt = {
              originalEvent: e,
              type: 'cxtdrag',
              position: { x: now[0], y: now[1] }
            };
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            if (r.touchData.start) {
              r.touchData.start.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }

            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }
            r.touchData.cxtDragged = true;

            var near = r.findNearestElement(now[0], now[1], true, true);

            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {

              if (r.touchData.cxtOver) {
                r.touchData.cxtOver.emit({
                  originalEvent: e,
                  type: 'cxtdragout',
                  position: { x: now[0], y: now[1] }
                });
              }

              r.touchData.cxtOver = near;

              if (near) {
                near.emit({
                  originalEvent: e,
                  type: 'cxtdragover',
                  position: { x: now[0], y: now[1] }
                });
              }
            }

            // box selection
          } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
            e.preventDefault();

            r.data.bgActivePosistion = undefined;

            this.lastThreeTouch = +new Date();

            if (!r.touchData.selecting) {
              cy.emit('boxstart');
            }

            r.touchData.selecting = true;

            r.redrawHint('select', true);

            if (!select || select.length === 0 || select[0] === undefined) {
              select[0] = (now[0] + now[2] + now[4]) / 3;
              select[1] = (now[1] + now[3] + now[5]) / 3;
              select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
              select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
            } else {
              select[2] = (now[0] + now[2] + now[4]) / 3;
              select[3] = (now[1] + now[3] + now[5]) / 3;
            }

            select[4] = 1;
            r.touchData.selecting = true;

            r.redraw();

            // pinch to zoom
          } else if (capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
            // two fingers => pinch to zoom
            e.preventDefault();

            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            var draggedEles = r.dragData.touchDragEles;
            if (draggedEles) {
              r.redrawHint('drag', true);

              for (var i = 0; i < draggedEles.length; i++) {
                var de_p = draggedEles[i]._private;

                de_p.grabbed = false;
                de_p.rscratch.inDragLayer = false;
              }
            }

            // (x2, y2) for fingers 1 and 2
            var f1x2 = e.touches[0].clientX - offsetLeft,
                f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft,
                f2y2 = e.touches[1].clientY - offsetTop;

            var distance2 = distance(f1x2, f1y2, f2x2, f2y2);
            // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
            // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
            var factor = distance2 / distance1;

            if (twoFingersStartInside) {
              // delta finger1
              var df1x = f1x2 - f1x1;
              var df1y = f1y2 - f1y1;

              // delta finger 2
              var df2x = f2x2 - f2x1;
              var df2y = f2y2 - f2y1;

              // translation is the normalised vector of the two fingers movement
              // i.e. so pinching cancels out and moving together pans
              var tx = (df1x + df2x) / 2;
              var ty = (df1y + df2y) / 2;

              // adjust factor by the speed multiplier
              // var speed = 1.5;
              // if( factor > 1 ){
              //   factor = (factor - 1) * speed + 1;
              // } else {
              //   factor = 1 - (1 - factor) * speed;
              // }

              // now calculate the zoom
              var zoom1 = cy.zoom();
              var zoom2 = zoom1 * factor;
              var pan1 = cy.pan();

              // the model center point converted to the current rendered pos
              var ctrx = modelCenter1[0] * zoom1 + pan1.x;
              var ctry = modelCenter1[1] * zoom1 + pan1.y;

              var pan2 = {
                x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
                y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
              };

              // remove dragged eles
              if (r.touchData.start && r.touchData.start.active()) {
                var draggedEles = r.dragData.touchDragEles;

                freeDraggedElements(draggedEles);

                r.redrawHint('drag', true);
                r.redrawHint('eles', true);

                r.touchData.start.unactivate().emit('free');
              }

              cy.viewport({
                zoom: zoom2,
                pan: pan2,
                cancelOnFailedZoom: true
              });

              distance1 = distance2;
              f1x1 = f1x2;
              f1y1 = f1y2;
              f2x1 = f2x2;
              f2y1 = f2y2;

              r.pinching = true;
            }

            // Re-project
            if (e.touches[0]) {
              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
            }
            if (e.touches[1]) {
              var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
            }
            if (e.touches[2]) {
              var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
            }
          } else if (e.touches[0]) {
            var start = r.touchData.start;
            var last = r.touchData.last;
            var near;

            if (!r.hoverData.draggingEles && !r.swipePanning) {
              near = r.findNearestElement(now[0], now[1], true, true);
            }

            if (capture && start != null) {
              e.preventDefault();
            }

            // dragging nodes
            if (capture && start != null && r.nodeIsDraggable(start)) {

              if (isOverThresholdDrag) {
                // then dragging can happen
                var draggedEles = r.dragData.touchDragEles;
                var justStartedDrag = !r.dragData.didDrag;

                if (justStartedDrag) {
                  addNodesToDrag(cy.collection(draggedEles), { inDragLayer: true });
                }

                for (var k = 0; k < draggedEles.length; k++) {
                  var draggedEle = draggedEles[k];

                  if (r.nodeIsDraggable(draggedEle) && draggedEle.grabbed()) {
                    r.dragData.didDrag = true;
                    var dPos = draggedEle.position();

                    if (is.number(disp[0]) && is.number(disp[1])) {
                      dPos.x += disp[0];
                      dPos.y += disp[1];
                    }

                    if (justStartedDrag) {
                      r.redrawHint('eles', true);

                      var dragDelta = r.touchData.dragDelta;

                      if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                        dPos.x += dragDelta[0];
                        dPos.y += dragDelta[1];
                      }
                    }
                  }
                }

                var tcol = cy.collection(draggedEles);

                tcol.dirtyCompoundBoundsCache();
                tcol.emit('position drag');

                r.hoverData.draggingEles = true;

                r.redrawHint('drag', true);

                if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {

                  r.redrawHint('eles', true);
                }

                r.redraw();
              } else {
                // otherise keep track of drag delta for later
                var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

                if (dragDelta.length === 0) {
                  dragDelta.push(disp[0]);
                  dragDelta.push(disp[1]);
                } else {
                  dragDelta[0] += disp[0];
                  dragDelta[1] += disp[1];
                }
              }
            }

            // touchmove
            {
              triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
                position: { x: now[0], y: now[1] }
              });

              if ((!start || !start.grabbed()) && near != last) {
                if (last) {
                  last.emit({ originalEvent: e, type: 'tapdragout', position: { x: now[0], y: now[1] } });
                }
                if (near) {
                  near.emit({ originalEvent: e, type: 'tapdragover', position: { x: now[0], y: now[1] } });
                }
              }

              r.touchData.last = near;
            }

            // check to cancel taphold
            if (capture) {
              for (var i = 0; i < now.length; i++) {
                if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {

                  r.touchData.singleTouchMoved = true;
                }
              }
            }

            // panning
            if (capture && (start == null || start.isEdge()) && cy.panningEnabled() && cy.userPanningEnabled()) {

              var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

              if (allowPassthrough) {
                e.preventDefault();

                if (r.swipePanning) {
                  cy.panBy({
                    x: disp[0] * zoom,
                    y: disp[1] * zoom
                  });
                } else if (isOverThresholdDrag) {
                  r.swipePanning = true;

                  cy.panBy({
                    x: dx * zoom,
                    y: dy * zoom
                  });

                  if (start) {
                    start.unactivate();

                    if (!r.data.bgActivePosistion) {
                      r.data.bgActivePosistion = math.array2point(r.touchData.startPosition);
                    }

                    r.redrawHint('select', true);

                    r.touchData.start = null;
                  }
                }
              }

              // Re-project
              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
              now[0] = pos[0];now[1] = pos[1];
            }
          }

          for (var j = 0; j < now.length; j++) {
            earlier[j] = now[j];
          }
          //r.redraw();
        }, false);

        var touchcancelHandler;
        r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
          // eslint-disable-line no-undef
          var start = r.touchData.start;

          r.touchData.capture = false;

          if (start) {
            start.unactivate();
          }
        });

        var touchendHandler;
        r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
          // eslint-disable-line no-undef
          var start = r.touchData.start;

          var capture = r.touchData.capture;

          if (capture) {
            r.touchData.capture = false;

            e.preventDefault();
          } else {
            return;
          }

          var select = r.selection;

          r.swipePanning = false;
          r.hoverData.draggingEles = false;

          var cy = r.cy;
          var zoom = cy.zoom();
          var now = r.touchData.now;
          var earlier = r.touchData.earlier;

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
          }
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
          }
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
          }

          if (start) {
            start.unactivate();
          }

          var ctxTapend;
          if (r.touchData.cxt) {
            ctxTapend = {
              originalEvent: e,
              type: 'cxttapend',
              position: { x: now[0], y: now[1] }
            };

            if (start) {
              start.emit(ctxTapend);
            } else {
              cy.emit(ctxTapend);
            }

            if (!r.touchData.cxtDragged) {
              var ctxTap = {
                originalEvent: e,
                type: 'cxttap',
                position: { x: now[0], y: now[1] }
              };

              if (start) {
                start.emit(ctxTap);
              } else {
                cy.emit(ctxTap);
              }
            }

            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }
            r.touchData.cxt = false;
            r.touchData.start = null;

            r.redraw();
            return;
          }

          // no more box selection if we don't have three fingers
          if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
            r.touchData.selecting = false;

            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

            select[0] = undefined;
            select[1] = undefined;
            select[2] = undefined;
            select[3] = undefined;
            select[4] = 0;

            r.redrawHint('select', true);

            cy.emit('boxend');

            var eleWouldBeSelected = function eleWouldBeSelected(ele) {
              return ele.selectable() && !ele.selected();
            };

            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

            if (box.nonempty()) {
              r.redrawHint('eles', true);
            }

            r.redraw();
          }

          if (start != null) {
            start.unactivate();
          }

          if (e.touches[2]) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
          } else if (e.touches[1]) {
            // ignore
          } else if (e.touches[0]) {
            // ignore

            // Last touch released
          } else if (!e.touches[0]) {

            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            var draggedEles = r.dragData.touchDragEles;

            if (start != null) {

              var startWasGrabbed = start._private.grabbed;

              freeDraggedElements(draggedEles);

              r.redrawHint('drag', true);
              r.redrawHint('eles', true);

              if (startWasGrabbed) {
                start.emit('free');
              }

              triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
                position: { x: now[0], y: now[1] }
              });

              start.unactivate();

              r.touchData.start = null;
            } else {
              var near = r.findNearestElement(now[0], now[1], true, true);

              triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
                position: { x: now[0], y: now[1] }
              });
            }

            var dx = r.touchData.startPosition[0] - now[0];
            var dx2 = dx * dx;
            var dy = r.touchData.startPosition[1] - now[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;
            var rdist2 = dist2 * zoom * zoom;

            // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
            if (start != null && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
            ) {

                if (cy.selectionType() === 'single') {
                  cy.$(':selected').unmerge(start).unselect();
                  start.select();
                } else {
                  if (start.selected()) {
                    start.unselect();
                  } else {
                    start.select();
                  }
                }

                r.redrawHint('eles', true);
              }

            // Tap event, roughly same as mouse click event for touch
            if (!r.touchData.singleTouchMoved) {
              triggerEvents(start, ['tap', 'vclick'], e, {
                position: { x: now[0], y: now[1] }
              });
            }

            r.touchData.singleTouchMoved = true;
          }

          for (var j = 0; j < now.length; j++) {
            earlier[j] = now[j];
          }

          r.dragData.didDrag = false; // reset for next mousedown

          if (e.touches.length === 0) {
            r.touchData.dragDelta = [];
            r.touchData.startPosition = null;
            r.touchData.startGPosition = null;
          }

          if (e.touches.length < 2) {
            r.pinching = false;
            r.redrawHint('eles', true);
            r.redraw();
          }

          //r.redraw();
        }, false);

        // fallback compatibility layer for ms pointer events
        if (typeof TouchEvent === 'undefined') {

          var pointers = [];

          var makeTouch = function makeTouch(e) {
            return {
              clientX: e.clientX,
              clientY: e.clientY,
              force: 1,
              identifier: e.pointerId,
              pageX: e.pageX,
              pageY: e.pageY,
              radiusX: e.width / 2,
              radiusY: e.height / 2,
              screenX: e.screenX,
              screenY: e.screenY,
              target: e.target
            };
          };

          var makePointer = function makePointer(e) {
            return {
              event: e,
              touch: makeTouch(e)
            };
          };

          var addPointer = function addPointer(e) {
            pointers.push(makePointer(e));
          };

          var removePointer = function removePointer(e) {
            for (var i = 0; i < pointers.length; i++) {
              var p = pointers[i];

              if (p.event.pointerId === e.pointerId) {
                pointers.splice(i, 1);
                return;
              }
            }
          };

          var updatePointer = function updatePointer(e) {
            var p = pointers.filter(function (p) {
              return p.event.pointerId === e.pointerId;
            })[0];

            p.event = e;
            p.touch = makeTouch(e);
          };

          var addTouchesToEvent = function addTouchesToEvent(e) {
            e.touches = pointers.map(function (p) {
              return p.touch;
            });
          };

          var pointerIsMouse = function pointerIsMouse(e) {
            return e.pointerType === 'mouse' || e.pointerType === 4;
          };

          r.registerBinding(r.container, 'pointerdown', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            e.preventDefault();

            addPointer(e);

            addTouchesToEvent(e);
            touchstartHandler(e);
          });

          r.registerBinding(r.container, 'pointerup', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            removePointer(e);

            addTouchesToEvent(e);
            touchendHandler(e);
          });

          r.registerBinding(r.container, 'pointercancel', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            removePointer(e);

            addTouchesToEvent(e);
            touchcancelHandler(e);
          });

          r.registerBinding(r.container, 'pointermove', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            e.preventDefault();

            updatePointer(e);

            addTouchesToEvent(e);
            touchmoveHandler(e);
          });
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 123 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var BRp = {};

      BRp.generatePolygon = function (name, points) {
        return this.nodeShapes[name] = {
          renderer: this,

          name: name,

          points: points,

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return math.polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
          }
        };
      };

      BRp.generateEllipse = function () {
        return this.nodeShapes['ellipse'] = {
          renderer: this,

          name: 'ellipse',

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return math.intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return math.checkInEllipse(x, y, width, height, centerX, centerY, padding);
          }
        };
      };

      BRp.generateRoundRectangle = function () {
        return this.nodeShapes['roundrectangle'] = {
          renderer: this,

          name: 'roundrectangle',

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

            var cornerRadius = math.getRoundRectangleRadius(width, height);
            var diam = cornerRadius * 2;

            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
              return true;
            }

            // Check top left quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

              return true;
            }

            // Check top right quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

              return true;
            }

            // Check bottom right quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            // Check bottom left quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            return false;
          }
        };
      };

      BRp.generateCutRectangle = function () {
        return this.nodeShapes['cutrectangle'] = {
          renderer: this,

          name: 'cutrectangle',

          cornerLength: math.getCutRectangleCornerLength(),

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
            var cl = this.cornerLength;
            var hh = height / 2;
            var hw = width / 2;
            var xBegin = centerX - hw;
            var xEnd = centerX + hw;
            var yBegin = centerY - hh;
            var yEnd = centerY + hh;

            // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
            return {
              topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
              topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
              bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
              bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
            };
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
            var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);

            return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
              return true;
            }
            var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
            return math.pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
          }

        };
      };

      BRp.generateBarrel = function () {
        return this.nodeShapes['barrel'] = {
          renderer: this,

          name: 'barrel',

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            // use two fixed t values for the bezier curve approximation

            var t0 = 0.15;
            var t1 = 0.5;
            var t2 = 0.85;

            var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

            var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
              // approximate curve pts based on the two t values
              var m0 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t0);
              var m1 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t1);
              var m2 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t2);

              return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
            };

            var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));

            return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
          },

          generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
            var hh = height / 2;
            var hw = width / 2;
            var xBegin = centerX - hw;
            var xEnd = centerX + hw;
            var yBegin = centerY - hh;
            var yEnd = centerY + hh;

            var curveConstants = math.getBarrelCurveConstants(width, height);
            var hOffset = curveConstants.heightOffset;
            var wOffset = curveConstants.widthOffset;
            var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;

            // points are in clockwise order, inner (imaginary) control pt on [4, 5]
            var pts = {
              topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
              topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
              bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
              bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
            };

            pts.topLeft.isTop = true;
            pts.topRight.isTop = true;
            pts.bottomLeft.isBottom = true;
            pts.bottomRight.isBottom = true;

            return pts;
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

            var curveConstants = math.getBarrelCurveConstants(width, height);
            var hOffset = curveConstants.heightOffset;
            var wOffset = curveConstants.widthOffset;

            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
              return true;
            }

            var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

            var getCurveT = function getCurveT(x, y, curvePts) {
              var x0 = curvePts[4];
              var x1 = curvePts[2];
              var x2 = curvePts[0];
              var y0 = curvePts[5];
              // var y1 = curvePts[ 3 ];
              var y2 = curvePts[1];

              var xMin = Math.min(x0, x2);
              var xMax = Math.max(x0, x2);
              var yMin = Math.min(y0, y2);
              var yMax = Math.max(y0, y2);

              if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
                var coeff = math.bezierPtsToQuadCoeff(x0, x1, x2);
                var roots = math.solveQuadratic(coeff[0], coeff[1], coeff[2], x);

                var validRoots = roots.filter(function (r) {
                  return 0 <= r && r <= 1;
                });

                if (validRoots.length > 0) {
                  return validRoots[0];
                }
              }
              return null;
            };

            var curveRegions = Object.keys(barrelCurvePts);
            for (var i = 0; i < curveRegions.length; i++) {
              var corner = curveRegions[i];
              var cornerPts = barrelCurvePts[corner];
              var t = getCurveT(x, y, cornerPts);

              if (t == null) {
                continue;
              }

              var y0 = cornerPts[5];
              var y1 = cornerPts[3];
              var y2 = cornerPts[1];
              var bezY = math.qbezierAt(y0, y1, y2, t);

              if (cornerPts.isTop && bezY <= y) {
                return true;
              }
              if (cornerPts.isBottom && y <= bezY) {
                return true;
              }
            }
            return false;
          }
        };
      };

      BRp.generateBottomRoundrectangle = function () {
        return this.nodeShapes['bottomroundrectangle'] = {
          renderer: this,

          name: 'bottomroundrectangle',

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            var topStartX = nodeX - (width / 2 + padding);
            var topStartY = nodeY - (height / 2 + padding);
            var topEndY = topStartY;
            var topEndX = nodeX + (width / 2 + padding);

            var topIntersections = math.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
            if (topIntersections.length > 0) {
              return topIntersections;
            }

            return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

            var cornerRadius = math.getRoundRectangleRadius(width, height);
            var diam = 2 * cornerRadius;

            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
              return true;
            }

            // check non-rounded top side
            var outerWidth = width / 2 + 2 * padding;
            var outerHeight = height / 2 + 2 * padding;
            var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];
            if (math.pointInsidePolygonPoints(x, y, points)) {
              return true;
            }

            // Check bottom right quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            // Check bottom left quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            return false;
          }
        };
      };

      BRp.registerNodeShapes = function () {
        var nodeShapes = this.nodeShapes = {};
        var renderer = this;

        this.generateEllipse();

        this.generatePolygon('triangle', math.generateUnitNgonPointsFitToSquare(3, 0));

        this.generatePolygon('rectangle', math.generateUnitNgonPointsFitToSquare(4, 0));
        nodeShapes['square'] = nodeShapes['rectangle'];

        this.generateRoundRectangle();

        this.generateCutRectangle();

        this.generateBarrel();

        this.generateBottomRoundrectangle();

        this.generatePolygon('diamond', [0, 1, 1, 0, 0, -1, -1, 0]);

        this.generatePolygon('pentagon', math.generateUnitNgonPointsFitToSquare(5, 0));

        this.generatePolygon('hexagon', math.generateUnitNgonPointsFitToSquare(6, 0));

        this.generatePolygon('heptagon', math.generateUnitNgonPointsFitToSquare(7, 0));

        this.generatePolygon('octagon', math.generateUnitNgonPointsFitToSquare(8, 0));

        var star5Points = new Array(20);
        {
          var outerPoints = math.generateUnitNgonPoints(5, 0);
          var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);

          // Outer radius is 1; inner radius of star is smaller
          var innerRadius = 0.5 * (3 - Math.sqrt(5));
          innerRadius *= 1.57;

          for (var i = 0; i < innerPoints.length / 2; i++) {
            innerPoints[i * 2] *= innerRadius;
            innerPoints[i * 2 + 1] *= innerRadius;
          }

          for (var i = 0; i < 20 / 4; i++) {
            star5Points[i * 4] = outerPoints[i * 2];
            star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];

            star5Points[i * 4 + 2] = innerPoints[i * 2];
            star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
          }
        }

        star5Points = math.fitPolygonToSquare(star5Points);

        this.generatePolygon('star', star5Points);

        this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);

        this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);

        this.generatePolygon('concavehexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);

        this.generatePolygon('tag', [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1]);

        nodeShapes.makePolygon = function (points) {

          // use caching on user-specified polygons so they are as fast as native shapes

          var key = points.join('$');
          var name = 'polygon-' + key;
          var shape;

          if (shape = this[name]) {
            // got cached shape
            return shape;
          }

          // create and cache new shape
          return renderer.generatePolygon(name, points);
        };
      };

      module.exports = BRp;

      /***/
    },
    /* 124 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var BRp = {};

      BRp.timeToRender = function () {
        return this.redrawTotalTime / this.redrawCount;
      };

      BRp.redraw = function (options) {
        options = options || util.staticEmptyObject();

        var r = this;

        if (r.averageRedrawTime === undefined) {
          r.averageRedrawTime = 0;
        }
        if (r.lastRedrawTime === undefined) {
          r.lastRedrawTime = 0;
        }
        if (r.lastDrawTime === undefined) {
          r.lastDrawTime = 0;
        }

        r.requestedFrame = true;
        r.renderOptions = options;
      };

      BRp.beforeRender = function (fn, priority) {
        // the renderer can't add tick callbacks when destroyed
        if (this.destroyed) {
          return;
        }

        priority = priority || 0;

        var cbs = this.beforeRenderCallbacks;

        cbs.push({ fn: fn, priority: priority });

        // higher priority callbacks executed first
        cbs.sort(function (a, b) {
          return b.priority - a.priority;
        });
      };

      var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
        var cbs = r.beforeRenderCallbacks;

        for (var i = 0; i < cbs.length; i++) {
          cbs[i].fn(willDraw, startTime);
        }
      };

      BRp.startRenderLoop = function () {
        var r = this;

        if (r.renderLoopStarted) {
          return;
        } else {
          r.renderLoopStarted = true;
        }

        var renderFn = function renderFn(requestTime) {
          if (r.destroyed) {
            return;
          }

          if (r.requestedFrame && !r.skipFrame) {
            beforeRenderCallbacks(r, true, requestTime);

            var startTime = util.performanceNow();

            r.render(r.renderOptions);

            var endTime = r.lastDrawTime = util.performanceNow();

            if (r.averageRedrawTime === undefined) {
              r.averageRedrawTime = endTime - startTime;
            }

            if (r.redrawCount === undefined) {
              r.redrawCount = 0;
            }

            r.redrawCount++;

            if (r.redrawTotalTime === undefined) {
              r.redrawTotalTime = 0;
            }

            var duration = endTime - startTime;

            r.redrawTotalTime += duration;
            r.lastRedrawTime = duration;

            // use a weighted average with a bias from the previous average so we don't spike so easily
            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

            r.requestedFrame = false;
          } else {
            beforeRenderCallbacks(r, false, requestTime);
          }

          r.skipFrame = false;

          util.requestAnimationFrame(renderFn);
        };

        util.requestAnimationFrame(renderFn);
      };

      module.exports = BRp;

      /***/
    },
    /* 125 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*
      The canvas renderer was written by Yue Dong.
      
      Modifications tracked on Github.
      */

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var ElementTextureCache = __webpack_require__(126);
      var LayeredTextureCache = __webpack_require__(127);

      var CR = CanvasRenderer;
      var CRp = CanvasRenderer.prototype;

      CRp.CANVAS_LAYERS = 3;
      //
      CRp.SELECT_BOX = 0;
      CRp.DRAG = 1;
      CRp.NODE = 2;

      CRp.BUFFER_COUNT = 3;
      //
      CRp.TEXTURE_BUFFER = 0;
      CRp.MOTIONBLUR_BUFFER_NODE = 1;
      CRp.MOTIONBLUR_BUFFER_DRAG = 2;

      function CanvasRenderer(options) {
        var r = this;

        r.data = {
          canvases: new Array(CRp.CANVAS_LAYERS),
          contexts: new Array(CRp.CANVAS_LAYERS),
          canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),

          bufferCanvases: new Array(CRp.BUFFER_COUNT),
          bufferContexts: new Array(CRp.CANVAS_LAYERS)
        };

        var tapHlOff = '-webkit-tap-highlight-color: rgba(0,0,0,0);';

        r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef
        var containerStyle = r.data.canvasContainer.style;
        r.data.canvasContainer.setAttribute('style', tapHlOff);
        containerStyle.position = 'relative';
        containerStyle.zIndex = '0';
        containerStyle.overflow = 'hidden';

        var container = options.cy.container();
        container.appendChild(r.data.canvasContainer);

        if ((container.getAttribute('style') || '').indexOf(tapHlOff) < 0) {
          container.setAttribute('style', (container.getAttribute('style') || '') + tapHlOff);
        }

        for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
          var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
          r.data.contexts[i] = canvas.getContext('2d');
          canvas.setAttribute('style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + (is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : ''));
          canvas.style.position = 'absolute';
          canvas.setAttribute('data-id', 'layer' + i);
          canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
          r.data.canvasContainer.appendChild(canvas);

          r.data.canvasNeedsRedraw[i] = false;
        }
        r.data.topCanvas = r.data.canvases[0];

        r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
        r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
        r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');

        for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
          r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
          r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
          r.data.bufferCanvases[i].style.position = 'absolute';
          r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
          r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
          r.data.bufferCanvases[i].style.visibility = 'hidden';
          //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
        }

        r.pathsEnabled = true;

        r.data.eleTxrCache = new ElementTextureCache(r);
        r.data.lyrTxrCache = new LayeredTextureCache(r, r.data.eleTxrCache);

        r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var rs = ele._private.rstyle;
            var de = rs.dirtyEvents;

            if (ele.isNode() && de && de.length === 1 && de['position']) {
              // then keep cached ele texture
            } else {
              r.data.eleTxrCache.invalidateElement(ele);

              // NB this block of code should not be ported to 3.3 (unstable branch).
              // - This check is unneccesary in 3.3 as caches will be stored without respect to opacity.
              // - This fix may result in lowered performance for compound graphs.
              // - Ref : Opacity of child node is not updated for certain zoom levels after parent opacity is overriden #2078
              if (ele.isParent() && de['style']) {
                var op1 = rs.prevParentOpacity;
                var op2 = ele.pstyle('opacity').pfValue;

                rs.prevParentOpacity = op2;

                if (op1 !== op2) {
                  var descs = ele.descendants();

                  for (var j = 0; j < descs.length; j++) {
                    r.data.eleTxrCache.invalidateElement(descs[j]);
                  }
                }
              }
            }
          }

          if (eles.length > 0) {
            r.data.lyrTxrCache.invalidateElements(eles);
          }
        });
      }

      CRp.redrawHint = function (group, bool) {
        var r = this;

        switch (group) {
          case 'eles':
            r.data.canvasNeedsRedraw[CRp.NODE] = bool;
            break;
          case 'drag':
            r.data.canvasNeedsRedraw[CRp.DRAG] = bool;
            break;
          case 'select':
            r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;
            break;
        }
      };

      // whether to use Path2D caching for drawing
      var pathsImpld = typeof Path2D !== 'undefined';

      CRp.path2dEnabled = function (on) {
        if (on === undefined) {
          return this.pathsEnabled;
        }

        this.pathsEnabled = on ? true : false;
      };

      CRp.usePaths = function () {
        return pathsImpld && this.pathsEnabled;
      };

      [__webpack_require__(128), __webpack_require__(129), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132), __webpack_require__(133), __webpack_require__(134), __webpack_require__(135), __webpack_require__(136), __webpack_require__(137)].forEach(function (props) {
        util.extend(CRp, props);
      });

      module.exports = CR;

      /***/
    },
    /* 126 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var util = __webpack_require__(1);
      var Heap = __webpack_require__(9);
      var defs = __webpack_require__(19);

      var minTxrH = 25; // the size of the texture cache for small height eles (special case)
      var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
      var minLvl = -4; // when scaling smaller than that we don't need to re-render
      var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
      var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
      var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
      var defTxrWidth = 1024; // default/minimum texture width
      var maxTxrW = 1024; // the maximum width of a texture
      var maxTxrH = 1024; // the maximum height of a texture
      var minUtility = 0.5; // if usage of texture is less than this, it is retired
      var maxFullness = 0.8; // fullness of texture after which queue removal is checked
      var maxFullnessChecks = 10; // dequeued after this many checks
      var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
      var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
      var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
      var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
      var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
      var deqFastCost = 0.9; // % of frame time to be used when >60fps
      var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
      var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

      var getTxrReasons = {
        dequeue: 'dequeue',
        downscale: 'downscale',
        highQuality: 'highQuality'
      };

      var ElementTextureCache = function ElementTextureCache(renderer) {
        var self = this;

        self.renderer = renderer;
        self.onDequeues = [];

        self.setupDequeueing();
      };

      var ETCp = ElementTextureCache.prototype;

      ETCp.reasons = getTxrReasons;

      // the list of textures in which new subtextures for elements can be placed
      ETCp.getTextureQueue = function (txrH) {
        var self = this;
        self.eleImgCaches = self.eleImgCaches || {};

        return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
      };

      // the list of usused textures which can be recycled (in use in texture queue)
      ETCp.getRetiredTextureQueue = function (txrH) {
        var self = this;

        var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
        var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];

        return rtxtrQ;
      };

      // queue of element draw requests at different scale levels
      ETCp.getElementQueue = function () {
        var self = this;

        var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
          return b.reqs - a.reqs;
        });

        return q;
      };

      // queue of element draw requests at different scale levels (element id lookup)
      ETCp.getElementIdToQueue = function () {
        var self = this;

        var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

        return id2q;
      };

      ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
        var self = this;
        var r = this.renderer;
        var rs = ele._private.rscratch;
        var zoom = r.cy.zoom();

        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
          return null;
        }

        if (lvl == null) {
          lvl = Math.ceil(math.log2(zoom * pxRatio));
        }

        if (lvl < minLvl) {
          lvl = minLvl;
        } else if (zoom >= maxZoom || lvl > maxLvl) {
          return null;
        }

        var scale = Math.pow(2, lvl);
        var eleScaledH = bb.h * scale;
        var eleScaledW = bb.w * scale;
        var caches = rs.imgCaches = rs.imgCaches || {};
        var eleCache = caches[lvl];

        if (eleCache) {
          return eleCache;
        }

        var txrH; // which texture height this ele belongs to

        if (eleScaledH <= minTxrH) {
          txrH = minTxrH;
        } else if (eleScaledH <= txrStepH) {
          txrH = txrStepH;
        } else {
          txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
        }

        if (eleScaledH > maxTxrH || eleScaledW > maxTxrW || !allowEdgeTxrCaching && ele.isEdge() || !allowParentTxrCaching && ele.isParent()) {
          return null; // caching large elements is not efficient
        }

        var txrQ = self.getTextureQueue(txrH);

        // first try the second last one in case it has space at the end
        var txr = txrQ[txrQ.length - 2];

        var addNewTxr = function addNewTxr() {
          return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
        };

        // try the last one if there is no second last one
        if (!txr) {
          txr = txrQ[txrQ.length - 1];
        }

        // if the last one doesn't exist, we need a first one
        if (!txr) {
          txr = addNewTxr();
        }

        // if there's no room in the current texture, we need a new one
        if (txr.width - txr.usedWidth < eleScaledW) {
          txr = addNewTxr();
        }

        var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);
        var scalableFrom = function scalableFrom(otherCache) {
          return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
        };

        var deqing = reason && reason === getTxrReasons.dequeue;
        var highQualityReq = reason && reason === getTxrReasons.highQuality;
        var downscaleReq = reason && reason === getTxrReasons.downscale;

        var higherCache; // the nearest cache with a higher level
        for (var l = lvl + 1; l <= maxLvl; l++) {
          var c = caches[l];

          if (c) {
            higherCache = c;break;
          }
        }

        var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

        var downscale = function downscale() {
          txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
        };

        // reset ele area in texture
        txr.context.setTransform(1, 0, 0, 1, 0, 0);
        txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

        if (scalableFrom(oneUpCache)) {
          // then we can relatively cheaply rescale the existing image w/o rerendering
          downscale();
        } else if (scalableFrom(higherCache)) {
          // then use the higher cache for now and queue the next level down
          // to cheaply scale towards the smaller level

          if (highQualityReq) {
            for (var l = higherCache.level; l > lvl; l--) {
              oneUpCache = self.getElement(ele, bb, pxRatio, l, getTxrReasons.downscale);
            }

            downscale();
          } else {
            self.queueElement(ele, higherCache.level - 1);

            return higherCache;
          }
        } else {

          var lowerCache; // the nearest cache with a lower level
          if (!deqing && !highQualityReq && !downscaleReq) {
            for (var l = lvl - 1; l >= minLvl; l--) {
              var c = caches[l];

              if (c) {
                lowerCache = c;break;
              }
            }
          }

          if (scalableFrom(lowerCache)) {
            // then use the lower quality cache for now and queue the better one for later

            self.queueElement(ele, lvl);

            return lowerCache;
          }

          txr.context.translate(txr.usedWidth, 0);
          txr.context.scale(scale, scale);

          r.drawElement(txr.context, ele, bb, scaledLabelShown);

          txr.context.scale(1 / scale, 1 / scale);
          txr.context.translate(-txr.usedWidth, 0);
        }

        eleCache = caches[lvl] = {
          ele: ele,
          x: txr.usedWidth,
          texture: txr,
          level: lvl,
          scale: scale,
          width: eleScaledW,
          height: eleScaledH,
          scaledLabelShown: scaledLabelShown
        };

        txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);

        txr.eleCaches.push(eleCache);

        self.checkTextureFullness(txr);

        return eleCache;
      };

      ETCp.invalidateElement = function (ele) {
        var self = this;
        var caches = ele._private.rscratch.imgCaches;

        if (caches) {
          for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
            var cache = caches[lvl];

            if (cache) {
              var txr = cache.texture;

              // remove space from the texture it belongs to
              txr.invalidatedWidth += cache.width;

              // remove refs with the element
              caches[lvl] = null;
              util.removeFromArray(txr.eleCaches, cache);

              // remove from queue since the old req was for the old state
              self.removeFromQueue(ele);

              // might have to remove the entire texture if it's not efficiently using its space
              self.checkTextureUtility(txr);
            }
          }
        }
      };

      ETCp.checkTextureUtility = function (txr) {
        // invalidate all entries in the cache if the cache size is small
        if (txr.invalidatedWidth >= minUtility * txr.width) {
          this.retireTexture(txr);
        }
      };

      ETCp.checkTextureFullness = function (txr) {
        // if texture has been mostly filled and passed over several times, remove
        // it from the queue so we don't need to waste time looking at it to put new things

        var self = this;
        var txrQ = self.getTextureQueue(txr.height);

        if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
          util.removeFromArray(txrQ, txr);
        } else {
          txr.fullnessChecks++;
        }
      };

      ETCp.retireTexture = function (txr) {
        var self = this;
        var txrH = txr.height;
        var txrQ = self.getTextureQueue(txrH);

        // retire the texture from the active / searchable queue:

        util.removeFromArray(txrQ, txr);

        txr.retired = true;

        // remove the refs from the eles to the caches:

        var eleCaches = txr.eleCaches;

        for (var i = 0; i < eleCaches.length; i++) {
          var eleCache = eleCaches[i];
          var ele = eleCache.ele;
          var lvl = eleCache.level;
          var imgCaches = ele._private.rscratch.imgCaches;

          if (imgCaches) {
            imgCaches[lvl] = null;
          }
        }

        util.clearArray(eleCaches);

        // add the texture to a retired queue so it can be recycled in future:

        var rtxtrQ = self.getRetiredTextureQueue(txrH);

        rtxtrQ.push(txr);
      };

      ETCp.addTexture = function (txrH, minW) {
        var self = this;
        var txrQ = self.getTextureQueue(txrH);
        var txr = {};

        txrQ.push(txr);

        txr.eleCaches = [];

        txr.height = txrH;
        txr.width = Math.max(defTxrWidth, minW);
        txr.usedWidth = 0;
        txr.invalidatedWidth = 0;
        txr.fullnessChecks = 0;

        txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
        txr.canvas.width = txr.width;
        txr.canvas.height = txr.height;

        txr.context = txr.canvas.getContext('2d');

        return txr;
      };

      ETCp.recycleTexture = function (txrH, minW) {
        var self = this;
        var txrQ = self.getTextureQueue(txrH);
        var rtxtrQ = self.getRetiredTextureQueue(txrH);

        for (var i = 0; i < rtxtrQ.length; i++) {
          var txr = rtxtrQ[i];

          if (txr.width >= minW) {
            txr.retired = false;

            txr.usedWidth = 0;
            txr.invalidatedWidth = 0;
            txr.fullnessChecks = 0;

            util.clearArray(txr.eleCaches);

            txr.context.setTransform(1, 0, 0, 1, 0, 0);
            txr.context.clearRect(0, 0, txr.width, txr.height);

            util.removeFromArray(rtxtrQ, txr);
            txrQ.push(txr);

            return txr;
          }
        }
      };

      ETCp.queueElement = function (ele, lvl) {
        var self = this;
        var q = self.getElementQueue();
        var id2q = self.getElementIdToQueue();
        var id = ele.id();
        var existingReq = id2q[id];

        if (existingReq) {
          // use the max lvl b/c in between lvls are cheap to make
          existingReq.level = Math.max(existingReq.level, lvl);
          existingReq.reqs++;

          q.updateItem(existingReq);
        } else {
          var req = {
            ele: ele,
            level: lvl,
            reqs: 1
          };

          q.push(req);

          id2q[id] = req;
        }
      };

      ETCp.dequeue = function (pxRatio /*, extent*/) {
        var self = this;
        var q = self.getElementQueue();
        var id2q = self.getElementIdToQueue();
        var dequeued = [];

        for (var i = 0; i < maxDeqSize; i++) {
          if (q.size() > 0) {
            var req = q.pop();
            var ele = req.ele;
            var caches = ele._private.rscratch.imgCaches;

            // dequeueing isn't necessary when an existing cache exists
            if (caches[req.level] != null) {
              continue;
            }

            id2q[ele.id()] = null;

            dequeued.push(req);

            var bb = ele.boundingBox();

            self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
          } else {
            break;
          }
        }

        return dequeued;
      };

      ETCp.removeFromQueue = function (ele) {
        var self = this;
        var q = self.getElementQueue();
        var id2q = self.getElementIdToQueue();
        var req = id2q[ele.id()];

        if (req != null) {
          // bring to front of queue
          req.reqs = util.MAX_INT;
          q.updateItem(req);

          q.pop(); // remove from queue

          id2q[ele.id()] = null; // remove from lookup map
        }
      };

      ETCp.onDequeue = function (fn) {
        this.onDequeues.push(fn);
      };
      ETCp.offDequeue = function (fn) {
        util.removeFromArray(this.onDequeues, fn);
      };

      ETCp.setupDequeueing = defs.setupDequeueing({
        deqRedrawThreshold: deqRedrawThreshold,
        deqCost: deqCost,
        deqAvgCost: deqAvgCost,
        deqNoDrawCost: deqNoDrawCost,
        deqFastCost: deqFastCost,
        deq: function deq(self, pxRatio, extent) {
          return self.dequeue(pxRatio, extent);
        },
        onDeqd: function onDeqd(self, deqd) {
          for (var i = 0; i < self.onDequeues.length; i++) {
            var fn = self.onDequeues[i];

            fn(deqd);
          }
        },
        shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
          for (var i = 0; i < deqd.length; i++) {
            var bb = deqd[i].ele.boundingBox();

            if (math.boundingBoxesIntersect(bb, extent)) {
              return true;
            }
          }

          return false;
        },
        priority: function priority(self) {
          return self.renderer.beforeRenderPriorities.eleTxrDeq;
        }
      });

      module.exports = ElementTextureCache;

      /***/
    },
    /* 127 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var Heap = __webpack_require__(9);
      var is = __webpack_require__(0);
      var defs = __webpack_require__(19);

      var defNumLayers = 1; // default number of layers to use
      var minLvl = -4; // when scaling smaller than that we don't need to re-render
      var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
      var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
      var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
      var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
      var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
      var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
      var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
      var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
      var deqFastCost = 0.9; // % of frame time to be used when >60fps
      var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
      var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
      var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
      var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
      var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

      var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

      // var log = function(){ console.log.apply( console, arguments ); };

      var LayeredTextureCache = function LayeredTextureCache(renderer, eleTxrCache) {
        var self = this;

        var r = self.renderer = renderer;

        self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

        self.firstGet = true;

        self.lastInvalidationTime = util.performanceNow() - 2 * invalidThreshold;

        self.skipping = false;

        r.beforeRender(function (willDraw, now) {
          if (now - self.lastInvalidationTime <= invalidThreshold) {
            self.skipping = true;
          } else {
            self.skipping = false;
          }
        });

        var qSort = function qSort(a, b) {
          return b.reqs - a.reqs;
        };

        self.layersQueue = new Heap(qSort);

        self.eleTxrCache = eleTxrCache;

        self.setupEleCacheInvalidation();

        self.setupDequeueing();
      };

      var LTCp = LayeredTextureCache.prototype;

      var layerIdPool = 0;
      var MAX_INT = Math.pow(2, 53) - 1;

      LTCp.makeLayer = function (bb, lvl) {
        var scale = Math.pow(2, lvl);

        var w = Math.ceil(bb.w * scale);
        var h = Math.ceil(bb.h * scale);

        var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

        canvas.width = w;
        canvas.height = h;

        var layer = {
          id: layerIdPool = ++layerIdPool % MAX_INT,
          bb: bb,
          level: lvl,
          width: w,
          height: h,
          canvas: canvas,
          context: canvas.getContext('2d'),
          eles: [],
          elesQueue: [],
          reqs: 0
        };

        // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

        var cxt = layer.context;
        var dx = -layer.bb.x1;
        var dy = -layer.bb.y1;

        // do the transform on creation to save cycles (it's the same for all eles)
        cxt.scale(scale, scale);
        cxt.translate(dx, dy);

        return layer;
      };

      LTCp.getLayers = function (eles, pxRatio, lvl) {
        var self = this;
        var r = self.renderer;
        var cy = r.cy;
        var zoom = cy.zoom();
        var firstGet = self.firstGet;

        self.firstGet = false;

        // log('--\nget layers with %s eles', eles.length);
        //log eles.map(function(ele){ return ele.id() }) );

        if (lvl == null) {
          lvl = Math.ceil(math.log2(zoom * pxRatio));

          if (lvl < minLvl) {
            lvl = minLvl;
          } else if (zoom >= maxZoom || lvl > maxLvl) {
            return null;
          }
        }

        self.validateLayersElesOrdering(lvl, eles);

        var layersByLvl = self.layersByLevel;
        var scale = Math.pow(2, lvl);
        var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
        var bb;

        var lvlComplete = self.levelIsComplete(lvl, eles);
        var tmpLayers;

        var checkTempLevels = function checkTempLevels() {
          var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
            self.validateLayersElesOrdering(l, eles);

            if (self.levelIsComplete(l, eles)) {
              tmpLayers = layersByLvl[l];
              return true;
            }
          };

          var checkLvls = function checkLvls(dir) {
            if (tmpLayers) {
              return;
            }

            for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {
              if (canUseAsTmpLvl(l)) {
                break;
              }
            }
          };

          checkLvls(+1);
          checkLvls(-1);

          // remove the invalid layers; they will be replaced as needed later in this function
          for (var i = layers.length - 1; i >= 0; i--) {
            var layer = layers[i];

            if (layer.invalid) {
              util.removeFromArray(layers, layer);
            }
          }
        };

        if (!lvlComplete) {
          // if the current level is incomplete, then use the closest, best quality layerset temporarily
          // and later queue the current layerset so we can get the proper quality level soon

          checkTempLevels();
        } else {
          // log('level complete, using existing layers\n--');
          return layers;
        }

        var getBb = function getBb() {
          if (!bb) {
            bb = math.makeBoundingBox();

            for (var i = 0; i < eles.length; i++) {
              math.updateBoundingBox(bb, eles[i].boundingBox());
            }
          }

          return bb;
        };

        var makeLayer = function makeLayer(opts) {
          opts = opts || {};

          var after = opts.after;

          getBb();

          var area = bb.w * scale * (bb.h * scale);

          if (area > maxLayerArea) {
            return null;
          }

          var layer = self.makeLayer(bb, lvl);

          if (after != null) {
            var index = layers.indexOf(after) + 1;

            layers.splice(index, 0, layer);
          } else if (opts.insert === undefined || opts.insert) {
            // no after specified => first layer made so put at start
            layers.unshift(layer);
          }

          // if( tmpLayers ){
          //self.queueLayer( layer );
          // }

          return layer;
        };

        if (self.skipping && !firstGet) {
          // log('skip layers');
          return null;
        }

        // log('do layers');

        var layer = null;
        var maxElesPerLayer = eles.length / defNumLayers;
        var allowLazyQueueing = alwaysQueue && !firstGet;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var rs = ele._private.rscratch;
          var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

          // log('look at ele', ele.id());

          var existingLayer = caches[lvl];

          if (existingLayer) {
            // reuse layer for later eles
            // log('reuse layer for', ele.id());
            layer = existingLayer;
            continue;
          }

          if (!layer || layer.eles.length >= maxElesPerLayer || !math.boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
            // log('make new layer for ele %s', ele.id());

            layer = makeLayer({ insert: true, after: layer });

            // if now layer can be built then we can't use layers at this level
            if (!layer) {
              return null;
            }

            // log('new layer with id %s', layer.id);
          }

          if (tmpLayers || allowLazyQueueing) {
            // log('queue ele %s in layer %s', ele.id(), layer.id);
            self.queueLayer(layer, ele);
          } else {
            // log('draw ele %s in layer %s', ele.id(), layer.id);
            self.drawEleInLayer(layer, ele, lvl, pxRatio);
          }

          layer.eles.push(ele);

          caches[lvl] = layer;
        }

        // log('--');

        if (tmpLayers) {
          // then we only queued the current layerset and can't draw it yet
          return tmpLayers;
        }

        if (allowLazyQueueing) {
          // log('lazy queue level', lvl);
          return null;
        }

        return layers;
      };

      // a layer may want to use an ele cache of a higher level to avoid blurriness
      // so the layer level might not equal the ele level
      LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
        return lvl;
      };

      function imgSmoothing(context, bool) {
        if (context.imageSmoothingEnabled != null) {
          context.imageSmoothingEnabled = bool;
        } else {
          context.webkitImageSmoothingEnabled = bool;
          context.mozImageSmoothingEnabled = bool;
          context.msImageSmoothingEnabled = bool;
        }
      }

      LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
        var self = this;
        var r = this.renderer;
        var context = layer.context;
        var bb = ele.boundingBox();

        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
          return;
        }

        var eleCache = self.eleTxrCache;
        var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

        lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

        var cache = useEleTxrCaching ? eleCache.getElement(ele, bb, null, lvl, reason) : null;

        if (cache) {
          if (disableEleImgSmoothing) {
            imgSmoothing(context, false);
          }

          context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);

          if (disableEleImgSmoothing) {
            imgSmoothing(context, true);
          }
        } else {
          // if the element is not cacheable, then draw directly
          r.drawElement(context, ele);
        }
      };

      LTCp.levelIsComplete = function (lvl, eles) {
        var self = this;
        var layers = self.layersByLevel[lvl];

        if (!layers || layers.length === 0) {
          return false;
        }

        var numElesInLayers = 0;

        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];

          // if there are any eles needed to be drawn yet, the level is not complete
          if (layer.reqs > 0) {
            return false;
          }

          // if the layer is invalid, the level is not complete
          if (layer.invalid) {
            return false;
          }

          numElesInLayers += layer.eles.length;
        }

        // we should have exactly the number of eles passed in to be complete
        if (numElesInLayers !== eles.length) {
          return false;
        }

        return true;
      };

      LTCp.validateLayersElesOrdering = function (lvl, eles) {
        var layers = this.layersByLevel[lvl];

        if (!layers) {
          return;
        }

        // if in a layer the eles are not in the same order, then the layer is invalid
        // (i.e. there is an ele in between the eles in the layer)

        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          var offset = -1;

          // find the offset
          for (var j = 0; j < eles.length; j++) {
            if (layer.eles[0] === eles[j]) {
              offset = j;
              break;
            }
          }

          if (offset < 0) {
            // then the layer has nonexistant elements and is invalid
            this.invalidateLayer(layer);
            continue;
          }

          // the eles in the layer must be in the same continuous order, else the layer is invalid

          var o = offset;

          for (var j = 0; j < layer.eles.length; j++) {
            if (layer.eles[j] !== eles[o + j]) {
              // log('invalidate based on ordering', layer.id);

              this.invalidateLayer(layer);
              break;
            }
          }
        }
      };

      LTCp.updateElementsInLayers = function (eles, update) {
        var self = this;
        var isEles = is.element(eles[0]);

        // collect udpated elements (cascaded from the layers) and update each
        // layer itself along the way
        for (var i = 0; i < eles.length; i++) {
          var req = isEles ? null : eles[i];
          var ele = isEles ? eles[i] : eles[i].ele;
          var rs = ele._private.rscratch;
          var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

          for (var l = minLvl; l <= maxLvl; l++) {
            var layer = caches[l];

            if (!layer) {
              continue;
            }

            // if update is a request from the ele cache, then it affects only
            // the matching level
            if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
              continue;
            }

            update(layer, ele, req);
          }
        }
      };

      LTCp.haveLayers = function () {
        var self = this;
        var haveLayers = false;

        for (var l = minLvl; l <= maxLvl; l++) {
          var layers = self.layersByLevel[l];

          if (layers && layers.length > 0) {
            haveLayers = true;
            break;
          }
        }

        return haveLayers;
      };

      LTCp.invalidateElements = function (eles) {
        var self = this;

        self.lastInvalidationTime = util.performanceNow();

        // log('update invalidate layer time from eles');

        if (eles.length === 0 || !self.haveLayers()) {
          return;
        }

        self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
          self.invalidateLayer(layer);
        });
      };

      LTCp.invalidateLayer = function (layer) {
        // log('update invalidate layer time');

        this.lastInvalidationTime = util.performanceNow();

        if (layer.invalid) {
          return;
        } // save cycles

        var lvl = layer.level;
        var eles = layer.eles;
        var layers = this.layersByLevel[lvl];

        // log('invalidate layer', layer.id );

        util.removeFromArray(layers, layer);
        // layer.eles = [];

        layer.elesQueue = [];

        layer.invalid = true;

        if (layer.replacement) {
          layer.replacement.invalid = true;
        }

        for (var i = 0; i < eles.length; i++) {
          var caches = eles[i]._private.rscratch.imgLayerCaches;

          if (caches) {
            caches[lvl] = null;
          }
        }
      };

      LTCp.refineElementTextures = function (eles) {
        var self = this;

        // log('refine', eles.length);

        self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
          var rLyr = layer.replacement;

          if (!rLyr) {
            rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
            rLyr.replaces = layer;
            rLyr.eles = layer.eles;

            // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
          }

          if (!rLyr.reqs) {
            for (var i = 0; i < rLyr.eles.length; i++) {
              self.queueLayer(rLyr, rLyr.eles[i]);
            }

            // log('queue replacement layer refinement', rLyr.id);
          }
        });
      };

      LTCp.setupEleCacheInvalidation = function () {
        var self = this;
        var eleDeqs = [];

        if (!useEleTxrCaching) {
          return;
        }

        var updatedElesInLayers = util.debounce(function () {
          self.refineElementTextures(eleDeqs);

          eleDeqs = [];
        }, refineEleDebounceTime);

        self.eleTxrCache.onDequeue(function (reqs) {
          for (var i = 0; i < reqs.length; i++) {
            eleDeqs.push(reqs[i]);
          }

          updatedElesInLayers();
        });
      };

      LTCp.queueLayer = function (layer, ele) {
        var self = this;
        var q = self.layersQueue;
        var elesQ = layer.elesQueue;
        var hasId = elesQ.hasId = elesQ.hasId || {};

        // if a layer is going to be replaced, queuing is a waste of time
        if (layer.replacement) {
          return;
        }

        if (ele) {
          if (hasId[ele.id()]) {
            return;
          }

          elesQ.push(ele);
          hasId[ele.id()] = true;
        }

        if (layer.reqs) {
          layer.reqs++;

          q.updateItem(layer);
        } else {
          layer.reqs = 1;

          q.push(layer);
        }
      };

      LTCp.dequeue = function (pxRatio) {
        var self = this;
        var q = self.layersQueue;
        var deqd = [];
        var eleDeqs = 0;

        while (eleDeqs < maxDeqSize) {
          if (q.size() === 0) {
            break;
          }

          var layer = q.peek();

          // if a layer has been or will be replaced, then don't waste time with it
          if (layer.replacement) {
            // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
            q.pop();
            continue;
          }

          // if this is a replacement layer that has been superceded, then forget it
          if (layer.replaces && layer !== layer.replaces.replacement) {
            // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
            q.pop();
            continue;
          }

          if (layer.invalid) {
            // log('replacement layer %s is invalid; dequeued', layer.id);
            q.pop();
            continue;
          }

          var ele = layer.elesQueue.shift();

          if (ele) {
            // log('dequeue layer %s', layer.id);

            self.drawEleInLayer(layer, ele, layer.level, pxRatio);

            eleDeqs++;
          }

          if (deqd.length === 0) {
            // we need only one entry in deqd to queue redrawing etc
            deqd.push(true);
          }

          // if the layer has all its eles done, then remove from the queue
          if (layer.elesQueue.length === 0) {
            q.pop();

            layer.reqs = 0;

            // log('dequeue of layer %s complete', layer.id);

            // when a replacement layer is dequeued, it replaces the old layer in the level
            if (layer.replaces) {
              self.applyLayerReplacement(layer);
            }

            self.requestRedraw();
          }
        }

        return deqd;
      };

      LTCp.applyLayerReplacement = function (layer) {
        var self = this;
        var layersInLevel = self.layersByLevel[layer.level];
        var replaced = layer.replaces;
        var index = layersInLevel.indexOf(replaced);

        // if the replaced layer is not in the active list for the level, then replacing
        // refs would be a mistake (i.e. overwriting the true active layer)
        if (index < 0 || replaced.invalid) {
          // log('replacement layer would have no effect', layer.id);
          return;
        }

        layersInLevel[index] = layer; // replace level ref

        // replace refs in eles
        for (var i = 0; i < layer.eles.length; i++) {
          var _p = layer.eles[i]._private;
          var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

          if (cache) {
            cache[layer.level] = layer;
          }
        }

        // log('apply replacement layer %s over %s', layer.id, replaced.id);

        self.requestRedraw();
      };

      LTCp.requestRedraw = util.debounce(function () {
        var r = this.renderer;

        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        r.redraw();
      }, 100);

      LTCp.setupDequeueing = defs.setupDequeueing({
        deqRedrawThreshold: deqRedrawThreshold,
        deqCost: deqCost,
        deqAvgCost: deqAvgCost,
        deqNoDrawCost: deqNoDrawCost,
        deqFastCost: deqFastCost,
        deq: function deq(self, pxRatio) {
          return self.dequeue(pxRatio);
        },
        onDeqd: util.noop,
        shouldRedraw: util.trueify,
        priority: function priority(self) {
          return self.renderer.beforeRenderPriorities.lyrTxrDeq;
        }
      });

      module.exports = LayeredTextureCache;

      /***/
    },
    /* 128 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      var impl;

      CRp.arrowShapeImpl = function (name) {
        return (impl || (impl = {
          'polygon': function polygon(context, points) {
            for (var i = 0; i < points.length; i++) {
              var pt = points[i];

              context.lineTo(pt.x, pt.y);
            }
          },

          'triangle-backcurve': function triangleBackcurve(context, points, controlPoint) {
            var firstPt;

            for (var i = 0; i < points.length; i++) {
              var pt = points[i];

              if (i === 0) {
                firstPt = pt;
              }

              context.lineTo(pt.x, pt.y);
            }

            context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
          },

          'triangle-tee': function triangleTee(context, trianglePoints, teePoints) {
            if (context.beginPath) {
              context.beginPath();
            }

            var triPts = trianglePoints;
            for (var i = 0; i < triPts.length; i++) {
              var pt = triPts[i];

              context.lineTo(pt.x, pt.y);
            }

            if (context.closePath) {
              context.closePath();
            }

            if (context.beginPath) {
              context.beginPath();
            }

            var teePts = teePoints;
            var firstTeePt = teePoints[0];
            context.moveTo(firstTeePt.x, firstTeePt.y);

            for (var i = 0; i < teePts.length; i++) {
              var pt = teePts[i];

              context.lineTo(pt.x, pt.y);
            }
            if (context.closePath) {
              context.closePath();
            }
          },

          'triangle-cross': function triangleCross(context, trianglePoints, crossLinePoints) {
            if (context.beginPath) {
              context.beginPath();
            }

            var triPts = trianglePoints;
            for (var i = 0; i < triPts.length; i++) {
              var pt = triPts[i];

              context.lineTo(pt.x, pt.y);
            }

            if (context.closePath) {
              context.closePath();
            }

            if (context.beginPath) {
              context.beginPath();
            }

            var teePts = crossLinePoints;
            var firstTeePt = crossLinePoints[0];
            context.moveTo(firstTeePt.x, firstTeePt.y);

            for (var i = 0; i < teePts.length; i++) {
              var pt = teePts[i];

              context.lineTo(pt.x, pt.y);
            }
            if (context.closePath) {
              context.closePath();
            }
          },

          'circle': function circle(context, rx, ry, r) {
            context.arc(rx, ry, r, 0, Math.PI * 2, false);
          }
        }))[name];
      };

      module.exports = CRp;

      /***/
    },
    /* 129 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var CRp = {};

      CRp.drawElement = function (context, ele, shiftToOriginWithBb, showLabel) {
        var r = this;

        if (ele.isNode()) {
          r.drawNode(context, ele, shiftToOriginWithBb, showLabel);
        } else {
          r.drawEdge(context, ele, shiftToOriginWithBb, showLabel);
        }
      };

      CRp.drawCachedElement = function (context, ele, pxRatio, extent) {
        var r = this;
        var bb = ele.boundingBox();

        if (bb.w === 0 || bb.h === 0) {
          return;
        }

        if (!extent || math.boundingBoxesIntersect(bb, extent)) {
          var cache = r.data.eleTxrCache.getElement(ele, bb, pxRatio);

          if (cache != null) {
            context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);
          } else {
            // if the element is not cacheable, then draw directly
            r.drawElement(context, ele);
          }
        }
      };

      CRp.drawElements = function (context, eles) {
        var r = this;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          r.drawElement(context, ele);
        }
      };

      CRp.drawCachedElements = function (context, eles, pxRatio, extent) {
        var r = this;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          r.drawCachedElement(context, ele, pxRatio, extent);
        }
      };

      CRp.drawCachedNodes = function (context, eles, pxRatio, extent) {
        var r = this;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (!ele.isNode()) {
            continue;
          }

          r.drawCachedElement(context, ele, pxRatio, extent);
        }
      };

      CRp.drawLayeredElements = function (context, eles, pxRatio, extent) {
        var r = this;

        var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

        if (layers) {
          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            var bb = layer.bb;

            if (bb.w === 0 || bb.h === 0) {
              continue;
            }

            context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
          }
        } else {
          // fall back on plain caching if no layers
          r.drawCachedElements(context, eles, pxRatio, extent);
        }
      };

      CRp.drawDebugPoints = function (context, eles) {
        var draw = function draw(x, y, color) {
          context.fillStyle = color;
          context.fillRect(x - 1, y - 1, 3, 3);
        };

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var rs = ele._private.rscratch;

          if (ele.isNode()) {
            var p = ele.position();

            draw(p.x, p.y, 'magenta');
          } else {
            var pts = rs.allpts;

            for (var j = 0; j + 1 < pts.length; j += 2) {
              var x = pts[j];
              var y = pts[j + 1];

              draw(x, y, 'cyan');
            }

            draw(rs.midX, rs.midY, 'yellow');
          }
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 130 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      CRp.drawEdge = function (context, edge, shiftToOriginWithBb, drawLabel) {
        var r = this;
        var rs = edge._private.rscratch;
        var usePaths = r.usePaths();

        if (!edge.visible()) {
          return;
        }

        // if bezier ctrl pts can not be calculated, then die
        if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
          // isNaN in case edge is impossible and browser bugs (e.g. safari)
          return;
        }

        var bb = void 0;
        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;

          context.translate(-bb.x1, -bb.y1);
        }

        var overlayPadding = edge.pstyle('overlay-padding').pfValue;
        var overlayWidth = 2 * overlayPadding;
        var overlayOpacity = edge.pstyle('overlay-opacity').value;
        var overlayColor = edge.pstyle('overlay-color').value;
        var lineColor = edge.pstyle('line-color').value;
        var opacity = edge.pstyle('opacity').value;
        var lineStyle = edge.pstyle('line-style').value;
        var edgeWidth = edge.pstyle('width').pfValue;

        var drawLine = function drawLine() {
          var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

          context.lineWidth = edgeWidth;
          context.lineCap = 'butt';

          r.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], strokeOpacity);

          r.drawEdgePath(edge, context, rs.allpts, lineStyle);
        };

        var drawOverlay = function drawOverlay() {
          var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : overlayOpacity;

          context.lineWidth = overlayWidth;

          if (rs.edgeType === 'self' && !usePaths) {
            context.lineCap = 'butt';
          } else {
            context.lineCap = 'round';
          }

          r.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], strokeOpacity);

          r.drawEdgePath(edge, context, rs.allpts, 'solid');
        };

        var drawArrows = function drawArrows() {
          var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

          r.drawArrowheads(context, edge, arrowOpacity);
        };

        var drawText = function drawText() {
          r.drawElementText(context, edge, drawLabel);
        };

        context.lineJoin = 'round';

        var ghost = edge.pstyle('ghost').value === 'yes';

        if (ghost) {
          var gx = edge.pstyle('ghost-offset-x').pfValue;
          var gy = edge.pstyle('ghost-offset-y').pfValue;
          var ghostOpacity = edge.pstyle('ghost-opacity').value;
          var effectiveGhostOpacity = opacity * ghostOpacity;

          context.translate(gx, gy);

          drawLine(effectiveGhostOpacity);
          drawArrows(effectiveGhostOpacity);

          context.translate(-gx, -gy);
        }

        drawLine();
        drawArrows();
        drawOverlay();
        drawText();

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      CRp.drawEdgePath = function (edge, context, pts, type) {
        var rs = edge._private.rscratch;
        var canvasCxt = context;
        var path = void 0;
        var pathCacheHit = false;
        var usePaths = this.usePaths();

        if (usePaths) {
          var pathCacheKey = pts.join('$');
          var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

          if (keyMatches) {
            path = context = rs.pathCache;
            pathCacheHit = true;
          } else {
            path = context = new Path2D(); // eslint-disable-line no-undef
            rs.pathCacheKey = pathCacheKey;
            rs.pathCache = path;
          }
        }

        if (canvasCxt.setLineDash) {
          // for very outofdate browsers
          switch (type) {
            case 'dotted':
              canvasCxt.setLineDash([1, 1]);
              break;

            case 'dashed':
              canvasCxt.setLineDash([6, 3]);
              break;

            case 'solid':
              canvasCxt.setLineDash([]);
              break;
          }
        }

        if (!pathCacheHit && !rs.badLine) {
          if (context.beginPath) {
            context.beginPath();
          }
          context.moveTo(pts[0], pts[1]);

          switch (rs.edgeType) {
            case 'bezier':
            case 'self':
            case 'compound':
            case 'multibezier':
              for (var i = 2; i + 3 < pts.length; i += 4) {
                context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
              }
              break;

            case 'straight':
            case 'segments':
            case 'haystack':
              for (var _i = 2; _i + 1 < pts.length; _i += 2) {
                context.lineTo(pts[_i], pts[_i + 1]);
              }
              break;
          }
        }

        context = canvasCxt;
        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        // reset any line dashes
        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }
      };

      CRp.drawArrowheads = function (context, edge, opacity) {
        var rs = edge._private.rscratch;
        var isHaystack = rs.edgeType === 'haystack';

        if (!isHaystack) {
          this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
        }

        this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);

        this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

        if (!isHaystack) {
          this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
        }
      };

      CRp.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
        if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
          return;
        }

        var self = this;
        var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;
        if (arrowShape === 'none') {
          return;
        }

        var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
        var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
        var edgeWidth = edge.pstyle('width').pfValue;
        var edgeOpacity = edge.pstyle('opacity').value;

        if (opacity === undefined) {
          opacity = edgeOpacity;
        }

        var gco = context.globalCompositeOperation;

        if (opacity !== 1 || arrowFill === 'hollow') {
          // then extra clear is needed
          context.globalCompositeOperation = 'destination-out';

          self.fillStyle(context, 255, 255, 255, 1);
          self.strokeStyle(context, 255, 255, 255, 1);

          self.drawArrowShape(edge, prefix, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);

          context.globalCompositeOperation = gco;
        } // otherwise, the opaque arrow clears it for free :)

        var color = edge.pstyle(prefix + '-arrow-color').value;
        self.fillStyle(context, color[0], color[1], color[2], opacity);
        self.strokeStyle(context, color[0], color[1], color[2], opacity);

        self.drawArrowShape(edge, prefix, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
      };

      CRp.drawArrowShape = function (edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
        var r = this;
        var usePaths = this.usePaths();
        var rs = edge._private.rscratch;
        var pathCacheHit = false;
        var path = void 0;
        var canvasContext = context;
        var translation = { x: x, y: y };
        var scale = edge.pstyle('arrow-scale').value;
        var size = this.getArrowWidth(edgeWidth, scale);
        var shapeImpl = r.arrowShapes[shape];

        if (usePaths) {
          var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
          rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
          rs.arrowPathCache = rs.arrowPathCache || {};

          var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
          if (alreadyCached) {
            path = context = rs.arrowPathCache[arrowType];
            pathCacheHit = true;
          } else {
            path = context = new Path2D(); // eslint-disable-line no-undef
            rs.arrowPathCacheKey[arrowType] = pathCacheKey;
            rs.arrowPathCache[arrowType] = path;
          }
        }

        if (context.beginPath) {
          context.beginPath();
        }

        if (!pathCacheHit) {
          shapeImpl.draw(context, size, angle, translation, edgeWidth);
        }

        if (!shapeImpl.leavePathOpen && context.closePath) {
          context.closePath();
        }

        context = canvasContext;

        if (fill === 'filled' || fill === 'both') {
          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        }

        if (fill === 'hollow' || fill === 'both') {
          context.lineWidth = shapeImpl.matchEdgeWidth ? edgeWidth : 1;
          context.lineJoin = 'miter';

          if (usePaths) {
            context.stroke(path);
          } else {
            context.stroke();
          }
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 131 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      CRp.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
        var r = this;

        // detect problematic cases for old browsers with bad images (cheaper than try-catch)
        if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
          return;
        }

        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
      };

      CRp.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
        var r = this;
        var pos = node.position();
        var nodeX = pos.x;
        var nodeY = pos.y;
        var styleObj = node.cy().style();
        var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
        var fit = getIndexedStyle(node, 'background-fit', 'value', index);
        var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
        var nodeW = node.width();
        var nodeH = node.height();
        var paddingX2 = node.padding() * 2;
        var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
        var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
        var rs = node._private.rscratch;
        var clip = node.pstyle('background-clip').value;
        var shouldClip = clip === 'node';
        var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;

        var imgW = img.width || img.cachedW;
        var imgH = img.height || img.cachedH;

        // workaround for broken browsers like ie
        if (null == imgW || null == imgH) {
          document.body.appendChild(img); // eslint-disable-line no-undef

          imgW = img.cachedW = img.width || img.offsetWidth;
          imgH = img.cachedH = img.height || img.offsetHeight;

          document.body.removeChild(img); // eslint-disable-line no-undef
        }

        var w = imgW;
        var h = imgH;

        if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
          if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
            w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
          } else {
            w = getIndexedStyle(node, 'background-width', 'pfValue', index);
          }
        }

        if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
          if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
            h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
          } else {
            h = getIndexedStyle(node, 'background-height', 'pfValue', index);
          }
        }

        if (w === 0 || h === 0) {
          return; // no point in drawing empty image (and chrome is broken in this case)
        }

        if (fit === 'contain') {
          var scale = Math.min(nodeTW / w, nodeTH / h);

          w *= scale;
          h *= scale;
        } else if (fit === 'cover') {
          var scale = Math.max(nodeTW / w, nodeTH / h);

          w *= scale;
          h *= scale;
        }

        var x = nodeX - nodeTW / 2; // left
        if (getIndexedStyle(node, 'background-position-x', 'units', index) === '%') {
          x += (nodeTW - w) * getIndexedStyle(node, 'background-position-x', 'pfValue', index);
        } else {
          x += getIndexedStyle(node, 'background-position-x', 'pfValue', index);
        }

        var y = nodeY - nodeTH / 2; // top
        if (getIndexedStyle(node, 'background-position-y', 'units', index) === '%') {
          y += (nodeTH - h) * getIndexedStyle(node, 'background-position-y', 'pfValue', index);
        } else {
          y += getIndexedStyle(node, 'background-position-y', 'pfValue', index);
        }

        if (rs.pathCache) {
          x -= nodeX;
          y -= nodeY;

          nodeX = 0;
          nodeY = 0;
        }

        var gAlpha = context.globalAlpha;

        context.globalAlpha = imgOpacity;

        if (repeat === 'no-repeat') {

          if (shouldClip) {
            context.save();

            if (rs.pathCache) {
              context.clip(rs.pathCache);
            } else {
              r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

              context.clip();
            }
          }

          r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

          if (shouldClip) {
            context.restore();
          }
        } else {
          var pattern = context.createPattern(img, repeat);
          context.fillStyle = pattern;

          r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

          context.translate(x, y);
          context.fill();
          context.translate(-x, -y);
        }

        context.globalAlpha = gAlpha;
      };

      module.exports = CRp;

      /***/
    },
    /* 132 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var CRp = {};

      CRp.eleTextBiggerThanMin = function (ele, scale) {
        if (!scale) {
          var zoom = ele.cy().zoom();
          var pxRatio = this.getPixelRatio();
          var lvl = Math.ceil(math.log2(zoom * pxRatio)); // the effective texture level

          scale = Math.pow(2, lvl);
        }

        var computedSize = ele.pstyle('font-size').pfValue * scale;
        var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

        if (computedSize < minSize) {
          return false;
        }

        return true;
      };

      CRp.drawElementText = function (context, ele, force) {
        var r = this;

        if (force === undefined) {
          if (!r.eleTextBiggerThanMin(ele)) {
            return;
          }
        } else {
          if (!force) {
            return;
          }
        }

        if (ele.isNode()) {
          var label = ele.pstyle('label');

          if (!label || !label.value) {
            return;
          }

          var textHalign = ele.pstyle('text-halign').strValue;
          var textValign = ele.pstyle('text-valign').strValue;

          switch (textHalign) {
            case 'left':
              context.textAlign = 'right';
              break;

            case 'right':
              context.textAlign = 'left';
              break;

            default:
              // e.g. center
              context.textAlign = 'center';
          }

          context.textBaseline = 'bottom';
        } else {
          var label = ele.pstyle('label');
          var srcLabel = ele.pstyle('source-label');
          var tgtLabel = ele.pstyle('target-label');

          if ((!label || !label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
            return;
          }

          context.textAlign = 'center';
          context.textBaseline = 'bottom';
        }

        r.drawText(context, ele);

        if (ele.isEdge()) {
          r.drawText(context, ele, 'source');

          r.drawText(context, ele, 'target');
        }
      };

      CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

      CRp.getFontCache = function (context) {
        var cache;

        this.fontCaches = this.fontCaches || [];

        for (var i = 0; i < this.fontCaches.length; i++) {
          cache = this.fontCaches[i];

          if (cache.context === context) {
            return cache;
          }
        }

        cache = {
          context: context
        };
        this.fontCaches.push(cache);

        return cache;
      };

      // set up canvas context with font
      // returns transformed text string
      CRp.setupTextStyle = function (context, ele) {
        // Font style
        var parentOpacity = ele.effectiveOpacity();
        var labelStyle = ele.pstyle('font-style').strValue;
        var labelSize = ele.pstyle('font-size').pfValue + 'px';
        var labelFamily = ele.pstyle('font-family').strValue;
        var labelWeight = ele.pstyle('font-weight').strValue;
        var opacity = ele.pstyle('text-opacity').value * ele.pstyle('opacity').value * parentOpacity;
        var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
        var color = ele.pstyle('color').value;
        var outlineColor = ele.pstyle('text-outline-color').value;

        var fontCacheKey = ele._private.fontKey;
        var cache = this.getFontCache(context);

        if (cache.key !== fontCacheKey) {
          context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

          cache.key = fontCacheKey;
        }

        // Calculate text draw position based on text alignment

        // so text outlines aren't jagged
        context.lineJoin = 'round';

        this.fillStyle(context, color[0], color[1], color[2], opacity);

        this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
      };

      function roundRect(ctx, x, y, width, height, radius) {
        var radius = radius || 5;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      // Draw text
      CRp.drawText = function (context, ele, prefix) {
        var _p = ele._private;
        var rscratch = _p.rscratch;
        var parentOpacity = ele.effectiveOpacity();
        if (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0) {
          return;
        }

        var textX = util.getPrefixedProperty(rscratch, 'labelX', prefix);
        var textY = util.getPrefixedProperty(rscratch, 'labelY', prefix);
        var text = this.getLabelText(ele, prefix);

        if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
          this.setupTextStyle(context, ele);

          var pdash = prefix ? prefix + '-' : '';
          var textW = util.getPrefixedProperty(rscratch, 'labelWidth', prefix);
          var textH = util.getPrefixedProperty(rscratch, 'labelHeight', prefix);
          var textAngle = util.getPrefixedProperty(rscratch, 'labelAngle', prefix);
          var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
          var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;

          var isEdge = ele.isEdge();
          var isNode = ele.isNode();

          var halign = ele.pstyle('text-halign').value;
          var valign = ele.pstyle('text-valign').value;

          if (isEdge) {
            halign = 'center';
            valign = 'center';
          }

          textX += marginX;
          textY += marginY;

          var rotation = ele.pstyle('text-rotation');
          var theta;

          if (rotation.strValue === 'autorotate') {
            theta = isEdge ? textAngle : 0;
          } else if (rotation.strValue === 'none') {
            theta = 0;
          } else {
            theta = rotation.pfValue;
          }

          if (theta !== 0) {
            var orgTextX = textX;
            var orgTextY = textY;

            context.translate(orgTextX, orgTextY);
            context.rotate(theta);

            textX = 0;
            textY = 0;
          }

          switch (valign) {
            case 'top':
              break;
            case 'center':
              textY += textH / 2;
              break;
            case 'bottom':
              textY += textH;
              break;
          }

          var backgroundOpacity = ele.pstyle('text-background-opacity').value;
          var borderOpacity = ele.pstyle('text-border-opacity').value;
          var textBorderWidth = ele.pstyle('text-border-width').pfValue;
          var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

          if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
            var bgX = textX - backgroundPadding;

            switch (halign) {
              case 'left':
                bgX -= textW;
                break;
              case 'center':
                bgX -= textW / 2;
                break;
              case 'right':
                break;
            }

            var bgY = textY - textH - backgroundPadding;
            var bgW = textW + 2 * backgroundPadding;
            var bgH = textH + 2 * backgroundPadding;

            if (backgroundOpacity > 0) {
              var textFill = context.fillStyle;
              var textBackgroundColor = ele.pstyle('text-background-color').value;

              context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
              var styleShape = ele.pstyle('text-background-shape').strValue;
              if (styleShape == 'roundrectangle') {
                roundRect(context, bgX, bgY, bgW, bgH, 2);
              } else {
                context.fillRect(bgX, bgY, bgW, bgH);
              }
              context.fillStyle = textFill;
            }

            if (textBorderWidth > 0 && borderOpacity > 0) {
              var textStroke = context.strokeStyle;
              var textLineWidth = context.lineWidth;
              var textBorderColor = ele.pstyle('text-border-color').value;
              var textBorderStyle = ele.pstyle('text-border-style').value;

              context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
              context.lineWidth = textBorderWidth;

              if (context.setLineDash) {
                // for very outofdate browsers
                switch (textBorderStyle) {
                  case 'dotted':
                    context.setLineDash([1, 1]);
                    break;
                  case 'dashed':
                    context.setLineDash([4, 2]);
                    break;
                  case 'double':
                    context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
                    context.setLineDash([]);
                    break;
                  case 'solid':
                    context.setLineDash([]);
                    break;
                }
              }

              context.strokeRect(bgX, bgY, bgW, bgH);

              if (textBorderStyle === 'double') {
                var whiteWidth = textBorderWidth / 2;

                context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
              }

              if (context.setLineDash) {
                // for very outofdate browsers
                context.setLineDash([]);
              }
              context.lineWidth = textLineWidth;
              context.strokeStyle = textStroke;
            }
          }

          var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

          if (lineWidth > 0) {
            context.lineWidth = lineWidth;
          }

          if (ele.pstyle('text-wrap').value === 'wrap') {
            var lines = util.getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
            var lineHeight = textH / lines.length;

            switch (valign) {
              case 'top':
                textY -= (lines.length - 1) * lineHeight;
                break;
              case 'center':
              case 'bottom':
                textY -= (lines.length - 1) * lineHeight;
                break;
            }

            for (var l = 0; l < lines.length; l++) {
              if (lineWidth > 0) {
                context.strokeText(lines[l], textX, textY);
              }

              context.fillText(lines[l], textX, textY);

              textY += lineHeight;
            }
          } else {
            if (lineWidth > 0) {
              context.strokeText(text, textX, textY);
            }

            context.fillText(text, textX, textY);
          }

          if (theta !== 0) {
            context.rotate(-theta);
            context.translate(-orgTextX, -orgTextY);
          }
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 133 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /* global Path2D */

      var is = __webpack_require__(0);

      var CRp = {};

      CRp.drawNode = function (context, node, shiftToOriginWithBb, drawLabel) {
        var r = this;
        var nodeWidth = void 0,
            nodeHeight = void 0;
        var _p = node._private;
        var rs = _p.rscratch;
        var pos = node.position();

        if (!is.number(pos.x) || !is.number(pos.y)) {
          return; // can't draw node with undefined position
        }

        if (!node.visible()) {
          return;
        }

        var parentOpacity = node.effectiveOpacity();

        var usePaths = r.usePaths();
        var path = void 0;
        var pathCacheHit = false;

        var padding = node.padding();

        nodeWidth = node.width() + 2 * padding;
        nodeHeight = node.height() + 2 * padding;

        //
        // setup shift

        var bb = void 0;
        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;

          context.translate(-bb.x1, -bb.y1);
        }

        //
        // load bg image

        var bgImgProp = node.pstyle('background-image');
        var urls = bgImgProp.value;
        var urlDefined = new Array(urls.length);
        var image = new Array(urls.length);
        var numImages = 0;
        for (var i = 0; i < urls.length; i++) {
          var url = urls[i];
          var defd = urlDefined[i] = url != null && url !== 'none';

          if (defd) {
            var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);

            numImages++;

            // get image, and if not loaded then ask to redraw when later loaded
            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
              node.emitAndNotify('background');
            });
          }
        }

        //
        // setup styles

        var darkness = node.pstyle('background-blacken').value;
        var borderWidth = node.pstyle('border-width').pfValue;
        var bgColor = node.pstyle('background-color').value;
        var bgOpacity = node.pstyle('background-opacity').value * parentOpacity;
        var borderColor = node.pstyle('border-color').value;
        var borderStyle = node.pstyle('border-style').value;
        var borderOpacity = node.pstyle('border-opacity').value * parentOpacity;

        context.lineJoin = 'miter'; // so borders are square with the node shape

        var setupShapeColor = function setupShapeColor() {
          var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;

          r.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], bgOpy);
        };

        var setupBorderColor = function setupBorderColor() {
          var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;

          r.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
        };

        //
        // setup shape

        var styleShape = node.pstyle('shape').strValue;
        var shapePts = node.pstyle('shape-polygon-points').pfValue;

        if (usePaths) {
          var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + (styleShape === 'polygon' ? '$' + shapePts.join('$') : '');

          context.translate(pos.x, pos.y);

          if (rs.pathCacheKey === pathCacheKey) {
            path = rs.pathCache;
            pathCacheHit = true;
          } else {
            path = new Path2D();
            rs.pathCacheKey = pathCacheKey;
            rs.pathCache = path;
          }
        }

        var drawShape = function drawShape() {
          if (!pathCacheHit) {

            var npos = pos;

            if (usePaths) {
              npos = {
                x: 0,
                y: 0
              };
            }

            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
          }

          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        };

        var drawImages = function drawImages() {
          var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

          var prevBging = _p.backgrounding;
          var totalCompleted = 0;

          for (var _i = 0; _i < image.length; _i++) {
            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
              totalCompleted++;
              r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
            }
          }

          _p.backgrounding = !(totalCompleted === numImages);
          if (prevBging !== _p.backgrounding) {
            // update style b/c :backgrounding state changed
            node.updateStyle(false);
          }
        };

        var drawPie = function drawPie() {
          var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parentOpacity;

          if (r.hasPie(node)) {
            r.drawPie(context, node, pieOpacity);

            // redraw/restore path if steps after pie need it
            if (redrawShape) {

              if (!usePaths) {
                r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
              }
            }
          }
        };

        var darken = function darken() {
          var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

          var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
          var c = darkness > 0 ? 0 : 255;

          if (darkness !== 0) {
            r.fillStyle(context, c, c, c, opacity);

            if (usePaths) {
              context.fill(path);
            } else {
              context.fill();
            }
          }
        };

        var drawBorder = function drawBorder() {
          if (borderWidth > 0) {

            context.lineWidth = borderWidth;
            context.lineCap = 'butt';

            if (context.setLineDash) {
              // for very outofdate browsers
              switch (borderStyle) {
                case 'dotted':
                  context.setLineDash([1, 1]);
                  break;

                case 'dashed':
                  context.setLineDash([4, 2]);
                  break;

                case 'solid':
                case 'double':
                  context.setLineDash([]);
                  break;
              }
            }

            if (usePaths) {
              context.stroke(path);
            } else {
              context.stroke();
            }

            if (borderStyle === 'double') {
              context.lineWidth = borderWidth / 3;

              var gco = context.globalCompositeOperation;
              context.globalCompositeOperation = 'destination-out';

              if (usePaths) {
                context.stroke(path);
              } else {
                context.stroke();
              }

              context.globalCompositeOperation = gco;
            }

            // reset in case we changed the border style
            if (context.setLineDash) {
              // for very outofdate browsers
              context.setLineDash([]);
            }
          }
        };

        var drawOverlay = function drawOverlay() {
          var overlayPadding = node.pstyle('overlay-padding').pfValue;
          var overlayOpacity = node.pstyle('overlay-opacity').value;
          var overlayColor = node.pstyle('overlay-color').value;

          if (overlayOpacity > 0) {
            r.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

            r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);

            context.fill();
          }
        };

        var drawText = function drawText() {
          r.drawElementText(context, node, drawLabel);
        };

        var ghost = node.pstyle('ghost').value === 'yes';

        if (ghost) {
          var gx = node.pstyle('ghost-offset-x').pfValue;
          var gy = node.pstyle('ghost-offset-y').pfValue;
          var ghostOpacity = node.pstyle('ghost-opacity').value;
          var effGhostOpacity = ghostOpacity * parentOpacity;

          context.translate(gx, gy);

          setupShapeColor(ghostOpacity * bgOpacity);
          drawShape();
          drawImages(effGhostOpacity);
          drawPie(darkness !== 0 || borderWidth !== 0);
          darken(effGhostOpacity);
          setupBorderColor(ghostOpacity * borderOpacity);
          drawBorder();

          context.translate(-gx, -gy);
        }

        setupShapeColor();
        drawShape();
        drawImages();
        drawPie(darkness !== 0 || borderWidth !== 0);
        darken();
        setupBorderColor();
        drawBorder();

        if (usePaths) {
          context.translate(-pos.x, -pos.y);
        }

        drawText();
        drawOverlay();

        //
        // clean up shift

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      // does the node have at least one pie piece?
      CRp.hasPie = function (node) {
        node = node[0]; // ensure ele ref

        return node._private.hasPie;
      };

      CRp.drawPie = function (context, node, nodeOpacity, pos) {
        node = node[0]; // ensure ele ref
        pos = pos || node.position();

        var cyStyle = node.cy().style();
        var pieSize = node.pstyle('pie-size');
        var x = pos.x;
        var y = pos.y;
        var nodeW = node.width();
        var nodeH = node.height();
        var radius = Math.min(nodeW, nodeH) / 2; // must fit in node
        var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
        var usePaths = this.usePaths();

        if (usePaths) {
          x = 0;
          y = 0;
        }

        if (pieSize.units === '%') {
          radius = radius * pieSize.pfValue;
        } else if (pieSize.pfValue !== undefined) {
          radius = pieSize.pfValue / 2;
        }

        for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
          // 1..N
          var size = node.pstyle('pie-' + i + '-background-size').value;
          var color = node.pstyle('pie-' + i + '-background-color').value;
          var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
          var percent = size / 100; // map integer range [0, 100] to [0, 1]

          // percent can't push beyond 1
          if (percent + lastPercent > 1) {
            percent = 1 - lastPercent;
          }

          var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
          var angleDelta = 2 * Math.PI * percent;
          var angleEnd = angleStart + angleDelta;

          // ignore if
          // - zero size
          // - we're already beyond the full circle
          // - adding the current slice would go beyond the full circle
          if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
            continue;
          }

          context.beginPath();
          context.moveTo(x, y);
          context.arc(x, y, radius, angleStart, angleEnd);
          context.closePath();

          this.fillStyle(context, color[0], color[1], color[2], opacity);

          context.fill();

          lastPercent += percent;
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 134 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      var util = __webpack_require__(1);

      var motionBlurDelay = 100;

      // var isFirefox = typeof InstallTrigger !== 'undefined';

      CRp.getPixelRatio = function () {
        var context = this.data.contexts[0];

        if (this.forcedPixelRatio != null) {
          return this.forcedPixelRatio;
        }

        var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

        return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
      };

      CRp.paintCache = function (context) {
        var caches = this.paintCaches = this.paintCaches || [];
        var needToCreateCache = true;
        var cache;

        for (var i = 0; i < caches.length; i++) {
          cache = caches[i];

          if (cache.context === context) {
            needToCreateCache = false;
            break;
          }
        }

        if (needToCreateCache) {
          cache = {
            context: context
          };
          caches.push(cache);
        }

        return cache;
      };

      CRp.fillStyle = function (context, r, g, b, a) {
        context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // turn off for now, seems context does its own caching

        // var cache = this.paintCache(context);

        // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // if( cache.fillStyle !== fillStyle ){
        //   context.fillStyle = cache.fillStyle = fillStyle;
        // }
      };

      CRp.strokeStyle = function (context, r, g, b, a) {
        context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // turn off for now, seems context does its own caching

        // var cache = this.paintCache(context);

        // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // if( cache.strokeStyle !== strokeStyle ){
        //   context.strokeStyle = cache.strokeStyle = strokeStyle;
        // }
      };

      // Resize canvas
      CRp.matchCanvasSize = function (container) {
        var r = this;
        var data = r.data;
        var bb = r.findContainerClientCoords();
        var width = bb[2];
        var height = bb[3];
        var pixelRatio = r.getPixelRatio();
        var mbPxRatio = r.motionBlurPxRatio;

        if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
          pixelRatio = mbPxRatio;
        }

        var canvasWidth = width * pixelRatio;
        var canvasHeight = height * pixelRatio;
        var canvas;

        if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
          return; // save cycles if same
        }

        r.fontCaches = null; // resizing resets the style

        var canvasContainer = data.canvasContainer;
        canvasContainer.style.width = width + 'px';
        canvasContainer.style.height = height + 'px';

        for (var i = 0; i < r.CANVAS_LAYERS; i++) {
          canvas = data.canvases[i];

          canvas.width = canvasWidth;
          canvas.height = canvasHeight;

          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        }

        for (var i = 0; i < r.BUFFER_COUNT; i++) {
          canvas = data.bufferCanvases[i];

          canvas.width = canvasWidth;
          canvas.height = canvasHeight;

          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        }

        r.textureMult = 1;
        if (pixelRatio <= 1) {
          canvas = data.bufferCanvases[r.TEXTURE_BUFFER];

          r.textureMult = 2;
          canvas.width = canvasWidth * r.textureMult;
          canvas.height = canvasHeight * r.textureMult;
        }

        r.canvasWidth = canvasWidth;
        r.canvasHeight = canvasHeight;
      };

      CRp.renderTo = function (cxt, zoom, pan, pxRatio) {
        this.render({
          forcedContext: cxt,
          forcedZoom: zoom,
          forcedPan: pan,
          drawAllLayers: true,
          forcedPxRatio: pxRatio
        });
      };

      CRp.render = function (options) {
        options = options || util.staticEmptyObject();

        var forcedContext = options.forcedContext;
        var drawAllLayers = options.drawAllLayers;
        var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
        var forcedZoom = options.forcedZoom;
        var forcedPan = options.forcedPan;
        var r = this;
        var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
        var cy = r.cy;var data = r.data;
        var needDraw = data.canvasNeedsRedraw;
        var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
        var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
        var mbPxRatio = r.motionBlurPxRatio;
        var hasCompoundNodes = cy.hasCompoundNodes();
        var inNodeDragGesture = r.hoverData.draggingEles;
        var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
        motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
        var motionBlurFadeEffect = motionBlur;

        if (!forcedContext) {
          if (r.prevPxRatio !== pixelRatio) {
            r.invalidateContainerClientCoordsCache();
            r.matchCanvasSize(r.container);

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }

          r.prevPxRatio = pixelRatio;
        }

        if (!forcedContext && r.motionBlurTimeout) {
          clearTimeout(r.motionBlurTimeout);
        }

        if (motionBlur) {
          if (r.mbFrames == null) {
            r.mbFrames = 0;
          }

          r.mbFrames++;

          if (r.mbFrames < 3) {
            // need several frames before even high quality motionblur
            motionBlurFadeEffect = false;
          }

          // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
          if (r.mbFrames > r.minMbLowQualFrames) {
            //r.fullQualityMb = false;
            r.motionBlurPxRatio = r.mbPxRBlurry;
          }
        }

        if (r.clearingMotionBlur) {
          r.motionBlurPxRatio = 1;
        }

        // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
        // because a rogue async texture frame would clear needDraw
        if (r.textureDrawLastFrame && !textureDraw) {
          needDraw[r.NODE] = true;
          needDraw[r.SELECT_BOX] = true;
        }

        var coreStyle = cy.style()._private.coreStyle;

        var zoom = cy.zoom();
        var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
        var pan = cy.pan();
        var effectivePan = {
          x: pan.x,
          y: pan.y
        };

        var vp = {
          zoom: zoom,
          pan: {
            x: pan.x,
            y: pan.y
          }
        };
        var prevVp = r.prevViewport;
        var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

        // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
        if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
          r.motionBlurPxRatio = 1;
        }

        if (forcedPan) {
          effectivePan = forcedPan;
        }

        // apply pixel ratio

        effectiveZoom *= pixelRatio;
        effectivePan.x *= pixelRatio;
        effectivePan.y *= pixelRatio;

        var eles = r.getCachedZSortedEles();

        function mbclear(context, x, y, w, h) {
          var gco = context.globalCompositeOperation;

          context.globalCompositeOperation = 'destination-out';
          r.fillStyle(context, 255, 255, 255, r.motionBlurTransparency);
          context.fillRect(x, y, w, h);

          context.globalCompositeOperation = gco;
        }

        function setContextTransform(context, clear) {
          var ePan, eZoom, w, h;

          if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
            ePan = {
              x: pan.x * mbPxRatio,
              y: pan.y * mbPxRatio
            };

            eZoom = zoom * mbPxRatio;

            w = r.canvasWidth * mbPxRatio;
            h = r.canvasHeight * mbPxRatio;
          } else {
            ePan = effectivePan;
            eZoom = effectiveZoom;

            w = r.canvasWidth;
            h = r.canvasHeight;
          }

          context.setTransform(1, 0, 0, 1, 0, 0);

          if (clear === 'motionBlur') {
            mbclear(context, 0, 0, w, h);
          } else if (!forcedContext && (clear === undefined || clear)) {
            context.clearRect(0, 0, w, h);
          }

          if (!drawAllLayers) {
            context.translate(ePan.x, ePan.y);
            context.scale(eZoom, eZoom);
          }
          if (forcedPan) {
            context.translate(forcedPan.x, forcedPan.y);
          }
          if (forcedZoom) {
            context.scale(forcedZoom, forcedZoom);
          }
        }

        if (!textureDraw) {
          r.textureDrawLastFrame = false;
        }

        if (textureDraw) {
          r.textureDrawLastFrame = true;

          var bb;

          if (!r.textureCache) {
            r.textureCache = {};

            bb = r.textureCache.bb = cy.mutableElements().boundingBox();

            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];

            var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];

            cxt.setTransform(1, 0, 0, 1, 0, 0);
            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);

            r.render({
              forcedContext: cxt,
              drawOnlyNodeLayer: true,
              forcedPxRatio: pixelRatio * r.textureMult
            });

            var vp = r.textureCache.viewport = {
              zoom: cy.zoom(),
              pan: cy.pan(),
              width: r.canvasWidth,
              height: r.canvasHeight
            };

            vp.mpan = {
              x: (0 - vp.pan.x) / vp.zoom,
              y: (0 - vp.pan.y) / vp.zoom
            };
          }

          needDraw[r.DRAG] = false;
          needDraw[r.NODE] = false;

          var context = data.contexts[r.NODE];

          var texture = r.textureCache.texture;
          var vp = r.textureCache.viewport;
          bb = r.textureCache.bb;

          context.setTransform(1, 0, 0, 1, 0, 0);

          if (motionBlur) {
            mbclear(context, 0, 0, vp.width, vp.height);
          } else {
            context.clearRect(0, 0, vp.width, vp.height);
          }

          var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
          var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
          r.fillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
          context.fillRect(0, 0, vp.width, vp.height);

          var zoom = cy.zoom();

          setContextTransform(context, false);

          context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
          context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
        } else if (r.textureOnViewport && !forcedContext) {
          // clear the cache since we don't need it
          r.textureCache = null;
        }

        var extent = cy.extent();
        var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles;
        var hideEdges = r.hideEdgesOnViewport && vpManip;

        var needMbClear = [];

        needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
        if (needMbClear[r.NODE]) {
          r.clearedForMotionBlur[r.NODE] = true;
        }

        needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
        if (needMbClear[r.DRAG]) {
          r.clearedForMotionBlur[r.DRAG] = true;
        }

        if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
          var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
          var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
          var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

          setContextTransform(context, clear);

          if (hideEdges) {
            r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
          } else {
            r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
          }

          if (r.debug) {
            r.drawDebugPoints(context, eles.nondrag);
          }

          if (!drawAllLayers && !motionBlur) {
            needDraw[r.NODE] = false;
          }
        }

        if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
          var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
          var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);

          setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

          if (hideEdges) {
            r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
          } else {
            r.drawCachedElements(context, eles.drag, pixelRatio, extent);
          }

          if (r.debug) {
            r.drawDebugPoints(context, eles.drag);
          }

          if (!drawAllLayers && !motionBlur) {
            needDraw[r.DRAG] = false;
          }
        }

        if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
          var context = forcedContext || data.contexts[r.SELECT_BOX];

          setContextTransform(context);

          if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
            var zoom = r.cy.zoom();
            var borderWidth = coreStyle['selection-box-border-width'].value / zoom;

            context.lineWidth = borderWidth;
            context.fillStyle = 'rgba(' + coreStyle['selection-box-color'].value[0] + ',' + coreStyle['selection-box-color'].value[1] + ',' + coreStyle['selection-box-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

            if (borderWidth > 0) {
              context.strokeStyle = 'rgba(' + coreStyle['selection-box-border-color'].value[0] + ',' + coreStyle['selection-box-border-color'].value[1] + ',' + coreStyle['selection-box-border-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

              context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
            }
          }

          if (data.bgActivePosistion && !r.hoverData.selecting) {
            var zoom = r.cy.zoom();
            var pos = data.bgActivePosistion;

            context.fillStyle = 'rgba(' + coreStyle['active-bg-color'].value[0] + ',' + coreStyle['active-bg-color'].value[1] + ',' + coreStyle['active-bg-color'].value[2] + ',' + coreStyle['active-bg-opacity'].value + ')';

            context.beginPath();
            context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
            context.fill();
          }

          var timeToRender = r.lastRedrawTime;
          if (r.showFps && timeToRender) {
            timeToRender = Math.round(timeToRender);
            var fps = Math.round(1000 / timeToRender);

            context.setTransform(1, 0, 0, 1, 0, 0);

            context.fillStyle = 'rgba(255, 0, 0, 0.75)';
            context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
            context.lineWidth = 1;
            context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

            var maxFps = 60;
            context.strokeRect(0, 30, 250, 20);
            context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
          }

          if (!drawAllLayers) {
            needDraw[r.SELECT_BOX] = false;
          }
        }

        // motionblur: blit rendered blurry frames
        if (motionBlur && mbPxRatio !== 1) {
          var cxtNode = data.contexts[r.NODE];
          var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];

          var cxtDrag = data.contexts[r.DRAG];
          var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

          var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
            cxt.setTransform(1, 0, 0, 1, 0, 0);

            if (needClear || !motionBlurFadeEffect) {
              cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
            } else {
              mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
            }

            var pxr = mbPxRatio;

            cxt.drawImage(txt, // img
            0, 0, // sx, sy
            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
            0, 0, // x, y
            r.canvasWidth, r.canvasHeight // w, h
            );
          };

          if (needDraw[r.NODE] || needMbClear[r.NODE]) {
            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
            needDraw[r.NODE] = false;
          }

          if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
            needDraw[r.DRAG] = false;
          }
        }

        r.prevViewport = vp;

        if (r.clearingMotionBlur) {
          r.clearingMotionBlur = false;
          r.motionBlurCleared = true;
          r.motionBlur = true;
        }

        if (motionBlur) {
          r.motionBlurTimeout = setTimeout(function () {
            r.motionBlurTimeout = null;

            r.clearedForMotionBlur[r.NODE] = false;
            r.clearedForMotionBlur[r.DRAG] = false;
            r.motionBlur = false;
            r.clearingMotionBlur = !textureDraw;
            r.mbFrames = 0;

            needDraw[r.NODE] = true;
            needDraw[r.DRAG] = true;

            r.redraw();
          }, motionBlurDelay);
        }

        if (!forcedContext) {
          cy.emit('render');
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 135 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var CRp = {};

      // @O Polygon drawing
      CRp.drawPolygonPath = function (context, x, y, width, height, points) {

        var halfW = width / 2;
        var halfH = height / 2;

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(x + halfW * points[0], y + halfH * points[1]);

        for (var i = 1; i < points.length / 2; i++) {
          context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
        }

        context.closePath();
      };

      // Round rectangle drawing
      CRp.drawRoundRectanglePath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var cornerRadius = math.getRoundRectangleRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        }

        // Start at top middle
        context.moveTo(x, y - halfHeight);
        // Arc from middle top to right side
        context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
        // Arc from right side to bottom
        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
        // Arc from bottom to left side
        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
        // Arc from left side to topBorder
        context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
        // Join line
        context.lineTo(x, y - halfHeight);

        context.closePath();
      };

      CRp.drawBottomRoundRectanglePath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var cornerRadius = math.getRoundRectangleRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        }

        // Start at top middle
        context.moveTo(x, y - halfHeight);
        context.lineTo(x + halfWidth, y - halfHeight);
        context.lineTo(x + halfWidth, y);

        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);

        context.lineTo(x - halfWidth, y - halfHeight);
        context.lineTo(x, y - halfHeight);

        context.closePath();
      };

      CRp.drawCutRectanglePath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var cornerLength = math.getCutRectangleCornerLength();

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(x - halfWidth + cornerLength, y - halfHeight);

        context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
        context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
        context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
        context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
        context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
        context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
        context.lineTo(x - halfWidth, y - halfHeight + cornerLength);

        context.closePath();
      };

      CRp.drawBarrelPath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;

        var xBegin = x - halfWidth;
        var xEnd = x + halfWidth;
        var yBegin = y - halfHeight;
        var yEnd = y + halfHeight;

        var barrelCurveConstants = math.getBarrelCurveConstants(width, height);
        var wOffset = barrelCurveConstants.widthOffset;
        var hOffset = barrelCurveConstants.heightOffset;
        var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(xBegin, yBegin + hOffset);

        context.lineTo(xBegin, yEnd - hOffset);
        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);

        context.lineTo(xEnd - wOffset, yEnd);
        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);

        context.lineTo(xEnd, yBegin + hOffset);
        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);

        context.lineTo(xBegin + wOffset, yBegin);
        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);

        context.closePath();
      };

      var sin0 = Math.sin(0);
      var cos0 = Math.cos(0);

      var sin = {};
      var cos = {};

      var ellipseStepSize = Math.PI / 40;

      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
        sin[i] = Math.sin(i);
        cos[i] = Math.cos(i);
      }

      CRp.drawEllipsePath = function (context, centerX, centerY, width, height) {
        if (context.beginPath) {
          context.beginPath();
        }

        if (context.ellipse) {
          context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
        } else {
          var xPos, yPos;
          var rw = width / 2;
          var rh = height / 2;
          for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

            if (i === 0) {
              context.moveTo(xPos, yPos);
            } else {
              context.lineTo(xPos, yPos);
            }
          }
        }

        context.closePath();
      };

      module.exports = CRp;

      /***/
    },
    /* 136 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var CRp = {};

      CRp.createBuffer = function (w, h) {
        var buffer = document.createElement('canvas'); // eslint-disable-line no-undef
        buffer.width = w;
        buffer.height = h;

        return [buffer, buffer.getContext('2d')];
      };

      CRp.bufferCanvasImage = function (options) {
        var cy = this.cy;
        var eles = cy.mutableElements();
        var bb = eles.boundingBox();
        var ctrRect = this.findContainerClientCoords();
        var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
        var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
        var specdMaxDims = is.number(options.maxWidth) || is.number(options.maxHeight);
        var pxRatio = this.getPixelRatio();
        var scale = 1;

        if (options.scale !== undefined) {
          width *= options.scale;
          height *= options.scale;

          scale = options.scale;
        } else if (specdMaxDims) {
          var maxScaleW = Infinity;
          var maxScaleH = Infinity;

          if (is.number(options.maxWidth)) {
            maxScaleW = scale * options.maxWidth / width;
          }

          if (is.number(options.maxHeight)) {
            maxScaleH = scale * options.maxHeight / height;
          }

          scale = Math.min(maxScaleW, maxScaleH);

          width *= scale;
          height *= scale;
        }

        if (!specdMaxDims) {
          width *= pxRatio;
          height *= pxRatio;
          scale *= pxRatio;
        }

        var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

        buffCanvas.width = width;
        buffCanvas.height = height;

        buffCanvas.style.width = width + 'px';
        buffCanvas.style.height = height + 'px';

        var buffCxt = buffCanvas.getContext('2d');

        // Rasterize the layers, but only if container has nonzero size
        if (width > 0 && height > 0) {

          buffCxt.clearRect(0, 0, width, height);

          buffCxt.globalCompositeOperation = 'source-over';

          var zsortedEles = this.getCachedZSortedEles();

          if (options.full) {
            // draw the full bounds of the graph
            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
            buffCxt.scale(scale, scale);

            this.drawElements(buffCxt, zsortedEles);

            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
          } else {
            // draw the current view
            var pan = cy.pan();

            var translation = {
              x: pan.x * scale,
              y: pan.y * scale
            };

            scale *= cy.zoom();

            buffCxt.translate(translation.x, translation.y);
            buffCxt.scale(scale, scale);

            this.drawElements(buffCxt, zsortedEles);

            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(-translation.x, -translation.y);
          }

          // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs
          if (options.bg) {
            buffCxt.globalCompositeOperation = 'destination-over';

            buffCxt.fillStyle = options.bg;
            buffCxt.rect(0, 0, width, height);
            buffCxt.fill();
          }
        }

        return buffCanvas;
      };

      function b64ToBlob(b64, mimeType) {
        var bytes = atob(b64);
        var buff = new ArrayBuffer(bytes.length);
        var buffUint8 = new Uint8Array(buff);

        for (var i = 0; i < bytes.length; i++) {
          buffUint8[i] = bytes.charCodeAt(i);
        }

        return new Blob([buff], { type: mimeType });
      }

      function b64UriToB64(b64uri) {
        var i = b64uri.indexOf(',');

        return b64uri.substr(i + 1);
      };

      function output(options, canvas, mimeType) {
        var b64Uri = canvas.toDataURL(mimeType, options.quality);

        switch (options.output) {
          case 'blob':
            return b64ToBlob(b64UriToB64(b64Uri), mimeType);

          case 'base64':
            return b64UriToB64(b64Uri);

          case 'base64uri':
          default:
            return b64Uri;
        }
      }

      CRp.png = function (options) {
        return output(options, this.bufferCanvasImage(options), 'image/png');
      };

      CRp.jpg = function (options) {
        return output(options, this.bufferCanvasImage(options), 'image/jpeg');
      };

      module.exports = CRp;

      /***/
    },
    /* 137 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      CRp.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
        switch (name) {
          case 'ellipse':
            return this.drawEllipsePath(context, centerX, centerY, width, height);
          case 'polygon':
            return this.drawPolygonPath(context, centerX, centerY, width, height, points);
          case 'roundrectangle':
            return this.drawRoundRectanglePath(context, centerX, centerY, width, height);
          case 'cutrectangle':
            return this.drawCutRectanglePath(context, centerX, centerY, width, height);
          case 'bottomroundrectangle':
            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);
          case 'barrel':
            return this.drawBarrelPath(context, centerX, centerY, width, height);
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 138 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Style = __webpack_require__(18);

      // a dummy stylesheet object that doesn't need a reference to the core
      // (useful for init)
      var Stylesheet = function Stylesheet() {
        if (!(this instanceof Stylesheet)) {
          return new Stylesheet();
        }

        this.length = 0;
      };

      var sheetfn = Stylesheet.prototype;

      sheetfn.instanceString = function () {
        return 'stylesheet';
      };

      // just store the selector to be parsed later
      sheetfn.selector = function (selector) {
        var i = this.length++;

        this[i] = {
          selector: selector,
          properties: []
        };

        return this; // chaining
      };

      // just store the property to be parsed later
      sheetfn.css = function (name, value) {
        var i = this.length - 1;

        if (is.string(name)) {
          this[i].properties.push({
            name: name,
            value: value
          });
        } else if (is.plainObject(name)) {
          var map = name;

          for (var j = 0; j < Style.properties.length; j++) {
            var prop = Style.properties[j];
            var mapVal = map[prop.name];

            if (mapVal === undefined) {
              // also try camel case name
              mapVal = map[util.dash2camel(prop.name)];
            }

            if (mapVal !== undefined) {
              var _name = prop.name;
              var _value = mapVal;

              this[i].properties.push({
                name: _name,
                value: _value
              });
            }
          }
        }

        return this; // chaining
      };

      sheetfn.style = sheetfn.css;

      // generate a real style object from the dummy stylesheet
      sheetfn.generateStyle = function (cy) {
        var style = new Style(cy);

        return this.appendToStyle(style);
      };

      // append a dummy stylesheet object on a real style object
      sheetfn.appendToStyle = function (style) {
        for (var i = 0; i < this.length; i++) {
          var context = this[i];
          var selector = context.selector;
          var props = context.properties;

          style.selector(selector); // apply selector

          for (var j = 0; j < props.length; j++) {
            var prop = props[j];

            style.css(prop.name, prop.value); // apply property
          }
        }

        return style;
      };

      module.exports = Stylesheet;

      /***/
    },
    /* 139 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = "snapshot-2fd4aa6cc2-1531006893492";

      /***/
    }]
    /******/)
  );
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"timers":497}],6:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');
var $ = require('jquery');
var user = require('./user');
var funcs = require('./funcs');

var Menu = function () {
  function Menu(gui) {
    _classCallCheck(this, Menu);

    this.gui = gui;
    this.reset();
    this.bind();
  }

  _createClass(Menu, [{
    key: 'reset',
    value: function reset() {

      this.is_visible = false;
      this.pinned = {
        login: false,
        'manage-permissions': false,
        collab: true,

        'save-corpus': false,
        'upload-corpus': false,
        'download-corpus': false,
        'discard-corpus': false,

        'export-as-latex': false,
        'export-as-png': false,
        'export-as-svg': false,

        'show-help': true,
        'show-settings': false,
        'show-table': false
      };
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _this = this;

      $('#btnMenuDropdown').click(function (e) {
        return _this.toggle(e);
      });
      $('.dropdown-group-item .pin').click(function (e) {
        return _this.togglePinned(e);
      });

      $('.dropdown-group-item[name="logout"]').click(function (e) {
        return user.logout();
      });
      $('.dropdown-group-item[name="login"]').click(function (e) {
        return user.login();
      });
      $('.dropdown-group-item[name="manage-repos"]').click(function (e) {
        return user.manage.repos();
      });
      $('.dropdown-group-item[name="manage-permissions"]').click(function (e) {
        return user.manage.permissions();
      });
    }
  }, {
    key: 'update',
    value: function update() {

      $('#dropdown-container .dropdown-toggle').removeClass('open');
      if (this.is_visible) {
        $('#dropdown-container .dropdown-toggle').addClass('open');
      }

      $('#dropdown-container .dropdown-content').removeClass('menu-show menu-hidden').addClass(this.is_visible ? 'menu-show' : 'menu-hidden');

      $('.dropdown-group-item.pinnable, .btn.pinnable').removeClass('pinned unpinned');
      _.each(this.pinned, function (bool, name) {
        $('.dropdown-group-item[name="' + name + '"]').addClass(bool ? 'pinned' : 'unpinned');
        $('.btn.pinnable[name="' + name + '"]').addClass(bool ? 'pinned' : 'unpinned');
      });

      $('.btn-group .btn').css('border-radius', '0');
      $('.btn-group').each(function (i, group) {
        group = $(group);

        var visible = false,
            first = null,
            last = null;

        group.children().each(function (j, btn) {
          btn = $(btn);

          if (!btn.hasClass('unpinned') && btn.hasClass('btn')) {
            first = first || btn;
            last = btn;
          }

          if (btn.hasClass('pinnable')) {
            visible = visible || btn.hasClass('pinned');
          } else {
            visible = true;
          }
        });

        group.css('display', visible ? 'inline-flex' : 'none');
        if (first) first.css('border-top-left-radius', '5px').css('border-bottom-left-radius', '5px');
        if (last) last.css('border-top-right-radius', '5px').css('border-bottom-right-radius', '5px');
      });
    }
  }, {
    key: 'toggle',
    value: function toggle(event) {
      this.is_visible = !this.is_visible;
      this.gui.update();
    }
  }, {
    key: 'togglePinned',
    value: function togglePinned(event) {
      var name = $(event.target).closest('.dropdown-group-item').attr('name');

      this.pinned[name] = !this.pinned[name];
      this.gui.update();
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        is_visible: this.is_visible,
        pinned: this.pinned
      };
    },
    set: function set(state) {

      this.reset();
      if (!state) return;

      if (state) this.pinned = state.pinned || this.pinned;
    }
  }]);

  return Menu;
}();

module.exports = Menu;

},{"./funcs":9,"./user":34,"jquery":394,"underscore":499}],7:[function(require,module,exports){
'use strict';

/**
 * Custom ERROR objects
 *
 * throwing custom error objects instead of relying on native JavaScript ones
 * allows us to do a few things:
 *  - we know explicitly whether this error arose in a predictable way (i.e. we
 *    have seen it before, we know why it's happening, etc.)
 *  - errors that are not (instanceof AnnotatrixError) will therefore be all
 *    "unforeseen" JavaScript errors, and we should prioritize fixing those
 *  - custom handling (e.g., log it to the console even if we catch it later on)
 *
 */

/**
 * AnnotatrixError
 *
 * underspecified common ancestor of all custom errors, so it will be on the prototype
 * chain (all will be an "instanceof" AnnotatrixError)
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AnnotatrixError = function (_Error) {
  _inherits(AnnotatrixError, _Error);

  function AnnotatrixError() {
    var _ref;

    _classCallCheck(this, AnnotatrixError);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // maintains proper stack trace for where our error was thrown (i.e. doesn't
    //   include the constructor, but only available on V8)
    var _this = _possibleConstructorReturn(this, (_ref = AnnotatrixError.__proto__ || Object.getPrototypeOf(AnnotatrixError)).call.apply(_ref, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this, AnnotatrixError);

    // override prototype name
    _this.name = 'AnnotatrixError';

    // log all errors, even if we eventually catch them ... note that this does
    //   not show the full stack trace
    log.error(_this.message);
    return _this;
  }

  return AnnotatrixError;
}(Error);

/**
 * NotImplementedError
 *
 * throw this if we get somewhere that we know has not been implemented
 */


var NotImplementedError = function (_AnnotatrixError) {
  _inherits(NotImplementedError, _AnnotatrixError);

  function NotImplementedError() {
    var _ref2;

    _classCallCheck(this, NotImplementedError);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _this2 = _possibleConstructorReturn(this, (_ref2 = NotImplementedError.__proto__ || Object.getPrototypeOf(NotImplementedError)).call.apply(_ref2, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this2, NotImplementedError);

    _this2.name = 'NotImplementedError';
    return _this2;
  }

  return NotImplementedError;
}(AnnotatrixError);

/**
 * AssertionError
 *
 * throw this if Tester.assert() fails
 */


var AssertionError = function (_AnnotatrixError2) {
  _inherits(AssertionError, _AnnotatrixError2);

  function AssertionError() {
    var _ref3;

    _classCallCheck(this, AssertionError);

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var _this3 = _possibleConstructorReturn(this, (_ref3 = AssertionError.__proto__ || Object.getPrototypeOf(AssertionError)).call.apply(_ref3, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this3, AssertionError);

    _this3.name = 'AssertionError';
    return _this3;
  }

  return AssertionError;
}(AnnotatrixError);

/**
 * GUIError
 */


var GUIError = function (_AnnotatrixError3) {
  _inherits(GUIError, _AnnotatrixError3);

  function GUIError() {
    var _ref4;

    _classCallCheck(this, GUIError);

    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    var _this4 = _possibleConstructorReturn(this, (_ref4 = GUIError.__proto__ || Object.getPrototypeOf(GUIError)).call.apply(_ref4, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this4, GUIError);

    _this4.name = 'GUIError';
    return _this4;
  }

  return GUIError;
}(AnnotatrixError);

/**
 * ParseError
 */


var ParseError = function (_AnnotatrixError4) {
  _inherits(ParseError, _AnnotatrixError4);

  function ParseError() {
    var _ref5;

    _classCallCheck(this, ParseError);

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    var _this5 = _possibleConstructorReturn(this, (_ref5 = ParseError.__proto__ || Object.getPrototypeOf(ParseError)).call.apply(_ref5, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this5, ParseError);

    _this5.name = 'ParseError';
    return _this5;
  }

  return ParseError;
}(AnnotatrixError);

/**
 *
 */


var DeserializationError = function (_AnnotatrixError5) {
  _inherits(DeserializationError, _AnnotatrixError5);

  function DeserializationError() {
    var _ref6;

    _classCallCheck(this, DeserializationError);

    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    var _this6 = _possibleConstructorReturn(this, (_ref6 = DeserializationError.__proto__ || Object.getPrototypeOf(DeserializationError)).call.apply(_ref6, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this6, DeserializationError);

    _this6.name = 'DeserializationError';
    return _this6;
  }

  return DeserializationError;
}(AnnotatrixError);

module.exports = {
  AnnotatrixError: AnnotatrixError,
  NotImplementedError: NotImplementedError,
  // AssertionError,
  GUIError: GUIError,
  ParseError: ParseError,
  DeserializationError: DeserializationError
};

},{}],8:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var $ = require('jquery');
var C2S = require('canvas2svg');
var funcs = require('./funcs');

function latex() {

  var tokensLine = '',
      posLine = '',
      deprelLines = [];

  _.each(graph.eles(), function (node) {
    if (node.data.name === 'form') {
      if (node.data.analysis.upostag === undefined) return 'error';

      tokensLine += ' \\& ' + node.data.label;
      posLine += '\\&{\\tt ' + node.data.analysis.upostag + '}';
    }

    if (node.data.name === 'dependency') {
      if (node.data.label === undefined) return 'error';

      var source = node.data.sourceToken.id,
          target = node.data.targetToken.id,
          label = node.data.sourceToken.deprel;

      deprelLines.push('depedge{' + source + '}{' + target + '}{' + label + '}');
    }
  });

  tokensLine = tokensLine.replace('\\&', '') + ' \\\\';
  posLine = posLine.replace('\\&', '') + ' \\\\';

  // now make the LaTeX from it
  var latex = ['\\begin{dependency}', '  \\begin{deptext}[column sep=0.4cm]', '    ' + tokensLine, '    ' + posLine, '  \\end{deptext}'].concat(deprelLines.map(function (line) {
    return '  \\' + line;
  }), '\\end{dependency} \\\\').join('\n');

  funcs.download(manager.filename + '.tex', 'application/x-latex', latex);

  return latex;
}

function png() {

  var link = $('<a>').attr('download', manager.filename + '.png').attr('href', cy.png());
  $('body').append(link);
  link[0].click();

  return;
}

function svg() {
  var ctx = new C2S(cy.width(), cy.height());
  cy.renderer().renderTo(ctx); // DEBUG: this doesn't work

  funcs.download(manager.filename + '.svg', 'image/svg+xml', ctx.getSerializedSvg());
}

module.exports = {
  latex: latex,
  png: png,
  svg: svg
};

},{"./funcs":9,"canvas2svg":47,"jquery":394,"underscore":499}],9:[function(require,module,exports){
(function (global){
'use strict';

/**
 * shared functions
 */

var _ = require('underscore');
var $ = require('jquery');

var status = require('./status');

module.exports = {

  inBrowser: function inBrowser() {
    try {
      return !!window;
    } catch (e) {
      return false;
    }
  },

  global: function (_global) {
    function global() {
      return _global.apply(this, arguments);
    }

    global.toString = function () {
      return _global.toString();
    };

    return global;
  }(function () {
    try {
      // browser
      return window;
    } catch (e) {
      // node
      return global;
    }
  }),

  download: function download(filename, mimetype, uriComponent) {
    if (!gui.inBrowser) return false;

    var link = $('<a>').attr('download', filename).attr('href', 'data:' + mimetype + '; charset=utf-8,' + encodeURIComponent(uriComponent));
    $('body').append(link);
    link[0].click();
    return true;
  },

  getTreebankId: function getTreebankId() {
    var match = location.href.match(/treebank_id=([0-9a-f-]{36})(#|\/|$|&)/);
    if (!match) {
      status.error('invalid treebank url, must be valid UUID4');
      return;
    }

    return match[1];
  },

  link: function link(href) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_blank';

    var link = $('<a>').attr('href', href).attr('target', target);
    $('body').append(link);
    link[0].click();
  },

  noop: function noop(arg) {
    return arg;
  },

  getUsername: function getUsername(data) {
    return data.username || '<Anonymous>';
  },

  getPresentUsers: function getPresentUsers(room) {
    return Object.keys(room.users).length;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./status":24,"jquery":394,"underscore":499}],10:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var _ = require('underscore');

var cfg = require('./config');
var cytoscape = require('./cytoscape/cytoscape');
var errors = require('./errors');
var funcs = require('./funcs');
var sort = require('./sort');
var validate = require('./validate');
var ProgressBar = require('./progress-bar');

var Graph = function () {
  function Graph(options) {
    var _this = this;

    _classCallCheck(this, Graph);

    this.options = _.defaults(options, {
      container: funcs.inBrowser() ? $('#cy') : null,
      boxSelectionEnabled: false,
      autounselectify: true,
      autoungrabify: true,
      zoomingEnabled: true,
      userZoomingEnabled: false,
      wheelSensitivity: 0.1,
      style: require('./cy-style'),
      layout: null,
      elements: []
    });

    // only do this for in-browser ... add the .selfcomplete method to $()
    if (gui.inBrowser) require('./selfcomplete');

    this.progressBar = new ProgressBar();

    // cy handlers
    this.click = {
      form: function form(event) {
        var target = event.target;
        log.debug('called onClickFormNode(' + target.attr('id') + ')');

        if (gui.moving_dependency) {

          var dep = cy.$('.selected');
          var source = cy.$('.arc-source');

          _this.makeDependency(source, target);
          _this.removeDependency(dep);
          cy.$('.moving').removeClass('moving');
          gui.moving_dependency = false;

          // right-click the new edge
          cy.$('#' + source.attr('id') + ' -> #' + target.attr('id')).trigger('cxttapend');
        } else {

          _this.save();

          cy.$('.arc-source').removeClass('arc-source');
          cy.$('.arc-target').removeClass('arc-target');
          cy.$('.selected').removeClass('selected');

          if (target.hasClass('activated')) {
            target.removeClass('activated');
          } else {

            var _source = cy.$('.activated');
            target.addClass('activated');

            // if there was already an activated node
            if (_source.length === 1) {
              _this.makeDependency(_source, target);
              _source.removeClass('activated');
              target.removeClass('activated');
            }
          }
        }
      },
      pos: function pos(event) {
        var target = event.target;
        log.debug('called onClickPosNode(' + target.attr('id') + ')');

        _this.save();
        gui.editing = target;

        cy.$('.activated').removeClass('activated');
        cy.$('.arc-source').removeClass('arc-source');
        cy.$('.arc-target').removeClass('arc-target');
        cy.$('.selected').removeClass('selected');

        editLabel(target);
      },
      multiword: function multiword(event) {
        var target = event.target;

        if (target.hasClass('multiword-active')) {
          target.removeClass('multiword-active');
        } else {
          cy.$('.multiword-active').removeClass('multiword-active');
          target.addClass('multiword-active');
        }
      },
      dependency: function dependency(event) {
        var target = event.target;
        log.debug('called onClickDependencyEdge(' + target.attr('id') + ')');

        _this.save();
        gui.editing = target;

        cy.$('.activated').removeClass('activated');
        cy.$('.arc-source').removeClass('arc-source');
        cy.$('.arc-target').removeClass('arc-target');
        cy.$('.selected').removeClass('selected');

        editLabel(target);
      }
    };
    this.cxttapend = {
      form: function form(event) {
        var target = event.target;
        log.debug('called onCxttapendFormNode(' + target.attr('id') + ')');

        _this.save();
        gui.editing = target;

        cy.$('.activated').removeClass('activated');
        cy.$('.arc-source').removeClass('arc-source');
        cy.$('.arc-target').removeClass('arc-target');
        cy.$('.selected').removeClass('selected');

        editLabel(target);
      },
      dependency: function dependency(event) {
        var target = event.target;
        log.debug('called onCxttapendDependencyEdge(' + target.attr('id') + ')');

        /**
         * Activated when an arc is selected. Adds classes showing what is selected.
         */

        _this.save();

        cy.$('.activated').removeClass('activated');

        if (target.hasClass('selected')) {

          cy.$('#' + target.data('source')).removeClass('arc-source');
          cy.$('#' + target.data('target')).removeClass('arc-target'); // visual effects on targeted node
          target.removeClass('selected');
        } else {

          cy.$('.arc-source').removeClass('arc-source');
          cy.$('#' + target.data('source')).addClass('arc-source');

          cy.$('.arc-target').removeClass('arc-target');
          cy.$('#' + target.data('target')).addClass('arc-target');

          cy.$('.selected').removeClass('selected');
          target.addClass('selected');
        }
      }
    };
  }

  _createClass(Graph, [{
    key: 'eles',
    value: function eles() {
      //if (manager.graphable)
      return _.map(manager.current._nx.getCytoscapeEles(manager.current.format), function (ele) {
        if (ele.data.name === 'dependency') {

          var src = ele.data.sourceToken,
              tar = ele.data.targetToken;

          ele.data.label = gui.is_ltr ? tar.indices.absolute > src.indices.absolute ? src.deprel + '\u22B3' : '\u22B2' + src.deprel : tar.indices.absolute > src.indices.absolute ? '\u22B2' + src.deprel : src.deprel + '\u22B3';

          ele.data.ctrl = getCtrl(src, tar);
          ele.style = getStyle(src, tar);
          ele.classes = validate.depEdgeClasses(manager.current.eles, ele);
        } else if (ele.data.name === 'pos-node') {
          ele.classes = validate.posNodeClasses(ele);
        }

        return ele;
      });
      //return [];
    }
  }, {
    key: 'update',
    value: function update() {
      if (gui.graph_disabled) return;

      this.options.layout = {
        name: 'tree',
        padding: 0,
        nodeDimensionsIncludeLabels: false,
        cols: gui.is_vertical ? 2 : undefined,
        rows: gui.is_vertical ? undefined : 2,
        sort: gui.is_vertical ? sort.vertical : gui.is_ltr ? sort.ltr : sort.rtl
      };
      this.options.elements = this.eles();

      window.cy = cytoscape(this.options).minZoom(0.1).maxZoom(10.0).zoom(gui.zoom).pan(gui.pan);

      // add a slight delay to ensure this gets drawn last
      if (!gui.zoom && !gui.pan) setTimeout(function () {
        cy.fit().center();
        gui.zoom = cy.zoom();
        gui.pan = cy.pan();
      }, 5);

      this.bind();
      this.progressBar.update();

      return this;
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _this2 = this;

      /**
       * Binds event handlers to cy elements.
       * NOTE: If you change the style of a node (e.g. its selector) then
       * you also need to update it here.
       */

      // set a countdown to triggering a "background" click unless a node/edge intercepts it
      $('#cy canvas, #mute').mouseup(function (event) {
        gui.intercepted = false;
        setTimeout(function () {
          return _this2.clear();
        }, 100);
      });
      $('#cy canvas').mousemove(function (event) {
        gui.intercepted = true;
      });
      $('#edit').mouseup(function (event) {
        gui.intercepted = true;
      });
      cy.on('click cxttapend', '*', function (event) {
        gui.intercepted = true;

        // DEBUG: this line should be taken out in production
        console.info('clicked ' + event.target.attr('id') + ', data:', event.target.data());
      });

      // bind the cy events
      cy.on('click', 'node.form', function (e) {
        return _this2.click.form(e);
      });
      cy.on('click', 'node.pos', function (e) {
        return _this2.click.pos(e);
      });
      cy.on('click', '$node > node', function (e) {
        return _this2.click.multiword(e);
      });
      cy.on('click', 'edge.dependency', function (e) {
        return _this2.click.dependency(e);
      });
      cy.on('cxttapend', 'node.form', function (e) {
        return _this2.cxttapend.form(e);
      });
      cy.on('cxttapend', 'edge.dependency', function (e) {
        return _this2.cxttapend.dependency(e);
      });
    }
  }, {
    key: 'clear',
    value: function clear() {
      log.info('called onClickCanvas(intercepted: ' + gui.intercepted + ')');

      // intercepted by clicking a canvas subobject || mousemove (i.e. drag) || #edit
      if (gui.intercepted) return;

      this.save();

      cy.$('.activated').removeClass('activated');
      cy.$('.multiword-active').removeClass('multiword-active');
      cy.$('.arc-source').removeClass('arc-source');
      cy.$('.arc-target').removeClass('arc-target');
      cy.$('.selected').removeClass('selected');
      cy.$('.moving').removeClass('moving');
      cy.$('.merge').removeClass('merge');
      gui.moving_dependency = false;

      $('#mute').removeClass('activated');
      $('#edit').removeClass('activated');
    }
  }, {
    key: 'save',
    value: function save() {
      log.debug('called saveGraphEdits(target:' + (gui.editing ? gui.editing.attr('id') : 'null') + ', text:' + (gui.editing ? $('#edit').val() : '') + ')');

      cy.$('.input').removeClass('input');

      if (gui.editing === null) return; // nothing to do

      var analysis = gui.editing.data().analysis || gui.editing.data().sourceToken,
          attr = gui.editing.data().attr,
          oldValue = analysis[attr],
          newValue = $('#edit').val();

      modify(analysis.id, attr, newValue);

      window.undoManager.add({
        undo: function undo() {
          modify(analysis.id, attr, oldValue);
        },
        redo: function redo() {
          modify(analysis.id, attr, newValue);
        }
      });

      gui.editing = null;
    }
  }, {
    key: 'makeDependency',
    value: function makeDependency(src, tar) {
      var _this3 = this;

      log.debug('called makeDependency(' + src.attr('id') + '=>' + tar.attr('id') + ')');
      /**
       * Called by clicking a form-node while there is already an active form-node.
       * Changes the text data and redraws the graph. Currently supports only conllu.
       */

      src = src.data('analysis');
      tar = tar.data('analysis');

      if (src === tar) {
        log.warn('makeDependency(): unable to create dependency within superToken ' + src.superTokenId);
        return;
      }

      addHead(src.id, tar.id);

      undoManager.add({
        undo: function undo() {
          removeHead(src.id, tar.id);
          _this3.clear();
        },
        redo: function redo() {
          addHead(src.id, tar.id);
          _this3.clear();
        }
      });

      /*
      // TODO:
      // If the target POS tag is PUNCT set the deprel to @punct [99%]
      // IF the target POS tag is CCONJ set the deprel to @cc [88%]
      // IF the target POS tag is SCONJ set the deprel to @mark [86%]
      // IF the target POS tag is DET set the deprel to @det [83%]
       const POS_TO_REL = {
          'PUNCT': 'punct',
          'DET': 'det',
          'CCONJ': 'cc',
          'SCONJ': 'mark'
      }
       // TODO: Put this somewhere better
      if (thisToken.upostag in POS_TO_REL)
          sentAndPrev = changeConlluAttr(sent, indices, 'deprel', POS_TO_REL[thisToken.upostag]);
       let isValidDep = true;
      if (thisToken.upostag === 'PUNCT' && !is_projective_nodes(sent.tokens, [targetIndex])) {
          log.warn('writeArc(): Non-projective punctuation');
          isValidDep = false
      }*/
    }
  }, {
    key: 'removeDependency',
    value: function removeDependency(ele) {
      log.debug('called removeDependency(' + ele.attr('id') + ')');

      var src = ele.data('sourceToken'),
          tar = ele.data('targetToken');

      removeHead(src.id, tar.id);

      undoManager.add({
        undo: function undo() {
          addHead(src.id, tar.id);
        },
        redo: function redo() {
          removeHead(src.id, tar.id);
        }
      });
    }
  }, {
    key: 'setRoot',
    value: function setRoot(ele) {
      log.debug('called setAsRoot(' + ele.attr('id') + ')');

      // check if there is already a root
      var oldRoot = void 0;
      manager.current.forEach(function (token) {
        token.forEach(function (analysis) {
          if (analysis.head == 0 || analysis.deprel.toLowerCase() == 'root') oldRoot = analysis;
        });
      });

      // set new root
      var newRoot = ele.data('analysis');
      if (!newRoot) return;

      if (oldRoot) {
        modify(oldRoot.id, 'head', []);
        modify(oldRoot.id, 'deprel', undefined);
      }

      var oldHead = newRoot.head,
          oldDeprel = newRoot.deprel;

      modify(newRoot.id, 'head', '0');
      modify(newRoot.id, 'deprel', 'root');

      undoManager.add({
        undo: function undo() {
          if (oldRoot) {
            modify(oldRoot.id, 'head', '0');
            modify(oldRoot.id, 'deprel', 'root');
          }

          modify(newRoot.id, 'head', oldHead);
          modify(newRoot.id, 'deprel', oldDeprel);
        },
        redo: function redo() {
          if (oldRoot) {
            modify(oldRoot.id, 'head', []);
            modify(oldRoot.id, 'deprel', undefined);
          }

          modify(newRoot.id, 'head', '0');
          modify(newRoot.id, 'deprel', 'root');
        }
      });
    }
  }, {
    key: 'merge',
    value: function merge(direction, strategy) {
      throw new errors.NotImplementedError('merging not implemented');
      log.error('called mergeNodes(' + dir + ')');

      // old: (toMerge, side, how)

      /* Support for merging tokens into either a new token or a supertoken.
      Recieves the node to merge, side (right or left) and a string denoting
      how to merge the nodes. In case of success, redraws the tree. */
      // const indices = findConlluId(toMerge);

      var oldSentence = manager.toString();

      // prefer traits on this one
      var major = cy.$('.merge').data('conllu');
      // either one to the left or to the right (w/o wrapping)
      var minor = manager.current.tokens[major.superTokenId + (direction === 'left' ? -1 : 1)];

      // make sure we have stuff
      if (!major || !minor) {
        log.error('mergeNodes(): cannot merge these tokens');
        return;
      }

      manager.current.merge(major, minor, strategy);

      undoManager.add({
        undo: function undo() {
          manager.parse(oldSentence);
        },
        redo: function redo() {
          manager.parse(manager.conllu);
        }
      });
    }
  }]);

  return Graph;
}();

function getStyle(src, tar) {
  var style = {
    'control-point-weights': '0.1 0.5 1',
    'target-endpoint': '0% -50%'
  };

  if (tar.indices.absolute < src.indices.absolute) {
    style['source-endpoint'] = -10 * cfg.defaultEdgeCoeff + 'px -50%';
  } else {
    style['source-endpoint'] = 10 * cfg.defaultEdgeCoeff + 'px -50%';
  }

  return style;
}

function getCtrl(src, tar) {
  return new Array(4).fill(getEdgeHeight(src, tar));
}

function getEdgeHeight(src, tar) {

  var diff = tar.indices.absolute - src.indices.absolute;

  var edgeHeight = cfg.defaultEdgeHeight * diff;
  if (gui.is_ltr) edgeHeight *= -1;
  if (Math.abs(edgeHeight) !== 1) edgeHeight *= cfg.defaultEdgeCoeff;
  if (gui.is_vertical) edgeHeight = 45;

  log.debug('getEdgeHeight(): ' + edgeHeight);

  return edgeHeight;
}

function editLabel(target) {
  log.debug('called editLabel(' + target.attr('id') + ')');

  target.addClass('input');

  // get rid of direction arrows
  var label = target.data('label').replace(/[â³â²]/, '');
  target.data('label', label);

  // get bounding box
  var bbox = target.renderedBoundingBox();
  bbox.color = target.style('background-color');
  if (target.data('name') === 'dependency') {
    bbox.w = 100;
    bbox.h = cy.nodes()[0].renderedHeight();
    bbox.color = 'white';

    if (gui.is_vertical) {
      bbox.y1 += (bbox.y2 - bbox.y1) / 2 - 15;
      bbox.x1 = bbox.x2 - 70;
    } else {
      bbox.x1 += (bbox.x2 - bbox.x1) / 2 - 50;
    }
  }

  // TODO: rank the labels + make the style better
  var autocompletes = target.data('name') === 'pos-node' ? validate.U_POS : target.data('name') === 'dependency' ? validate.U_DEPRELS : [];

  // add the edit input
  $('#edit').val('').focus().val(label).css('top', bbox.y1).css('left', bbox.x1).css('height', bbox.h).css('width', bbox.w + 5).attr('target', target.attr('id')).addClass('activated').selfcomplete({
    lookup: autocompletes,
    tabDisabled: false,
    autoSelectFirst: true,
    lookupLimit: 5
  });

  // add the background-mute div
  $('#mute').addClass('activated').css('height', gui.is_vertical ? gui.tokens.length * 50 + 'px' : $(window).width() - 10);

  $('#edit').focus(); // move cursor to the end
  if (target.data('name') === 'dependency') $('#edit').select(); // highlight the current contents
}

function modify(id, attr, value) {

  // check we don't have any whitespace
  if (/\s+/g.test(value)) {
    var message = 'ERROR: Unable to add changes with whitespace!  Try creating a new node first.';
    log.error(message);
    alert(message); // TODO: probably should streamline errors
    gui.editing = null;
    return;
  }

  var ana = manager.current.get(id);

  ana[attr] = value;
  manager.parse(manager.toString());
}

function addHead(srcId, tarId) {
  var dep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  var src = manager.current.get(srcId),
      tar = manager.current.get(tarId);

  src.addHead(tar, dep);
  manager.parse(manager.toString());
}

function removeHead(srcId, tarId) {
  var src = manager.current.get(srcId),
      tar = manager.current.get(tarId);

  src.removeHead(tar);
  manager.parse(manager.toString());
}

module.exports = Graph;

},{"./config":3,"./cy-style":4,"./cytoscape/cytoscape":5,"./errors":7,"./funcs":9,"./progress-bar":18,"./selfcomplete":19,"./sort":23,"./validate":36,"jquery":394,"underscore":499}],11:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var _ = require('underscore');

var Menu = require('./dropdown-menu');
var funcs = require('./funcs');
var errors = require('./errors');
var setupUndos = require('./undo-manager');
var table = require('./table');
var storage = require('./local-storage');

var KEYS = {
  DELETE: 46,
  BACKSPACE: 8,
  ENTER: 13,
  ESC: 27,
  TAB: 9,
  RIGHT: 39,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  MINUS: 173,
  MINUS_: 189,
  EQUALS: 61,
  EQUALS_: 187,
  SHIFT: 16,
  CTRL: 17,
  OPT: 18,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  META: 224,
  D: 68,
  I: 73,
  J: 74,
  K: 75,
  M: 77,
  P: 80,
  R: 82,
  S: 83,
  X: 88,
  Y: 89,
  Z: 90,
  0: 48
};

var pressed = {}; // used for onCtrlKeyup

var GUI = function () {
  function GUI() {
    var _this = this;

    _classCallCheck(this, GUI);

    this.keys = KEYS;

    this.is_textarea_visible = true;
    this.are_labels_visible = true;
    this.is_vertical = false;
    this.is_ltr = true;
    this.is_enhanced = false;
    this.readonly = false;

    this.pan = this.pan || null;
    this.zoom = this.zoom || null;
    this.graph_disabled = false;
    this.intercepted = false;
    this.moving_dependency = false;
    this.editing = null;

    this.inBrowser = funcs.inBrowser();

    if (this.inBrowser) {
      setupUndos();
      undoManager.setCallback(function () {
        return _this.update();
      });

      this.menu = new Menu(this);
      this.modals = require('./modals/index');
    }

    this.toggle = {
      dropdown: function dropdown(event) {
        return _this.menu.toggle(event);
      },
      pin: function pin(event) {
        return _this.menu.togglePinned(event);
      },

      table: function table(event) {
        _this.is_table_view = !_this.is_table_view;
        _this.update();
      },

      tableColumn: function tableColumn(event) {

        var target = $(event.target),
            col = target.attr('col-id');

        _this.column_visible(col, !_this.column_visible(col));
        target.toggleClass('column-hidden').find('i').toggleClass('fa-angle-double-right').toggleClass('fa-angle-double-left');

        $('td[col-id=' + col + ']').css('visibility', _this.column_visible(col) ? 'visible' : 'hidden');

        _this.update();
      },

      textarea: function textarea(event) {

        $('#btnToggleTextarea i').toggleClass('fa-chevron-up').toggleClass('fa-chevron-down');
        _this.is_textarea_visible = !_this.is_textarea_visible;

        _this.update();
      },

      rtl: function rtl(event) {

        $('#RTL .fa').toggleClass('fa-align-right').toggleClass('fa-align-left');
        _this.is_ltr = !_this.is_ltr;

        _this.update();
      },

      vertical: function vertical(event) {

        $('#vertical .fa').toggleClass('fa-rotate-90');
        _this.is_vertical = !_this.is_vertical;

        _this.update();
      },

      enhanced: function enhanced(event) {

        $('#enhanced .fa').toggleClass('fa-tree').toggleClass('fa-magic');
        _this.is_enhanced = !_this.is_enhanced;

        _this.update();
      }
    };
  }

  _createClass(GUI, [{
    key: 'update',
    value: function update() {
      if (!this.inBrowser) return;

      this.menu.update();

      // textarea
      $('#text-data').removeClass('readonly').val(manager.toString());

      // navigation buttons
      $('.btn, .dropdown-group-item').removeClass('disabled').prop('disabled', false);

      manager.updateFilter();
      $('#total-sentences').text(manager.totalSentences);
      $('#current-sentence').val(manager.currentSentence);
      if (!manager.index && (manager._filtered.length || manager.length)) $('#btnPrevSentence').addClass('disabled');
      if (manager.index === (manager._filtered.length || manager.length) - 1) $('#btnNextSentence').addClass('disabled');

      if (!server.is_running) $('[name="upload-corpus"]').addClass('disabled').prop('disabled', true);
      if (manager.format !== 'CoNLL-U') $('[name="show-table"]').addClass('disabled').prop('disabled', true);

      // TODO: until SVG is fixed
      $('[name="export-as-svg"]').addClass('disabled').prop('disabled', true);

      $('#btnUndo').prop('disabled', !undoManager.hasUndo());
      $('#btnRedo').prop('disabled', !undoManager.hasRedo());

      $('.nav-link').removeClass('active').filter('[name="' + manager.format + '"]').addClass('active');

      $('.tab-warning').hide();
      if (manager.current.conversion_warning) $('.format-tab[name="' + manager.current.format + '"] .tab-warning').show().attr('title', manager.current.conversion_warning);

      if (manager.format !== 'CoNLL-U') this.is_table_view = false;

      if (this.is_table_view) {
        $('#btnToggleTable i').removeClass('fa-code');
        $('#text-data').hide();
        $('#table-data').show();
        table.build();
      } else {
        $('#btnToggleTable i').addClass('fa-code');
        $('#text-data').show();
        $('#table-data').hide();
      }

      if (this.is_textarea_visible) {
        $('#data-container').show();
        $('#top-buttons-container').removeClass('extra-space');
        $('#btnToggleTable').show();
      } else {
        $('#data-container').hide();
        $('#top-buttons-container').addClass('extra-space');
        $('.nav-link').not('.active').hide();
        $('#btnToggleTable').hide();
      }

      $('#label-container').css('display', this.are_labels_visible && this.is_textarea_visible ? 'flex' : 'none');

      try {
        // need this in case `cy` DNE
        this.zoom = cy.zoom();
        this.pan = cy.pan();
      } catch (e) {
        this.zoom = null;
        this.pan = null;
      }
      labeler.update();
      graph.update();
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _this2 = this;

      if (!this.inBrowser) return;

      $('#btnPrevSentence').click(function (e) {
        return manager.prev();
      });
      $('#btnNextSentence').click(function (e) {
        return manager.next();
      });
      $('#current-sentence').blur(function (e) {
        var index = parseInt($('current-sentence').val()) - 1;
        manager.index = index;
      });
      $('#btnRemoveSentence').click(function (e) {
        return manager.removeSentence();
      });
      $('#btnAddSentence').click(function (e) {
        return manager.insertSentence();
      });

      $('[name="save-corpus"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.save();
      });
      $('[name="upload-corpus"]').click(function (e) {
        var target = $(e.target);
        if (!target.is('.pin') && !target.closest('a').hasClass('disabled')) _this2.modals.upload.show();
      });
      $('[name="download-corpus"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.download();
      });
      $('[name="discard-corpus"]').click(function (e) {
        if ($(e.target).is('.pin')) return;

        var conf = confirm('Do you want to clear the corpus (remove all sentences)?');
        if (!conf) {
          log.info('corpus::clear(): not clearing corpus');
          return;
        }

        storage.clear();
        manager.reset();
      });

      $('[name="export-as-latex"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.export.latex();
      });
      $('[name="export-as-png"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.export.png();
      });
      $('[name="export-as-svg"]').click(function (e) {
        var target = $(e.target);
        if (!target.is('.pin') && !target.closest('a').hasClass('disabled')) manager.export.svg();
      });

      $('[name="show-labels"]').click(function (e) {
        if ($(e.target).is('.pin')) return;

        _this2.are_labels_visible = !_this2.are_labels_visible;
        _this2.update();
      });
      $('[name="show-help"]').click(function (e) {
        if (!$(e.target).is('.pin')) funcs.link('/help', '_self');
      });
      $('[name="show-settings"]').click(function (e) {
        if (!$(e.target).is('.pin')) funcs.link('/settings?treebank_id=' + funcs.getTreebankId(), '_self');
      });

      $('.format-tab').click(function (e) {

        manager.current.format = $(e.target).attr('name');
        _this2.update();
      });

      $('[name="show-table"]').click(function (e) {
        var target = $(e.target);
        if (!target.is('.pin') && !target.closest('a').hasClass('disabled')) _this2.toggle.table(e);
      });
      $('.thead-default th').click(function (e) {
        return _this2.toggle.tableColumn(e);
      });
      $('#btnToggleTextarea').click(function (e) {
        return _this2.toggle.textarea(e);
      });

      $('#label-clear-filter').click(function (e) {
        labeler.clearFilter();
        gui.update();
      });

      $('#RTL').click(function (e) {
        return _this2.toggle.rtl(e);
      });
      $('#vertical').click(function (e) {
        return _this2.toggle.vertical(e);
      });
      $('#enhanced').click(function (e) {
        return _this2.toggle.enhanced(e);
      });

      $('#current-sentence').keyup(function (e) {
        return onKeyupInCurrentSentence(e);
      });
      $('#text-data').keyup(function (e) {
        return onEditTextData(e);
      });
      $('#edit').keyup(function (e) {
        return onKeyupInEditLabel(e);
      });
      onkeyup = onKeyupInDocument;

      // prevent accidentally leaving the page
      window.onbeforeunload = function () {
        manager.save();
        // DEBUG: uncomment this line for production
        // return 'Are you sure you want to leave?';
      };
    }
  }, {
    key: 'column_visible',
    value: function column_visible(col, bool) {
      if (typeof bool === 'boolean') manager.current.column_visibilities[col] = bool;

      return manager.current.column_visibilities[col];
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      cy.zoom(this.zoom * 1.1);
      this.update();

      return this;
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      cy.zoom(this.zoom / 1.1);
      this.update();

      return this;
    }
  }, {
    key: 'state',
    get: function get() {
      return {

        menu: this.menu ? this.menu.state : null,
        is_textarea_visible: this.is_textarea_visible,
        are_labels_visible: this.are_labels_visible,
        is_vertical: this.is_vertical,
        is_ltr: this.is_ltr,
        is_enhanced: this.is_enhanced,
        readonly: this.readonly,

        pan: this.pan,
        zoom: this.zoom

      };
    },
    set: function set(state) {

      this.menu.state = state.menu;

      this.is_textarea_visible = state.is_textarea_visible, this.are_labels_visible = state.are_labels_visible, this.is_vertical = state.is_vertical;
      this.is_ltr = state.is_ltr;
      this.is_enhanced = state.is_enhanced;
      this.readonly = state.readonly;

      this.pan = state.pan;
      this.zoom = state.zoom;

      this.update();
    }
  }, {
    key: 'is_table_view',
    get: function get() {
      return manager.current.is_table_view;
    },
    set: function set(bool) {

      manager.current.is_table_view = false;
      if (typeof bool === 'boolean' && manager.format === 'CoNLL-U') manager.current.is_table_view = bool;

      return manager.current.is_table_view;
    }
  }]);

  return GUI;
}();

function onKeyupInDocument(event) {
  log.info('called onKeyupInDocument(' + event.which + ')');

  // returns true if it caught something
  if (onCtrlKeyup(event)) return;

  // editing an input
  if ($('#text-data').is(':focus') || $('#edit').is(':focus')) return;

  // if we get here, we're handling a keypress without an input-focus or ctrl-press
  // (which means it wasn't already handled)
  log.debug('onKeyupInDocument(): handling event.which:' + event.which);

  switch (event.which) {
    case KEYS.DELETE:
    case KEYS.BACKSPACE:
    case KEYS.X:
      if (cy.$('.selected').length) {
        graph.removeDependency(cy.$('.selected'));
      } /* else if (cy.$('.supAct').length) {
         removeSup(st);
        }*/
      break;

    case KEYS.D:
      if (cy.$('.selected').length) {
        cy.$('.selected').toggleClass('moving');
        gui.moving_dependency = !gui.moving_dependency;
      }
      break;

    case KEYS.M:
      if (cy.$('node.form.merge').length) {

        cy.$('node.form.activated').removeClass('activated');

        cy.$('node.form.merge').addClass('activated').removeClass('merge');
      } else if (cy.$('node.form.activated').length) {

        cy.$('node.form.activated').removeClass('activated').addClass('merge');
      }

      break;

    case KEYS.P:
      /* if (text not focused)
        setPunct();*/
      break;

    case KEYS.R:
      if (cy.$('node.form.activated')) graph.setRoot(cy.$('node.form.activated'));
      break;

    case KEYS.S:
      // wf.addClass('supertoken');
      // wf.removeClass('activated');
      break;

    case KEYS.LEFT:

      // avoid panning the window
      if (event.preventDefault) event.preventDefault();

      if (cy.$('node.form.merge').length) mergeNodes('left');
      break;

    case KEYS.RIGHT:

      // avoid panning the window
      if (event.preventDefault) event.preventDefault();

      if (cy.$('node.form.merge').length) {
        mergeNodes('right');
      } /*else if (cy.$('.supertoken')) {
        // mergeNodes(toMerge, KEYS.SIDES[key.which], 'subtoken');
        // mergeNodes(toSup, KEYS.SIDES[key.which], 'supertoken');
        }*/
      break;

    case KEYS.EQUALS:
    case KEYS.EQUALS_:
      if (event.shiftKey) {
        gui.zoomIn();
      } else {
        cy.fit().center();
      }
      break;

    case KEYS.MINUS:
    case KEYS.MINUS_:
      if (event.shiftKey) {
        gui.zoomOut();
      } else {
        cy.fit().center();
      }
      break;

    case KEYS.ENTER:
      gui.intercepted = false;
      graph.clear();
      break;

  }
}
function onCtrlKeyup(event) {
  log.debug('called onCtrlKeyup(which:' + event.which + ', pressed:' + JSON.stringify(pressed) + ')');

  // handle Ctrl + <keypress>
  // solution based on https://stackoverflow.com/a/12444641/5181692
  pressed[event.which] = event.type == 'keyup';
  log.info('ctrl: ' + pressed[KEYS.CTRL] + ', shift: ' + pressed[KEYS.CTRL] + ', y: ' + pressed[KEYS.Y] + ', z: ' + pressed[KEYS.Z] + ', this: ' + event.which);

  if (!pressed[KEYS.CTRL]) return false;

  if (pressed[KEYS.PAGE_DOWN]) {
    var _pressed;

    if (pressed[KEYS.SHIFT]) {
      manager.last();
    } else {
      manager.next();
    }
    pressed = (_pressed = {}, _defineProperty(_pressed, KEYS.CTRL, true), _defineProperty(_pressed, KEYS.SHIFT, pressed[KEYS.SHIFT]), _pressed);
    return true;
  } else if (pressed[KEYS.PAGE_UP]) {
    var _pressed2;

    if (pressed[KEYS.SHIFT]) {
      manager.first();
    } else {
      manager.prev();
    }
    pressed = (_pressed2 = {}, _defineProperty(_pressed2, KEYS.CTRL, true), _defineProperty(_pressed2, KEYS.SHIFT, pressed[KEYS.SHIFT]), _pressed2);
    return true;
  } else if (pressed[KEYS.Z] && !pressed[KEYS.SHIFT]) {
    undoManager.undo();
    pressed = _defineProperty({}, KEYS.CTRL, true);
    return true;
  } else if (pressed[KEYS.Y] || pressed[KEYS.Z]) {
    var _pressed4;

    undoManager.redo();
    pressed = (_pressed4 = {}, _defineProperty(_pressed4, KEYS.CTRL, true), _defineProperty(_pressed4, KEYS.SHIFT, pressed[KEYS.SHIFT]), _pressed4);
    setTimeout(function () {
      // catch only events w/in next 500 msecs
      pressed[KEYS.SHIFT] = false;
    }, 500);
    return true;
  } else if (47 < event.which && event.which < 58) {
    // key in 0-9

    if ($(':focus').is('input')) return false;

    var num = event.which - 48;
    cy.zoom(Math.pow(1.5, num - 5));
    gui.update();
    return true;
  } else {
    log.error('onCtrlKeyup(): uncaught key combination');
  }

  return false;
}
function onKeyupInCurrentSentence(event) {
  log.debug('called onKeyupInCurrentSentence(' + event.which + ')');

  switch (event.which) {
    case KEYS.ENTER:
      manager.index = parseInt($('current-sentence').val()) - 1;
      break;
    case KEYS.LEFT:
    case KEYS.J:
      manager.prev();
      break;
    case KEYS.RIGHT:
    case KEYS.K:
      manager.next();
      break;
    case KEYS.MINUS:
      manager.removeSentence();
      break;
    case KEYS.EQUALS:
      manager.insertSentence();
      break;
  }
}
function onKeyupInEditLabel(event) {
  log.debug('called onKeyupInEditLabel(' + event.which + ')');

  switch (event.which) {
    case KEYS.ENTER:
      graph.clear();
      break;
    case KEYS.TAB:
      console.log('what should happen here???');
      break;
    case KEYS.ESC:
      gui.editing = null;
      graph.clear();
      break;
  }
}
function onEditTextData(event) {
  log.debug('called onEditTextData(key: ' + event.which + ', parseTimer: ' + gui.parseTimer + ')');

  switch (event.which) {
    case KEYS.ESC:
      this.blur();
      break;

    case KEYS.ENTER:
      onEnter(event);
      break;

    default:
      // wait a full second before parsing (this prevents immediate trimming
      //   of whitespace and other annoying side effects), and avoid redundant
      //   parsing if we edit again w/in that 1-sec window
      clearTimeout(gui.parseTimer);
      if (!$('#text-data').hasClass('readonly')) gui.parseTimer = setTimeout(function () {
        manager.parse($('#text-data').val());
      }, 1000);
  }
}
function onEnter(event) {
  log.debug('called onEnter()');

  var sentence = $('#text-data').val(),
      cursor = $('#text-data').prop('selectionStart') - 1,
      lines = sentence.split(/\n/),
      lineId = null,
      before = void 0,
      during = void 0,
      after = void 0,
      cursorLine = 0;

  if (gui.is_table_view) {

    var target = $(event.target);
    cursor = parseInt(target.attr('row-id')) || parseInt(target.attr('col-id'));
    cursorLine = target.attr('row-id');
  } else {

    if (manager.format === 'Unknown' || manager.format === 'plain text') return;

    // get current line number
    var acc = 0;
    $.each(lines, function (i, line) {
      acc += line.length;
      if (acc + i < cursor) cursorLine = i + 1;
    });
    log.debug('onEnter(): cursor on line[' + cursorLine + ']: "' + lines[cursorLine] + '"');

    // advance the cursor until we are at the end of a line that isn't followed by a comment
    //   or at the very beginning of the textarea
    if (cursor !== 0 || sentence.startsWith('#')) {
      log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '" (not at textarea start OR textarea has comments)');
      while (sentence[cursor + 1] === '#' || sentence[cursor] !== '\n') {
        log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '", line[' + cursorLine + ']: ' + lines[cursorLine]);
        if (cursor === sentence.length) break;
        if (sentence[cursor] === '\n') cursorLine++;
        cursor++;
      }
    } else {
      log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '" (at textarea start)');
      cursorLine = -1;
    }
  }

  log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '", line[' + cursorLine + ']: ' + lines[cursorLine]);

  if (event.preventDefault) // bc of testing, sometimes these are fake events
    event.preventDefault();

  switch (manager.format) {
    case 'CoNLL-U':

      if (cursor) {
        var tabs = lines[cursorLine].split('\t');
        var token = manager.current.getById(tabs[0]).token;
        manager.current.insertTokenAfter(token);
      } else {
        var _token = manager.current[0].token;
        manager.current.insertTokenBefore(_token);
      }

      // parse but persist the table settings
      var is_table_view = manager.current.is_table_view;
      var column_visibilities = manager.current.column_visibilities;
      manager.parse(manager.conllu);
      manager.current.is_table_view = is_table_view;
      manager.current.column_visibilities = column_visibilities;

      break;

    case 'CG3':

      throw new errors.NotImplementedError('can\'t onEnter with CG3 :/');
      /*
      // advance to the end of an analysis
      log.debug(`onEnter(): line[${cursorLine}]: "${lines[cursorLine]}", cursor[${cursor}]: "${sentence[cursor]}"`);
      while (cursorLine < lines.length - 1) {
          if (lines[cursorLine + 1].startsWith('"<'))
              break;
          cursorLine++;
          cursor += lines[cursorLine].length + 1;
          log.debug(`onEnter(): incrementing line[${cursorLine}]: "${lines[cursorLine]}", cursor[${cursor}]: "${sentence[cursor]}"`);
      }
       lineId = lines.slice(0, cursorLine + 1).reduce((acc, line) => {
          return acc + line.startsWith('"<');
      }, 0) + 1;
      log.debug(`onEnter(): inserting line with id: ${lineId}`);
      log.debug(`onEnter(): resetting all content lines: [${lines}]`);
       const incrementIndices = (lines, lineId) => {
        return lines.map((line) => {
          if (line.startsWith('#'))
            return line;
          (line.match(/[#>][0-9]+/g) || []).map((match) => {
            let id = parseInt(match.slice(1));
            id += (id >= lineId ? 1 : 0);
            line = line.replace(match, `${match.slice(0,1)}${id}`)
          });
          return line;
        });
      }
      before = incrementIndices(lines.slice(0, cursorLine + 1), lineId);
      during = [`"<_>"`, `\t${getCG3Analysis(lineId, {id:lineId})}`];
      after = incrementIndices(lines.slice(cursorLine + 1), lineId);
       log.debug(`onEnter(): preceding line(s) : [${before}]`);
      log.debug(`onEnter(): interceding lines : [${during}]`);
      log.debug(`onEnter(): proceeding line(s): [${after}]`);
       $('#text-data').val(before.concat(during, after).join('\n'))
        .prop('selectionStart', cursor)
        .prop('selectionEnd', cursor);*/

      break;

    default:
      insertSentence();
  }

  gui.update();
}

function mergeNodes(direction) {

  // the highlighted one is the "major" token
  var major = cy.$('node.form.merge').data().analysis;

  // find the "minor" token by moving either one clump to the left or right
  var minorClump = major.clump + (direction === 'left' && gui.is_ltr || direction === 'right' && !gui.is_ltr ? -1 : 1);

  // iterate tokens until we find a matching candidate
  var minor = null;
  major.sentence.forEach(function (token) {
    if (token.analysis.clump === minorClump) minor = token.analysis;
  });

  // do the merge
  if (major && minor) major.token.mergeWith(minor.token);

  // clean up
  cy.$('node.form.merge').removeClass('merge');
  gui.update();
}

module.exports = GUI;

},{"./dropdown-menu":6,"./errors":7,"./funcs":9,"./local-storage":14,"./modals/index":16,"./table":25,"./undo-manager":33,"jquery":394,"underscore":499}],12:[function(require,module,exports){
'use strict';

require('babel-polyfill');

var Log = require('./browser-logger');
var Manager = require('./manager');
var Server = require('./server');

var funcs = require('./funcs');

// on ready
$(function () {

	funcs.global().log = new Log();
	funcs.global().server = new Server();
	funcs.global().manager = new Manager();
});

module.exports = require('./test/data/index');

},{"./browser-logger":1,"./funcs":9,"./manager":15,"./server":21,"./test/data/index":29,"babel-polyfill":39}],13:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');
var $ = require('jquery');
var DeserializationError = require('./errors').DeserializationError;
var nx = require('notatrix');

var regex = {
  labelComment: /(labels|tags)\s*=\s+(.*)$/,
  labelContent: /([\w-:]+)/,
  labelByName: function labelByName(name) {
    return new RegExp('(\\s+)' + name + '(\\s+|$)');
  }
};

// NOTE: 16777215 (base 10) = ffffff (base 16)
var magic = 16777215;
var ENTER = 13;

var Label = function () {
  function Label(name) {
    _classCallCheck(this, Label);

    name = name || 'default';

    this.name = name;
    this.bColor = hashStringToHex(name);
    this.tColor = getTextColor(this.bColor);
    this.desc = '';
  }

  _createClass(Label, [{
    key: 'changeColor',
    value: function changeColor(color) {

      if (color) {
        color = (color.match(/^#?([a-f\d]{6})/i) || [])[1];
        var int = parseInt(color, 16);
        if (isNaN(int) || int < 0 || int > magic) return false; // out of bounds

        color = '#' + color;
      } else {
        color = getRandomHexColor();
      }

      this.bColor = color;
      this.tColor = getTextColor(color);

      return true;
    }
  }, {
    key: 'render',
    value: function render(labeler) {

      var inComments = labeler.has(this.name),
          filtering = labeler._filter.has(this.name);

      $('#labels-horiz').append($('<li>').attr('name', this.name).addClass('label horiz').addClass(inComments ? 'in-comments' : 'not-in-comments').addClass(filtering ? 'filtering' : 'not-filtering').append($('<div>').addClass('label-text').text(this.name).css('background-color', this.bColor).css('color', this.tColor).click(function (e) {
        return labeler.handle.click.label(e);
      })).append($('<div>').addClass('label-hidden').append($('<div>').addClass('label-hidden-group').append($('<div>').addClass('label-hidden-item').append($('<strong>').text('Name')).append($('<input>').attr('name', 'label-name').val(this.name).keyup(function (e) {
        return labeler.handle.keyup.name(e);
      }))).append($('<div>').addClass('label-hidden-item').append($('<strong>').text('Description')).append($('<input>').attr('name', 'label-desc').val(this.desc).keyup(function (e) {
        return labeler.handle.keyup.desc(e);
      }))).append($('<div>').addClass('label-hidden-item').append($('<strong>').text('Color')).append($('<div>').addClass('label-hidden-item-inner').append($('<span>').addClass('hex-color-group').text('#').append($('<input>').attr('name', 'label-color').attr('pattern', '[A-Fa-f\\d]{6}').val(this.bColor.substr(1)).keyup(function (e) {
        return labeler.handle.keyup.color(e);
      }))).append($('<button>').attr('type', 'button').addClass('btn btn-secondary refresh-color').css('background-color', this.bColor).click(function (e) {
        return labeler.handle.click.refresh(e);
      }).append($('<i>').addClass('fa fa-refresh')))))).append($('<hr>')).append($('<div>').addClass('label-hidden-group').append($('<div>').addClass('label-hidden-item').append($('<div>').addClass('label-hidden-item-inner').append($('<input>').attr('name', 'filtering').attr('type', 'checkbox').prop('checked', filtering).click(function (e) {
        return labeler.handle.click.checkbox.filtering(e);
      })).append($('<span>').addClass('filtering-label checkbox-label').text('filtering'))))).append($('<hr>')).append($('<div>').addClass('label-hidden-group').append($('<div>').addClass('label-hidden-item delete-item').append($('<button>').attr('type', 'button').addClass('btn btn-secondary delete-button').text('delete').click(function (e) {
        return labeler.handle.click.delete(e);
      }))))));
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        name: this.name,
        desc: this.desc,
        bColor: this.bColor,
        tColor: this.tColor
      };
    },
    set: function set(state) {
      if (!state.name) throw new DeserializationError('cannot set name to "' + state.name + '"');

      state.desc = state.desc || '';
      if (typeof state.desc !== 'string') throw new DeserializationError('cannot set description to non-string value');

      this.name = state.name;
      this.desc = state.desc;

      if (!this.changeColor(state.bColor)) throw new DeserializationError('cannot set background color to "' + state.bColor + '"');
    }
  }]);

  return Label;
}();

var Labeler = function () {
  function Labeler() {
    var _this = this;

    _classCallCheck(this, Labeler);

    this._labels = [];
    this._filter = new Set();

    // don't want the "jQuery needs a window" errors during testing
    if (!gui || !gui.inBrowser) return this;

    $('#label-input').keyup(function (e) {
      if (e.which === ENTER) _this.handle.enter(e);
    });

    this.handle = {
      enter: function enter(event) {
        var names = $('#label-input').val().trim();
        _.each(names.split(/\s+/), function (name) {

          var added = false;
          if (name) added = _this.add(name);

          if (added) _this.addInComments(name); // add to the comments
        });

        $('#label-input').val('');
        gui.update();
      },

      click: {
        label: function label(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name');

          if (_this.has(name)) {
            _this.removeInComments(name);
          } else {
            _this.addInComments(name);
          }

          manager.updateFilter();
          gui.update();
          flashDropdown(name);
        },

        refresh: function refresh(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              label = _this.get(name);

          label.changeColor();
          gui.update();
          flashDropdown(name);
        },

        checkbox: {
          filtering: function filtering(event) {
            var target = $(event.target),
                name = target.closest('li').attr('name');

            _this.toggleFilter(name);
            manager.updateFilter();
            gui.update();
            flashDropdown(name);
          }
        },

        delete: function _delete(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name');

          var response = confirm('Are you sure you want to delete the label "' + name + '" from all sentences?');
          if (!response) return;

          _this.remove(name);
          gui.update();
        }
      },

      keyup: {
        name: function name(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              value = target.val();

          if (event.which === ENTER) {

            if (_this.has(value)) {
              // TODO: alert
              return; // don't want multiple things with the same name
            }

            if (!regex.labelContent.test(value)) {
              // TODO: alert
              return; // must match our content pattern
            }

            _this.edit(name, { name: value });
            _this.editInComments(name, value);
            gui.update();
            flashDropdown(value, 'label-name');
          }
        },

        desc: function desc(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              value = target.val();

          if (event.which === ENTER) {
            _this.edit(name, { desc: value });
            gui.update();
            flashDropdown(name, 'label-desc');
          }
        },

        color: function color(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              value = target.val();

          if (event.which === ENTER) {
            _this.edit(name, { color: value });
            gui.update();
            flashDropdown(name, 'label-color');
          }
        }
      }
    };
  }

  _createClass(Labeler, [{
    key: 'parse',
    value: function parse(comments) {
      var _this2 = this;

      _.each(Labeler.parseComments(comments), function (label) {
        if (label) _this2.add(label);
      });

      return this; // chaining
    }
  }, {
    key: 'has',
    value: function has(index, name) {

      if (name === undefined) {
        name = index;
        index = manager.index;
      }

      var comments = manager.getSentence(index).comments;

      var has = false;
      _.each(comments, function (comment) {
        _.each(Labeler.parseComment(comment), function (label) {
          if (name === label) has = true;
        });
      });

      return has;
    }
  }, {
    key: 'get',
    value: function get(name) {

      var ret = null;
      if (name && typeof name === 'string') _.each(this._labels, function (label) {
        if (label.name === name) ret = label;
      });

      return ret;
    }
  }, {
    key: 'add',
    value: function add(name) {
      var found = false;
      _.each(this._labels, function (label) {
        if (label.name === name) found = true;
      });

      if (!found) this._labels.push(new Label(name));

      return !found; // so we know if success or not
    }
  }, {
    key: 'remove',
    value: function remove(name) {
      this._labels = this._labels.filter(function (label) {
        if (label.name !== name) return label;
      });
      for (var i = 0; i < manager.length; i++) {
        this.removeInComments(i, name);
      }
    }
  }, {
    key: 'edit',
    value: function edit(name, values) {
      var label = this.get(name);
      if (!label) return null;

      if (values.name) {
        for (var i = 0; i < manager.length; i++) {
          this.editInComments(i, label.name, values.name);
        }
        label.name = values.name;
      }

      if (values.desc || values.desc === '') label.desc = values.desc;

      if (values.color) label.changeColor(values.color.startsWith('#') ? values.color : '#' + values.color);
    }
  }, {
    key: 'update',
    value: function update() {
      var _this3 = this;

      if (!gui || !gui.inBrowser) return;

      $('#label-clear-filter .label-text').addClass('disabled');
      if (this._filter.size) $('#label-clear-filter .label-text').removeClass('disabled');

      $('.label.horiz').detach();
      _.each(this._labels, function (label) {
        return label.render(_this3);
      });
    }
  }, {
    key: 'addInComments',
    value: function addInComments(index, name) {

      if (name === undefined) {
        name = index;
        index = manager.index;
      }

      var done = false;
      manager.getSentence(index).comments = manager.getSentence(index).comments.map(function (comment) {

        if (comment.body.match(regex.labelComment) && !done) {
          comment.body = comment.body + ' ' + name;
          done = true;
        }

        return comment;
      });

      if (!done) manager.getSentence(index).push(new nx.Comment('labels = ' + name));
    }
  }, {
    key: 'removeInComments',
    value: function removeInComments(index, name) {

      if (name === undefined) {
        name = index;
        index = manager.index;
      }

      manager.getSentence(index).comments = manager.getSentence(index).comments.map(function (comment) {
        comment.body = comment.body.replace(regex.labelByName(name), '$1');
        return comment;
      });
    }
  }, {
    key: 'editInComments',
    value: function editInComments(index, oldName, newName) {

      if (newName === undefined) {
        newName = oldName;
        oldName = index;
        index = manager.index;
      }

      manager.getSentence(index).comments = manager.getSentence(index).comments.map(function (comment) {
        comment.body = comment.body.replace(regex.labelByName(name), '$1');
        return comment;
      });
    }
  }, {
    key: 'addFilter',
    value: function addFilter(name) {
      var _this4 = this;

      // make sure it's a valid name
      manager.map(function (i) {
        if (_this4.has(i, name)) _this4._filter.add(name);
      });

      return this; // chaining
    }
  }, {
    key: 'filter',
    value: function filter(name) {
      return this.addFilter(name); // alias
    }
  }, {
    key: 'removeFilter',
    value: function removeFilter(name) {
      this._filter.delete(name);
      return this;
    }
  }, {
    key: 'unfilter',
    value: function unfilter(name) {
      return this.removeFilter(name); // alias
    }
  }, {
    key: 'clearFilter',
    value: function clearFilter() {
      var _this5 = this;

      this._filter.forEach(function (name) {
        return _this5.removeFilter(name);
      });
      return this;
    }
  }, {
    key: 'toggleFilter',
    value: function toggleFilter(name) {

      if (this._filter.has(name)) {
        this.removeFilter(name);
      } else {
        this.addFilter(name);
      }

      return this;
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        labels: this._labels.map(function (label) {
          return label.state;
        }),
        filter: Array.from(this._filter)
      };
    },
    set: function set(state) {
      var _this6 = this;

      this._labels = state.labels.map(function (labelState) {
        var label = new Label();
        label.state = labelState;
        return label;
      });

      this._filter = new Set();
      _.each(state.filter, function (name) {
        _this6.addFilter(name);
      });
    }
  }], [{
    key: 'parseComment',
    value: function parseComment(comment) {
      var labels = [];
      var labelString = comment.body.match(regex.labelComment);

      if (labelString) labelString[2].split(/\s/).forEach(function (label) {

        var content = label.match(regex.labelContent);
        if (content) labels.push(content[1]);
      });

      return labels;
    }
  }, {
    key: 'parseComments',
    value: function parseComments(comments) {
      return _.reduce(comments, function (l, comment) {
        return l.concat(Labeler.parseComment(comment));
      }, []);
    }
  }]);

  return Labeler;
}();

function flashDropdown(name, inputName) {
  var dropdown = $('li[name="' + name + '"] .label-hidden');

  // show dropdown part immediately
  dropdown.css('display', 'flex');

  // wait 0.5 secs to return to standard dropdown behavior
  setTimeout(function () {
    return dropdown.css('display', '');
  }, 500);

  if (inputName) {
    dropdown.find('input[name="' + inputName + '"]').focus();
  }
}

function hashStringToHex(string) {
  var hash = 0;
  for (var i = 0; i < string.length; i++) {
    hash = string.charCodeAt(i) + ((hash << 5) - hash);
  }

  var hex = '#';
  for (var _i = 0; _i < 3; _i++) {
    var value = hash >> _i * 8 & 0xFF;
    hex += ('00' + value.toString(16)).substr(-2);
  }
  return hex;
}

function getRandomHexColor() {

  var color = '';
  do {
    color = '#' + Math.floor(Math.random() * magic).toString(16);
  } while (color.length !== 7);

  return color;
}

function hexToRGB(hex) {
  var match = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);

  if (match) return [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16)];
}

function getTextColor(background) {

  var color = '#ffffff';

  var rgb = hexToRGB(background);
  if (!rgb) return color;

  var _rgb = _slicedToArray(rgb, 3),
      r = _rgb[0],
      g = _rgb[1],
      b = _rgb[2];

  if (Math.pow(r, 2) + Math.pow(g, 2) + Math.pow(b, 2) > Math.pow(255 - r, 2) + Math.pow(255 - g, 2) + Math.pow(255 - b, 2)) color = '#000000';

  return color;
}

module.exports = Labeler;

},{"./errors":7,"jquery":394,"notatrix":461,"underscore":499}],14:[function(require,module,exports){
'use strict';

var KEY = require('./config').localStorageKey;
var getTreebankId = require('./funcs').getTreebankId;

function isAvailable() {

  try {
    localStorage;
  } catch (e) {
    return false;
  }

  /* Taken from https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API */

  try {
    var x = '__storage_test__';

    localStorage.setItem(x, x);
    localStorage.removeItem(x);
    return true;
  } catch (e) {

    return e instanceof DOMException && (e.code === 1014 // Firefox
    || e.code === 22 // everything else

    // test name field too, because code might not be present
    || e.name === 'NS_ERROR_DOM_QUOTA_REACHED' // Firefox
    || e.name === 'QuotaExceededError') // everything else

    // acknowledge QuotaExceededError only if there's something already stored
    && localStorage.length !== 0;
  }
}

function getAvailableSpace() {

  /* Returns the remaining available space in localStorage */
  if (!isAvailable()) return 0;

  var max = 10 * 1024 * 1024,
      testKey = 'size-test-' + Math.random().toString(); // generate random key
  var i = 64,
      string1024 = '',
      string = '',
      found = 0;

  if (localStorage) {

    error = error || 25e4;

    // fill a string with 1024 symbols/bytes
    while (i--) {
      string1024 += 1e16;
    } // fill a string with "max" amount of symbols/bytes
    i = max / 1024;
    while (i--) {
      string += string1024;
    }i = max;

    // binary search
    while (i > 1) {
      try {
        localStorage.setItem(testKey, string.substr(0, i));
        localStorage.removeItem(testKey);

        if (found < i - error) {
          found = i;
          i *= 1.5;
        } else {
          break;
        }
      } catch (e) {
        localStorage.removeItem(testKey);
        i = found + (i - found) / 2;
      }
    }
  }

  return found;
}

function isQuotaExceeded(event) {

  if (event && event.code === 22) {
    return true;
  } else if (event && event.code === 1014) {
    return event.name === 'NS_ERROR_DOM_QUOTA_REACHED';
  } else if (event) {
    return event.number === -2147024882; // IE8
  }

  return false;
}

function formatUploadSize(fileSize) {

  if (fileSize < 1024) return fileSize + ' B';

  if (fileSize < 1048576) return (fileSize / 1024).toFixed(1) + ' kB';

  return (fileSize / 1048576).toFixed(1) + ' mB';
}

function save(value) {

  if (!isAvailable()) return null;

  return localStorage.setItem(getTreebankId() || KEY, value);
}

function load() {

  if (!isAvailable()) return null;

  return localStorage.getItem(getTreebankId() || KEY);
}

function clear() {

  if (!isAvailable()) return null;

  return localStorage.removeItem(getTreebankId() || KEY);
}

module.exports = {
  isAvailable: isAvailable,
  //isQuotaExceeded,
  //getAvailableSpace,
  //formatUploadSize,
  save: save,
  load: load,
  clear: clear
};

},{"./config":3,"./funcs":9}],15:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var _ = require('underscore');
var nx = require('notatrix');

var cfg = require('./config');
var funcs = require('./funcs');
var GUI = require('./gui');
var Graph = require('./graph');
var Labeler = require('./labels');
var errors = require('./errors');
var storage = require('./local-storage');
var export_ = require('./export');
var status = require('./status');
var Sentence = require('./sentence');
var Users = require('./users');
var Socket = require('./socket');

var Manager = function () {
  function Manager() {
    var _this = this;

    _classCallCheck(this, Manager);

    funcs.global().manager = this;
    funcs.global().gui = new GUI();
    funcs.global().graph = new Graph();
    funcs.global().labeler = new Labeler();
    if (gui.inBrowser) this.socket = Socket(this);
    this.users = new Users();
    gui.bind();

    this.reset();
    this.load();

    this.export = export_;

    // save once every ? msecs
    setInterval(function () {
      return _this.save();
    }, cfg.saveInterval);
  }

  _createClass(Manager, [{
    key: 'reset',
    value: function reset() {
      this.filename = cfg.defaultFilename;

      this._sentences = [];
      this._index = -1;

      this._filtered = [];
      this._filterIndex = null;
    }
  }, {
    key: 'map',
    value: function map(callback) {
      return this._sentences.map(function (sentence, i) {
        return callback(i, sentence);
      });
    }
  }, {
    key: 'updateFilter',
    value: function updateFilter() {
      var _this2 = this;

      this._filtered = [];
      this._filterIndex = -1;
      this.map(function (i) {
        labeler._filter.forEach(function (name) {

          // ones that have this label
          if (labeler.has(i, name) && _this2._filtered.indexOf(i) === -1) {

            // save to array
            _this2._filtered.push(i);

            // keep counting up for the _filterIndex
            if (i <= _this2.index) _this2._filterIndex++;
          }
        });
      });

      if (this._filterIndex < 0) this._filterIndex = null;

      // if we filter out our current sentence
      if (this._filtered.length && this._filtered.indexOf(this._index) === -1) this.index = 0;

      return this;
    }
  }, {
    key: 'first',
    value: function first() {

      this.updateFilter();

      this.index = this.length ? 0 : -1;
      return this;
    }
  }, {
    key: 'prev',
    value: function prev() {

      if (!this.length) return null;

      this.updateFilter();

      var index = this._filtered.length ? this._filterIndex : this._index;

      if (index === 0) {
        log.warn('Annotatrix: already at the first sentence!');
        return null;
      }

      this.index = --index;
      return this;
    }
  }, {
    key: 'next',
    value: function next() {

      if (!this.length) return null;

      this.updateFilter();

      var index = this._filtered.length ? this._filterIndex : this._index;
      var total = this._filtered.length ? this._filtered.length - 1 : this._length - 1;

      if (index === total) {
        log.warn('Annotatrix: already at the last sentence!');
        return null;
      }

      this.index = ++index;
      return this;
    }
  }, {
    key: 'last',
    value: function last() {

      this.updateFilter();

      this.index = this._filtered.length ? this._filtered.length - 1 : this.length - 1;
      return this;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.current ? this.current.toString() : null;
    }
  }, {
    key: 'setSentence',
    value: function setSentence(index, text) {

      if (text === null || text === undefined) {
        // if only passed 1 arg
        text = index || '';
        index = this.index;
      }

      if (0 > index || index > this.length - 1) return null;

      this._sentences[index].update(text);

      var sent = this._sentences[index];
      this.emit('update', {
        type: 'modify',
        index: index,
        format: sent.format,
        nx: sent.nx
      });
      gui.update();

      return this.getSentence(index);
    }
  }, {
    key: 'getSentence',
    value: function getSentence(index) {

      if (index === undefined) index = this.index;

      if (0 > index || index > this.length - 1) return null;

      return this._sentences[index];
    }
  }, {
    key: 'insertSentence',
    value: function insertSentence(index, text) {

      if (text === null || text === undefined) {
        // if only passed 1 arg
        text = index || cfg.defaultInsertedSentence;
        index = this.index + 1;
      }

      index = parseFloat(index);
      if (isNaN(index)) throw new errors.AnnotatrixError('cannot insert at NaN');

      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);

      var sent = new Sentence(text);
      this._sentences = this._sentences.slice(0, index).concat(sent).concat(this._sentences.slice(index));

      this.emit('update', {
        type: 'insert',
        index: index,
        format: sent.format,
        nx: sent.nx
      });

      this.index = index;
      gui.update();

      return sent.text;
    }
  }, {
    key: 'removeSentence',
    value: function removeSentence(index) {

      if (!this.length) return null;

      if (index === undefined) // if not passed args
        index = this.index;

      index = parseFloat(index);
      if (isNaN(index)) throw new errors.AnnotatrixError('cannot insert at NaN');

      index = index < 0 ? 0 : index > this.length - 1 ? this.length - 1 : parseInt(index);

      var removed = this._sentences.splice(index, 1)[0];
      if (!this.length) this.insertSentence();
      this.index--;

      this.emit('update', {
        type: 'remove',
        index: index,
        format: removed.format,
        nx: null
      });
      gui.update();

      return removed;
    }
  }, {
    key: 'pushSentence',
    value: function pushSentence(text) {
      return this.insertSentence(Infinity, text);
    }
  }, {
    key: 'popSentence',
    value: function popSentence(text) {
      return this.removeSentence(Infinity);
    }
  }, {
    key: 'parse',
    value: function parse(text) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


      var index = options.index || this.index;
      var splitted = nx.split(text, options); //.map(transform);

      // set the first one at the current index
      this.setSentence(index, splitted[0]);

      // iterate over all elements except the first
      _.each(splitted, function (split, i) {
        if (i) _this3.insertSentence(index + i, split);
      });
      gui.update();
      return this; // chaining
    }
  }, {
    key: 'save',
    value: function save() {

      status.normal('saving...');

      var state = JSON.stringify(this.state);

      storage.save(state);
      if (server && server.is_running) server.save(state);

      return state;
    }
  }, {
    key: 'load',
    value: function load(state) {

      state = state || (server && server.is_running ? server.load() : storage.load());

      if (!state) {
        // unable to load
        if (!this.current) this.insertSentence(cfg.defaultSentence);

        return null;
      }

      // parse it back from a string
      if (typeof state === 'string') state = JSON.parse(state);

      this.state = state;

      return state;
    }
  }, {
    key: 'emit',
    value: function emit(eventName, data) {
      //console.log('try emitting', eventName, data)
      if (this.socket && this.socket.initialized && this.socket.isOpen) this.socket.emit(eventName, data);
    }
  }, {
    key: 'download',
    value: function download() {
      funcs.download(this.filename + '.corpus', 'text/plain', this.corpus);
    }
  }, {
    key: 'length',
    get: function get() {
      return this._sentences.length;
    }
  }, {
    key: 'totalSentences',
    get: function get() {
      return this._filtered.length ? this._filtered.length + ' (total: ' + this.length + ')' : '' + this.length;
    }
  }, {
    key: 'currentSentence',
    get: function get() {
      return this.index + 1;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {

      var total = this._filtered.length || this.length;

      index = parseInt(index);
      if (isNaN(index)) {
        log.warn('Annotatrix: index out of range: ' + index);
        index = this._filterIndex || this.index;
      } else if (index < 0 && total) {
        log.warn('Annotatrix: index out of range: ' + (index + 1));
        index = 0;
      } else if (index > total - 1) {
        log.warn('Annotatrix: index out of range: ' + (index + 1));
        index = total - 1;
      }

      if (this._filtered.length) {
        this._filterIndex = index;
        this._index = this._filtered[index];
      } else {
        this._filterIndex = null;
        this._index = index;
      }

      gui.update();
      this.emit('pan', { index: this.index });
      return this.index;
    }
  }, {
    key: 'current',
    get: function get() {
      return this._sentences[this.index];
    },
    set: function set(sent) {
      if (sent instanceof Sentence) this._sentences[this.index] = sent;
    }
  }, {
    key: 'sentence',
    set: function set(text) {
      return this.setSentence(text);
    }
  }, {
    key: 'format',
    get: function get() {
      if (this.current) return this.current.format;
    }
  }, {
    key: 'conllu',
    get: function get() {
      throw new Error('old method');
      if (this.current) return this.current._nx.to('CoNLL-U');
    }
  }, {
    key: 'cg3',
    get: function get() {
      throw new Error('old method');
      if (this.current) return this.current._nx.to('CG3');
    }
  }, {
    key: 'graphable',
    get: function get() {
      return this.format === 'CoNLL-U' || this.format === 'CG3';
    }
  }, {
    key: 'corpus',
    get: function get() {
      var _this4 = this;

      var fileHeader = cfg.downloadHasFileHeader ? '# __ud_annotatrix_filename__ = "' + this.filename + '"\n# __ud_annotatrix_timestamp__ = "' + new Date() + '"\n# __ud_annotatrix_version__ = "' + cfg.version + '"\n' : '';

      var sentences = this.map(function (i, sent) {
        var sentenceHeader = cfg.downloadHasSentenceHeader ? '# __ud_annotatrix_id__ = "' + (i + 1) + '"\n# __ud_annotatrix_format__ = "' + _this4.format + '"\n' : '';
        var content = _this4.format === 'Unknown' ? '' : _this4.sentence;

        return '' + sentenceHeader + content;
      }).join('\n\n');

      return '' + fileHeader + sentences;
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        meta: {
          current_index: this.index,
          owner: this.users.owner,
          github_url: this.users.github_url,
          gui: gui.state,
          labeler: labeler.state,
          permissions: this.users.permissions,
          editors: this.users.editors
        },
        sentences: this.map(function (i, sent) {
          return sent.state;
        })
      };
    },
    set: function set(state) {

      console.info('LOADING STATE', state);
      this._index = state.meta.current_index;
      this._sentences = state.sentences.map(function (state) {

        var sent = new Sentence();
        sent.state = state;
        return sent;
      });
      if (!this.current) this.insertSentence(cfg.defaultSentence);

      // update users stuff
      this.users.state = _.pick(state.meta, ['owner', 'github_url', 'permissions', 'editors']);

      labeler.state = state.meta.labeler;
      this.updateFilter(); // use the filters set in labeler

      // this triggers a gui refresh
      gui.state = state.meta.gui;
    }
  }]);

  return Manager;
}();

module.exports = Manager;

},{"./config":3,"./errors":7,"./export":8,"./funcs":9,"./graph":10,"./gui":11,"./labels":13,"./local-storage":14,"./sentence":20,"./socket":22,"./status":24,"./users":35,"jquery":394,"notatrix":461,"underscore":499}],16:[function(require,module,exports){
'use strict';

module.exports = {
  upload: require('./upload')
};

},{"./upload":17}],17:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var $ = require('jquery');

var modal = $('#upload-modal');

function show() {
  modal.show();
}

function hide() {
  modal.hide();
}

function enable() {
  modal.find('[type="submit"]').prop('disabled', false);
}

modal.find('[name="close"]').click(hide);

module.exports = {
  show: show,
  hide: hide,
  enable: enable
};

},{"jquery":394,"underscore":499}],18:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProgressBar = function () {
  function ProgressBar() {
    _classCallCheck(this, ProgressBar);

    this.element = gui.inBrowser ? $('#progressBar') : null;
  }

  _createClass(ProgressBar, [{
    key: 'update',
    value: function update() {
      if (!manager.current || !this.element) return;

      var percentage = manager.current._nx.progress * 100;
      this.element.css('width', percentage + '%');
    }
  }]);

  return ProgressBar;
}();

module.exports = ProgressBar;

},{}],19:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Note: I had to change the name from [Aa]utocomplete to [Ss]elfcomplete
// in order to get this to work at the same time as JQuery-UI

/**
*  Ajax Selfcomplete for jQuery, version 1.4.4
*  (c) 2017 Tomas Kirda
*
*  Ajax Selfcomplete for jQuery is freely distributable under the terms of an MIT-style license.
*  For details, see the web site: https://github.com/devbridge/jQuery-Selfcomplete
*/

/*jslint  browser: true, white: true, single: true, this: true, multivar: true */
/*global define, window, document, jQuery, exports, require */

// Expose plugin as an AMD module if AMD loader is present:
(function (factory) {
    "use strict";

    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof require === 'function') {
        // Browserify
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function ($) {
    'use strict';

    var utils = function () {
        return {
            escapeRegExChars: function escapeRegExChars(value) {
                return value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
            },
            createNode: function createNode(containerClass) {
                var div = document.createElement('div');
                div.className = containerClass;
                div.style.position = 'absolute';
                div.style.display = 'none';
                return div;
            }
        };
    }(),
        keys = {
        ESC: 27,
        TAB: 9,
        RETURN: 13,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40
    },
        noop = $.noop;

    function Selfcomplete(el, options) {
        var that = this;

        // Shared variables:
        that.element = el;
        that.el = $(el);
        that.suggestions = [];
        that.badQueries = [];
        that.selectedIndex = -1;
        that.currentValue = that.element.value;
        that.timeoutId = null;
        that.cachedResponse = {};
        that.onChangeTimeout = null;
        that.onChange = null;
        that.isLocal = false;
        that.suggestionsContainer = null;
        that.noSuggestionsContainer = null;
        that.options = $.extend({}, Selfcomplete.defaults, options);
        that.classes = {
            selected: 'selfcomplete-selected',
            suggestion: 'selfcomplete-suggestion'
        };
        that.hint = null;
        that.hintValue = '';
        that.selection = null;

        // Initialize and set options:
        that.initialize();
        that.setOptions(options);
    }

    Selfcomplete.utils = utils;

    $.Selfcomplete = Selfcomplete;

    Selfcomplete.defaults = {
        ajaxSettings: {},
        autoSelectFirst: false,
        appendTo: 'body',
        serviceUrl: null,
        lookup: null,
        onSelect: null,
        width: 'auto',
        minChars: 1,
        maxHeight: 300,
        deferRequestBy: 0,
        params: {},
        formatResult: _formatResult,
        formatGroup: _formatGroup,
        delimiter: null,
        zIndex: 9999,
        type: 'GET',
        noCache: false,
        onSearchStart: noop,
        onSearchComplete: noop,
        onSearchError: noop,
        preserveInput: false,
        containerClass: 'selfcomplete-suggestions',
        tabDisabled: false,
        dataType: 'text',
        currentRequest: null,
        triggerSelectOnValidInput: true,
        preventBadQueries: true,
        lookupFilter: _lookupFilter,
        paramName: 'query',
        transformResult: _transformResult,
        showNoSuggestionNotice: false,
        noSuggestionNotice: 'No results',
        orientation: 'bottom',
        forceFixPosition: false
    };

    function _lookupFilter(suggestion, originalQuery, queryLowerCase) {
        return suggestion.value.toLowerCase().startsWith(queryLowerCase) !== false;
    };

    function _transformResult(response) {
        return typeof response === 'string' ? $.parseJSON(response) : response;
    };

    function _formatResult(suggestion, currentValue) {
        // Do not replace anything if the current value is empty
        if (!currentValue) {
            return suggestion.value;
        }

        var pattern = '(' + utils.escapeRegExChars(currentValue) + ')';

        return suggestion.value.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/&lt;(\/?strong)&gt;/g, '<$1>');
    };

    function _formatGroup(suggestion, category) {
        return '<div class="selfcomplete-group">' + category + '</div>';
    };

    Selfcomplete.prototype = {

        initialize: function initialize() {
            var that = this,
                suggestionSelector = '.' + that.classes.suggestion,
                selected = that.classes.selected,
                options = that.options,
                container;

            // Remove selfcomplete attribute to prevent native suggestions:
            that.element.setAttribute('selfcomplete', 'off');

            // html() deals with many types: htmlString or Element or Array or jQuery
            that.noSuggestionsContainer = $('<div class="selfcomplete-no-suggestion"></div>').html(this.options.noSuggestionNotice).get(0);

            that.suggestionsContainer = Selfcomplete.utils.createNode(options.containerClass);

            container = $(that.suggestionsContainer);

            container.appendTo(options.appendTo || 'body');

            // Only set width if it was provided:
            if (options.width !== 'auto') {
                container.css('width', options.width);
            }

            // Listen for mouse over event on suggestions list:
            container.on('mouseover.selfcomplete', suggestionSelector, function () {
                that.activate($(this).data('index'));
            });

            // Deselect active element when mouse leaves suggestions container:
            container.on('mouseout.selfcomplete', function () {
                that.selectedIndex = -1;
                container.children('.' + selected).removeClass(selected);
            });

            // Listen for click event on suggestions list:
            container.on('click.selfcomplete', suggestionSelector, function () {
                that.select($(this).data('index'));
            });

            container.on('click.selfcomplete', function () {
                clearTimeout(that.blurTimeoutId);
            });

            that.fixPositionCapture = function () {
                if (that.visible) {
                    that.fixPosition();
                }
            };

            $(window).on('resize.selfcomplete', that.fixPositionCapture);

            that.el.on('keydown.selfcomplete', function (e) {
                that.onKeyPress(e);
            });
            that.el.on('keyup.selfcomplete', function (e) {
                that.onKeyUp(e);
            });
            that.el.on('blur.selfcomplete', function () {
                that.onBlur();
            });
            that.el.on('focus.selfcomplete', function () {
                that.onFocus();
            });
            that.el.on('change.selfcomplete', function (e) {
                that.onKeyUp(e);
            });
            that.el.on('input.selfcomplete', function (e) {
                that.onKeyUp(e);
            });
        },

        onFocus: function onFocus() {
            var that = this;

            that.fixPosition();

            if (that.el.val().length >= that.options.minChars) {
                that.onValueChange();
            }
        },

        onBlur: function onBlur() {
            var that = this;

            // If user clicked on a suggestion, hide() will
            // be canceled, otherwise close suggestions
            that.blurTimeoutId = setTimeout(function () {
                that.hide();
            }, 200);
        },

        abortAjax: function abortAjax() {
            var that = this;
            if (that.currentRequest) {
                that.currentRequest.abort();
                that.currentRequest = null;
            }
        },

        setOptions: function setOptions(suppliedOptions) {
            var that = this,
                options = $.extend({}, that.options, suppliedOptions);

            that.isLocal = Array.isArray(options.lookup);

            if (that.isLocal) {
                options.lookup = that.verifySuggestionsFormat(options.lookup);
            }

            options.orientation = that.validateOrientation(options.orientation, 'bottom');

            // Adjust height, width and z-index:
            $(that.suggestionsContainer).css({
                'max-height': options.maxHeight + 'px',
                'width': options.width + 'px',
                'z-index': options.zIndex
            });

            this.options = options;
        },

        clearCache: function clearCache() {
            this.cachedResponse = {};
            this.badQueries = [];
        },

        clear: function clear() {
            this.clearCache();
            this.currentValue = '';
            this.suggestions = [];
        },

        disable: function disable() {
            var that = this;
            that.disabled = true;
            clearTimeout(that.onChangeTimeout);
            that.abortAjax();
        },

        enable: function enable() {
            this.disabled = false;
        },

        fixPosition: function fixPosition() {
            // Use only when container has already its content

            var that = this,
                $container = $(that.suggestionsContainer),
                containerParent = $container.parent().get(0);
            // Fix position automatically when appended to body.
            // In other cases force parameter must be given.
            if (containerParent !== document.body && !that.options.forceFixPosition) {
                return;
            }

            // Choose orientation
            var orientation = that.options.orientation,
                containerHeight = $container.outerHeight(),
                height = that.el.outerHeight(),
                offset = that.el.offset(),
                styles = { 'top': offset.top, 'left': offset.left };

            if (orientation === 'auto') {
                var viewPortHeight = $(window).height(),
                    scrollTop = $(window).scrollTop(),
                    topOverflow = -scrollTop + offset.top - containerHeight,
                    bottomOverflow = scrollTop + viewPortHeight - (offset.top + height + containerHeight);

                orientation = Math.max(topOverflow, bottomOverflow) === topOverflow ? 'top' : 'bottom';
            }

            if (orientation === 'top') {
                styles.top += -containerHeight;
            } else {
                styles.top += height;
            }

            // If container is not positioned to body,
            // correct its position using offset parent offset
            if (containerParent !== document.body) {
                var opacity = $container.css('opacity'),
                    parentOffsetDiff;

                if (!that.visible) {
                    $container.css('opacity', 0).show();
                }

                parentOffsetDiff = $container.offsetParent().offset();
                styles.top -= parentOffsetDiff.top;
                styles.left -= parentOffsetDiff.left;

                if (!that.visible) {
                    $container.css('opacity', opacity).hide();
                }
            }

            if (that.options.width === 'auto') {
                styles.width = that.el.outerWidth() + 'px';
            }

            $container.css(styles);
        },

        isCursorAtEnd: function isCursorAtEnd() {
            var that = this,
                valLength = that.el.val().length,
                selectionStart = that.element.selectionStart,
                range;

            if (typeof selectionStart === 'number') {
                return selectionStart === valLength;
            }
            if (document.selection) {
                range = document.selection.createRange();
                range.moveStart('character', -valLength);
                return valLength === range.text.length;
            }
            return true;
        },

        onKeyPress: function onKeyPress(e) {
            var that = this;

            // If suggestions are hidden and user presses arrow down, display suggestions:
            if (!that.disabled && !that.visible && e.which === keys.DOWN && that.currentValue) {
                that.suggest();
                return;
            }

            if (that.disabled || !that.visible) {
                return;
            }

            switch (e.which) {
                case keys.ESC:
                    that.el.val(that.currentValue);
                    that.hide();
                    break;
                case keys.RIGHT:
                    if (that.hint && that.options.onHint && that.isCursorAtEnd()) {
                        that.selectHint();
                        break;
                    }
                    return;
                case keys.TAB:
                    if (that.hint && that.options.onHint) {
                        that.selectHint();
                        return;
                    }
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    if (that.options.tabDisabled === false) {
                        return;
                    }
                    break;
                case keys.RETURN:
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    break;
                case keys.UP:
                    that.moveUp();
                    break;
                case keys.DOWN:
                    that.moveDown();
                    break;
                default:
                    return;
            }

            // Cancel event if function did not return:
            e.stopImmediatePropagation();
            e.preventDefault();
        },

        onKeyUp: function onKeyUp(e) {
            var that = this;

            if (that.disabled) {
                return;
            }

            switch (e.which) {
                case keys.UP:
                case keys.DOWN:
                    return;
            }

            clearTimeout(that.onChangeTimeout);

            if (that.currentValue !== that.el.val()) {
                that.findBestHint();
                if (that.options.deferRequestBy > 0) {
                    // Defer lookup in case when value changes very quickly:
                    that.onChangeTimeout = setTimeout(function () {
                        that.onValueChange();
                    }, that.options.deferRequestBy);
                } else {
                    that.onValueChange();
                }
            }
        },

        onValueChange: function onValueChange() {
            if (this.ignoreValueChange) {
                this.ignoreValueChange = false;
                return;
            }

            var that = this,
                options = that.options,
                value = that.el.val(),
                query = that.getQuery(value);

            if (that.selection && that.currentValue !== query) {
                that.selection = null;
                (options.onInvalidateSelection || $.noop).call(that.element);
            }

            clearTimeout(that.onChangeTimeout);
            that.currentValue = value;
            that.selectedIndex = -1;

            // Check existing suggestion for the match before proceeding:
            if (options.triggerSelectOnValidInput && that.isExactMatch(query)) {
                that.select(0);
                return;
            }

            if (query.length < options.minChars) {
                that.hide();
            } else {
                that.getSuggestions(query);
            }
        },

        isExactMatch: function isExactMatch(query) {
            var suggestions = this.suggestions;

            return suggestions.length === 1 && suggestions[0].value.toLowerCase() === query.toLowerCase();
        },

        getQuery: function getQuery(value) {
            var delimiter = this.options.delimiter,
                parts;

            if (!delimiter) {
                return value;
            }
            parts = value.split(delimiter);
            return $.trim(parts[parts.length - 1]);
        },

        getSuggestionsLocal: function getSuggestionsLocal(query) {
            var that = this,
                options = that.options,
                queryLowerCase = query.toLowerCase(),
                filter = options.lookupFilter,
                limit = parseInt(options.lookupLimit, 10),
                data;

            data = {
                suggestions: $.grep(options.lookup, function (suggestion) {
                    return filter(suggestion, query, queryLowerCase);
                })
            };

            if (limit && data.suggestions.length > limit) {
                data.suggestions = data.suggestions.slice(0, limit);
            }

            return data;
        },

        getSuggestions: function getSuggestions(q) {
            var response,
                that = this,
                options = that.options,
                serviceUrl = options.serviceUrl,
                params,
                cacheKey,
                ajaxSettings;

            options.params[options.paramName] = q;

            if (options.onSearchStart.call(that.element, options.params) === false) {
                return;
            }

            params = options.ignoreParams ? null : options.params;

            if ($.isFunction(options.lookup)) {
                options.lookup(q, function (data) {
                    that.suggestions = data.suggestions;
                    that.suggest();
                    options.onSearchComplete.call(that.element, q, data.suggestions);
                });
                return;
            }

            if (that.isLocal) {
                response = that.getSuggestionsLocal(q);
            } else {
                if ($.isFunction(serviceUrl)) {
                    serviceUrl = serviceUrl.call(that.element, q);
                }
                cacheKey = serviceUrl + '?' + $.param(params || {});
                response = that.cachedResponse[cacheKey];
            }

            if (response && Array.isArray(response.suggestions)) {
                that.suggestions = response.suggestions;
                that.suggest();
                options.onSearchComplete.call(that.element, q, response.suggestions);
            } else if (!that.isBadQuery(q)) {
                that.abortAjax();

                ajaxSettings = {
                    url: serviceUrl,
                    data: params,
                    type: options.type,
                    dataType: options.dataType
                };

                $.extend(ajaxSettings, options.ajaxSettings);

                that.currentRequest = $.ajax(ajaxSettings).done(function (data) {
                    var result;
                    that.currentRequest = null;
                    result = options.transformResult(data, q);
                    that.processResponse(result, q, cacheKey);
                    options.onSearchComplete.call(that.element, q, result.suggestions);
                }).fail(function (jqXHR, textStatus, errorThrown) {
                    options.onSearchError.call(that.element, q, jqXHR, textStatus, errorThrown);
                });
            } else {
                options.onSearchComplete.call(that.element, q, []);
            }
        },

        isBadQuery: function isBadQuery(q) {
            if (!this.options.preventBadQueries) {
                return false;
            }

            var badQueries = this.badQueries,
                i = badQueries.length;

            while (i--) {
                if (q.indexOf(badQueries[i]) === 0) {
                    return true;
                }
            }

            return false;
        },

        hide: function hide() {
            var that = this,
                container = $(that.suggestionsContainer);

            if ($.isFunction(that.options.onHide) && that.visible) {
                that.options.onHide.call(that.element, container);
            }

            that.visible = false;
            that.selectedIndex = -1;
            clearTimeout(that.onChangeTimeout);
            $(that.suggestionsContainer).hide();
            that.signalHint(null);
        },

        suggest: function suggest() {
            if (!this.suggestions.length) {
                if (this.options.showNoSuggestionNotice) {
                    this.noSuggestions();
                } else {
                    this.hide();
                }
                return;
            }

            var that = this,
                options = that.options,
                groupBy = options.groupBy,
                formatResult = options.formatResult,
                value = that.getQuery(that.currentValue),
                className = that.classes.suggestion,
                classSelected = that.classes.selected,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer),
                beforeRender = options.beforeRender,
                html = '',
                category,
                formatGroup = function formatGroup(suggestion, index) {
                var currentCategory = suggestion.data[groupBy];

                if (category === currentCategory) {
                    return '';
                }

                category = currentCategory;

                return options.formatGroup(suggestion, category);
            };

            if (options.triggerSelectOnValidInput && that.isExactMatch(value)) {
                that.select(0);
                return;
            }

            // Build suggestions inner HTML:
            $.each(that.suggestions, function (i, suggestion) {
                if (groupBy) {
                    html += formatGroup(suggestion, value, i);
                }

                html += '<div class="' + className + '" data-index="' + i + '">' + formatResult(suggestion, value, i) + '</div>';
            });

            this.adjustContainerWidth();

            noSuggestionsContainer.detach();
            container.html(html);

            if ($.isFunction(beforeRender)) {
                beforeRender.call(that.element, container, that.suggestions);
            }

            that.fixPosition();
            container.show();

            // Select first value by default:
            if (options.autoSelectFirst) {
                that.selectedIndex = 0;
                container.scrollTop(0);
                container.children('.' + className).first().addClass(classSelected);
            }

            that.visible = true;
            that.findBestHint();
        },

        noSuggestions: function noSuggestions() {
            var that = this,
                beforeRender = that.options.beforeRender,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer);

            this.adjustContainerWidth();

            // Some explicit steps. Be careful here as it easy to get
            // noSuggestionsContainer removed from DOM if not detached properly.
            noSuggestionsContainer.detach();

            // clean suggestions if any
            container.empty();
            container.append(noSuggestionsContainer);

            if ($.isFunction(beforeRender)) {
                beforeRender.call(that.element, container, that.suggestions);
            }

            that.fixPosition();

            container.show();
            that.visible = true;
        },

        adjustContainerWidth: function adjustContainerWidth() {
            var that = this,
                options = that.options,
                width,
                container = $(that.suggestionsContainer);

            // If width is auto, adjust width before displaying suggestions,
            // because if instance was created before input had width, it will be zero.
            // Also it adjusts if input width has changed.
            if (options.width === 'auto') {
                width = that.el.outerWidth();
                container.css('width', width > 0 ? width : 300);
            } else if (options.width === 'flex') {
                // Trust the source! Unset the width property so it will be the max length
                // the containing elements.
                container.css('width', '');
            }
        },

        findBestHint: function findBestHint() {
            var that = this,
                value = that.el.val().toLowerCase(),
                bestMatch = null;

            if (!value) {
                return;
            }

            $.each(that.suggestions, function (i, suggestion) {
                var foundMatch = suggestion.value.toLowerCase().indexOf(value) === 0;
                if (foundMatch) {
                    bestMatch = suggestion;
                }
                return !foundMatch;
            });

            that.signalHint(bestMatch);
        },

        signalHint: function signalHint(suggestion) {
            var hintValue = '',
                that = this;
            if (suggestion) {
                hintValue = that.currentValue + suggestion.value.substr(that.currentValue.length);
            }
            if (that.hintValue !== hintValue) {
                that.hintValue = hintValue;
                that.hint = suggestion;
                (this.options.onHint || $.noop)(hintValue);
            }
        },

        verifySuggestionsFormat: function verifySuggestionsFormat(suggestions) {
            // If suggestions is string array, convert them to supported format:
            if (suggestions.length && typeof suggestions[0] === 'string') {
                return $.map(suggestions, function (value) {
                    return { value: value, data: null };
                });
            }

            return suggestions;
        },

        validateOrientation: function validateOrientation(orientation, fallback) {
            orientation = $.trim(orientation || '').toLowerCase();

            if ($.inArray(orientation, ['auto', 'bottom', 'top']) === -1) {
                orientation = fallback;
            }

            return orientation;
        },

        processResponse: function processResponse(result, originalQuery, cacheKey) {
            var that = this,
                options = that.options;

            result.suggestions = that.verifySuggestionsFormat(result.suggestions);

            // Cache results if cache is not disabled:
            if (!options.noCache) {
                that.cachedResponse[cacheKey] = result;
                if (options.preventBadQueries && !result.suggestions.length) {
                    that.badQueries.push(originalQuery);
                }
            }

            // Return if originalQuery is not matching current query:
            if (originalQuery !== that.getQuery(that.currentValue)) {
                return;
            }

            that.suggestions = result.suggestions;
            that.suggest();
        },

        activate: function activate(index) {
            var that = this,
                activeItem,
                selected = that.classes.selected,
                container = $(that.suggestionsContainer),
                children = container.find('.' + that.classes.suggestion);

            container.find('.' + selected).removeClass(selected);

            that.selectedIndex = index;

            if (that.selectedIndex !== -1 && children.length > that.selectedIndex) {
                activeItem = children.get(that.selectedIndex);
                $(activeItem).addClass(selected);
                return activeItem;
            }

            return null;
        },

        selectHint: function selectHint() {
            var that = this,
                i = $.inArray(that.hint, that.suggestions);

            that.select(i);
        },

        select: function select(i) {
            var that = this;
            that.hide();
            that.onSelect(i);
        },

        moveUp: function moveUp() {
            var that = this;

            if (that.selectedIndex === -1) {
                return;
            }

            if (that.selectedIndex === 0) {
                $(that.suggestionsContainer).children().first().removeClass(that.classes.selected);
                that.selectedIndex = -1;
                that.ignoreValueChange = false;
                that.el.val(that.currentValue);
                that.findBestHint();
                return;
            }

            that.adjustScroll(that.selectedIndex - 1);
        },

        moveDown: function moveDown() {
            var that = this;

            if (that.selectedIndex === that.suggestions.length - 1) {
                return;
            }

            that.adjustScroll(that.selectedIndex + 1);
        },

        adjustScroll: function adjustScroll(index) {
            var that = this,
                activeItem = that.activate(index);

            if (!activeItem) {
                return;
            }

            var offsetTop,
                upperBound,
                lowerBound,
                heightDelta = $(activeItem).outerHeight();

            offsetTop = activeItem.offsetTop;
            upperBound = $(that.suggestionsContainer).scrollTop();
            lowerBound = upperBound + that.options.maxHeight - heightDelta;

            if (offsetTop < upperBound) {
                $(that.suggestionsContainer).scrollTop(offsetTop);
            } else if (offsetTop > lowerBound) {
                $(that.suggestionsContainer).scrollTop(offsetTop - that.options.maxHeight + heightDelta);
            }

            if (!that.options.preserveInput) {
                // During onBlur event, browser will trigger "change" event,
                // because value has changed, to avoid side effect ignore,
                // that event, so that correct suggestion can be selected
                // when clicking on suggestion with a mouse
                that.ignoreValueChange = true;
                that.el.val(that.getValue(that.suggestions[index].value));
            }

            that.signalHint(null);
        },

        onSelect: function onSelect(index) {
            var that = this,
                onSelectCallback = that.options.onSelect,
                suggestion = that.suggestions[index];

            that.currentValue = that.getValue(suggestion.value);

            if (that.currentValue !== that.el.val() && !that.options.preserveInput) {
                that.el.val(that.currentValue);
            }

            that.signalHint(null);
            that.suggestions = [];
            that.selection = suggestion;

            if ($.isFunction(onSelectCallback)) {
                onSelectCallback.call(that.element, suggestion);
            }
        },

        getValue: function getValue(value) {
            var that = this,
                delimiter = that.options.delimiter,
                currentValue,
                parts;

            if (!delimiter) {
                return value;
            }

            currentValue = that.currentValue;
            parts = currentValue.split(delimiter);

            if (parts.length === 1) {
                return value;
            }

            return currentValue.substr(0, currentValue.length - parts[parts.length - 1].length) + value;
        },

        dispose: function dispose() {
            var that = this;
            that.el.off('.selfcomplete').removeData('selfcomplete');
            $(window).off('resize.selfcomplete', that.fixPositionCapture);
            $(that.suggestionsContainer).remove();
        }
    };

    // Create chainable jQuery plugin:
    $.fn.devbridgeSelfcomplete = function (options, args) {
        var dataKey = 'selfcomplete';
        // If function invoked without argument return
        // instance of the first matched element:
        if (!arguments.length) {
            return this.first().data(dataKey);
        }

        return this.each(function () {
            var inputElement = $(this),
                instance = inputElement.data(dataKey);

            if (typeof options === 'string') {
                if (instance && typeof instance[options] === 'function') {
                    instance[options](args);
                }
            } else {
                // If instance already exists, destroy it:
                if (instance && instance.dispose) {
                    instance.dispose();
                }
                instance = new Selfcomplete(this, options);
                inputElement.data(dataKey, instance);
            }
        });
    };

    // Don't overwrite if it already exists
    if (!$.fn.selfcomplete) {
        $.fn.selfcomplete = $.fn.devbridgeSelfcomplete;
    }
});

},{"jquery":394}],20:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');
var nx = require('notatrix');
var errors = require('./errors');
var status = require('./status');

function encode(serial, options) {
  try {

    var format = detectFormat(serial, options);

    if (format === 'notatrix serial') format = 'CoNLL-U';

    options = _.extend({
      interpretAs: format,
      allowEmptyString: true
    }, options);

    return {
      format: format,
      sent: new nx.Sentence(serial, options)
    };
  } catch (e) {

    if (e instanceof nx.NotatrixError) {

      console.log(e);
      return {
        format: 'plain text',
        sent: new nx.Sentence('', options)
      };
    } else {

      throw e;
    }
  }
}

function detectFormat(serial, options) {

  if (!serial) return 'plain text';

  var formats = nx.detect(serial, {
    suppressDetectorErrors: true,
    returnAllMatches: true,
    allowEmptyString: true
  });

  if (formats.length === 0) {

    status.error('Unable to interpret input');
    serial = '';
    return 'plain text';
  } else if (formats.indexOf('notatrix serial') > -1) {

    return 'notatrix serial';
  } else if (formats.length === 1) {

    console.log('Interpreting as ' + formats[0]);
    return formats[0];
  } else {

    // order we'd want to display in if we get multiple hits
    var preferences = ['CoNLL-U', 'CG3', 'SD', 'plain text', 'Brackets'];

    for (var i = 0; i < preferences.length; i++) {
      var pref = preferences[i];
      if (formats.indexOf(pref) > -1) {
        status.normal('Interpreting as ' + pref);
        return pref;
      }
    }

    // just choose one
    status.normal('Interpreting as ' + formats[0]);
    return formats[0];
  }
}

var Sentence = function () {
  function Sentence(serial, options) {
    _classCallCheck(this, Sentence);

    var encoded = encode(serial, options);
    console.log('encoded', encoded);
    this.format = encoded.format;
    this._nx = encoded.sent;
    this.conversion_warning = null;

    this.is_table_view = false;
    this.column_visibilities = new Array(10).fill(true);

    labeler.parse(this._nx.comments);
  }

  _createClass(Sentence, [{
    key: 'toString',
    value: function toString(format) {

      format = format || this.format;

      try {

        var converted = this._nx.to(format);
        this.conversion_warning = converted.loss.length ? 'Unable to convert: ' + converted.loss.join(', ') : null;

        return converted.output;
      } catch (e) {
        if (e instanceof nx.GeneratorError) {

          status.error(e.message);
          return null;
        } else {

          throw e;
        }
      }
    }
  }, {
    key: 'update',
    value: function update(serial, options) {

      try {

        this._nx.update(serial, options);
      } catch (e) {

        var encoded = encode(serial, options);
        this._nx = encoded.sent;
        this.format = encoded.format;
      }

      labeler.parse(this._nx.comments);
      return this;
    }
  }, {
    key: 'clear',
    value: function clear() {

      this.format = null;
      this._nx = null;
      return this;
    }
  }, {
    key: 'get',
    value: function get(id) {
      return this._nx.query(function (e) {
        return e.indices.absolute === id;
      })[0];
    }
  }, {
    key: 'conllu',
    get: function get() {
      return this.toString('CoNLL-U');
    }
  }, {
    key: 'cg3',
    get: function get() {
      return this.toString('CG3');
    }
  }, {
    key: 'text',
    get: function get() {
      return this.toString('plain text');
    }
  }, {
    key: 'nx',
    get: function get() {
      return this.toString('notatrix serial');
    }
  }, {
    key: 'comments',
    get: function get() {
      return this._nx.comments;
    },
    set: function set(comments) {
      this._nx.comments = comments;
      return this;
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        column_visibilities: this.column_visibilities,
        format: this.format,
        is_table_view: this.is_table_view,
        nx: this._nx.to.notatrixSerial,
        input: this._input
      };
    },
    set: function set(state) {

      this._input = state.input;
      this.column_visibilities = state.column_visibilities;
      this.format = state.format;
      this.is_table_view = state.is_table_view;
      this._nx = new nx.Sentence(state.nx);

      return this;
    }
  }]);

  return Sentence;
}();

module.exports = Sentence;

},{"./errors":7,"./status":24,"notatrix":461,"underscore":499}],21:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var storage = require('./local-storage');
var status = require('./status');
var user = require('./user');
var funcs = require('./funcs');

var Server = function () {
	function Server() {
		_classCallCheck(this, Server);

		this.treebank_id = funcs.getTreebankId();
		this.check();
	}

	_createClass(Server, [{
		key: 'check',
		value: function check() {
			var _this = this;

			this.is_running = false;
			try {
				$.ajax({
					type: 'GET',
					url: '/running',
					success: function success(data) {
						status.normal('connected to server');
						log.info('checkServer AJAX response: ' + JSON.stringify(data));
						_this.is_running = true;
						gui.update();
						gui.modals.upload.enable();
						_this.load();
					},
					error: function error(data) {
						status.error('unable to connect to server');
						log.error('Unable to complete AJAX request for check()');
						gui.menu.update();
					}
				});
			} catch (e) {
				status.error('unable to connect to server');
				log.error('AJAX error in check(): ' + e.message);
				gui.menu.update();
			}
		}
	}, {
		key: 'save',
		value: function save(state) {

			if (!this.is_running) return null;

			try {
				$.ajax({
					type: 'POST',
					url: '/save?treebank_id=' + this.treebank_id,
					contentType: "application/json; charset=utf-8",
					data: state,
					dataType: 'json',
					success: function success(data) {
						if (data.status === 'failure') {
							log.error('Unable to save(): server error');
						} else {
							log.info('Successfully saved to server');
						}
					},
					error: function error(data) {
						log.error('Unable to complete AJAX request for save()');
					}
				});
			} catch (e) {
				log.error('AJAX error in save(): ' + e.message);
			}
		}
	}, {
		key: 'load',
		value: function load() {

			if (!this.is_running) return null;

			try {
				$.ajax({
					type: 'GET',
					url: '/load?treebank_id=' + this.treebank_id,
					success: function success(data) {
						if (data.status === 'failure') {
							log.error('Unable to load(): server error');
						} else {
							log.info('Successfully loaded from server');
							manager.load(data);
						}
					},
					error: function error(data) {
						log.critical('Unable to complete AJAX request for load()');
					}
				});
			} catch (e) {
				log.critical('AJAX error in load(): ' + e.message);
			}

			return null; // want the loading to fail
		}
	}]);

	return Server;
}();

module.exports = Server;

},{"./funcs":9,"./local-storage":14,"./status":24,"./user":34,"jquery":394}],22:[function(require,module,exports){
'use strict';

var Socket = require('socket.io-client');
var status = require('./status');
var collab = require('./collaboration');
var funcs = require('./funcs');

var selfid = null;

module.exports = function (manager) {

  // get a new socket.io client, but make sure we don't emit anything until
  //   we've received confirmation from the server
  var socket = Socket();
  socket.initialized = false;

  socket.on('connection', function (data) {
    console.log('connection', data);
    socket.initialized = true;
    selfid = data.id;

    var num = funcs.getPresentUsers(data.room);
    collab.update(selfid, data.room);
    socket.emit('pan', { index: manager.index });
  });

  socket.on('new connection', function (data) {
    console.log('new connection', data);

    var name = funcs.getUsername(data);
    collab.update(selfid, data.room);
    status.normal(name + ' joined');
  });

  socket.on('disconnection', function (data) {
    console.log('disconnection', data);

    var name = funcs.getUsername(data);
    collab.update(selfid, data.room);
    status.normal(name + ' left');
  });

  socket.on('update', function (data) {
    console.log('update', data);
    var name = funcs.getUsername(data);
    var verb = {
      modify: 'modified',
      remove: 'removed',
      insert: 'inserted'
    }[data.type];

    socket.isOpen = false;
    status.normal(name + ' ' + verb + ' sentence #' + (data.index + 1));

    var text = void 0;
    if (data.format === 'CoNLL-U') {
      text = convert.to.conllu(data.nx);
    } else if (data.format === 'CG3') {
      text = convert.to.cg3(data.nx);
    } else if (data.format === 'plain text') {
      text = convert.to.plainText(data.nx);
    } else {
      status.normal('Cannot output to ' + data.format + ', converting to CoNLL-U');
      text = convert.to.conllu(data.nx);
    }

    if (data.type === 'modify') {

      manager.parse(text, { index: data.index });
    } else if (data.type === 'insert') {
      console.log('insert', text, 'at', data.index);
    } else if (data.type === 'remove') {
      console.log('remove', text, 'at', data.index);
    }

    socket.isOpen = true;
  });

  socket.on('pan', function (data) {
    console.log('pan', data);
    collab.update(selfid, data.room);
  });

  return socket;
};

},{"./collaboration":2,"./funcs":9,"./status":24,"socket.io-client":484}],23:[function(require,module,exports){
'use strict';

var _ = require('underscore');

// NB: sorting will break if sentence has more than this many tokens
var LARGE_NUMBER = 10000;

function vertical(n1, n2) {

  var num = function num(node) {
    var id = parseInt(node.data('num')),
        offset = node.data('name') === 'pos-node' ? 0 : 0.5;

    return isNaN(id) ? -Infinity : id + offset;
  };

  var num1 = num(n1);
  var num2 = num(n2);

  return num1 === num2 ? 0 : num1 < num2 ? -1 : 1;
}

function ltr(n1, n2) {

  var num = function num(node) {
    var id = parseInt(node.data('num')),
        offset = node.data('name') === 'pos-node' ? LARGE_NUMBER : 0;

    return isNaN(id) ? -Infinity : id + offset;
  };

  var num1 = num(n1);
  var num2 = num(n2);

  return num1 === num2 ? 0 : num1 < num2 ? -1 : 1;
}

function rtl(n1, n2) {
  var num = function num(node) {
    var id = parseInt(node.data('num')),
        offset = node.data('name') === 'pos-node' ? 0 : LARGE_NUMBER;

    return isNaN(id) ? -Infinity : id + offset;
  };

  var num1 = num(n1);
  var num2 = num(n2);

  return num1 === num2 ? 0 : num1 < num2 ? 1 : -1;
}

module.exports = {
  vertical: vertical,
  ltr: ltr,
  rtl: rtl
};

},{"underscore":499}],24:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var cfg = require('./config');

function Status(text, isError) {
  return $('<div>').addClass('status').addClass(isError ? 'error' : 'normal').text(text);
}

function normal(text) {

  if (!gui.inBrowser) return null;

  var div = Status(text, false);
  $('.status-container').prepend(div);
  div.fadeOut(cfg.statusNormalFadeout);
  setTimeout(div.detach, cfg.statusNormalFadeout);
}

function error(text) {

  if (!gui.inBrowser) return null;

  var div = Status(text, true);
  $('.status-container').prepend(div);
  div.fadeOut(cfg.statusErrorFadeout);
  setTimeout(div.detach, cfg.statusErrorFadeout);
}

module.exports = {
  normal: normal,
  error: error
};

},{"./config":3,"jquery":394}],25:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var validate = require('./validate');

function build() {
  $('#table-data tbody').empty();

  manager.current.forEach(function (token, i) {
    var tr = $('<tr>').attr('id', 'table_' + i);

    $.each(['id', 'form', 'lemma', 'upostag', 'xpostag', 'feats', 'head', 'deprel', 'deps', 'misc'], function (j, field) {

      var value = token.analysis[field];

      var valid = {},
          td = $('<td>'),
          inputSpan = $('<span>').attr('name', 'input'),
          errorSpan = $('<span>').attr('name', 'error');

      if (value !== '_') {
        if (j === 3) valid = validate.is_upos(value);
        if (j === 7) valid = validate.is_udeprel(value);
      }

      td.prop('contenteditable', true).attr('row-id', i).attr('col-id', j).attr('tok-id', token.analysis.id).attr('field', field).attr('name', j === 0 ? 'index' : 'content').css('visibility', gui.column_visible(j) ? 'visible' : 'hidden').blur(edit).keyup(function (event) {
        if (event.which === gui.keys.ESC) {
          $(event.target).blur();
        } else if (event.which === gui.keys.ENTER) {
          gui.onEnter(event);
        }
      });

      inputSpan.text(value);

      if (!valid) {
        log.warn('buildTable(): error parsing cell (err:"' + valid.err + '", value:"' + value + '")');
        /*document.l10n.formatValue(valid.err, valid.data).then(title => {
          errorSpan.addClass('fa fa-exclamation-triangle')
            .addClass('parse-error')
            .attr('aria-hidden', 'true')
            .attr('title', title);
        });*/
      }
      tr.append(td.append(inputSpan).append(errorSpan));
    });

    $('#table-data tbody').append(tr);
  });
}

function edit(event) {

  var target = $(event.target),
      id = target.attr('tok-id'),
      ana = manager.current.getById(id),
      field = target.attr('field'),
      value = target.text();

  ana[field] = value;
  gui.update();
}

module.exports = {
  build: build,
  edit: edit
};

},{"./validate":36,"jquery":394}],26:[function(require,module,exports){
'use strict';

module.exports = {
  0: '[root [nsubj I] have [obj [amod [advmod too] many] commitments] [advmod right now] [punct .]]'
};

},{}],27:[function(require,module,exports){
'use strict';

module.exports = {
	nested: '# sent_id = wikipedia:Poyvi_Paragu\xE1i:11\n# text = Poyvi pete\u0129ha \xF1ane ret\xE3megua niko ojepuru\u2019yp\xFDkuri 15 jasypo guive 16 jasypote\u0129 meve ary 1811-pe.\n# text[spa] = Bandera uno nosotros de-de _ \xE9l-se-utiliz\xF3-_ 15 maio desde 16 junio hasta a\xF1o 1811-en.\n"<Poyvi>"\n\t"poyvi" n\n"<pete\u0129ha>"\n\t"pete" n incp\n\t\t"\u0129" v tv pres\n\t\t\t"ha" subs\n\t"pete\u0129ha" num\n"<\xF1ane>"\n\t"\xF1and\xE9" prn pers p1 incl pl\n"<ret\xE3megua>"\n\t"*ret\xE3megua"\n"<niko>"\n\t"*niko"\n"<ojepuru\u02BCyp\xFDkuri>"\n\t"*ojepuru\u02BCyp\xFDkuri"\n"<15>"\n\t"15" num @amod\n"<jasypo>"\n\t"ja" n incp\n\t\t"sy" n incp\n\t\t\t"po" n\n\t"ja" n incp\n\t\t"sy" n incp\n\t\t\t"po" v iv pres\n\t"ja" n incp\n\t\t"sy" n incp\n\t\t\t"po" v tv pres\n\t"ja" prn p1 pl\n\t\t"sy" n incp\n\t\t\t"po" n\n\t"ja" prn p1 pl\n\t\t"sy" n incp\n\t\t\t"po" v iv pres\n\t"ja" prn p1 pl\n\t\t"sy" n incp\n\t\t\t"po" v tv pres\n\t"jasy" n incp\n\t\t"po" n\n\t"jasy" n incp\n\t\t"po" v iv pres\n\t"jasy" n incp\n\t\t"po" v tv pres\n\t"jasypo" n\n"<guive>"\n\t"guive" post @case\n"<16>"\n\t"16" num @amod\n"<jasypote\u0129>"\n\t"jasypote\u0129" n\n"<meve>"\n\t"peve" post @case\n"<ary>"\n\t"ary" n\n"<1811-pe>"\n\t"1811" num\n\t\t"pe" post @case',

	/*nested_2: `"<ab>"
 	"A" #1->
 		"B" #2->
 "<cde>"
 	"C" #3->
 		"D" #4->
 			"E" #5->
 "<f>"
 	"F" #6->
 "<h>"
 	"H" #7->`,*/

	kdt_tagged_1: '# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt\n"<\u04E8\u0441\u043A\u0435\u043C\u0435\u043D\u043D\u0456\u04A3>"\n\t"\u04E8\u0441\u043A\u0435\u043C\u0435\u043D" np top gen @nmod:poss #1->3\n"<\u0430\u0440>"\n\t"\u0430\u0440" adj @amod #2->3\n"<\u0436\u0430\u0493\u044B\u043D\u0434\u0430>"\n\t"\u0436\u0430\u049B" n px3sp loc @conj #3->7\n"<,>"\n\t"," cm @punct #4->7\n"<\u0411\u04B1\u049B\u0442\u044B\u0440\u043C\u0430\u043D\u044B\u04A3>"\n\t"\u0411\u04B1\u049B\u0442\u044B\u0440\u043C\u0430" np top gen @nmod:poss #5->7\n"<\u043E\u04A3>"\n\t"\u043E\u04A3" adj @amod #6->7\n"<\u0436\u0430\u0493\u044B\u043D\u0434\u0430>"\n\t"\u0436\u0430\u049B" n px3sp loc @nmod #7->11\n"<\u04D9\u043B\u0435\u043C\u0433\u0435>"\n\t"\u04D9\u043B\u0435\u043C" n dat @nmod #8->9\n"<\u0430\u044F\u043D>"\n\t"\u0430\u044F\u043D" adj @acl #9->10\n"<\u0410\u043B\u0442\u0430\u0439>"\n\t"\u0410\u043B\u0442\u0430\u0439" np top nom @nsubj #10->11\n"<\u0431\u0430\u0440>"\n\t"\u0431\u0430\u0440" adj @root #11->0\n\t\t"\u0435" cop aor p3 sg @cop #12->11\n"<.>"\n\t"." sent @punct #13->11',

	kdt_tagged_2: '# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt\n"<\u0410\u0442\u0442\u0430\u043D>"\n\t"\u0430\u0442\u0442\u0430\u043D" v iv imp p2 sg @root #1->0\n"<!>"\n\t"!" sent @punct #2->1',

	kdt_tagged_3: '# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt\n"<\u041C\u0430\u043D\u0430\u0493\u044B>"\n\t"\u043C\u0430\u043D\u0430\u0493\u044B" det dem @det #1->3\n"<\u0430\u043B\u0430>"\n\t"\u0430\u043B\u0430" adj @amod #2->3\n"<\u0430\u0442\u0442\u044B>"\n\t"\u0430\u0442\u0442\u044B" adj subst nom @nsubj #3->4\n"<\u043A\u0456\u043C>"\n\t"\u043A\u0456\u043C" prn itg nom @root #4->0\n\t\t"\u0435" cop aor p3 sg @cop #5->4\n"<?>"\n\t"?" sent @punct #6->4',

	0: '"<\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D>"\n\t"\u043F\u0430\u0442\u0448\u0430" n ins @nmod #1->3\n"<\u0441\u043E\u0493\u044B\u0441>"\n\t"\u0441\u043E\u0493\u044B\u0441" n nom @obj #2->3\n"<\u0430\u0448\u049B\u0430\u043D\u0434\u0430>"\n\t"\u0430\u0448" v tv ger_past loc @advcl #3->12\n"<,>"\n\t"," cm @punct #4->12\n"<\u0435\u043B-\u0436\u04B1\u0440\u0442>"\n\t"\u0435\u043B-\u0436\u04B1\u0440\u0442" n nom @conj #5->7\n"<,>"\n\t"," cm @punct #6->7\n"<\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B>"\n\t"\u043E\u0442\u0430\u043D" n px1sg acc @obj #7->8\n"<\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430>"\n\t"\u049B\u043E\u0440\u0493\u0430" v tv ger dat @advcl #8->12\n"<,>"\n\t"," cm @punct #9->12\n"<\u0431\u0456\u0437>"\n\t"\u0431\u0456\u0437" prn pers p1 pl nom @nsubj #10->12\n"<\u0441\u043E\u0493\u044B\u0441\u049B\u0430>"\n\t"\u0441\u043E\u0493\u044B\u0441" n dat @nmod #11->12\n"<\u0431\u0430\u0440\u0434\u044B\u049B>"\n\t"\u0431\u0430\u0440" v iv ifi p1 pl @root #12->0\n"<.>"\n\t"." sent @punct #13->12',

	1: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n"<He>"\n\t"he" det pos f sp @det #1->2\n"<boued>"\n\t"boued" n m sg @obj #2->4\n"<e>"\n\t"e" vpart obj @aux #3->4\n"<tebr>"\n\t"debri\xF1" vblex pri p3 sg @root #4->0\n"<Mona>"\n\t"Mona" np ant f sg @nsubj #5->4\n"<er>"\n\t"e" pr @case #6->8\n\t\t"an" det def sp @det #7->8\n"<gegin>"\n\t"kegin" n f sg @obl #8->4\n"<.>"\n\t"." sent @punct #9->4',

	2: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n"<He>"\n\t"he" det pos f sp @det #1->2\n"<boued>"\n\t"boued" n m sg @obj #2->4\n"<e>"\n\t"e" vpart obj @aux #3->4\n"<tebr>"\n\t"debri\xF1" vblex pri p3 sg @root #4->0\n"<Mona>"\n\t"Mona" np ant f sg @nsubj #5->4\n"<er>"\n\t"e" pr @case #6->8\n\t\t"an" det def sp @det #7->8\n"<gegin>"\n\t"kegin" n f sg @obl #8->4\n\t"kegin" n f pl @obl #9->\n"<.>"\n\t"." sent @punct #10->4', // note: changed line `"kegin" n f pl @obl #8->4`

	with_semicolumn: '\n"<Siedzieli\u015Bmy>"\n\t"siedzie\u0107" vblex impf past p1 m pl\n"<w>"\n\t"w" pr\n"<moim>"\n;   "m\xF3j" prn pos mi sg loc\n"<pokoju>"\n\t"pok\xF3j" n mi sg loc\n"<,>"\n\t"," cm\n"<pal\u0105c>"\n\t"pali\u0107" vblex impf pprs adv\n"<i>"\n\t"i" cnjcoo\n"<rozmawiaj\u0105c>"\n\t"rozmawia\u0107" vblex impf pprs adv\n"<o>"\n\t"o" pr\n"<tem>"\n\t"to" prn dem mi sg loc\n"<,>"\n\t"," cm\n"<jak>"\n\t"jak" rel adv\n"<marni>"\n\t"marny" adj sint mp pl nom\n"<jeste\u015Bmy>"\n\t"by\u0107" vbser pres p1 pl\n"<,>"\n\t"," cm\n"<marni>"\n\t"marny" adj sint mp pl nom\n"<z>"\n\t"z" pr\n"<lekarskiego>"\n\t"lekarski" adj mi sg gen\n"<punktu>"\n\t"punkt" n mi sg gen\n"<widzenia>"\n;   "widzie\u0107" vblex impf ger nt sg gen\n"<chc\u0119>"\n\t"chcie\u0107" vblex impf pres p1 sg\n"<powiedzie\u0107>"\n\t"powiedzie\u0107" vblex perf inf\n"<,>"\n\t"," cm\n"<naturalnie>"\n\t"naturalnie" adv sint\n"<.>"\n\t"." sent',

	simple: '"<\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D>"\n\t"\u043F\u0430\u0442\u0448\u0430" n ins @nmod #1->3\n"<\u0441\u043E\u0493\u044B\u0441>"\n\t"\u0441\u043E\u0493\u044B\u0441" n nom @obj #2->3\n"<\u0430\u0448\u049B\u0430\u043D\u0434\u0430>"\n\t"\u0430\u0448" v tv ger_past loc @advcl #3->12\n"<,>"\n\t"," cm @punct #4->12\n"<\u0435\u043B-\u0436\u04B1\u0440\u0442>"\n\t"\u0435\u043B-\u0436\u04B1\u0440\u0442" n nom @conj #5->7\n"<,>"\n\t"," cm @punct #6->7\n"<\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B>"\n\t"\u043E\u0442\u0430\u043D" n px1sg acc @obj #7->8\n"<\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430>"\n\t"\u049B\u043E\u0440\u0493\u0430" v tv ger dat @advcl #8->12\n"<,>"\n\t"," cm @punct #9->12\n"<\u0431\u0456\u0437>"\n\t"\u0431\u0456\u0437" prn pers p1 pl nom @nsubj #10->12\n"<\u0441\u043E\u0493\u044B\u0441\u049B\u0430>"\n\t"\u0441\u043E\u0493\u044B\u0441" n dat @nmod #11->12\n"<\u0431\u0430\u0440\u0434\u044B\u049B>"\n\t"\u0431\u0430\u0440" v iv ifi p1 pl @root #12->0\n"<.>"\n\t"." sent @punct #13->12',

	simple_with_comments: '# comment #1\n# comment #2\n"<\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D>"\n\t"\u043F\u0430\u0442\u0448\u0430" n ins @nmod #1->3\n"<\u0441\u043E\u0493\u044B\u0441>"\n\t"\u0441\u043E\u0493\u044B\u0441" n nom @obj #2->3\n"<\u0430\u0448\u049B\u0430\u043D\u0434\u0430>"\n\t"\u0430\u0448" v tv ger_past loc @advcl #3->12\n"<,>"\n\t"," cm @punct #4->12\n"<\u0435\u043B-\u0436\u04B1\u0440\u0442>"\n\t"\u0435\u043B-\u0436\u04B1\u0440\u0442" n nom @conj #5->7\n"<,>"\n\t"," cm @punct #6->7\n"<\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B>"\n\t"\u043E\u0442\u0430\u043D" n px1sg acc @obj #7->8\n"<\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430>"\n\t"\u049B\u043E\u0440\u0493\u0430" v tv ger dat @advcl #8->12\n"<,>"\n\t"," cm @punct #9->12\n"<\u0431\u0456\u0437>"\n\t"\u0431\u0456\u0437" prn pers p1 pl nom @nsubj #10->12\n"<\u0441\u043E\u0493\u044B\u0441\u049B\u0430>"\n\t"\u0441\u043E\u0493\u044B\u0441" n dat @nmod #11->12\n"<\u0431\u0430\u0440\u0434\u044B\u049B>"\n\t"\u0431\u0430\u0440" v iv ifi p1 pl @root #12->0\n"<.>"\n\t"." sent @punct #13->12',

	with_spans: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n"<He>"\n\t"he" det pos f sp @det #1->2\n"<boued>"\n\t"boued" n m sg @obj #2->4\n"<e>"\n\t"e" vpart obj @aux #3->4\n"<tebr>"\n\t"debri\xF1" vblex pri p3 sg @root #4->0\n"<Mona>"\n\t"Mona" np ant f sg @nsubj #5->4\n"<er>"\n\t"e" pr @case #6->8\n\t\t"an" det def sp @det #7->8\n"<gegin>"\n\t"kegin" n f sg @obl #8->4\n"<.>"\n\t"." sent @punct #9->4',

	apertium_kaz_1: '# https://bpaste.net/show/be7c03e6213e\n"<\u0427\u0430\u0443>"\n\t"*\u0427\u0430\u0443"\n"<->"\n\t"\u0445" guio\n\t"-" guio\n"<\u0447\u0430\u0443>"\n\t"*\u0447\u0430\u0443"\n"<\u0448\u044B\u0493\u0443>"\n\t"\u0448\u044B\u0493\u0443" n attr\n\t"\u0448\u044B\u049B" v tv ger nom\n\t"\u0448\u044B\u049B" v iv ger nom\n\t"\u0448\u044B\u0493\u0443" n nom\n;\t"\u0448\u044B\u0493\u0443" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u0448\u044B\u0493\u0443" n nom\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n;\t"\u0448\u044B\u049B" vaux ger nom REMOVE:766\n"<\u0442\u0435\u0433\u0456\u043D\u0435\u043D>"\n\t"\u0442\u0435\u043A" n px3sp abl\n;\t"\u0442\u0435\u043A" n px3sp abl\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u0442\u0435\u043A" n px3sp abl\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0448\u043F\u0438\u0446\u0442\u0435\u0440>"\n\t"*\u0448\u043F\u0438\u0446\u0442\u0435\u0440"\n"<\u0442\u043E\u0431\u044B\u043D\u0430>"\n\t"\u0442\u043E\u043F" n px3sp dat\n"<\u0436\u0430\u0442\u0430\u0434\u044B>"\n\t"\u0436\u0430\u0442" v iv aor p3 sg\n;\t"\u0436\u0430\u0442" vaux aor p3 pl REMOVE:766\n;\t"\u0436\u0430\u0442" vaux aor p3 sg REMOVE:766\n;\t"\u0436\u0430\u0442" v iv aor p3 pl REMOVE:846\n"<.>"\n\t"." sent',

	apertium_kaz_2: '# https://bpaste.net/show/be7c03e6213e\n"<\u049A\u0430\u043D\u044B\u043D\u0434\u0430>"\n\t"\u049B\u0430\u043D" n px3sp loc\n;\t"\u049B\u0430\u043D" n px3sp loc\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u049B\u0430\u043D" n px3sp loc\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0442\u0438\u0431\u0435\u0442>"\n\t"*\u0442\u0438\u0431\u0435\u0442"\n"<\u0438\u0442\u0456\u043D\u0456\u04A3>"\n\t"\u0438\u0442" n px3sp gen\n"<(>"\n\t"(" lpar\n"<\u043C\u0430\u0441\u0442\u0438\u0444>"\n\t"*\u043C\u0430\u0441\u0442\u0438\u0444"\n"<)>"\n\t")" rpar\n"<\u049B\u0430\u043D\u044B>"\n\t"\u049B\u0430\u043D" n px3sp nom\n;\t"\u049B\u0430\u043D" n px3sp nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u049B\u0430\u043D" n px3sp nom\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0431\u0430\u0440>"\n\t"\u0431\u0430\u0440" adj SELECT:1118\n\t"\u0431\u0430\u0440" adj subst nom SELECT:1118\n\t\t"\u0435" cop aor p3 sg\n\t"\u0431\u0430\u0440" adj subst nom SELECT:1118\n\t"\u0431\u0430\u0440" adj SELECT:1118\n\t\t"\u0435" cop aor p3 sg\n;\t"\u0431\u0430\u0440" n attr REMOVE:567\n;\t"\u0431\u0430\u0440" adj\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" adj subst nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" n nom SELECT:1118\n;\t"\u0431\u0430\u0440" det qnt SELECT:1118\n;\t"\u0431\u0430\u0440" v iv imp p2 sg SELECT:1118\n;\t"\u0431\u0430\u0440" n nom SELECT:1118\n;\t\t"\u0435" cop aor p3 sg\n"<\u0434\u0435\u0433\u0435\u043D>"\n\t"\u0434\u0435" v tv gpr_past SELECT:813\n\t"\u0434\u0435" v tv gpr_past subst nom SELECT:813\n;\t"\u0434\u0435" v tv ger_past nom SELECT:813\n;\t"\u0434\u0435" v tv past p3 pl SELECT:813\n;\t"\u0434\u0435" v tv past p3 sg SELECT:813\n"<\u0442\u04B1\u0436\u044B\u0440\u044B\u043C>"\n\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n nom\n\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n attr\n;\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n nom\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0431\u0430\u0440>"\n\t"\u0431\u0430\u0440" adj\n\t"\u0431\u0430\u0440" n nom\n\t"\u0431\u0430\u0440" adj\n\t\t"\u0435" cop aor p3 sg\n\t"\u0431\u0430\u0440" adj subst nom\n\t\t"\u0435" cop aor p3 sg\n\t"\u0431\u0430\u0440" adj subst nom\n\t"\u0431\u0430\u0440" v iv imp p2 sg\n\t"\u0431\u0430\u0440" n nom\n\t\t"\u0435" cop aor p3 sg\n;\t"\u0431\u0430\u0440" det qnt REMOVE:551\n;\t"\u0431\u0430\u0440" n attr REMOVE:567\n;\t"\u0431\u0430\u0440" adj subst nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" adj\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n"<.>"\n\t"." sent'

};

},{}],28:[function(require,module,exports){
"use strict";

module.exports = {
  labels_1: "# text = \"This is a simple sentence.\"\n# labels = label1 another_label a-third-label\n1\tThis\tThis\t_\t_\t_\t_\t_\t_\t_\n2\tis\tis\t_\t_\t_\t_\t_\t_\t_\n3\ta\ta\t_\t_\t_\t_\t_\t_\t_\n4\tsimple\tsimple\t_\t_\t_\t_\t_\t_\t_\n5\tsentence\tsentence\t_\t_\t_\t_\t_\t_\t_\n6\t.\t.\tPUNCT\tPUNCT\t_\t_\t_\t_\t_",

  labels_2: "# labels = one_label second third-label\n# labels = row_2 again:here this, that\n1\tThis\tThis\t_\t_\t_\t_\t_\t_\t_",

  labels_3: "# tags = this-is-a-tag test testing test\n1\tThis\tThis\t_\t_\t_\t_\t_\t_\t_",

  labels_4: "# labels = new label1 one_label this-is-a-tag\n1\tHullo\thello\t_\t_\t_\t_\t_\t_\t_",

  nested_2: "# text = ab cde f h\n1-2\tab\t_\t_\t_\t_\t_\t_\t_\t_\n1\ta\tA\t_\t_\t_\t_\t_\t_\t_\n2\tb\tB\t_\t_\t_\t_\t_\t_\t_\n3-5\tcde\t_\t_\t_\t_\t_\t_\t_\t_\n3\tc\tC\t_\t_\t_\t_\t_\t_\t_\n4\td\tD\t_\t_\t_\t_\t_\t_\t_\n5\te\tE\t_\t_\t_\t_\t_\t_\t_\n6\tf\tF\t_\t_\t_\t_\t_\t_\t_\n6.1\tsilent_g\tG\t_\t_\t_\t_\t_\t_\t_\n7\th\tH\t_\t_\t_\t_\t_\t_\t_",

  t: "# testing :)\n1-3\tHe\t_\t_\t_\t_\t_\t_\t_\t_\n1\tboued\tboued\tn\t_\tm|sg\t4\tobj\t_\t_\n2\te\te\tvpart\t_\tobj\t4\taux\t_\t_\n3\ttebr\tdebri\xF1\tvblex\t_\tpri|p3|sg\t0\troot\t_\t_\n4\tdoob\tdoobie\tnp\t_\t_\t3\t_\t_\t_\n5\tMona\tMona\tnp\t_\tant|f|sg\t4\tnsubj\t_\t_",

  empty: "1      Sue       Sue       _       _       _       _       _       _       _\n2      likes     like       _       _       _       _       _       _       _\n3      coffee    coffee       _       _       _       _       _       _       _\n4      and       and       _       _       _       _       _       _       _\n5      Bill      Bill       _       _       _       _       _       _       _\n5.1    likes     like       _       _       _       _       _       _       _\n6      tea       tea       _       _       _       _       _       _       _",

  0: "# sent_id = _\n# text = this is a test\n1\tthis\t_\t_\t_\t_\t_\t_\t_\t_\n2\tis\t_\t_\t_\t_\t_\t_\t_\t_\n3\ta\t_\t_\t_\t_\t_\t_\t_\t_\n4\ttest\t_\t_\t_\t_\t_\t_\t_\t_",

  1: "1\tthis\t_\t_\t_\t_\t_\t_\t_\t_\n2\tis\t_\t_\t_\t_\t_\t_\t_\t_\n3\ta\t_\t_\t_\t_\t_\t_\t_\t_\n4\ttest\t_\t_\t_\t_\t_\t_\t_\t_",

  cat_ancora: "# url = https://raw.githubusercontent.com/UniversalDependencies/UD_Catalan-AnCora/dev/ca_ancora-ud-test.conllu\n# sent_id = test-s1\n# text = El darrer n\xFAmero de l'Observatori del Mercat de Treball d'Osona inclou un informe especial sobre la contractaci\xF3 a trav\xE9s de les empreses de treball temporal, les ETT.\n# orig_file_sentence 001#1\n1\tEl\tel\tDET\tDET\tDefinite=Def|Gender=Masc|Number=Sing|PronType=Art\t3\tdet\t_\t_\n2\tdarrer\tdarrer\tADJ\tADJ\tGender=Masc|Number=Sing|NumType=Ord\t3\tamod\t_\t_\n3\tn\xFAmero\tn\xFAmero\tNOUN\tNOUN\tGender=Masc|Number=Sing\t13\tnsubj\t_\t_\n4\tde\tde\tADP\tADP\tAdpType=Prep\t6\tcase\t_\t_\n5\tl'\tel\tDET\tDET\tDefinite=Def|Number=Sing|PronType=Art\t6\tdet\t_\tSpaceAfter=No\n6\tObservatori\tObservatori\tPROPN\tPROPN\t_\t3\tnmod\t_\tMWE=Observatori_del_Mercat_de_Treball_d'_Osona|MWEPOS=PROPN\n7\tdel\tdel\tADP\tADP\tAdpType=Preppron|Gender=Masc|Number=Sing\t8\tcase\t_\t_\n8\tMercat\tMercat\tPROPN\tPROPN\t_\t6\tflat\t_\t_\n9\tde\tde\tADP\tADP\tAdpType=Prep\t10\tcase\t_\t_\n10\tTreball\tTreball\tPROPN\tPROPN\t_\t6\tflat\t_\t_\n11\td'\td'\tADP\tADP\tAdpType=Prep\t12\tcase\t_\tSpaceAfter=No\n12\tOsona\tOsona\tPROPN\tPROPN\t_\t6\tflat\t_\t_\n13\tinclou\tincloure\tVERB\tVERB\tMood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin\t0\troot\t_\t_\n14\tun\tun\tNUM\tNUM\tGender=Masc|Number=Sing|NumType=Card\t15\tnummod\t_\t_\n15\tinforme\tinforme\tNOUN\tNOUN\tGender=Masc|Number=Sing\t13\tobj\t_\t_\n16\tespecial\tespecial\tADJ\tADJ\tNumber=Sing\t15\tamod\t_\t_\n17\tsobre\tsobre\tADP\tADP\tAdpType=Prep\t19\tcase\t_\t_\n18\tla\tel\tDET\tDET\tDefinite=Def|Gender=Fem|Number=Sing|PronType=Art\t19\tdet\t_\t_\n19\tcontractaci\xF3\tcontractaci\xF3\tNOUN\tNOUN\tGender=Fem|Number=Sing\t15\tnmod\t_\t_\n20\ta\ta\tADP\tADP\tAdpType=Prep\t24\tcase\t_\tMWE=a_trav\xE9s_de|MWEPOS=ADP\n21\ttrav\xE9s\ttrav\xE9s\tNOUN\tNOUN\t_\t20\tfixed\t_\t_\n22\tde\tde\tADP\tADP\tAdpType=Prep\t20\tfixed\t_\t_\n23\tles\tel\tDET\tDET\tDefinite=Def|Gender=Fem|Number=Plur|PronType=Art\t24\tdet\t_\t_\n24\tempreses\tempresa\tNOUN\tNOUN\tGender=Fem|Number=Plur\t19\tnmod\t_\t_\n25\tde\tde\tADP\tADP\tAdpType=Prep\t26\tcase\t_\t_\n26\ttreball\ttreball\tNOUN\tNOUN\tGender=Masc|Number=Sing\t24\tnmod\t_\t_\n27\ttemporal\ttemporal\tADJ\tADJ\tNumber=Sing\t26\tamod\t_\tSpaceAfter=No\n28\t,\t,\tPUNCT\tPUNCT\tPunctType=Comm\t30\tpunct\t_\t_\n29\tles\tel\tDET\tDET\tDefinite=Def|Gender=Fem|Number=Plur|PronType=Art\t30\tdet\t_\t_\n30\tETT\tETT\tPROPN\tPROPN\t_\t24\tappos\t_\tSpaceAfter=No\n31\t.\t.\tPUNCT\tPUNCT\tPunctType=Peri\t13\tpunct\t_\t_",

  with_tabs: "# sent_id = chapID01:paragID1:sentID1\n# text = \u041A\u0435\u0447\u0430\u0435\u043D\u044C \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F \u043A\u0430\u0440\u0432\u043E\u0442 .\n# text[eng] = Kechai was awoken by annoying flies.\n1\t\u041A\u0435\u0447\u0430\u0435\u043D\u044C\t\u041A\u0435\u0447\u0430\u0439\tN\tN\tSem/Ant_Mal|Prop|SP|Gen|Indef\t2\tobj\t_\t\u041A\u0435\u0447\u0430\u0435\u043D\u044C\n2\t\u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C\t\u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0435\u043C\u0441\tV\tV\tTV|Ind|Prt1|ScPl3|OcSg3\t0\troot\t_\t\u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C\n3\t\u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F\t\u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u043E\u043C\u0441\tPRC\tPrc\tV|TV|PrcPrsL|Sg|Nom|Indef\t4\tamod\t_\t\u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F\n4\t\u043A\u0430\u0440\u0432\u043E\u0442\t\u043A\u0430\u0440\u0432\u043E\tN\tN\tSem/Ani|N|Pl|Nom|Indef\t2\tnsubj\t_\t\u043A\u0430\u0440\u0432\u043E\u0442\n5\t.\t.\tCLB\tCLB\tCLB\t2\tpunct\t_\t.",

  without_tabs: "# sent_id = chapID01:paragID1:sentID1\n# text = \u041A\u0435\u0447\u0430\u0435\u043D\u044C \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F \u043A\u0430\u0440\u0432\u043E\u0442 .\n# text[eng] = Kechai was awoken by annoying flies.\n1 \u041A\u0435\u0447\u0430\u0435\u043D\u044C \u041A\u0435\u0447\u0430\u0439 N N Sem/Ant_Mal|Prop|SP|Gen|Indef 2 obj _ \u041A\u0435\u0447\u0430\u0435\u043D\u044C\n2 \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0435\u043C\u0441 V V TV|Ind|Prt1|ScPl3|OcSg3 0 root _ \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C\n3 \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u043E\u043C\u0441 PRC Prc V|TV|PrcPrsL|Sg|Nom|Indef 4 amod _ \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F\n4 \u043A\u0430\u0440\u0432\u043E\u0442 \u043A\u0430\u0440\u0432\u043E N N Sem/Ani|N|Pl|Nom|Indef 2 nsubj _ \u043A\u0430\u0440\u0432\u043E\u0442\n5 . . CLB CLB CLB 2 punct _ .",

  from_cg3_with_semicolumn: "1\tSiedzieli\u015Bmy\tsiedzie\u0107\tvblex\t_\timpf|past|p1|m|pl\t_\t_\t_\t_\n2\tw\tw\tpr\t_\t_\t_\t_\t_\t_\n3\tmoim\tm\xF3j\tprn\t_\tpos|mi|sg|loc\t_\t_\t_\t_\n4\tpokoju\tpok\xF3j\tn\t_\tmi|sg|loc\t_\t_\t_\t_\n5\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n6\tpal\u0105c\tpali\u0107\tvblex\t_\timpf|pprs|adv\t_\t_\t_\t_\n7\ti\ti\tcnjcoo\t_\t_\t_\t_\t_\t_\n8\trozmawiaj\u0105c\trozmawia\u0107\tvblex\t_\timpf|pprs|adv\t_\t_\t_\t_\n9\to\to\tpr\t_\t_\t_\t_\t_\t_\n10\ttem\tto\tprn\t_\tdem|mi|sg|loc\t_\t_\t_\t_\n11\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n12\tjak\tjak\trel\t_\tadv\t_\t_\t_\t_\n13\tmarni\tmarny\tadj\t_\tsint|mp|pl|nom\t_\t_\t_\t_\n14\tjeste\u015Bmy\tby\u0107\tvbser\t_\tpres|p1|pl\t_\t_\t_\t_\n15\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n16\tmarni\tmarny\tadj\t_\tsint|mp|pl|nom\t_\t_\t_\t_\n17\tz\tz\tpr\t_\t_\t_\t_\t_\t_\n18\tlekarskiego\tlekarski\tadj\t_\tmi|sg|gen\t_\t_\t_\t_\n19\tpunktu\tpunkt\tn\t_\tmi|sg|gen\t_\t_\t_\t_\n20\twidzenia\twidzie\u0107\tvblex\t_\timpf|ger|nt|sg|gen\t_\t_\t_\t_\n21\tchc\u0119\tchcie\u0107\tvblex\t_\timpf|pres|p1|sg\t_\t_\t_\t_\n22\tpowiedzie\u0107\tpowiedzie\u0107\tvblex\t_\tperf|inf\t_\t_\t_\t_\n23\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n24\tnaturalnie\tnaturalnie\tadv\t_\tsint\t_\t_\t_\t_\n25\t.\t.\tsent\t_\t_\t_\t_\t_\t_",

  from_cg3_simple: "1\t\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D\t\u043F\u0430\u0442\u0448\u0430\tn\t_\tins\t3\tnmod\t_\t_\n2\t\u0441\u043E\u0493\u044B\u0441\t\u0441\u043E\u0493\u044B\u0441\tn\t_\tnom\t3\tobj\t_\t_\n3\t\u0430\u0448\u049B\u0430\u043D\u0434\u0430\t\u0430\u0448\tv\t_\ttv|ger_past|loc\t12\tadvcl\t_\t_\n4\t,\t,\tcm\t_\t_\t12\tpunct\t_\t_\n5\t\u0435\u043B-\u0436\u04B1\u0440\u0442\t\u0435\u043B-\u0436\u04B1\u0440\u0442\tn\t_\tnom\t7\tconj\t_\t_\n6\t,\t,\tcm\t_\t_\t7\tpunct\t_\t_\n7\t\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B\t\u043E\u0442\u0430\u043D\tn\t_\tpx1sg|acc\t8\tobj\t_\t_\n8\t\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430\t\u049B\u043E\u0440\u0493\u0430\tv\t_\ttv|ger|dat\t12\tadvcl\t_\t_\n9\t,\t,\tcm\t_\t_\t12\tpunct\t_\t_\n10\t\u0431\u0456\u0437\t\u0431\u0456\u0437\tprn\t_\tpers|p1|pl|nom\t12\tnsubj\t_\t_\n11\t\u0441\u043E\u0493\u044B\u0441\u049B\u0430\t\u0441\u043E\u0493\u044B\u0441\tn\t_\tdat\t12\tnmod\t_\t_\n12\t\u0431\u0430\u0440\u0434\u044B\u049B\t\u0431\u0430\u0440\tv\t_\tiv|ifi|p1|pl\t0\troot\t_\t_\n13\t.\t.\tsent\t_\t_\t12\tpunct\t_\t_\n",

  from_cg3_with_spans: "# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n1\tHe\the\tdet\t_\tpos|f|sp\t2\tdet\t_\t_\n2\tboued\tboued\tn\t_\tm|sg\t4\tobj\t_\t_\n3\te\te\tvpart\t_\tobj\t4\taux\t_\t_\n4\ttebr\tdebri\xF1\tvblex\t_\tpri|p3|sg\t0\troot\t_\t_\n5\tMona\tMona\tnp\t_\tant|f|sg\t4\tnsubj\t_\t_\n6-7\ter\t_\t_\t_\t_\t_\t_\t_\t_\n6\t_\te\tpr\t_\t_\t8\tcase\t_\t_\n7\t_\tan\tdet\t_\tdef|sp\t8\tdet\t_\t_\n8\tgegin\tkegin\tn\t_\tf|sg\t4\tobl\t_\t_\n9\t.\t.\tsent\t_\t_\t4\tpunct\t_\t_\n",

  rueter_long: "# sent_id = BryzhinskijMixail_Kirdazht_manu:3859\n# text = \u041D\u043E \u0437\u044F\u0440\u0441 \u0432\u0430\u043B\u0433\u0441\u044C , \u0437\u044F\u0440\u0441 \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044C \u0434\u044B \u043C\u0435\u043A\u0435\u0432 \u043F\u0430\u0440\u0441\u0442\u0435 \u043F\u0435\u043A\u0441\u0442\u043D\u0435\u0441\u044C \u0432\u0435\u043B\u0435 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C , \u043A\u0443\u0436\u043E \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C , \u043A\u0443\u0440\u043E \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u0434\u044B \u044D\u0441\u0435\u0441\u0442 \u044E\u0440\u0442\u0441 \u0441\u043E\u0432\u0430\u043C\u043E \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u044D\u0440\u044C\u0432\u0430 \u043B\u0438\u0441\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C \u0441\u043E\u0432\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C \u0442\u0435 \u0441\u0432\u0430\u043B \u0442\u0435\u0439\u043D\u0435\u043C\u0430 , \u043A\u0435\u043D\u043A\u0448\u0442\u043D\u0435 \u0441\u0432\u0430\u043B \u043F\u0435\u043A\u0441\u0442\u0430\u0437\u044C \u0443\u043B\u0435\u0437\u0442 ; \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044B\u0437\u044C \u043A\u0435\u043B\u0435\u0441 \u0430\u043D\u0441\u044F\u043A \u0432\u0430\u043B\u0441\u043A\u0435 \u043C\u0430\u0440\u0442\u043E \u0434\u044B \u0447\u043E\u043F\u043E\u043D\u044C\u0431\u0435\u043B\u0435\u0432 \u2014 \u0440\u0430\u043A\u0448\u0430\u043D\u044C \u043B\u0438\u0432\u0442\u0435\u043C\u0430 \u0441\u043E\u0432\u0430\u0432\u0442\u043E\u043C\u0430 \u0448\u043A\u0430\u043D\u0435 , \u043A\u0443\u0439\u043C\u0435\u0441\u044C \u0442\u0430\u0433\u043E \u0441\u0442\u0430\u043A\u0430\u043B\u0433\u0430\u0434\u0441\u044C .\n# text_en = But by the time he got down the hill, opened and closed the village gate, the lane gate, the cluster gate and the one to their own home (something everyone coming or going had to do, so the gates would always be closed; they were only opened in the morning and at dusk for taking out and letting in the cattle), the wicker of clay had grown heavy again.\n# text_fi = Kun Ket\u0161ai tuli m\xE4elt\xE4 alas, avasi ja sulki huolellisesti kyl\xE4ver\xE4j\xE4ns\xE4, ??aukio/kentt\xE4ver\xE4j\xE4n, kujaver\xE4j\xE4n ja oman kotiver\xE4j\xE4n, savikontti ehti taas alkaa painaa h\xE4nen selk\xE4\xE4ns\xE4. (Kaikkien k\xE4vij\xF6iden tulee tehd\xE4 n\xE4in, jotta ver\xE4j\xE4t olisivat aina kiinni, ver\xE4j\xE4th\xE4n pidet\xE4\xE4n selkosen sel\xE4ll\xE4\xE4n vain aamulla ja illansuussa, kun karjaa ajetaan laitumelle tai kotiin.)\n1 \u041D\u043E \u043D\u043E CCONJ CC _ 3 cc _ _\n2 \u0437\u044F\u0440\u0441 \u0437\u044F\u0440\u0441 ADV Adv|Der/Ill|Adv|Sem/Time Derivation=Ill|AdvType=Tim 3 mark _ _\n3 \u0432\u0430\u043B\u0433\u0441\u044C \u0432\u0430\u043B\u0433\u043E\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 51 advcl _ SpaceAfter=No\n4 , , PUNCT CLB _ 6 punct _ _\n5 \u0437\u044F\u0440\u0441 \u0437\u044F\u0440\u0441 ADV Adv|Der/Ill|Adv|Sem/Time Derivation=Ill|AdvType=Tim 6 mark _ _\n6 \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044C \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 3 conj _ _\n7 \u0434\u044B \u0434\u044B CCONJ CC _ 10 cc _ _\n8 \u043C\u0435\u043A\u0435\u0432 \u043C\u0435\u043A\u0435\u0432 ADV Adv|Lat|Sg|Nom|Indef Case=Lat|Case=Nom|Definite=Ind|Number=Sing 10 advmod _ _\n9 \u043F\u0430\u0440\u0441\u0442\u0435 \u043F\u0430\u0440\u0441\u0442\u0435 ADV Adv|Manner AdvType=Man 10 advmod _ _\n10 \u043F\u0435\u043A\u0441\u0442\u043D\u0435\u0441\u044C \u043F\u0435\u043A\u0441\u0442\u043D\u0435\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 3 conj _ _\n11 \u0432\u0435\u043B\u0435 \u0432\u0435\u043B\u0435 NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 10 obj _ _\n12 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 11 goeswith _ SpaceAfter=No\n13 , , PUNCT CLB _ 15 punct _ _\n14 \u043A\u0443\u0436\u043E \u043A\u0443\u0436\u043E NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 12 conj _ _\n15 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 14 goeswith _ SpaceAfter=No\n16 , , PUNCT CLB _ 18 punct _ _\n17 \u043A\u0443\u0440\u043E \u043A\u0443\u0440\u043E NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 12 conj _ _\n18 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 17 goeswith _ _\n19 \u0434\u044B \u0434\u044B CCONJ CC _ 23 cc _ _\n20 \u044D\u0441\u0435\u0441\u0442 \u044D\u0441\u044C PRON Pron|Refl|Pl3|Gen|Variant=Short Case=Gen|Number=Plur|Person=3|PronType=Refl|Variant=Short 22 nmod _ _\n21 \u044E\u0440\u0442\u0441 \u044E\u0440\u0442 NOUN N|Sem/Inanim_Cnt|SP|Ill|Indef Case=Ill|Definite=Ind|Number=Plur,Sing 20 case _ _\n22 \u0441\u043E\u0432\u0430\u043C\u043E \u0441\u043E\u0432\u0430\u043C\u043E NOUN N|IV|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing|Valency=1 23 compound _ _\n23 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 12 conj _ _\n24 ( ( PUNCT PUNCT _ 29 punct _ SpaceAfter=No\n25 \u044D\u0440\u044C\u0432\u0430 \u044D\u0440\u044C\u0432\u0430 DET Det|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 26 det _ _\n26 \u043B\u0438\u0441\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C-\u0441\u043E\u0432\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C \u043B\u0438\u0441\u0438\u0446\u044F\u0442-\u0441\u043E\u0432\u0438\u0446\u044F\u0442 NOUN N|V|NomAg|Sg|Dat|Def Case=Dat|Definite=Def|Derivation=NomAg|Number=Sing 29 obl _ _\n27 \u0442\u0435 \u0442\u0435 PRON Pron|Dem|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing|PronType=Dem 29 nsubj _ _\n28 \u0441\u0432\u0430\u043B \u0441\u0432\u0430\u043B ADV Adv|Tot|Sem/Time_dur PronType=Tot|PronType=Tot 29 advmod _ _\n29 \u0442\u0435\u0439\u043D\u0435\u043C\u0430 \u0442\u0435\u0439\u043D\u0435\u043Cc VERB V|TV|Oblig|Clitic=Cop|Prs|ScSg3 Valency=2|VerbForm=Oblig|Clitic=Cop|Number[subj]=Sing|Person[subj]=3|Tense=Pres 3 parataxis _ SpaceAfter=No\n30 , , PUNCT CLB _ 33 punct _ _\n31 \u043A\u0435\u043D\u043A\u0448\u0442\u043D\u0435 \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Pl|Nom|Def Case=Nom|Definite=Def|Number=Plur 34 nsubj _ _\n32 \u0441\u0432\u0430\u043B \u0441\u0432\u0430\u043B ADV Adv|Tot|Sem/Time_dur PronType=Tot|PronType=Tot 33 advmod _ _\n33 \u043F\u0435\u043A\u0441\u0442\u0430\u0437\u044C \u043F\u0435\u043A\u0441\u0442\u0430\u043C\u0441 VERB V|Der/\u041E\u0437\u044C|Ger Derivation=Ozj|VerbForm=Conv 29 ccomp _ _\n34 \u0443\u043B\u0435\u0437\u0442 \u0443\u043B\u0435\u043C\u0441 AUX V|IV|Opt|ScPl3 Mood=Opt|Number[subj]=Plur|Person[subj]=3|Valency=1 33 cop _ SpaceAfter=No\n35 ; ; PUNCT CLB _ 29 punct _ _\n36 \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044B\u0437\u044C \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u043C\u0441 VERB V|Ind|Prs|ScPl3|Obj3 Mood=Ind|Number[subj]=Plur|Person[subj]=3|Tense=Pres|Obj3 29 conj _ _\n37 \u043A\u0435\u043B\u0435\u0441 \u043A\u0435\u043B\u0435\u0441 ADV Adv Adv 36 advmod _ _\n38 \u0430\u043D\u0441\u044F\u043A \u0430\u043D\u0441\u044F\u043A ADV Adv Adv 39 advmod _ _\n39 \u0432\u0430\u043B\u0441\u043A\u0435 \u0432\u0430\u043B\u0441\u043A\u0435 NOUN N|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 36 obl _ _\n40 \u043C\u0430\u0440\u0442\u043E \u043C\u0430\u0440\u0442\u043E ADP Adp|Po AdpType=Post 39 case _ _\n41 \u0434\u044B \u0434\u044B CCONJ CC _ 42 cc _ _\n42 \u0447\u043E\u043F\u043E\u043D\u044C\u0431\u0435\u043B\u0435\u0432 \u0447\u043E\u043F\u043E\u043D\u044C\u0431\u0435\u043B\u0435\u0432 ADV Adv|Lat Case=Lat 39 conj _ _\n43 \u2014 \u2014 PUNCT CLB _ 46 punct _ _\n44 \u0440\u0430\u043A\u0448\u0430\u043D\u044C \u0440\u0430\u043A\u0448\u0430 NOUN N|Sem/Anim_Cnt|SP|Gen|Indef Case=Gen|Definite=Ind|Number=Plur,Sing 45 nmod:gobj _ _\n45 \u043B\u0438\u0432\u0442\u0435\u043C\u0430-\u0441\u043E\u0432\u0430\u0432\u0442\u043E\u043C\u0430 \u043B\u0438\u0432\u0442\u0435\u043C\u0430-\u0441\u043E\u0432\u0430\u0432\u0442\u043E\u043C\u0430 NOUN N|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 36 nmod _ _\n46 \u0448\u043A\u0430\u043D\u0435 \u0448\u043A\u0430 NOUN N|Sem/Time|SP|Temp|Indef Case=Temp|Definite=Ind|Number=Plur,Sing 39 conj _ SpaceAfter=No\n47 ) ) PUNCT PUNCT _ 29 punct _ SpaceAfter=No\n48 , , PUNCT CLB _ 29 punct _ _\n49 \u043A\u0443\u0439\u043C\u0435\u0441\u044C \u043A\u0443\u0439\u043C\u0435 NOUN N|Sem/Inanim_Cnt|Sg|Nom|Def Case=Nom|Definite=Def|Number=Sing 51 nsubj _ _\n50 \u0442\u0430\u0433\u043E \u0442\u0430\u0433\u043E ADV Adv|Sem/Time AdvType=Tim 51 advmod _ _\n51 \u0441\u0442\u0430\u043A\u0430\u043B\u0433\u0430\u0434\u0441\u044C \u0441\u0442\u0430\u043A\u0430\u043B\u0433\u0430\u0434\u043E\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 0 root _ SpaceAfter=No\n52 . . PUNCT CLB _ 51 punct _ _",

  katya_aplonova_large_arrows: "# sent_id = html/meyer_gorog-contes_bambara_10amadu_tara.dis.html:16\n# text = ko ni i sera ka jiri nin bulu s\xF2r\xF2 ka na ni a ye, ko c\xE8k\xF2r\xF2ba b\xE8 se ka furak\xE8 o la.\n1\tko\tk\xF3\tPART\tcop\t_\t4\tdiscourse\t_\tGloss=QUOT\n2\tni\tn\xED\tSCONJ\tconj\t_\t4\tmark\t_\tGloss=si\n3\ti\t\xED\tPRON\tpers\tPronType=Prs\t4\tnsubj\t_\tGloss=2.SG\n4\tsera\tsera\tVERB\tv\tAspect=Perf|Valency=1|Polarity=Pos\t19\tadvcl\t_\tGloss=arriver|Morf=arriver,PFV.INTR\n5\tka\tk\xE0\tAUX\tpm\t_\t9\taux\t_\tGloss=INF\n6\tjiri\tj\xEDri\tNOUN\tn\t_\t8\tnmod:poss\t_\tGloss=arbre\n7\tnin\tn\xECn\tDET\tprn/dtm\tPronType=Dem|Definite-Def\t6\tdet\t_\tGloss=DEM\n8\tbulu\tb\xFAlu\tNOUN\tn\t_\t9\tobj\t_\tGloss=feuille\n9\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tVERB\tv\t_\t4\txcomp\t_\tGloss=obtenir\n10\tka\tk\xE0\tAUX\tpm\t_\t11\taux\t_\tGloss=INF\n11\tna\tn\xE0\tVERB\tv\t_\t9\txcomp\t_\tGloss=venir\n12\tni\tn\xED\tADP\tconj/prep\t_\t13\tcase\t_\tGloss=et\n13\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t11\tobl\t_\tGloss=3SG\n14\tye\ty\xE9\tADP\tpp\t_\t13\tcase\t_\tGloss=PP\n15\t,\t,\tPUNCT\t_\t_\t4\tpunct\t_\tGloss=,\n16\tko\tk\xF3\tPART\tcop\t_\t19\tdiscourse\t_\tGloss=QUOT\n17\tc\xE8k\xF2r\xF2ba\tc\u025B\u0300.k\u0254r\u0254.ba\tNOUN\tn\t_\t19\tnsubj\t_\tGloss=vieillard|Morf=vieillard,m\xE2le,vieux,AUGM\n18\tb\xE8\tb\u025B\u0301\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t19\taux\t_\tGloss=IPFV.AFF\n19\tse\ts\xE9\tVERB\tv\t_\t0\troot\t_\tGloss=arriver\n20\tka\tk\xE0\tAUX\tpm\t_\t21\taux\t_\tGloss=INF\n21\tfurak\xE8\tf\xFAra.k\u025B\tVERB\tv\t_\t19\txcomp\t_\tGloss=soigner|Morf=soigner,feuille,faire\n22\to\t\xF2\tPRON\tprn\t_\t21\tobl\t_\tGloss=ce\n23\tla\tl\xE1\tADP\tpp\t_\t22\tcase\t_\tGloss=dans\n24\t.\t.\tPUNCT\t_\t_\t19\tpunct\t_\tGloss=.\n",

  katya_aplonova_long: "# sent_id = html/meyer_gorog-contes_bambara_10amadu_tara.dis.html:19\n# text = ko u ye m\xF2g\xF2 nyini a ye, min b\xE8 a furak\xE8 sisan ko c\xE8 ye furak\xE8li cogoya b\xE8\xE8 f\xF2, ko fura nin s\xF2r\xF2 ka g\xE8l\xE8n ko epi ko ni o ye a s\xF2r\xF2 u ye ale den de ye, ni min b\xE8 sa de furanyini f\xE8 a ka sa nin min b\xE8 balo o ka balo ko u k\xF2n\xF2nt\xF2 b\xE8\xE8 ka taga fura nin nyini, ko u k\xF2n\xF2nt\xF2 b\xE8\xE8 ka taga ko nin min seginna ka a s\xF2r\xF2 fura ma na, ko a b\xE8 o den nin haramuya ka o g\xE8n, ka a b\xE8 a ba fana g\xE8n ko u ka a fil\xE8 u y\xE8r\xE8 ni min ma s\xF2n fana ko a b\xE8 o g\xE8n, o ni a ba b\xE8\xE8.\n# label = too_long_to_cut\n1\tko\tk\xF3\tPART\tcop\t_\t5\tdiscourse\t_\tGloss=QUOT\n2\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t5\tnsubj\t_\tGloss=3PL\n3\tye\ty\xE9\tAUX\tpm\tAspect=Perf|Valency=2|Polarity=Pos\t5\taux\t_\tGloss=PFV.TR\n4\tm\xF2g\xF2\tm\u0254\u0300g\u0254\tNOUN\tn\t_\t5\tobj\t_\tGloss=homme\n5\tnyini\t\u0272\xEDni\tVERB\tv\t_\t0\troot\t_\tGloss=chercher\n6\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t5\tobl\t_\tGloss=3SG\n7\tye\ty\xE9\tADP\tpp\t_\t6\tcase\t_\tGloss=PP\n8\t,\t,\tPUNCT\t_\t_\t5\tpunct\t_\tGloss=,\n9\tmin\tm\xEDn\tPRON\tprn\tPronType=Rel\t_\t_\t_\tGloss=REL\n10\tb\xE8\tb\u025B\u0301\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n11\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n12\tfurak\xE8\tf\xFAra.k\u025B\tVERB\tv\t_\t_\t_\t_\tGloss=soigner|Morf=soigner,feuille,faire\n13\tsisan\ts\xEDsan\tADV\tadv/n\t_\t_\t_\t_\tGloss=maintenant\n14\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n15\tc\xE8\tc\u025B\u0300\tNOUN\tn\t_\t_\t_\t_\tGloss=m\xE2le\n16\tye\tye\tAUX\tpm\tAspect=Perf|Valency=2|Polarity=Pos\t_\t_\t_\tGloss=PFV.TR\n17\tfurak\xE8li\tf\xFArak\u025Bli\tNOUN\tn\tVerbalForm=Vnoun\t_\t_\t_\tGloss=traitement|Morf=traitement,feuille,faire,NMLZ\n18\tcogoya\tc\xF3goya\tNOUN\tn\t_\t_\t_\t_\tGloss=mani\xE8re|Morf=mani\xE8re,mani\xE8re,ABSTR\n19\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n20\tf\xF2\tf\u0254\u0301\tVERB\tv\t_\t_\t_\t_\tGloss=dire\n21\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n22\tko\tk\xF3\tPART\tcop\t_\t27\tdiscourse\t_\tGloss=QUOT\n23\tfura\tf\xFAra\tNOUN\tn\t_\t25\tnmod:poss\t_\tGloss=feuille\n24\tnin\tn\xECn\tDET\tdtm\tPronType=Dem|Definite-Def\t23\tdet\t_\tGloss=DEM\n25\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tNOUN\tv\t_\t27\tnsubj\t_\tGloss=obtenir\n26\tka\tka\tAUX\tpm\tPolarity=Pos\t27\taux\t_\tGloss=QUAL.AFF\n27\tg\xE8l\xE8n\tg\u025B\u0300l\u025Bn\tVERB\tvq\t_\t_\t_\t_\tGloss=dur\n28\tko\tk\xF3\tPART\tcop\t_\t29\tdiscourse\t_\tGloss=QUOT\n29\tepi\tepi\tCCONJ\tconj\t_\t27\tcc\t_\tGloss=ETRG.FRA\n30\tko\tk\xF3\tVERB\tcop\t_\t37\tdiscourse\t_\tGloss=QUOT\n31\tni\tn\xED\tSCONJ\tconj\t_\t35\tmark\t_\tGloss=si\n32\to\t\xF2\tPRON\tprn\t_\t35\tnsubj\t_\tGloss=ce\n33\tye\tye\tAUX\tpm\tAspect=Perf|Valency=2|Polarity=Pos\t35\taux\t_\tGloss=PFV.TR\n34\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t35\tobj\t_\tGloss=3SG\n35\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tVERB\tv\t_\t37\tadvcl\t_\tGloss=obtenir\n36\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t37\tnsubj\t_\tGloss=3PL\n37\tye\ty\xE9\tVERB\tcop\tPolarity=Pos\t27\tparataxis\t_\tGloss=EQU\n38\tale\t\xE0l\xEA\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3|PronType=Emp\t39\tnmod:poss\t_\tGloss=3SG.EMPH\n39\tden\td\xE9n\tNOUN\tn\t_\t37\tobl\t_\tGloss=enfant\n40\tde\td\xE8\tPART\tprt\t_\t39\tdiscourse\t_\tGloss=FOC\n41\tye\ty\xE9\tADP\tpp\t_\t39\tcase\t_\tGloss=PP\n42\t,\t,\tPUNCT\t_\t_\t37\tpunct\t_\tGloss=,\n43\tni\tn\xED\tSCONJ\tconj\t_\t46\tmark\t_\tGloss=si\n44\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t46\t_\t_\tGloss=REL\n45\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t46\t_\t_\tGloss=IPFV.AFF\n46\tsa\ts\xE0\tVERB\tv\t_\t52\t_\t_\tGloss=mourir\n47\tde\td\xE8\tPART\tprt\t_\t46\t_\t_\tGloss=FOC\n48\tfuranyini\tfura\u0272ini\tNOUN\tn\t_\t46\t_\t_\tGloss=feuille|Morf=feuille,chercher\n49\tf\xE8\tf\u025B\u0300\tADP\tpp\t_\t48\t_\t_\tGloss=par\n50\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t52\t_\t_\tGloss=3SG\n51\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t52\t_\t_\tGloss=SBJV\n52\tsa\ts\xE0\tVERB\tv\t_\t37\t_\t_\tGloss=mourir\n53\tnin\tn\xED\tSCONJ\tconj\t_\t56\tmark\t_\tGloss=quand\n54\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t56\t_\t_\tGloss=REL\n55\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t56\t_\t_\tGloss=IPFV.AFF\n56\tbalo\tb\xE1lo\tVERB\tv\t_\t59\t_\t_\tGloss=vivre\n57\to\t\xF2\tPRON\tprn\t_\t59\t_\t_\tGloss=ce\n58\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t59\t_\t_\tGloss=SBJV\n59\tbalo\tb\xE1lo\tVERB\tv\t_\t52\t_\t_\tGloss=vivre\n60\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n61\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n62\tk\xF2n\xF2nt\xF2\tk\u0254\u0300n\u0254nt\u0254n\tNUM\tnum\t_\t_\t_\t_\tGloss=neuf\n63\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n64\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t_\t_\t_\tGloss=SBJV\n65\ttaga\tt\xE1ga\tVERB\tv\t_\t59\t_\t_\tGloss=aller\n66\tfura\tf\xFAra\tNOUN\tn\t_\t_\t_\t_\tGloss=feuille\n67\tnin\tn\xECn\tDET\tdtm\tPronType=Dem|Definite-Def\t_\t_\t_\tGloss=DEM\n68\tnyini\t\u0272\xEDni\tVERB\tv\t_\t_\t_\t_\tGloss=chercher\n69\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n70\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n71\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n72\tk\xF2n\xF2nt\xF2\tk\u0254\u0300n\u0254nt\u0254n\tNUM\tnum\t_\t_\t_\t_\tGloss=neuf\n73\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n74\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t_\t_\t_\tGloss=SBJV\n75\ttaga\tt\xE1ga\tVERB\tv\t_\t65\t_\t_\tGloss=aller\n76\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n77\tnin\tn\xED\tSCONJ\tconj\t_\t_\t_\t_\tGloss=quand\n78\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t_\t_\t_\tGloss=REL\n79\tseginna\tseginna\tVERB\tv\tAspect=Perf|Valency=1|Polarity=Pos\t85\t_\t_\tGloss=revenir|Morf=revenir,PFV.INTR\n80\tka\tk\xE0\tAUX\tpm\t_\t_\t_\t_\tGloss=INF\n81\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n82\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tVERB\tv\t_\t_\t_\t_\tGloss=obtenir\n83\tfura\tf\xFAra\tNOUN\tn\t_\t_\t_\t_\tGloss=feuille\n84\tma\tma\tAUX\tpm\tPolarity=Neg|Aspect=Perf\t_\t_\t_\tGloss=PFV.NEG\n85\tna\tn\xE0\tVERB\tv\t_\t75\t_\t_\tGloss=venir\n86\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n87\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n88\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n89\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n90\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n91\tden\td\xE9n\tNOUN\tn\t_\t_\t_\t_\tGloss=enfant\n92\tnin\tn\xECn\tDET\tdtm\tPronType=Dem|Definite-Def\t_\t_\t_\tGloss=DEM\n93\tharamuya\th\xE0ramuya\tVERB\tv\t_\t85\t_\t_\tGloss=interdire|Morf=interdire,interdire,ABSTR\n94\tka\tk\xE0\tAUX\tpm\t_\t_\t_\t_\tGloss=INF\n95\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n96\tg\xE8n\tg\u025B\u0301n\tVERB\tv\t_\t_\t_\t_\tGloss=chasser\n97\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n98\tka\tk\xE0\tAUX\tpm\t_\t_\t_\t_\tGloss=INF\n99\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n100\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n101\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n102\tba\tb\xE1\tNOUN\tn\t_\t_\t_\t_\tGloss=m\xE8re\n103\tfana\tf\xE1na\tPART\tprt\t_\t_\t_\t_\tGloss=aussi\n104\tg\xE8n\tg\u025B\u0301n\tVERB\tv\t_\t_\t_\t_\tGloss=chasser\n105\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n106\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n107\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t_\t_\t_\tGloss=SBJV\n108\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n109\tfil\xE8\tf\xEDl\u025B\tVERB\tv\t_\t_\t_\t_\tGloss=regarder\n110\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n111\ty\xE8r\xE8\ty\u025B\u0300r\u025B\u0302\tDET\tdtm\t_\t_\t_\t_\tGloss=m\xEAme\n112\tni\tn\xED\tSCONJ\tconj\t_\t_\t_\t_\tGloss=si\n113\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t_\t_\t_\tGloss=REL\n114\tma\tma\tAUX\tpm\tPolarity=Neg|Aspect=Perf\t_\t_\t_\tGloss=PFV.NEG\n115\ts\xF2n\ts\u0254\u0300n\tVERB\tv\t_\t_\t_\t_\tGloss=accepter\n116\tfana\tf\xE1na\tPART\tprt\t_\t_\t_\t_\tGloss=aussi\n117\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n118\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n119\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n120\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n121\tg\xE8n\tg\u025B\u0301n\tVERB\tv\t_\t_\t_\t_\tGloss=chasser\n122\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n123\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n124\tni\tni\tCCONJ\tconj\t_\t_\t_\t_\tGloss=et\n125\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n126\tba\tb\xE1\tNOUN\tn\t_\t_\t_\t_\tGloss=m\xE8re\n127\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n128\t.\t.\tPUNCT\t_\t_\t_\t_\t_\tGloss=.",

  ud_example_tabs: "1\tThey\tthey\tPRON\tPRP\tCase=Nom|Number=Plur\t2\tnsubj\t2:nsubj|4:nsubj\t_\n2\tbuy\tbuy\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Pres\t0\troot\t_\t_\n3\tand\tand\tCONJ\tCC\t_\t4\tcc\t4:cc\t_\n4\tsell\tsell\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Pres\t2\tconj\t2:conj\t_\n5\tbooks\tbook\tNOUN\tNNS\tNumber=Plur\t2\tobj\t2:obj|4:obj\t_\n6\t.\t.\tPUNCT\t.\t_\t2\tpunct\t2:punct\t_",

  ud_example_spaces: "1    They     they    PRON    PRP    Case=Nom|Number=Plur               2    nsubj    2:nsubj|4:nsubj _\n2    buy      buy     VERB    VBP    Number=Plur|Person=3|Tense=Pres    0    root     _          _\n3    and      and     CONJ    CC     _                                  4    cc       4:cc            _\n4    sell     sell    VERB    VBP    Number=Plur|Person=3|Tense=Pres    2    conj     2:conj   _\n5    books    book    NOUN    NNS    Number=Plur                        2    obj      2:obj|4:obj     _\n6    .        .       PUNCT   .      _                                  2    punct    2:punct         _",

  ud_example_modified: "1\tThey\tthey\tPRON\tPRP\tCase=Nom|Number=Plur\t2\tnsubj\t2:nsubj|4:nsubj\t_\n2\tbuy\tbuy\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Presroot\t0:root\t_\t_\t_\n3\tand\tand\tCONJ\tCC\t_\t4\tcc\t4:cc\t_\n4\tsell\tsell\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Presconj\t0:root|2:conj\t_\t_\t_\n5\tbooks\tbook\tNOUN\tNNS\tNumber=Plur\t2\tobj\t2:obj|4:obj\t_\n6\t.\t.\tPUNCT\t.\t_\t2\tpunct\t2:punct\t_"
};

},{}],29:[function(require,module,exports){
'use strict';

module.exports = {
  'Brackets': require('./brackets'),
  'CG3': require('./cg3'),
  'CoNLL-U': require('./conllu'),
  'plain text': require('./plain-text'),
  'SD': require('./sd'),
  'Unknown': require('./unknown')
};

},{"./brackets":26,"./cg3":27,"./conllu":28,"./plain-text":30,"./sd":31,"./unknown":32}],30:[function(require,module,exports){
'use strict';

module.exports = {
  0: 'this is a test',
  1: 'this is a test.',
  2: 'this is a test...',
  3: 'this is a test?',
  4: '\tthis is a test',
  5: 'More sentences = more data; ipso facto, yes.',
  parens_and_numbers: '\u0414\u04D9\u04AF\u043B\u04D9\u0442\u043B\u04D9\u0440\u043D\u0435\u04A3, \u0448\u0443\u043B \u0438\u0441\u04D9\u043F\u0442\u04D9\u043D \u0420\u0443\u0441\u0438\u044F\u043D\u0435\u04A3 \u0434\u04D9, \u0434\u0438\u04A3\u0433\u0435\u0437 \u0447\u0438\u043A\u043B\u04D9\u0440\u0435 \u044F\u0440\u0434\u0430\u043D 12 \u043C\u0438\u043B\u044C (\u044F\u043A\u0438 22,2 \u043A\u043C) \u0435\u0440\u0430\u043A\u043B\u044B\u043A\u0442\u0430 \u0443\u0437\u0443\u044B \u043A\u0438\u043B\u0435\u0448\u0435\u043D\u0433\u04D9\u043D'
};

},{}],31:[function(require,module,exports){
'use strict';

module.exports = {
  0: 'And Robert the fourth place .\ncc(Robert, And)\norphan(Robert, place)\npunct(Robert, .)\namod(place, fourth)\ndet(place, the)',

  1: 'ROOT And Robert the fourth place .\nroot(ROOT, Robert)\ncc(Robert, And)\norphan(Robert, place)\npunct(Robert, .)\namod(place, fourth)\ndet(place, the)',

  2: 'ROOT I love French fries .\nroot(ROOT, love)',

  // https://github.com/UniversalDependencies/docs/blob/pages-source/_u-dep/ccomp.md
  ccomp_1: 'He says that you like to swim\nccomp(says, like)\nmark(like, that)',

  ccomp_2: 'He says you like to swim\nccomp(says, like)',

  ccomp_3: 'The boss said to start digging\nccomp(said, start)\nmark(start, to)',

  ccomp_4: 'We started digging\nxcomp(started, digging)',

  ccomp_5: 'The important thing is to keep calm.\nccomp(is, keep)\nnsubj(is, thing)',

  ccomp_6: 'The problem is that this has never been tried .\nccomp(is, tried)\nnsubj(is, problem)'
};

},{}],32:[function(require,module,exports){
'use strict';

module.exports = {
  0: '',
  1: '\n',
  2: ' ',
  3: '\t',
  4: ' \t\n',
  5: '    '
};

},{}],33:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var UndoManager = require('undo-manager');

module.exports = function () {
	window.undoManager = new UndoManager();

	$('#btnUndo').click(function () {
		undoManager.undo();
	});
	$('#btnRedo').click(function () {
		undoManager.redo();
	});
};

},{"jquery":394,"undo-manager":500}],34:[function(require,module,exports){
'use strict';

var _ = require('underscore');

var status = require('./status');
var funcs = require('./funcs');

function login() {
  if (!server.is_running) return null;

  funcs.link('/oauth/login?treebank_id=' + funcs.getTreebankId(), '_self');
}

function logout() {
  if (!server.is_running) return null;

  funcs.link('/logout?treebank_id=' + funcs.getTreebankId(), '_self');
}

function repos() {
  funcs.link('/repos');
}

function permissions() {
  funcs.link('/permissions');
}

module.exports = {
  login: login,
  logout: logout,
  manage: {
    permissions: permissions,
    repos: repos
  }
};

},{"./funcs":9,"./status":24,"underscore":499}],35:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');

var Users = function Users() {
  _classCallCheck(this, Users);
};

module.exports = Users;

},{"underscore":499}],36:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var _ = require('underscore');

var U_DEPRELS = ['acl', 'advcl', 'advmod', 'amod', 'appos', 'aux', 'case', 'cc', 'ccomp', 'clf', 'compound', 'conj', 'cop', 'csubj', 'dep', 'det', 'discourse', 'dislocated', 'expl', 'fixed', 'flat', 'goeswith', 'iobj', 'list', 'mark', 'nmod', 'nsubj', 'nummod', 'obj', 'obl', 'orphan', 'parataxis', 'punct', 'reparandum', 'root', 'vocative', 'xcomp'];
var U_POS = ['ADJ', 'ADP', 'ADV', 'AUX', 'CCONJ', 'DET', 'INTJ', 'NOUN', 'NUM', 'PART', 'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'SYM', 'VERB', 'X'];

// TODO: Make this more clever, e.g. CCONJ can have a dependent in certain
// circumstances, e.g. and / or
var U_POS_LEAF = ['AUX', 'CCONJ', 'PART', 'PUNCT', 'SCONJ']; // no ADP

function is_upos(s) {
  log.debug('called is_pos(' + s + ')');

  // Checks if a relation is in the list of valid parts of speech
  // @s = the input relation
  // returns a bool
  s = (s || '').toUpperCase();

  var is_upos = false;
  _.each(U_POS, function (u_pos) {
    if (s === u_pos) is_upos = true;
  });

  return is_upos;
}

function is_udeprel(s) {
  log.debug('called is_udeprel(' + s + ')');

  // Checks if a relation is in the list of valid relations
  // @s = the input relation
  // returns a bool

  // Language-specific relations are `${universal_relation}:${some_string}`
  s = (s || '').split(':')[0].toLowerCase();

  var is_deprel = false;
  _.each(U_DEPRELS, function (u_deprel) {
    if (s.toLowerCase() === u_deprel) is_deprel = true;
  });

  return is_deprel;
}

function is_leaf(s) {
  log.debug('called is_leaf(' + s + ')');

  // Checks if a node is in the list of part-of-speech tags which
  // are usually leaf nodes
  // @s = part of speech tag

  // http://universaldependencies.org/u/dep/punct.html
  // Tokens with the relation punct always attach to content words (except in cases of ellipsis) and can never have dependents.
  s = (s || '').toUpperCase();

  var is_leaf = false;
  _.each(U_POS_LEAF, function (u_pos) {
    if (s === u_pos) is_leaf = true;
  });

  return is_leaf;
}

/*
function is_projective_nodes(tree, nodeList) {
  log.debug(`called is_projective_nodes(tree: ${JSON.stringify(tree)}, nodeList: ${JSON.stringify(nodeList)})`);

  let heads = {};

  $.each(tree, (i, node) => {
      if (node) {
          if (node.head && node.id) {
              heads[id] = head;
              nodes.push(id);
          }
      }
  });

  const nodes = Object.keys(heads);
  log.debug(`is_projective_nodes(): heads: ${JSON.stringify(heads)}`);

  $.each(nodeList, (i, nodeIdFromList) => {
    const nodeToCheck = nodes[nodeIdFromList],
      headToCheck = heads[nodeIdFromList];

    $.each(nodes, (j, node) => {
      const head = heads[node];

      log.debug(`is_projective_nodes(): checking (node: ${nodeToCheck}, head: ${headToCheck}) against (node: ${node}, head: ${head})`);
      if (node > nodeToCheck && node < headToCheck
        && (head > headToCheck || head < nodeToCheck))
        return false;
      if (node > headToCheck && node < nodeToCheck
        && (head > nodeToCheck || head < headToCheck))
        return false;
      if (head > nodeToCheck && head < headToCheck
        && (node < nodeToCheck || node > headToCheck))
        return false;
      if (head > headToCheck && head < nodeToCheck
        && (node > nodeToCheck || node < headToCheck))
        return false;
    });
  });

  log.debug(`is_projective_nodes(): got true`);
  return true;
}
*/

/*
function is_projective(tree) {
    log.debug(`called is_projective(${JSON.stringify(tree)})`);

    // Checks to see if a graph is projective
    var nodes = [];
    var heads = {};
    for(let node in tree) {
        if (!tree[node] || tree[node] == undefined) {
            continue;
        }
        var head = tree[node].head;
        var id = tree[node].id;
        if (!head || !id) {
            continue;
        }
        head = parseInt(head);
        id = parseInt(id.slice(2));
        heads[id] = head;
        nodes.push(id);
    }

//    console.log('is_projective()','heads', heads);
//    console.log('is_projective()','nodes', nodes);

    var res = true;

    for(let i in nodes) {
        var n_i =  nodes[i];
        for(let j in nodes) {
            var n_j =  nodes[j];
            //console.log('i:',nodes[i],'j:',nodes[j],'h(i):',heads[n_i],'h(j):',heads[n_j]);
            if ((nodes[j] > nodes[i]) && (nodes[j] < heads[n_i])) {
                if ((heads[n_j] > heads[n_i]) || (heads[n_j] < nodes[i])) {
                    res = false;
                    console.log('[0] is_projective()',res);
                    return res;
                }
            }
            if ((nodes[j] > heads[n_i]) && (nodes[j] < nodes[i])) {
                if ((heads[n_j] > nodes[i]) || (heads[n_j] < heads[n_i])) {
                    res = false;
                    console.log('[1] is_projective()',res);
                    return res;
                }
            }
            if (heads[n_j] > nodes[i] && heads[n_j] < heads[n_i]) {
                if (nodes[j] < nodes[i] || nodes[j] > heads[n_i]) {
                    res = false;
                    console.log('[2] is_projective()',res);
                    return res;
                }
            }
            if (heads[n_j] > heads[n_i] && heads[n_j] < nodes[i]) {
                if (nodes[j] > nodes[i] || nodes[j] < heads[n_i]) {
                    res = false;
                    console.log('[3] is_projective()',res);
                    return res;
                }
            }
        }
    }
//    console.log('is_projective()', res);

    return res;
}
*/

/*
function is_relation_conflict(tree) {
  log.debug(`called is_relation_conflict(${JSON.stringify(tree)})`);


  let count = new Map();
  $.each(tree, (i, word) => {
    if (word.deprel !== undefined) {
      list = (count.has(word.deprel) ? count.get(word.deprel) : []).concat(word.head);
      count.set(word.deprel, list);
    }
  });
  log.debug(`count: ${JSON.stringify(count)}`);


  let totalSubjects = new Map();
  if (count.has('nsubj')) {
    $.each(count.get('nsubj'), (i, nsubj) => {
      value = (totalSubjects.has(nsubj) ? totalSubjects.get(nsubj) + 1 : 1);
      totalSubjects.set(nsubj, value);
    });
  }
  if (count.has('csubj')) {
    $.each(count.get('csubj'), (i, csubj) => {
      value = (totalSubjects.has(csubj) ? totalSubjects.get(csubj) + 1 : 1);
      totalSubjects.set(nsubj, value);
    });
  }
  log.debug(`totalSubjects: ${JSON.stringify(totalSubjects)}`);


  let totalObjects = new Map();
  if (count.has('obj')) {
    $.each(count.get('obj'), (i, obj) => {
      value = (totalObjects.has(obj) ? totalObjects.get(obj) + 1 : 1);
      totalObjects.set(obj, value);
    });
  }
  log.debug(`totalObjects: ${JSON.stringify(totalObjects)}`);


  let conflicts = new Map();
  totalSubjects.forEach((i, subj, map) => {
    if (i > 1) {
      list = (conflicts.has(subj) ? conflicts.get(subj) : []).concat('subj');
      conflicts.set(subj, list);
    }
  });
  totalObjects.forEach((i, obj, map) => {
    if (i > 1) {
      list = (conflicts.has(obj) ? conflicts.get(obj) : []).concat('obj');
      conflicts.set(obj, list);
    }
  });
  if (count.has('obj') && count.has('ccomp'))
      conflicts.set('objccomp', []);
  log.debug(`conflicts: ${JSON.stringify(conflicts)}`);


  return conflicts;
}
*/

function is_cycle(graph, src, tar) {

  // recursive DFS
  function is_cycle_util(graph, src, tar) {

    // visit node
    seen.add(tar);

    // iterate neighbors
    var is_cycle = false;
    if (!tar.eachHead) {
      log.error('unable to read property eachHead of tar: ' + tar);
      return;
    }

    tar.eachHead(function (head) {

      is_cycle = head === src ? true // got back to source
      : seen.has(head) ? false : is_cycle_util(graph, src, head); // recurse
    });

    return is_cycle;
  }

  // keep track of visited nodes
  var seen = new Set();
  return is_cycle_util(graph, src, tar);
}

function depEdgeClasses(graph, ele) {
  var src = ele.data.sourceToken,
      tar = ele.data.targetToken;

  var classes = new Set(['dependency']);

  if (is_leaf(tar.upostag)) classes.add('error');

  if (is_cycle(graph, src, tar)) classes.add('error');

  var deprel = ele.data.deprel || src.deprel;

  if (!deprel || deprel === '_') {
    classes.add('incomplete');
  } else if (!is_udeprel(deprel)) {
    classes.add('error');
  }

  return Array.from(classes).join(' ');
}

function posNodeClasses(ele) {
  if (is_upos(ele.data.pos)) {
    return 'pos';
  } else {
    return 'pos error';
  }
}

module.exports = {
  U_DEPRELS: U_DEPRELS,
  U_POS: U_POS,
  depEdgeClasses: depEdgeClasses,
  posNodeClasses: posNodeClasses,
  is_upos: is_upos,
  is_udeprel: is_udeprel
};

},{"jquery":394,"underscore":499}],37:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],38:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],39:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/fn/regexp/escape":51,"core-js/shim":374,"regenerator-runtime/runtime":40}],40:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],41:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],42:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],43:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],44:[function(require,module,exports){

},{}],45:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],46:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":45,"ieee754":392}],47:[function(require,module,exports){
/*!!
 *  Canvas 2 Svg v1.0.15
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */

;(function() {
    "use strict";

    var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;

    //helper function to format a string
    function format(str, args) {
        var keys = Object.keys(args), i;
        for (i=0; i<keys.length; i++) {
            str = str.replace(new RegExp("\\{" + keys[i] + "\\}", "gi"), args[keys[i]]);
        }
        return str;
    }

    //helper function that generates a random string
    function randomString(holder) {
        var chars, randomstring, i;
        if (!holder) {
            throw new Error("cannot create a random attribute name for an undefined object");
        }
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
        randomstring = "";
        do {
            randomstring = "";
            for (i = 0; i < 12; i++) {
                randomstring += chars[Math.floor(Math.random() * chars.length)];
            }
        } while (holder[randomstring]);
        return randomstring;
    }

    //helper function to map named to numbered entities
    function createNamedToNumberedLookup(items, radix) {
        var i, entity, lookup = {}, base10, base16;
        items = items.split(',');
        radix = radix || 10;
        // Map from named to numbered entities.
        for (i = 0; i < items.length; i += 2) {
            entity = '&' + items[i + 1] + ';';
            base10 = parseInt(items[i], radix);
            lookup[entity] = '&#'+base10+';';
        }
        //FF and IE need to create a regex from hex values ie &nbsp; == \xa0
        lookup["\\xa0"] = '&#160;';
        return lookup;
    }

    //helper function to map canvas-textAlign to svg-textAnchor
    function getTextAnchor(textAlign) {
        //TODO: support rtl languages
        var mapping = {"left":"start", "right":"end", "center":"middle", "start":"start", "end":"end"};
        return mapping[textAlign] || mapping.start;
    }

    //helper function to map canvas-textBaseline to svg-dominantBaseline
    function getDominantBaseline(textBaseline) {
        //INFO: not supported in all browsers
        var mapping = {"alphabetic": "alphabetic", "hanging": "hanging", "top":"text-before-edge", "bottom":"text-after-edge", "middle":"central"};
        return mapping[textBaseline] || mapping.alphabetic;
    }

    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    // entity mapping courtesy of tinymce
    namedEntities = createNamedToNumberedLookup(
        '50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
            '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
            '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
            '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
            '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
            '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
            '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
            '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
            '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
            '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
            'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
            'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
            't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
            'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
            'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
            '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
            '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
            '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
            '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
            '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
            'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
            'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
            'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
            '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
            '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);


    //Some basic mappings for attributes and default values.
    STYLES = {
        "strokeStyle":{
            svgAttr : "stroke", //corresponding svg attribute
            canvas : "#000000", //canvas default
            svg : "none",       //svg default
            apply : "stroke"    //apply on stroke() or fill()
        },
        "fillStyle":{
            svgAttr : "fill",
            canvas : "#000000",
            svg : null, //svg default is black, but we need to special case this to handle canvas stroke without fill
            apply : "fill"
        },
        "lineCap":{
            svgAttr : "stroke-linecap",
            canvas : "butt",
            svg : "butt",
            apply : "stroke"
        },
        "lineJoin":{
            svgAttr : "stroke-linejoin",
            canvas : "miter",
            svg : "miter",
            apply : "stroke"
        },
        "miterLimit":{
            svgAttr : "stroke-miterlimit",
            canvas : 10,
            svg : 4,
            apply : "stroke"
        },
        "lineWidth":{
            svgAttr : "stroke-width",
            canvas : 1,
            svg : 1,
            apply : "stroke"
        },
        "globalAlpha": {
            svgAttr : "opacity",
            canvas : 1,
            svg : 1,
            apply : "fill stroke"
        },
        "font":{
            //font converts to multiple svg attributes, there is custom logic for this
            canvas : "10px sans-serif"
        },
        "shadowColor":{
            canvas : "#000000"
        },
        "shadowOffsetX":{
            canvas : 0
        },
        "shadowOffsetY":{
            canvas : 0
        },
        "shadowBlur":{
            canvas : 0
        },
        "textAlign":{
            canvas : "start"
        },
        "textBaseline":{
            canvas : "alphabetic"
        }
    };

    /**
     *
     * @param gradientNode - reference to the gradient
     * @constructor
     */
    CanvasGradient = function(gradientNode, ctx) {
        this.__root = gradientNode;
        this.__ctx = ctx;
    };

    /**
     * Adds a color stop to the gradient root
     */
    CanvasGradient.prototype.addColorStop = function(offset, color) {
        var stop = this.__ctx.__createElement("stop"), regex, matches;
        stop.setAttribute("offset", offset);
        if(color.indexOf("rgba") !== -1) {
            //separate alpha value, since webkit can't handle it
            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches = regex.exec(color);
            stop.setAttribute("stop-color", format("rgb({r},{g},{b})", {r:matches[1], g:matches[2], b:matches[3]}));
            stop.setAttribute("stop-opacity", matches[4]);
        } else {
            stop.setAttribute("stop-color", color);
        }
        this.__root.appendChild(stop);
    };

    CanvasPattern = function(pattern, ctx) {
        this.__root = pattern;
        this.__ctx = ctx;
    };

    /**
     * The mock canvas context
     * @param o - options include:
     * width - width of your canvas (defaults to 500)
     * height - height of your canvas (defaults to 500)
     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)
     * document - the document object (defaults to the current document)
     */
    ctx = function(o) {

        var defaultOptions = { width:500, height:500, enableMirroring : false}, options;

        //keep support for this way of calling C2S: new C2S(width,height)
        if(arguments.length > 1) {
            options = defaultOptions;
            options.width = arguments[0];
            options.height = arguments[1];
        } else if( !o ) {
            options = defaultOptions;
        } else {
            options = o;
        }

        if(!(this instanceof ctx)) {
            //did someone call this without new?
            return new ctx(options);
        }

        //setup options
        this.width = options.width || defaultOptions.width;
        this.height = options.height || defaultOptions.height;
        this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;

        this.canvas = this;   ///point back to this instance!
        this.__document = options.document || document;
        this.__canvas = this.__document.createElement("canvas");
        this.__ctx = this.__canvas.getContext("2d");

        this.__setDefaultStyles();
        this.__stack = [this.__getStyleState()];
        this.__groupStack = [];

        //the root svg element
        this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.__root.setAttribute("version", 1.1);
        this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        this.__root.setAttribute("width", this.width);
        this.__root.setAttribute("height", this.height);

        //make sure we don't generate the same ids in defs
        this.__ids = {};

        //defs tag
        this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
        this.__root.appendChild(this.__defs);

        //also add a group child. the svg element can't use the transform attribute
        this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
        this.__root.appendChild(this.__currentElement);
    };


    /**
     * Creates the specified svg element
     * @private
     */
    ctx.prototype.__createElement = function (elementName, properties, resetFill) {
        if (typeof properties === "undefined") {
            properties = {};
        }

        var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName),
            keys = Object.keys(properties), i, key;
        if(resetFill) {
            //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.
            element.setAttribute("fill", "none");
            element.setAttribute("stroke", "none");
        }
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            element.setAttribute(key, properties[key]);
        }
        return element;
    };

    /**
     * Applies default canvas styles to the context
     * @private
     */
    ctx.prototype.__setDefaultStyles = function() {
        //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/
        var keys = Object.keys(STYLES), i, key;
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            this[key] = STYLES[key].canvas;
        }
    };

    /**
     * Applies styles on restore
     * @param styleState
     * @private
     */
    ctx.prototype.__applyStyleState = function(styleState) {
        var keys = Object.keys(styleState), i, key;
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            this[key] = styleState[key];
        }
    };

    /**
     * Gets the current style state
     * @return {Object}
     * @private
     */
    ctx.prototype.__getStyleState = function() {
        var i, styleState = {}, keys = Object.keys(STYLES), key;
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            styleState[key] = this[key];
        }
        return styleState;
    };

    /**
     * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
     * @param type
     * @private
     */
    ctx.prototype.__applyStyleToCurrentElement = function(type) {
        var keys = Object.keys(STYLES), i, style, value, id, regex, matches;
        for(i=0; i<keys.length; i++) {
            style = STYLES[keys[i]];
            value = this[keys[i]];
            if(style.apply) {
                //is this a gradient or pattern?
                if(style.apply.indexOf("fill")!==-1 && value instanceof CanvasPattern) {
                    //pattern
                    if(value.__ctx) {
                        //copy over defs
                        while(value.__ctx.__defs.childNodes.length) {
                            id = value.__ctx.__defs.childNodes[0].getAttribute("id");
                            this.__ids[id] = id;
                            this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                        }
                    }
                    this.__currentElement.setAttribute("fill", format("url(#{id})", {id:value.__root.getAttribute("id")}));
                }
                else if(style.apply.indexOf("fill")!==-1 && value instanceof CanvasGradient) {
                    //gradient
                    this.__currentElement.setAttribute("fill", format("url(#{id})", {id:value.__root.getAttribute("id")}));
                } else if(style.apply.indexOf(type)!==-1 && style.svg !== value) {
                    if((style.svgAttr === "stroke" || style.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
                        //separate alpha value, since illustrator can't handle it
                        regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                        matches = regex.exec(value);
                        this.__currentElement.setAttribute(style.svgAttr, format("rgb({r},{g},{b})", {r:matches[1], g:matches[2], b:matches[3]}));
                        this.__currentElement.setAttribute(style.svgAttr+"-opacity", matches[4]);
                    } else {
                        //otherwise only update attribute if right type, and not svg default
                        this.__currentElement.setAttribute(style.svgAttr, value);
                    }
                }
            }
        }

    };

    /**
     * Will return the closest group or svg node. May return the current element.
     * @private
     */
    ctx.prototype.__closestGroupOrSvg = function(node) {
        node = node || this.__currentElement;
        if(node.nodeName === "g" || node.nodeName === "svg") {
            return node;
        } else {
            return this.__closestGroupOrSvg(node.parentNode);
        }
    };

    /**
     * Returns the serialized value of the svg so far
     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
     *                           If true, we attempt to find all named entities and encode it as a numeric entity.
     * @return serialized svg
     */
    ctx.prototype.getSerializedSvg = function(fixNamedEntities) {
        var serialized = new XMLSerializer().serializeToString(this.__root),
            keys, i, key, value, regexp, xmlns;

        //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly
        xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
        if(xmlns.test(serialized)) {
            serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg','xmlns:xlink="http://www.w3.org/1999/xlink');
        }

        if(fixNamedEntities) {
            keys = Object.keys(namedEntities);
            //loop over each named entity and replace with the proper equivalent.
            for(i=0; i<keys.length; i++) {
                key = keys[i];
                value = namedEntities[key];
                regexp = new RegExp(key, "gi");
                if(regexp.test(serialized)) {
                    serialized = serialized.replace(regexp, value);
                }
            }
        }

        return serialized;
    };


    /**
     * Returns the root svg
     * @return
     */
    ctx.prototype.getSvg = function() {
        return this.__root;
    };
    /**
     * Will generate a group tag.
     */
    ctx.prototype.save = function() {
        var group = this.__createElement("g"), parent = this.__closestGroupOrSvg();
        this.__groupStack.push(parent);
        parent.appendChild(group);
        this.__currentElement = group;
        this.__stack.push(this.__getStyleState());
    };
    /**
     * Sets current element to parent, or just root if already root
     */
    ctx.prototype.restore = function(){
        this.__currentElement = this.__groupStack.pop();
        var state = this.__stack.pop();
        this.__applyStyleState(state);

    };

    /**
     * Helper method to add transform
     * @private
     */
    ctx.prototype.__addTransform = function(t) {

        //if the current element has siblings, add another group
        var parent = this.__closestGroupOrSvg();
        if(parent.childNodes.length > 0) {
            var group = this.__createElement("g");
            parent.appendChild(group);
            this.__currentElement = group;
        }

        var transform = this.__currentElement.getAttribute("transform");
        if(transform) {
            transform += " ";
        } else {
            transform = "";
        }
        transform += t;
        this.__currentElement.setAttribute("transform", transform);
    };

    /**
     *  scales the current element
     */
    ctx.prototype.scale = function(x, y) {
        if(y === undefined) {
            y = x;
        }
        this.__addTransform(format("scale({x},{y})", {x:x, y:y}));
    };

    /**
     * rotates the current element
     */
    ctx.prototype.rotate = function(angle){
        var degrees = (angle * 180 / Math.PI);
        this.__addTransform(format("rotate({angle},{cx},{cy})", {angle:degrees, cx:0, cy:0}));
    };

    /**
     * translates the current element
     */
    ctx.prototype.translate = function(x, y){
        this.__addTransform(format("translate({x},{y})", {x:x,y:y}));
    };

    /**
     * applies a transform to the current element
     */
    ctx.prototype.transform = function(a, b, c, d, e, f){
        this.__addTransform(format("matrix({a},{b},{c},{d},{e},{f})", {a:a, b:b, c:c, d:d, e:e, f:f}));
    };

    /**
     * Create a new Path Element
     */
    ctx.prototype.beginPath = function(){
        var path, parent;

        // Note that there is only one current default path, it is not part of the drawing state.
        // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path
        this.__currentDefaultPath = "";
        this.__currentPosition = {};

        path = this.__createElement("path", {}, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(path);
        this.__currentElement = path;
    };

    /**
     * Helper function to apply currentDefaultPath to current path element
     * @private
     */
    ctx.prototype.__applyCurrentDefaultPath = function() {
        if(this.__currentElement.nodeName === "path") {
            var d = this.__currentDefaultPath;
            this.__currentElement.setAttribute("d", d);
        } else {
            throw new Error("Attempted to apply path command to node " + this.__currentElement.nodeName);
        }
    };

    /**
     * Helper function to add path command
     * @private
     */
    ctx.prototype.__addPathCommand = function(command){
        this.__currentDefaultPath += " ";
        this.__currentDefaultPath += command;
    };

    /**
     * Adds the move command to the current path element,
     * if the currentPathElement is not empty create a new path element
     */
    ctx.prototype.moveTo = function(x,y){
        if(this.__currentElement.nodeName !== "path") {
            this.beginPath();
        }

        // creates a new subpath with the given point
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("M {x} {y}", {x:x, y:y}));
    };

    /**
     * Closes the current path
     */
    ctx.prototype.closePath = function(){
        this.__addPathCommand("Z");
    };

    /**
     * Adds a line to command
     */
    ctx.prototype.lineTo = function(x, y){
        this.__currentPosition = {x: x, y: y};
        if (this.__currentDefaultPath.indexOf('M') > -1) {
            this.__addPathCommand(format("L {x} {y}", {x:x, y:y}));
        } else {
            this.__addPathCommand(format("M {x} {y}", {x:x, y:y}));
        }
    };

    /**
     * Add a bezier command
     */
    ctx.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
            {cp1x:cp1x, cp1y:cp1y, cp2x:cp2x, cp2y:cp2y, x:x, y:y}));
    };

    /**
     * Adds a quadratic curve to command
     */
    ctx.prototype.quadraticCurveTo = function(cpx, cpy, x, y){
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("Q {cpx} {cpy} {x} {y}", {cpx:cpx, cpy:cpy, x:x, y:y}));
    };


    /**
     * Return a new normalized vector of given vector
     */
    var normalize = function(vector) {
        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
        return [vector[0] / len, vector[1] / len];
    };

    /**
     * Adds the arcTo to the current path
     *
     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
     */
    ctx.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        // Let the point (x0, y0) be the last point in the subpath.
        var x0 = this.__currentPosition && this.__currentPosition.x;
        var y0 = this.__currentPosition && this.__currentPosition.y;

        // First ensure there is a subpath for (x1, y1).
        if (typeof x0 == "undefined" || typeof y0 == "undefined") {
            return;
        }

        // Negative values for radius must cause the implementation to throw an IndexSizeError exception.
        if (radius < 0) {
            throw new Error("IndexSizeError: The radius provided (" + radius + ") is negative.");
        }

        // If the point (x0, y0) is equal to the point (x1, y1),
        // or if the point (x1, y1) is equal to the point (x2, y2),
        // or if the radius radius is zero,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        if (((x0 === x1) && (y0 === y1))
            || ((x1 === x2) && (y1 === y2))
            || (radius === 0)) {
            this.lineTo(x1, y1);
            return;
        }

        // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);
        var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);
        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
            this.lineTo(x1, y1);
            return;
        }

        // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,
        // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),
        // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).
        // The points at which this circle touches these two lines are called the start and end tangent points respectively.

        // note that both vectors are unit vectors, so the length is 1
        var cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);
        var theta = Math.acos(Math.abs(cos));

        // Calculate origin
        var unit_vec_p1_origin = normalize([
            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
        ]);
        var len_p1_origin = radius / Math.sin(theta / 2);
        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];

        // Calculate start angle and end angle
        // rotate 90deg clockwise (note that y axis points to its down)
        var unit_vec_origin_start_tangent = [
            -unit_vec_p1_p0[1],
            unit_vec_p1_p0[0]
        ];
        // rotate 90deg counter clockwise (note that y axis points to its down)
        var unit_vec_origin_end_tangent = [
            unit_vec_p1_p2[1],
            -unit_vec_p1_p2[0]
        ];
        var getAngle = function(vector) {
            // get angle (clockwise) between vector and (1, 0)
            var x = vector[0];
            var y = vector[1];
            if (y >= 0) { // note that y axis points to its down
                return Math.acos(x);
            } else {
                return -Math.acos(x);
            }
        };
        var startAngle = getAngle(unit_vec_origin_start_tangent);
        var endAngle = getAngle(unit_vec_origin_end_tangent);

        // Connect the point (x0, y0) to the start tangent point by a straight line
        this.lineTo(x + unit_vec_origin_start_tangent[0] * radius,
                    y + unit_vec_origin_start_tangent[1] * radius);

        // Connect the start tangent point to the end tangent point by arc
        // and adding the end tangent point to the subpath.
        this.arc(x, y, radius, startAngle, endAngle);
    };

    /**
     * Sets the stroke property on the current element
     */
    ctx.prototype.stroke = function(){
        if(this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "fill stroke markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("stroke");
    };

    /**
     * Sets fill properties on the current element
     */
    ctx.prototype.fill = function(){
        if(this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "stroke fill markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("fill");
    };

    /**
     *  Adds a rectangle to the path.
     */
    ctx.prototype.rect = function(x, y, width, height){
        if(this.__currentElement.nodeName !== "path") {
            this.beginPath();
        }
        this.moveTo(x, y);
        this.lineTo(x+width, y);
        this.lineTo(x+width, y+height);
        this.lineTo(x, y+height);
        this.lineTo(x, y);
        this.closePath();
    };


    /**
     * adds a rectangle element
     */
    ctx.prototype.fillRect = function(x, y, width, height){
        var rect, parent;
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("fill");
    };

    /**
     * Draws a rectangle with no fill
     * @param x
     * @param y
     * @param width
     * @param height
     */
    ctx.prototype.strokeRect = function(x, y, width, height){
        var rect, parent;
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("stroke");
    };


    /**
     * "Clears" a canvas by just drawing a white rectangle in the current group.
     */
    ctx.prototype.clearRect = function(x, y, width, height) {
        var rect, parent = this.__closestGroupOrSvg();
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height,
            fill : "#FFFFFF"
        }, true);
        parent.appendChild(rect);
    };

    /**
     * Adds a linear gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createLinearGradient = function(x1, y1, x2, y2){
        var grad = this.__createElement("linearGradient", {
            id : randomString(this.__ids),
            x1 : x1+"px",
            x2 : x2+"px",
            y1 : y1+"px",
            y2 : y2+"px",
            "gradientUnits" : "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
    };

    /**
     * Adds a radial gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createRadialGradient = function(x0, y0, r0, x1, y1, r1){
        var grad = this.__createElement("radialGradient", {
            id : randomString(this.__ids),
            cx : x1+"px",
            cy : y1+"px",
            r  : r1+"px",
            fx : x0+"px",
            fy : y0+"px",
            "gradientUnits" : "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);

    };

    /**
     * Parses the font string and returns svg mapping
     * @private
     */
    ctx.prototype.__parseFont = function() {
        var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\"\sa-z]+?)\s*$/i;
        var fontPart = regex.exec( this.font );
        var data = {
            style : fontPart[1] || 'normal',
            size : fontPart[4] || '10px',
            family : fontPart[6] || 'sans-serif',
            weight: fontPart[3] || 'normal',
            decoration : fontPart[2] || 'normal',
            href : null
        };

        //canvas doesn't support underline natively, but we can pass this attribute
        if(this.__fontUnderline === "underline") {
            data.decoration = "underline";
        }

        //canvas also doesn't support linking, but we can pass this as well
        if(this.__fontHref) {
            data.href = this.__fontHref;
        }

        return data;
    };

    /**
     * Helper to link text fragments
     * @param font
     * @param element
     * @return {*}
     * @private
     */
    ctx.prototype.__wrapTextLink = function(font, element) {
        if(font.href) {
            var a = this.__createElement("a");
            a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
            a.appendChild(element);
            return a;
        }
        return element;
    };

    /**
     * Fills or strokes text
     * @param text
     * @param x
     * @param y
     * @param action - stroke or fill
     * @private
     */
    ctx.prototype.__applyText = function(text, x, y, action) {
        var font = this.__parseFont(),
            parent = this.__closestGroupOrSvg(),
            textElement = this.__createElement("text", {
                "font-family" : font.family,
                "font-size" : font.size,
                "font-style" : font.style,
                "font-weight" : font.weight,
                "text-decoration" : font.decoration,
                "x" : x,
                "y" : y,
                "text-anchor": getTextAnchor(this.textAlign),
                "dominant-baseline": getDominantBaseline(this.textBaseline)
            }, true);

        textElement.appendChild(this.__document.createTextNode(text));
        this.__currentElement = textElement;
        this.__applyStyleToCurrentElement(action);
        parent.appendChild(this.__wrapTextLink(font,textElement));
    };

    /**
     * Creates a text element
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.fillText = function(text, x, y){
        this.__applyText(text, x, y, "fill");
    };

    /**
     * Strokes text
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.strokeText = function(text, x, y){
        this.__applyText(text, x, y, "stroke");
    };

    /**
     * No need to implement this for svg.
     * @param text
     * @return {TextMetrics}
     */
    ctx.prototype.measureText = function(text){
        this.__ctx.font = this.font;
        return this.__ctx.measureText(text);
    };

    /**
     *  Arc command!
     */
    ctx.prototype.arc = function(x, y, radius, startAngle, endAngle, counterClockwise) {
        // in canvas no circle is drawn if no angle is provided.
        if (startAngle === endAngle) {
            return;
        }
        startAngle = startAngle % (2*Math.PI);
        endAngle = endAngle % (2*Math.PI);
        if(startAngle === endAngle) {
            //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)
            endAngle = ((endAngle + (2*Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2*Math.PI);
        }
        var endX = x+radius*Math.cos(endAngle),
            endY = y+radius*Math.sin(endAngle),
            startX = x+radius*Math.cos(startAngle),
            startY = y+radius*Math.sin(startAngle),
            sweepFlag = counterClockwise ? 0 : 1,
            largeArcFlag = 0,
            diff = endAngle - startAngle;

        // https://github.com/gliffy/canvas2svg/issues/4
        if(diff < 0) {
            diff += 2*Math.PI;
        }

        if(counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
        } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
        }

        this.lineTo(startX, startY);
        this.__addPathCommand(format("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {rx:radius, ry:radius, xAxisRotation:0, largeArcFlag:largeArcFlag, sweepFlag:sweepFlag, endX:endX, endY:endY}));

        this.__currentPosition = {x: endX, y: endY};
    };

    /**
     * Generates a ClipPath from the clip command.
     */
    ctx.prototype.clip = function(){
        var group = this.__closestGroupOrSvg(),
            clipPath = this.__createElement("clipPath"),
            id =  randomString(this.__ids),
            newGroup = this.__createElement("g");

        group.removeChild(this.__currentElement);
        clipPath.setAttribute("id", id);
        clipPath.appendChild(this.__currentElement);

        this.__defs.appendChild(clipPath);

        //set the clip path to this group
        group.setAttribute("clip-path", format("url(#{id})", {id:id}));

        //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations
        // to this path
        group.appendChild(newGroup);

        this.__currentElement = newGroup;

    };

    /**
     * Draws a canvas, image or mock context to this canvas.
     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
     */
    ctx.prototype.drawImage = function(){
        //convert arguments to a real array
        var args = Array.prototype.slice.call(arguments),
            image=args[0],
            dx, dy, dw, dh, sx=0, sy=0, sw, sh, parent, svg, defs, group,
            currentElement, svgImage, canvas, context, id;

        if(args.length === 3) {
            dx = args[1];
            dy = args[2];
            sw = image.width;
            sh = image.height;
            dw = sw;
            dh = sh;
        } else if(args.length === 5) {
            dx = args[1];
            dy = args[2];
            dw = args[3];
            dh = args[4];
            sw = image.width;
            sh = image.height;
        } else if(args.length === 9) {
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        } else {
            throw new Error("Inavlid number of arguments passed to drawImage: " + arguments.length);
        }

        parent = this.__closestGroupOrSvg();
        currentElement = this.__currentElement;

        if(image instanceof ctx) {
            //canvas2svg mock canvas context. In the future we may want to clone nodes instead.
            //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.
            svg = image.getSvg();
            defs = svg.childNodes[0];
            while(defs.childNodes.length) {
                id = defs.childNodes[0].getAttribute("id");
                this.__ids[id] = id;
                this.__defs.appendChild(defs.childNodes[0]);
            }
            group = svg.childNodes[1];
            parent.appendChild(group);
            this.__currentElement = group;
            this.translate(dx, dy);
            this.__currentElement = currentElement;
        } else if(image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            //canvas or image
            svgImage = this.__createElement("image");
            svgImage.setAttribute("width", dw);
            svgImage.setAttribute("height", dh);
            svgImage.setAttribute("preserveAspectRatio", "none");

            if(sx || sy || sw !== image.width || sh !== image.height) {
                //crop the image using a temporary canvas
                canvas = this.__document.createElement("canvas");
                canvas.width = dw;
                canvas.height = dh;
                context = canvas.getContext("2d");
                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
                image = canvas;
            }

            svgImage.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href",
                image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src"));
            parent.appendChild(svgImage);
            this.__currentElement = svgImage;
            this.translate(dx, dy);
            this.__currentElement = currentElement;
        }
    };

    /**
     * Generates a pattern tag
     */
    ctx.prototype.createPattern = function(image, repetition){
        var pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id = randomString(this.__ids),
            img;
        pattern.setAttribute("id", id);
        pattern.setAttribute("width", image.width);
        pattern.setAttribute("height", image.height);
        if(image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttribute("width", image.width);
            img.setAttribute("height", image.height);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href",
                image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src"));
            pattern.appendChild(img);
            this.__defs.appendChild(pattern);
        } else if(image instanceof ctx) {
            pattern.appendChild(image.__root.childNodes[1]);
            this.__defs.appendChild(pattern);
        }
        return new CanvasPattern(pattern, this);
    };

    /**
     * Not yet implemented
     */
    ctx.prototype.drawFocusRing = function(){};
    ctx.prototype.createImageData = function(){};
    ctx.prototype.getImageData = function(){};
    ctx.prototype.putImageData = function(){};
    ctx.prototype.globalCompositeOperation = function(){};
    ctx.prototype.setTransform = function(){};

    //add options for alternative namespace
    if (typeof window === "object") {
        window.C2S = ctx;
    }

    // CommonJS/Browserify
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = ctx;
    }

}());

},{}],48:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],49:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],50:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],51:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":72,"../../modules/core.regexp.escape":177}],52:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],53:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":67}],54:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":91,"./_wks":175}],55:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],56:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":100}],57:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":160,"./_to-length":164,"./_to-object":165}],58:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":160,"./_to-length":164,"./_to-object":165}],59:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":88}],60:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":160,"./_to-iobject":163,"./_to-length":164}],61:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":64,"./_ctx":74,"./_iobject":96,"./_to-length":164,"./_to-object":165}],62:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":52,"./_iobject":96,"./_to-length":164,"./_to-object":165}],63:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":98,"./_is-object":100,"./_wks":175}],64:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":63}],65:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":52,"./_invoke":95,"./_is-object":100}],66:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":67,"./_wks":175}],67:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],68:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":55,"./_ctx":74,"./_descriptors":78,"./_for-of":88,"./_iter-define":104,"./_iter-step":106,"./_meta":114,"./_object-create":119,"./_object-dp":120,"./_redefine-all":139,"./_set-species":146,"./_validate-collection":172}],69:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":59,"./_classof":66}],70:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":55,"./_an-object":56,"./_array-methods":61,"./_for-of":88,"./_has":90,"./_is-object":100,"./_meta":114,"./_redefine-all":139,"./_validate-collection":172}],71:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":55,"./_export":82,"./_fails":84,"./_for-of":88,"./_global":89,"./_inherit-if-required":94,"./_is-object":100,"./_iter-detect":105,"./_meta":114,"./_redefine":140,"./_redefine-all":139,"./_set-to-string-tag":147}],72:[function(require,module,exports){
var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],73:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":120,"./_property-desc":138}],74:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":52}],75:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":84}],76:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":56,"./_to-primitive":166}],77:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],78:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":84}],79:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":89,"./_is-object":100}],80:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],81:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":126,"./_object-keys":129,"./_object-pie":130}],82:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":72,"./_ctx":74,"./_global":89,"./_hide":91,"./_redefine":140}],83:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":175}],84:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],85:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":77,"./_fails":84,"./_hide":91,"./_redefine":140,"./_wks":175}],86:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":56}],87:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":74,"./_is-array":98,"./_is-object":100,"./_to-length":164,"./_wks":175}],88:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":56,"./_ctx":74,"./_is-array-iter":97,"./_iter-call":102,"./_to-length":164,"./core.get-iterator-method":176}],89:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],90:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],91:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":78,"./_object-dp":120,"./_property-desc":138}],92:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":89}],93:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":78,"./_dom-create":79,"./_fails":84}],94:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":100,"./_set-proto":145}],95:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],96:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":67}],97:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":107,"./_wks":175}],98:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":67}],99:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":100}],100:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],101:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":67,"./_is-object":100,"./_wks":175}],102:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":56}],103:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":91,"./_object-create":119,"./_property-desc":138,"./_set-to-string-tag":147,"./_wks":175}],104:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":82,"./_hide":91,"./_iter-create":103,"./_iterators":107,"./_library":108,"./_object-gpo":127,"./_redefine":140,"./_set-to-string-tag":147,"./_wks":175}],105:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":175}],106:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],107:[function(require,module,exports){
module.exports = {};

},{}],108:[function(require,module,exports){
module.exports = false;

},{}],109:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],110:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":113}],111:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],112:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],113:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],114:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":84,"./_has":90,"./_is-object":100,"./_object-dp":120,"./_uid":170}],115:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":82,"./_shared":149,"./es6.map":207,"./es6.weak-map":313}],116:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":67,"./_global":89,"./_task":159}],117:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":52}],118:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":84,"./_iobject":96,"./_object-gops":126,"./_object-keys":129,"./_object-pie":130,"./_to-object":165}],119:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":56,"./_dom-create":79,"./_enum-bug-keys":80,"./_html":92,"./_object-dps":121,"./_shared-key":148}],120:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":56,"./_descriptors":78,"./_ie8-dom-define":93,"./_to-primitive":166}],121:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":56,"./_descriptors":78,"./_object-dp":120,"./_object-keys":129}],122:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":84,"./_global":89,"./_library":108}],123:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":78,"./_has":90,"./_ie8-dom-define":93,"./_object-pie":130,"./_property-desc":138,"./_to-iobject":163,"./_to-primitive":166}],124:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":125,"./_to-iobject":163}],125:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":80,"./_object-keys-internal":128}],126:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],127:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":90,"./_shared-key":148,"./_to-object":165}],128:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":60,"./_has":90,"./_shared-key":148,"./_to-iobject":163}],129:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":80,"./_object-keys-internal":128}],130:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],131:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":72,"./_export":82,"./_fails":84}],132:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":129,"./_object-pie":130,"./_to-iobject":163}],133:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":56,"./_global":89,"./_object-gopn":125,"./_object-gops":126}],134:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":89,"./_string-trim":157,"./_string-ws":158}],135:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":89,"./_string-trim":157,"./_string-ws":158}],136:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],137:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":56,"./_is-object":100,"./_new-promise-capability":117}],138:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],139:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":140}],140:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":72,"./_global":89,"./_has":90,"./_hide":91,"./_uid":170}],141:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],142:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],143:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":52,"./_ctx":74,"./_export":82,"./_for-of":88}],144:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":82}],145:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":56,"./_ctx":74,"./_is-object":100,"./_object-gopd":123}],146:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":78,"./_global":89,"./_object-dp":120,"./_wks":175}],147:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":90,"./_object-dp":120,"./_wks":175}],148:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":149,"./_uid":170}],149:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: 'Â© 2018 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":72,"./_global":89,"./_library":108}],150:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":52,"./_an-object":56,"./_wks":175}],151:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":84}],152:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":77,"./_to-integer":162}],153:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":77,"./_is-regexp":101}],154:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":77,"./_export":82,"./_fails":84}],155:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":77,"./_string-repeat":156,"./_to-length":164}],156:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":77,"./_to-integer":162}],157:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":77,"./_export":82,"./_fails":84,"./_string-ws":158}],158:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],159:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":67,"./_ctx":74,"./_dom-create":79,"./_global":89,"./_html":92,"./_invoke":95}],160:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":162}],161:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":162,"./_to-length":164}],162:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],163:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":77,"./_iobject":96}],164:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":162}],165:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":77}],166:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":100}],167:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":55,"./_array-copy-within":57,"./_array-fill":58,"./_array-includes":60,"./_array-methods":61,"./_classof":66,"./_ctx":74,"./_descriptors":78,"./_export":82,"./_fails":84,"./_global":89,"./_has":90,"./_hide":91,"./_is-array-iter":97,"./_is-object":100,"./_iter-detect":105,"./_iterators":107,"./_library":108,"./_object-create":119,"./_object-dp":120,"./_object-gopd":123,"./_object-gopn":125,"./_object-gpo":127,"./_property-desc":138,"./_redefine-all":139,"./_set-species":146,"./_species-constructor":150,"./_to-absolute-index":160,"./_to-index":161,"./_to-integer":162,"./_to-length":164,"./_to-object":165,"./_to-primitive":166,"./_typed":169,"./_typed-buffer":168,"./_uid":170,"./_wks":175,"./core.get-iterator-method":176,"./es6.array.iterator":188}],168:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":55,"./_array-fill":58,"./_descriptors":78,"./_fails":84,"./_global":89,"./_hide":91,"./_library":108,"./_object-dp":120,"./_object-gopn":125,"./_redefine-all":139,"./_set-to-string-tag":147,"./_to-index":161,"./_to-integer":162,"./_to-length":164,"./_typed":169}],169:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":89,"./_hide":91,"./_uid":170}],170:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],171:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":89}],172:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":100}],173:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":72,"./_global":89,"./_library":108,"./_object-dp":120,"./_wks-ext":174}],174:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":175}],175:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":89,"./_shared":149,"./_uid":170}],176:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":66,"./_core":72,"./_iterators":107,"./_wks":175}],177:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":82,"./_replacer":141}],178:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":54,"./_array-copy-within":57,"./_export":82}],179:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":61,"./_export":82,"./_strict-method":151}],180:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":54,"./_array-fill":58,"./_export":82}],181:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":61,"./_export":82,"./_strict-method":151}],182:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":54,"./_array-methods":61,"./_export":82}],183:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":54,"./_array-methods":61,"./_export":82}],184:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":61,"./_export":82,"./_strict-method":151}],185:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":73,"./_ctx":74,"./_export":82,"./_is-array-iter":97,"./_iter-call":102,"./_iter-detect":105,"./_to-length":164,"./_to-object":165,"./core.get-iterator-method":176}],186:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":60,"./_export":82,"./_strict-method":151}],187:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":82,"./_is-array":98}],188:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":54,"./_iter-define":104,"./_iter-step":106,"./_iterators":107,"./_to-iobject":163}],189:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":82,"./_iobject":96,"./_strict-method":151,"./_to-iobject":163}],190:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":82,"./_strict-method":151,"./_to-integer":162,"./_to-iobject":163,"./_to-length":164}],191:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":61,"./_export":82,"./_strict-method":151}],192:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":73,"./_export":82,"./_fails":84}],193:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":62,"./_export":82,"./_strict-method":151}],194:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":62,"./_export":82,"./_strict-method":151}],195:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":67,"./_export":82,"./_fails":84,"./_html":92,"./_to-absolute-index":160,"./_to-length":164}],196:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":61,"./_export":82,"./_strict-method":151}],197:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":52,"./_export":82,"./_fails":84,"./_strict-method":151,"./_to-object":165}],198:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":146}],199:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":82}],200:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":75,"./_export":82}],201:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":82,"./_fails":84,"./_to-object":165,"./_to-primitive":166}],202:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":76,"./_hide":91,"./_wks":175}],203:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":140}],204:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":65,"./_export":82}],205:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":100,"./_object-dp":120,"./_object-gpo":127,"./_wks":175}],206:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":78,"./_object-dp":120}],207:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":71,"./_collection-strong":68,"./_validate-collection":172}],208:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":82,"./_math-log1p":111}],209:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":82}],210:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":82}],211:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":82,"./_math-sign":113}],212:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":82}],213:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":82}],214:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":82,"./_math-expm1":109}],215:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":82,"./_math-fround":110}],216:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":82}],217:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":82,"./_fails":84}],218:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":82}],219:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":82,"./_math-log1p":111}],220:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":82}],221:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":82,"./_math-sign":113}],222:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":82,"./_fails":84,"./_math-expm1":109}],223:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":82,"./_math-expm1":109}],224:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":82}],225:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":67,"./_descriptors":78,"./_fails":84,"./_global":89,"./_has":90,"./_inherit-if-required":94,"./_object-create":119,"./_object-dp":120,"./_object-gopd":123,"./_object-gopn":125,"./_redefine":140,"./_string-trim":157,"./_to-primitive":166}],226:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":82}],227:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":82,"./_global":89}],228:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":82,"./_is-integer":99}],229:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":82}],230:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":82,"./_is-integer":99}],231:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":82}],232:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":82}],233:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":82,"./_parse-float":134}],234:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":82,"./_parse-int":135}],235:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":53,"./_export":82,"./_fails":84,"./_string-repeat":156,"./_to-integer":162}],236:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":53,"./_export":82,"./_fails":84}],237:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":82,"./_object-assign":118}],238:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":82,"./_object-create":119}],239:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":78,"./_export":82,"./_object-dps":121}],240:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":78,"./_export":82,"./_object-dp":120}],241:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":100,"./_meta":114,"./_object-sap":131}],242:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":123,"./_object-sap":131,"./_to-iobject":163}],243:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":124,"./_object-sap":131}],244:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":127,"./_object-sap":131,"./_to-object":165}],245:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":100,"./_object-sap":131}],246:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":100,"./_object-sap":131}],247:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":100,"./_object-sap":131}],248:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":82,"./_same-value":142}],249:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":129,"./_object-sap":131,"./_to-object":165}],250:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":100,"./_meta":114,"./_object-sap":131}],251:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":100,"./_meta":114,"./_object-sap":131}],252:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":82,"./_set-proto":145}],253:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":66,"./_redefine":140,"./_wks":175}],254:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":82,"./_parse-float":134}],255:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":82,"./_parse-int":135}],256:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":52,"./_an-instance":55,"./_classof":66,"./_core":72,"./_ctx":74,"./_export":82,"./_for-of":88,"./_global":89,"./_is-object":100,"./_iter-detect":105,"./_library":108,"./_microtask":116,"./_new-promise-capability":117,"./_perform":136,"./_promise-resolve":137,"./_redefine-all":139,"./_set-species":146,"./_set-to-string-tag":147,"./_species-constructor":150,"./_task":159,"./_user-agent":171,"./_wks":175}],257:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":52,"./_an-object":56,"./_export":82,"./_fails":84,"./_global":89}],258:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":52,"./_an-object":56,"./_bind":65,"./_export":82,"./_fails":84,"./_global":89,"./_is-object":100,"./_object-create":119}],259:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":56,"./_export":82,"./_fails":84,"./_object-dp":120,"./_to-primitive":166}],260:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":56,"./_export":82,"./_object-gopd":123}],261:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":56,"./_export":82,"./_iter-create":103}],262:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":56,"./_export":82,"./_object-gopd":123}],263:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":56,"./_export":82,"./_object-gpo":127}],264:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":56,"./_export":82,"./_has":90,"./_is-object":100,"./_object-gopd":123,"./_object-gpo":127}],265:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":82}],266:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":56,"./_export":82}],267:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":82,"./_own-keys":133}],268:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":56,"./_export":82}],269:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":82,"./_set-proto":145}],270:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":56,"./_export":82,"./_has":90,"./_is-object":100,"./_object-dp":120,"./_object-gopd":123,"./_object-gpo":127,"./_property-desc":138}],271:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":78,"./_fails":84,"./_flags":86,"./_global":89,"./_inherit-if-required":94,"./_is-regexp":101,"./_object-dp":120,"./_object-gopn":125,"./_redefine":140,"./_set-species":146,"./_wks":175}],272:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":78,"./_flags":86,"./_object-dp":120}],273:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":85}],274:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":85}],275:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":85}],276:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":85,"./_is-regexp":101}],277:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":56,"./_descriptors":78,"./_fails":84,"./_flags":86,"./_redefine":140,"./es6.regexp.flags":272}],278:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":71,"./_collection-strong":68,"./_validate-collection":172}],279:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":154}],280:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":154}],281:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":154}],282:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":154}],283:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":82,"./_string-at":152}],284:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":82,"./_fails-is-regexp":83,"./_string-context":153,"./_to-length":164}],285:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":154}],286:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":154}],287:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":154}],288:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":82,"./_to-absolute-index":160}],289:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":82,"./_fails-is-regexp":83,"./_string-context":153}],290:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":154}],291:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":104,"./_string-at":152}],292:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":154}],293:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":82,"./_to-iobject":163,"./_to-length":164}],294:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":82,"./_string-repeat":156}],295:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":154}],296:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":82,"./_fails-is-regexp":83,"./_string-context":153,"./_to-length":164}],297:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":154}],298:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":154}],299:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":154}],300:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":157}],301:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":56,"./_descriptors":78,"./_enum-keys":81,"./_export":82,"./_fails":84,"./_global":89,"./_has":90,"./_hide":91,"./_is-array":98,"./_is-object":100,"./_library":108,"./_meta":114,"./_object-create":119,"./_object-dp":120,"./_object-gopd":123,"./_object-gopn":125,"./_object-gopn-ext":124,"./_object-gops":126,"./_object-keys":129,"./_object-pie":130,"./_property-desc":138,"./_redefine":140,"./_set-to-string-tag":147,"./_shared":149,"./_to-iobject":163,"./_to-primitive":166,"./_uid":170,"./_wks":175,"./_wks-define":173,"./_wks-ext":174}],302:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":56,"./_export":82,"./_fails":84,"./_global":89,"./_is-object":100,"./_set-species":146,"./_species-constructor":150,"./_to-absolute-index":160,"./_to-length":164,"./_typed":169,"./_typed-buffer":168}],303:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":82,"./_typed":169,"./_typed-buffer":168}],304:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],305:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],306:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],307:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],308:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],309:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],310:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],311:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":167}],312:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":167}],313:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":61,"./_collection":71,"./_collection-weak":70,"./_fails":84,"./_is-object":100,"./_meta":114,"./_object-assign":118,"./_redefine":140,"./_validate-collection":172}],314:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":71,"./_collection-weak":70,"./_validate-collection":172}],315:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":52,"./_add-to-unscopables":54,"./_array-species-create":64,"./_export":82,"./_flatten-into-array":87,"./_to-length":164,"./_to-object":165}],316:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":54,"./_array-species-create":64,"./_export":82,"./_flatten-into-array":87,"./_to-integer":162,"./_to-length":164,"./_to-object":165}],317:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":54,"./_array-includes":60,"./_export":82}],318:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":67,"./_export":82,"./_global":89,"./_microtask":116}],319:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":67,"./_export":82}],320:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":82,"./_global":89}],321:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":143}],322:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":144}],323:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":69,"./_export":82}],324:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":82}],325:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":82}],326:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":82}],327:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":82,"./_math-fround":110,"./_math-scale":112}],328:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":82}],329:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":82}],330:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":82}],331:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":82}],332:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":82}],333:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":82,"./_math-scale":112}],334:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":82}],335:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":82}],336:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":52,"./_descriptors":78,"./_export":82,"./_object-dp":120,"./_object-forced-pam":122,"./_to-object":165}],337:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":52,"./_descriptors":78,"./_export":82,"./_object-dp":120,"./_object-forced-pam":122,"./_to-object":165}],338:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":82,"./_object-to-array":132}],339:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":73,"./_export":82,"./_object-gopd":123,"./_own-keys":133,"./_to-iobject":163}],340:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":78,"./_export":82,"./_object-forced-pam":122,"./_object-gopd":123,"./_object-gpo":127,"./_to-object":165,"./_to-primitive":166}],341:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":78,"./_export":82,"./_object-forced-pam":122,"./_object-gopd":123,"./_object-gpo":127,"./_to-object":165,"./_to-primitive":166}],342:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":82,"./_object-to-array":132}],343:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":52,"./_an-instance":55,"./_an-object":56,"./_core":72,"./_export":82,"./_for-of":88,"./_global":89,"./_hide":91,"./_microtask":116,"./_redefine-all":139,"./_set-species":146,"./_wks":175}],344:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":72,"./_export":82,"./_global":89,"./_promise-resolve":137,"./_species-constructor":150}],345:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":82,"./_new-promise-capability":117,"./_perform":136}],346:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":56,"./_metadata":115}],347:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":56,"./_metadata":115}],348:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":56,"./_array-from-iterable":59,"./_metadata":115,"./_object-gpo":127,"./es6.set":278}],349:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":56,"./_metadata":115,"./_object-gpo":127}],350:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":56,"./_metadata":115}],351:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":56,"./_metadata":115}],352:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":56,"./_metadata":115,"./_object-gpo":127}],353:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":56,"./_metadata":115}],354:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":52,"./_an-object":56,"./_metadata":115}],355:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":143}],356:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":144}],357:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":69,"./_export":82}],358:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":82,"./_string-at":152}],359:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":77,"./_export":82,"./_flags":86,"./_is-regexp":101,"./_iter-create":103,"./_to-length":164}],360:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":82,"./_string-pad":155,"./_user-agent":171}],361:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":82,"./_string-pad":155,"./_user-agent":171}],362:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":157}],363:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":157}],364:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":173}],365:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":173}],366:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":82,"./_global":89}],367:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":143}],368:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":144}],369:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":143}],370:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":144}],371:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":89,"./_hide":91,"./_iterators":107,"./_object-keys":129,"./_redefine":140,"./_wks":175,"./es6.array.iterator":188}],372:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":82,"./_task":159}],373:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":82,"./_global":89,"./_user-agent":171}],374:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":72,"./modules/es6.array.copy-within":178,"./modules/es6.array.every":179,"./modules/es6.array.fill":180,"./modules/es6.array.filter":181,"./modules/es6.array.find":183,"./modules/es6.array.find-index":182,"./modules/es6.array.for-each":184,"./modules/es6.array.from":185,"./modules/es6.array.index-of":186,"./modules/es6.array.is-array":187,"./modules/es6.array.iterator":188,"./modules/es6.array.join":189,"./modules/es6.array.last-index-of":190,"./modules/es6.array.map":191,"./modules/es6.array.of":192,"./modules/es6.array.reduce":194,"./modules/es6.array.reduce-right":193,"./modules/es6.array.slice":195,"./modules/es6.array.some":196,"./modules/es6.array.sort":197,"./modules/es6.array.species":198,"./modules/es6.date.now":199,"./modules/es6.date.to-iso-string":200,"./modules/es6.date.to-json":201,"./modules/es6.date.to-primitive":202,"./modules/es6.date.to-string":203,"./modules/es6.function.bind":204,"./modules/es6.function.has-instance":205,"./modules/es6.function.name":206,"./modules/es6.map":207,"./modules/es6.math.acosh":208,"./modules/es6.math.asinh":209,"./modules/es6.math.atanh":210,"./modules/es6.math.cbrt":211,"./modules/es6.math.clz32":212,"./modules/es6.math.cosh":213,"./modules/es6.math.expm1":214,"./modules/es6.math.fround":215,"./modules/es6.math.hypot":216,"./modules/es6.math.imul":217,"./modules/es6.math.log10":218,"./modules/es6.math.log1p":219,"./modules/es6.math.log2":220,"./modules/es6.math.sign":221,"./modules/es6.math.sinh":222,"./modules/es6.math.tanh":223,"./modules/es6.math.trunc":224,"./modules/es6.number.constructor":225,"./modules/es6.number.epsilon":226,"./modules/es6.number.is-finite":227,"./modules/es6.number.is-integer":228,"./modules/es6.number.is-nan":229,"./modules/es6.number.is-safe-integer":230,"./modules/es6.number.max-safe-integer":231,"./modules/es6.number.min-safe-integer":232,"./modules/es6.number.parse-float":233,"./modules/es6.number.parse-int":234,"./modules/es6.number.to-fixed":235,"./modules/es6.number.to-precision":236,"./modules/es6.object.assign":237,"./modules/es6.object.create":238,"./modules/es6.object.define-properties":239,"./modules/es6.object.define-property":240,"./modules/es6.object.freeze":241,"./modules/es6.object.get-own-property-descriptor":242,"./modules/es6.object.get-own-property-names":243,"./modules/es6.object.get-prototype-of":244,"./modules/es6.object.is":248,"./modules/es6.object.is-extensible":245,"./modules/es6.object.is-frozen":246,"./modules/es6.object.is-sealed":247,"./modules/es6.object.keys":249,"./modules/es6.object.prevent-extensions":250,"./modules/es6.object.seal":251,"./modules/es6.object.set-prototype-of":252,"./modules/es6.object.to-string":253,"./modules/es6.parse-float":254,"./modules/es6.parse-int":255,"./modules/es6.promise":256,"./modules/es6.reflect.apply":257,"./modules/es6.reflect.construct":258,"./modules/es6.reflect.define-property":259,"./modules/es6.reflect.delete-property":260,"./modules/es6.reflect.enumerate":261,"./modules/es6.reflect.get":264,"./modules/es6.reflect.get-own-property-descriptor":262,"./modules/es6.reflect.get-prototype-of":263,"./modules/es6.reflect.has":265,"./modules/es6.reflect.is-extensible":266,"./modules/es6.reflect.own-keys":267,"./modules/es6.reflect.prevent-extensions":268,"./modules/es6.reflect.set":270,"./modules/es6.reflect.set-prototype-of":269,"./modules/es6.regexp.constructor":271,"./modules/es6.regexp.flags":272,"./modules/es6.regexp.match":273,"./modules/es6.regexp.replace":274,"./modules/es6.regexp.search":275,"./modules/es6.regexp.split":276,"./modules/es6.regexp.to-string":277,"./modules/es6.set":278,"./modules/es6.string.anchor":279,"./modules/es6.string.big":280,"./modules/es6.string.blink":281,"./modules/es6.string.bold":282,"./modules/es6.string.code-point-at":283,"./modules/es6.string.ends-with":284,"./modules/es6.string.fixed":285,"./modules/es6.string.fontcolor":286,"./modules/es6.string.fontsize":287,"./modules/es6.string.from-code-point":288,"./modules/es6.string.includes":289,"./modules/es6.string.italics":290,"./modules/es6.string.iterator":291,"./modules/es6.string.link":292,"./modules/es6.string.raw":293,"./modules/es6.string.repeat":294,"./modules/es6.string.small":295,"./modules/es6.string.starts-with":296,"./modules/es6.string.strike":297,"./modules/es6.string.sub":298,"./modules/es6.string.sup":299,"./modules/es6.string.trim":300,"./modules/es6.symbol":301,"./modules/es6.typed.array-buffer":302,"./modules/es6.typed.data-view":303,"./modules/es6.typed.float32-array":304,"./modules/es6.typed.float64-array":305,"./modules/es6.typed.int16-array":306,"./modules/es6.typed.int32-array":307,"./modules/es6.typed.int8-array":308,"./modules/es6.typed.uint16-array":309,"./modules/es6.typed.uint32-array":310,"./modules/es6.typed.uint8-array":311,"./modules/es6.typed.uint8-clamped-array":312,"./modules/es6.weak-map":313,"./modules/es6.weak-set":314,"./modules/es7.array.flat-map":315,"./modules/es7.array.flatten":316,"./modules/es7.array.includes":317,"./modules/es7.asap":318,"./modules/es7.error.is-error":319,"./modules/es7.global":320,"./modules/es7.map.from":321,"./modules/es7.map.of":322,"./modules/es7.map.to-json":323,"./modules/es7.math.clamp":324,"./modules/es7.math.deg-per-rad":325,"./modules/es7.math.degrees":326,"./modules/es7.math.fscale":327,"./modules/es7.math.iaddh":328,"./modules/es7.math.imulh":329,"./modules/es7.math.isubh":330,"./modules/es7.math.rad-per-deg":331,"./modules/es7.math.radians":332,"./modules/es7.math.scale":333,"./modules/es7.math.signbit":334,"./modules/es7.math.umulh":335,"./modules/es7.object.define-getter":336,"./modules/es7.object.define-setter":337,"./modules/es7.object.entries":338,"./modules/es7.object.get-own-property-descriptors":339,"./modules/es7.object.lookup-getter":340,"./modules/es7.object.lookup-setter":341,"./modules/es7.object.values":342,"./modules/es7.observable":343,"./modules/es7.promise.finally":344,"./modules/es7.promise.try":345,"./modules/es7.reflect.define-metadata":346,"./modules/es7.reflect.delete-metadata":347,"./modules/es7.reflect.get-metadata":349,"./modules/es7.reflect.get-metadata-keys":348,"./modules/es7.reflect.get-own-metadata":351,"./modules/es7.reflect.get-own-metadata-keys":350,"./modules/es7.reflect.has-metadata":352,"./modules/es7.reflect.has-own-metadata":353,"./modules/es7.reflect.metadata":354,"./modules/es7.set.from":355,"./modules/es7.set.of":356,"./modules/es7.set.to-json":357,"./modules/es7.string.at":358,"./modules/es7.string.match-all":359,"./modules/es7.string.pad-end":360,"./modules/es7.string.pad-start":361,"./modules/es7.string.trim-left":362,"./modules/es7.string.trim-right":363,"./modules/es7.symbol.async-iterator":364,"./modules/es7.symbol.observable":365,"./modules/es7.system.global":366,"./modules/es7.weak-map.from":367,"./modules/es7.weak-map.of":368,"./modules/es7.weak-set.from":369,"./modules/es7.weak-set.of":370,"./modules/web.dom.iterable":371,"./modules/web.immediate":372,"./modules/web.timers":373}],375:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":376,"engine.io-parser":386}],376:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0)
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":377,"./transports/index":378,"component-emitter":49,"debug":384,"engine.io-parser":386,"indexof":393,"parseqs":481,"parseuri":482}],377:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":49,"engine.io-parser":386}],378:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":379,"./polling-xhr":380,"./websocket":382,"xmlhttprequest-ssl":383}],379:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":381,"component-inherit":50}],380:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":381,"component-emitter":49,"component-inherit":50,"debug":384,"xmlhttprequest-ssl":383}],381:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":377,"component-inherit":50,"debug":384,"engine.io-parser":386,"parseqs":481,"xmlhttprequest-ssl":383,"yeast":504}],382:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../transport":377,"component-inherit":50,"debug":384,"engine.io-parser":386,"parseqs":481,"ws":44,"yeast":504}],383:[function(require,module,exports){
(function (global){
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"has-cors":391}],384:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))
},{"./debug":385,"_process":483}],385:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":395}],386:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":387,"./utf8":388,"after":37,"arraybuffer.slice":38,"base64-arraybuffer":42,"blob":43,"has-binary2":389}],387:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],388:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint, strict) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			if (strict) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
			return false;
		}
		return true;
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint, strict) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			if (!checkScalarValue(codePoint, strict)) {
				codePoint = 0xFFFD;
			}
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint, strict);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, itâs not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol(strict) {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol(strict)) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],389:[function(require,module,exports){
(function (Buffer){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this,require("buffer").Buffer)
},{"buffer":46,"isarray":390}],390:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],391:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],392:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],393:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],394:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],395:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],396:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],397:[function(require,module,exports){
module.exports = {
0: `[root [nsubj I] have [obj [amod [advmod too] many] commitments] [advmod right now] [punct .]]`
};

},{}],398:[function(require,module,exports){
module.exports = {
equals: `# sent_id = mst-0001
# text = PeÅreve baÅlamalÄ±.
"<PeÅreve>"
	"peÅrev" Noun @obl #1->2
"<baÅlamalÄ±>"
	"baÅla" Verb SpaceAfter=No @root #2->0
"<.>"
	"." Punc @punct #3->2`,

x_and_u_postag: `# text = Ãe'áº½nguÃ©ra iÃ±e'áº½rapoambuÃ©va (lenguas de flexiÃ³n), umi Ã±e'áº½te indoeuropeo-icha.
# text[spa] = Las lenguas de flexiÃ³n, aquellas lenguas como indoeuropeas.
# labels =
"<ÃeÊ¼áº½nguÃ©ra>"
	"Ã±eÊ¼áº½" n @nsubj #1->
		"kuÃ©ra" det pl @det #2->1
"<iÃ±eÊ¼áº½rapoambuÃ©va>"
	"iÃ±eÊ¼áº½rapoambuÃ©va" adj @amod #3->1
"<(>"
	"(" lpar @punct #4->5
"<lenguas>"
	"lenguas" barb @appos #5->1
"<de>"
	"de" barb @foreign #6->7
"<flexiÃ³n>"
	"flexiÃ³n" barb @foreign #7->5
"<)>"
	")" rpar @punct #8->5
"<,>"
	"," cm @punct #9->
"<umi>"
	"umi" adj dem pl @amod #10->11
"<Ã±eÊ¼áº½te>"
	"Ã±eÊ¼áº½" n @obl #11->
		"te" post @case #12->11
"<indoeuropeo-icha>"
	"indoeuropeo" barb @amod #13->11
		"icha" comp @dep #14->13
"<.>"
	"." sent @punct #15->`,

nested: `# sent_id = wikipedia:Poyvi_ParaguÃ¡i:11
# text = Poyvi peteÄ©ha Ã±ane retÃ£megua niko ojepuruâypÃ½kuri 15 jasypo guive 16 jasypoteÄ© meve ary 1811-pe.
# text[spa] = Bandera uno nosotros de-de _ Ã©l-se-utilizÃ³-_ 15 maio desde 16 junio hasta aÃ±o 1811-en.
"<Poyvi>"
	"poyvi" n
"<peteÄ©ha>"
	"pete" n incp
		"Ä©" v tv pres
			"ha" subs
	"peteÄ©ha" num
"<Ã±ane>"
	"Ã±andÃ©" prn pers p1 incl pl
"<retÃ£megua>"
	"*retÃ£megua"
"<niko>"
	"*niko"
"<ojepuruÊ¼ypÃ½kuri>"
	"*ojepuruÊ¼ypÃ½kuri"
"<15>"
	"15" num @amod
"<jasypo>"
	"ja" n incp
		"sy" n incp
			"po" n
	"ja" n incp
		"sy" n incp
			"po" v iv pres
	"ja" n incp
		"sy" n incp
			"po" v tv pres
	"ja" prn p1 pl
		"sy" n incp
			"po" n
	"ja" prn p1 pl
		"sy" n incp
			"po" v iv pres
	"ja" prn p1 pl
		"sy" n incp
			"po" v tv pres
	"jasy" n incp
		"po" n
	"jasy" n incp
		"po" v iv pres
	"jasy" n incp
		"po" v tv pres
	"jasypo" n
"<guive>"
	"guive" post @case
"<16>"
	"16" num @amod
"<jasypoteÄ©>"
	"jasypoteÄ©" n
"<meve>"
	"peve" post @case
"<ary>"
	"ary" n
"<1811-pe>"
	"1811" num
		"pe" post @case`,

/*nested_2: `"<ab>"
	"A" #1->
		"B" #2->
"<cde>"
	"C" #3->
		"D" #4->
			"E" #5->
"<f>"
	"F" #6->
"<h>"
	"H" #7->`,*/

kdt_tagged_1: `# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt
"<Ó¨ÑÐºÐµÐ¼ÐµÐ½Ð½ÑÒ£>"
	"Ó¨ÑÐºÐµÐ¼ÐµÐ½" np top gen @nmod:poss #1->3
"<Ð°Ñ>"
	"Ð°Ñ" adj @amod #2->3
"<Ð¶Ð°ÒÑÐ½Ð´Ð°>"
	"Ð¶Ð°Ò" n px3sp loc @conj #3->7
"<,>"
	"," cm @punct #4->7
"<ÐÒ±ÒÑÑÑÐ¼Ð°Ð½ÑÒ£>"
	"ÐÒ±ÒÑÑÑÐ¼Ð°" np top gen @nmod:poss #5->7
"<Ð¾Ò£>"
	"Ð¾Ò£" adj @amod #6->7
"<Ð¶Ð°ÒÑÐ½Ð´Ð°>"
	"Ð¶Ð°Ò" n px3sp loc @nmod #7->11
"<ÓÐ»ÐµÐ¼Ð³Ðµ>"
	"ÓÐ»ÐµÐ¼" n dat @nmod #8->9
"<Ð°ÑÐ½>"
	"Ð°ÑÐ½" adj @acl #9->10
"<ÐÐ»ÑÐ°Ð¹>"
	"ÐÐ»ÑÐ°Ð¹" np top nom @nsubj #10->11
"<Ð±Ð°Ñ>"
	"Ð±Ð°Ñ" adj @root #11->0
		"Ðµ" cop aor p3 sg @cop #12->11
"<.>"
	"." sent @punct #13->11`,

kdt_tagged_2: `# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt
"<ÐÑÑÐ°Ð½>"
	"Ð°ÑÑÐ°Ð½" v iv imp p2 sg @root #1->0
"<!>"
	"!" sent @punct #2->1`,

kdt_tagged_3: `# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt
"<ÐÐ°Ð½Ð°ÒÑ>"
	"Ð¼Ð°Ð½Ð°ÒÑ" det dem @det #1->3
"<Ð°Ð»Ð°>"
	"Ð°Ð»Ð°" adj @amod #2->3
"<Ð°ÑÑÑ>"
	"Ð°ÑÑÑ" adj subst nom @nsubj #3->4
"<ÐºÑÐ¼>"
	"ÐºÑÐ¼" prn itg nom @root #4->0
		"Ðµ" cop aor p3 sg @cop #5->4
"<?>"
	"?" sent @punct #6->4`,

0: `"<ÐÐ°ÑÑÐ°Ð¼ÐµÐ½>"
	"Ð¿Ð°ÑÑÐ°" n ins @nmod #1->3
"<ÑÐ¾ÒÑÑ>"
	"ÑÐ¾ÒÑÑ" n nom @obj #2->3
"<Ð°ÑÒÐ°Ð½Ð´Ð°>"
	"Ð°Ñ" v tv ger_past loc @advcl #3->12
"<,>"
	"," cm @punct #4->12
"<ÐµÐ»-Ð¶Ò±ÑÑ>"
	"ÐµÐ»-Ð¶Ò±ÑÑ" n nom @conj #5->7
"<,>"
	"," cm @punct #6->7
"<Ð¾ÑÐ°Ð½ÑÐ¼Ð´Ñ>"
	"Ð¾ÑÐ°Ð½" n px1sg acc @obj #7->8
"<ÒÐ¾ÑÒÐ°ÑÒÐ°>"
	"ÒÐ¾ÑÒÐ°" v tv ger dat @advcl #8->12
"<,>"
	"," cm @punct #9->12
"<Ð±ÑÐ·>"
	"Ð±ÑÐ·" prn pers p1 pl nom @nsubj #10->12
"<ÑÐ¾ÒÑÑÒÐ°>"
	"ÑÐ¾ÒÑÑ" n dat @nmod #11->12
"<Ð±Ð°ÑÐ´ÑÒ>"
	"Ð±Ð°Ñ" v iv ifi p1 pl @root #12->0
"<.>"
	"." sent @punct #13->12`,

1: `# text = He boued e tebr Mona er gegin.
# text[eng] = Mona eats her food here in the kitchen.
# labels = press_1986 ch_syntax p_197 to_check
"<He>"
	"he" det pos f sp @det #1->2
"<boued>"
	"boued" n m sg @obj #2->4
"<e>"
	"e" vpart obj @aux #3->4
"<tebr>"
	"debriÃ±" vblex pri p3 sg @root #4->0
"<Mona>"
	"Mona" np ant f sg @nsubj #5->4
"<er>"
	"e" pr @case #6->8
		"an" det def sp @det #7->8
"<gegin>"
	"kegin" n f sg @obl #8->4
"<.>"
	"." sent @punct #9->4`,

2: `# text = He boued e tebr Mona er gegin.
# text[eng] = Mona eats her food here in the kitchen.
# labels = press_1986 ch_syntax p_197 to_check
"<He>"
	"he" det pos f sp @det #1->2
"<boued>"
	"boued" n m sg @obj #2->4
"<e>"
	"e" vpart obj @aux #3->4
"<tebr>"
	"debriÃ±" vblex pri p3 sg @root #4->0
"<Mona>"
	"Mona" np ant f sg @nsubj #5->4
"<er>"
	"e" pr @case #6->8
		"an" det def sp @det #7->8
"<gegin>"
	"kegin" n f sg @obl #8->4
	"kegin" n f pl @obl #9->
"<.>"
	"." sent @punct #10->4`, // note: changed line `"kegin" n f pl @obl #8->4`

with_semicolumn: `
"<SiedzieliÅmy>"
	"siedzieÄ" vblex impf past p1 m pl
"<w>"
	"w" pr
"<moim>"
;   "mÃ³j" prn pos mi sg loc
"<pokoju>"
	"pokÃ³j" n mi sg loc
"<,>"
	"," cm
"<palÄc>"
	"paliÄ" vblex impf pprs adv
"<i>"
	"i" cnjcoo
"<rozmawiajÄc>"
	"rozmawiaÄ" vblex impf pprs adv
"<o>"
	"o" pr
"<tem>"
	"to" prn dem mi sg loc
"<,>"
	"," cm
"<jak>"
	"jak" rel adv
"<marni>"
	"marny" adj sint mp pl nom
"<jesteÅmy>"
	"byÄ" vbser pres p1 pl
"<,>"
	"," cm
"<marni>"
	"marny" adj sint mp pl nom
"<z>"
	"z" pr
"<lekarskiego>"
	"lekarski" adj mi sg gen
"<punktu>"
	"punkt" n mi sg gen
"<widzenia>"
;   "widzieÄ" vblex impf ger nt sg gen
"<chcÄ>"
	"chcieÄ" vblex impf pres p1 sg
"<powiedzieÄ>"
	"powiedzieÄ" vblex perf inf
"<,>"
	"," cm
"<naturalnie>"
	"naturalnie" adv sint
"<.>"
	"." sent`,

simple: `"<ÐÐ°ÑÑÐ°Ð¼ÐµÐ½>"
	"Ð¿Ð°ÑÑÐ°" n ins @nmod #1->3
"<ÑÐ¾ÒÑÑ>"
	"ÑÐ¾ÒÑÑ" n nom @obj #2->3
"<Ð°ÑÒÐ°Ð½Ð´Ð°>"
	"Ð°Ñ" v tv ger_past loc @advcl #3->12
"<,>"
	"," cm @punct #4->12
"<ÐµÐ»-Ð¶Ò±ÑÑ>"
	"ÐµÐ»-Ð¶Ò±ÑÑ" n nom @conj #5->7
"<,>"
	"," cm @punct #6->7
"<Ð¾ÑÐ°Ð½ÑÐ¼Ð´Ñ>"
	"Ð¾ÑÐ°Ð½" n px1sg acc @obj #7->8
"<ÒÐ¾ÑÒÐ°ÑÒÐ°>"
	"ÒÐ¾ÑÒÐ°" v tv ger dat @advcl #8->12
"<,>"
	"," cm @punct #9->12
"<Ð±ÑÐ·>"
	"Ð±ÑÐ·" prn pers p1 pl nom @nsubj #10->12
"<ÑÐ¾ÒÑÑÒÐ°>"
	"ÑÐ¾ÒÑÑ" n dat @nmod #11->12
"<Ð±Ð°ÑÐ´ÑÒ>"
	"Ð±Ð°Ñ" v iv ifi p1 pl @root #12->0
"<.>"
	"." sent @punct #13->12`,

simple_with_comments: `# comment #1
# comment #2
"<ÐÐ°ÑÑÐ°Ð¼ÐµÐ½>"
	"Ð¿Ð°ÑÑÐ°" n ins @nmod #1->3
"<ÑÐ¾ÒÑÑ>"
	"ÑÐ¾ÒÑÑ" n nom @obj #2->3
"<Ð°ÑÒÐ°Ð½Ð´Ð°>"
	"Ð°Ñ" v tv ger_past loc @advcl #3->12
"<,>"
	"," cm @punct #4->12
"<ÐµÐ»-Ð¶Ò±ÑÑ>"
	"ÐµÐ»-Ð¶Ò±ÑÑ" n nom @conj #5->7
"<,>"
	"," cm @punct #6->7
"<Ð¾ÑÐ°Ð½ÑÐ¼Ð´Ñ>"
	"Ð¾ÑÐ°Ð½" n px1sg acc @obj #7->8
"<ÒÐ¾ÑÒÐ°ÑÒÐ°>"
	"ÒÐ¾ÑÒÐ°" v tv ger dat @advcl #8->12
"<,>"
	"," cm @punct #9->12
"<Ð±ÑÐ·>"
	"Ð±ÑÐ·" prn pers p1 pl nom @nsubj #10->12
"<ÑÐ¾ÒÑÑÒÐ°>"
	"ÑÐ¾ÒÑÑ" n dat @nmod #11->12
"<Ð±Ð°ÑÐ´ÑÒ>"
	"Ð±Ð°Ñ" v iv ifi p1 pl @root #12->0
"<.>"
	"." sent @punct #13->12`,

with_spans: `# text = He boued e tebr Mona er gegin.
# text[eng] = Mona eats her food here in the kitchen.
# labels = press_1986 ch_syntax p_197 to_check
"<He>"
	"he" det pos f sp @det #1->2
"<boued>"
	"boued" n m sg @obj #2->4
"<e>"
	"e" vpart obj @aux #3->4
"<tebr>"
	"debriÃ±" vblex pri p3 sg @root #4->0
"<Mona>"
	"Mona" np ant f sg @nsubj #5->4
"<er>"
	"e" pr @case #6->8
		"an" det def sp @det #7->8
"<gegin>"
	"kegin" n f sg @obl #8->4
"<.>"
	"." sent @punct #9->4`,

apertium_kaz_1: `# https://bpaste.net/show/be7c03e6213e
"<Ð§Ð°Ñ>"
	"*Ð§Ð°Ñ"
"<->"
	"Ñ" guio
	"-" guio
"<ÑÐ°Ñ>"
	"*ÑÐ°Ñ"
"<ÑÑÒÑ>"
	"ÑÑÒÑ" n attr
	"ÑÑÒ" v tv ger nom
	"ÑÑÒ" v iv ger nom
	"ÑÑÒÑ" n nom
;	"ÑÑÒÑ" n nom
;		"Ðµ" cop aor p3 pl REMOVE:294
;	"ÑÑÒÑ" n nom
;		"Ðµ" cop aor p3 sg REMOVE:294
;	"ÑÑÒ" vaux ger nom REMOVE:766
"<ÑÐµÐ³ÑÐ½ÐµÐ½>"
	"ÑÐµÐº" n px3sp abl
;	"ÑÐµÐº" n px3sp abl
;		"Ðµ" cop aor p3 pl REMOVE:294
;	"ÑÐµÐº" n px3sp abl
;		"Ðµ" cop aor p3 sg REMOVE:294
"<ÑÐ¿Ð¸ÑÑÐµÑ>"
	"*ÑÐ¿Ð¸ÑÑÐµÑ"
"<ÑÐ¾Ð±ÑÐ½Ð°>"
	"ÑÐ¾Ð¿" n px3sp dat
"<Ð¶Ð°ÑÐ°Ð´Ñ>"
	"Ð¶Ð°Ñ" v iv aor p3 sg
;	"Ð¶Ð°Ñ" vaux aor p3 pl REMOVE:766
;	"Ð¶Ð°Ñ" vaux aor p3 sg REMOVE:766
;	"Ð¶Ð°Ñ" v iv aor p3 pl REMOVE:846
"<.>"
	"." sent`,

apertium_kaz_2: `# https://bpaste.net/show/be7c03e6213e
"<ÒÐ°Ð½ÑÐ½Ð´Ð°>"
	"ÒÐ°Ð½" n px3sp loc
;	"ÒÐ°Ð½" n px3sp loc
;		"Ðµ" cop aor p3 pl REMOVE:294
;	"ÒÐ°Ð½" n px3sp loc
;		"Ðµ" cop aor p3 sg REMOVE:294
"<ÑÐ¸Ð±ÐµÑ>"
	"*ÑÐ¸Ð±ÐµÑ"
"<Ð¸ÑÑÐ½ÑÒ£>"
	"Ð¸Ñ" n px3sp gen
"<(>"
	"(" lpar
"<Ð¼Ð°ÑÑÐ¸Ñ>"
	"*Ð¼Ð°ÑÑÐ¸Ñ"
"<)>"
	")" rpar
"<ÒÐ°Ð½Ñ>"
	"ÒÐ°Ð½" n px3sp nom
;	"ÒÐ°Ð½" n px3sp nom
;		"Ðµ" cop aor p3 pl REMOVE:294
;	"ÒÐ°Ð½" n px3sp nom
;		"Ðµ" cop aor p3 sg REMOVE:294
"<Ð±Ð°Ñ>"
	"Ð±Ð°Ñ" adj SELECT:1118
	"Ð±Ð°Ñ" adj subst nom SELECT:1118
		"Ðµ" cop aor p3 sg
	"Ð±Ð°Ñ" adj subst nom SELECT:1118
	"Ð±Ð°Ñ" adj SELECT:1118
		"Ðµ" cop aor p3 sg
;	"Ð±Ð°Ñ" n attr REMOVE:567
;	"Ð±Ð°Ñ" adj
;		"Ðµ" cop aor p3 pl REMOVE:853
;	"Ð±Ð°Ñ" n nom
;		"Ðµ" cop aor p3 pl REMOVE:853
;	"Ð±Ð°Ñ" adj subst nom
;		"Ðµ" cop aor p3 pl REMOVE:853
;	"Ð±Ð°Ñ" n nom SELECT:1118
;	"Ð±Ð°Ñ" det qnt SELECT:1118
;	"Ð±Ð°Ñ" v iv imp p2 sg SELECT:1118
;	"Ð±Ð°Ñ" n nom SELECT:1118
;		"Ðµ" cop aor p3 sg
"<Ð´ÐµÐ³ÐµÐ½>"
	"Ð´Ðµ" v tv gpr_past SELECT:813
	"Ð´Ðµ" v tv gpr_past subst nom SELECT:813
;	"Ð´Ðµ" v tv ger_past nom SELECT:813
;	"Ð´Ðµ" v tv past p3 pl SELECT:813
;	"Ð´Ðµ" v tv past p3 sg SELECT:813
"<ÑÒ±Ð¶ÑÑÑÐ¼>"
	"ÑÒ±Ð¶ÑÑÑÐ¼" n nom
	"ÑÒ±Ð¶ÑÑÑÐ¼" n attr
;	"ÑÒ±Ð¶ÑÑÑÐ¼" n nom
;		"Ðµ" cop aor p3 pl REMOVE:294
;	"ÑÒ±Ð¶ÑÑÑÐ¼" n nom
;		"Ðµ" cop aor p3 sg REMOVE:294
"<Ð±Ð°Ñ>"
	"Ð±Ð°Ñ" adj
	"Ð±Ð°Ñ" n nom
	"Ð±Ð°Ñ" adj
		"Ðµ" cop aor p3 sg
	"Ð±Ð°Ñ" adj subst nom
		"Ðµ" cop aor p3 sg
	"Ð±Ð°Ñ" adj subst nom
	"Ð±Ð°Ñ" v iv imp p2 sg
	"Ð±Ð°Ñ" n nom
		"Ðµ" cop aor p3 sg
;	"Ð±Ð°Ñ" det qnt REMOVE:551
;	"Ð±Ð°Ñ" n attr REMOVE:567
;	"Ð±Ð°Ñ" adj subst nom
;		"Ðµ" cop aor p3 pl REMOVE:853
;	"Ð±Ð°Ñ" adj
;		"Ðµ" cop aor p3 pl REMOVE:853
;	"Ð±Ð°Ñ" n nom
;		"Ðµ" cop aor p3 pl REMOVE:853
"<.>"
	"." sent`

};

},{}],399:[function(require,module,exports){
module.exports = {
turkic: `# sent_id = mst-0008
# text = Ercan Tezer, iÃ§ pazarda bu yÄ±l seksen bin otomobil ve toplam yuzotuz bin araÃ§ satÄ±lmasÄ±nÄ±n beklendiÄini kaydederek, " onalti yÄ±l geriden gidiyoruz " dedi.
1	Ercan	Ercan	PROPN	Prop	Case=Nom|Number=Sing|Person=3	26	nsubj	_	_
2	Tezer	Tezer	PROPN	Prop	Case=Nom|Number=Sing|Person=3	1	flat	_	SpaceAfter=No
3	,	,	PUNCT	Punc	_	26	punct	_	_
4	iÃ§	iÃ§	ADJ	Adj	_	16	amod	_	_
5	pazarda	pazar	NOUN	Noun	Case=Loc|Number=Sing|Person=3	4	compound	_	_
6	bu	bu	DET	Det	_	7	det	_	_
7	yÄ±l	yÄ±l	NOUN	Noun	Case=Nom|Number=Sing|Person=3	16	obl	_	_
8	seksen	seksen	NUM	ANum	NumType=Card	10	nummod	_	_
9	bin	bin	NUM	ANum	NumType=Card	8	flat	_	_
10	otomobil	otomobil	NOUN	Noun	Case=Nom|Number=Sing|Person=3	16	nsubj	_	_
11	ve	ve	CCONJ	Conj	_	15	cc	_	_
12	toplam	toplam	NOUN	Noun	Case=Nom|Number=Sing|Person=3	13	obl	_	_
13	yuzotuz	yuzotuz	NUM	ANum	NumType=Card	15	nummod	_	_
14	bin	bin	NUM	ANum	NumType=Card	13	flat	_	_
15	araÃ§	araÃ§	NOUN	Noun	Case=Nom|Number=Sing|Person=3	10	conj	_	_
16	satÄ±lmasÄ±nÄ±n	sat	VERB	Verb	Aspect=Perf|Case=Gen|Mood=Ind|Number[psor]=Sing|Person[psor]=3|Polarity=Pos|Tense=Pres|VerbForm=Vnoun|Voice=Pass	17	nmod:poss	_	_
17	beklendiÄini	bekle	VERB	Verb	Aspect=Perf|Case=Acc|Mood=Ind|Number[psor]=Sing|Person[psor]=3|Polarity=Pos|Tense=Past|VerbForm=Part|Voice=Pass	18	obj	_	_
18	kaydederek	kaydet	VERB	Verb	Aspect=Perf|Mood=Ind|Polarity=Pos|Tense=Pres|VerbForm=Conv	26	nmod	_	SpaceAfter=No
19	,	,	PUNCT	Punc	_	18	punct	_	_
20	"	"	PUNCT	Punc	_	24	punct	_	_
21	onalti	onalti	NUM	ANum	NumType=Card	22	nummod	_	_
22	yÄ±l	yÄ±l	NOUN	Noun	Case=Nom|Number=Sing|Person=3	23	nmod	_	_
23	geriden	geri	ADJ	NAdj	Case=Abl|Number=Sing|Person=3	24	amod	_	_
24	gidiyoruz	git	VERB	Verb	Aspect=Prog|Mood=Ind|Number=Plur|Person=1|Polarity=Pos|Polite=Infm|Tense=Pres	26	obj	_	_
25	"	"	PUNCT	Punc	_	24	punct	_	_
26	dedi	de	VERB	Verb	Aspect=Perf|Mood=Ind|Number=Sing|Person=3|Polarity=Pos|Tense=Past	0	root	_	SpaceAfter=No
27	.	.	PUNCT	Punc	_	26	punct	_	_`,

labels_1: `# text = "This is a simple sentence."
# labels = label1 another_label a-third-label
1	This	This	_	_	_	_	_	_	_
2	is	is	_	_	_	_	_	_	_
3	a	a	_	_	_	_	_	_	_
4	simple	simple	_	_	_	_	_	_	_
5	sentence	sentence	_	_	_	_	_	_	_
6	.	.	PUNCT	PUNCT	_	_	_	_	_`,

labels_2: `# labels = one_label second third-label
# labels = row_2 again:here this, that
1	This	This	_	_	_	_	_	_	_`,

labels_3: `# tags = this-is-a-tag test testing test
1	This	This	_	_	_	_	_	_	_`,

labels_4: `# labels = new label1 one_label this-is-a-tag
1	Hullo	hello	_	_	_	_	_	_	_`,

nested_2: `# text = ab cde f h
1-2	ab	_	_	_	_	_	_	_	_
1	a	A	_	_	_	_	_	_	_
2	b	B	_	_	_	_	_	_	_
3-5	cde	_	_	_	_	_	_	_	_
3	c	C	_	_	_	_	_	_	_
4	d	D	_	_	_	_	_	_	_
5	e	E	_	_	_	_	_	_	_
6	f	F	_	_	_	_	_	_	_
6.1	silent_g	G	_	_	_	_	_	_	_
7	h	H	_	_	_	_	_	_	_`,

t: `# testing :)
1-3	He	_	_	_	_	_	_	_	_
1	boued	boued	n	_	m|sg	4	obj	_	_
2	e	e	vpart	_	obj	4	aux	_	_
3	tebr	debriÃ±	vblex	_	pri|p3|sg	0	root	_	_
4	doob	doobie	np	_	_	3	_	_	_
5	Mona	Mona	np	_	ant|f|sg	4	nsubj	_	_`,

empty: `1      Sue       Sue       _       _       _       _       _       _       _
2      likes     like       _       _       _       _       _       _       _
3      coffee    coffee       _       _       _       _       _       _       _
4      and       and       _       _       _       _       _       _       _
5      Bill      Bill       _       _       _       _       _       _       _
5.1    likes     like       _       _       _       _       _       _       _
6      tea       tea       _       _       _       _       _       _       _`,

0: `# sent_id = _
# text = this is a test
1	this	_	_	_	_	_	_	_	_
2	is	_	_	_	_	_	_	_	_
3	a	_	_	_	_	_	_	_	_
4	test	_	_	_	_	_	_	_	_`,

1: `1	this	_	_	_	_	_	_	_	_
2	is	_	_	_	_	_	_	_	_
3	a	_	_	_	_	_	_	_	_
4	test	_	_	_	_	_	_	_	_`,

cat_ancora: `# url = https://raw.githubusercontent.com/UniversalDependencies/UD_Catalan-AnCora/dev/ca_ancora-ud-test.conllu
# sent_id = test-s1
# text = El darrer nÃºmero de l'Observatori del Mercat de Treball d'Osona inclou un informe especial sobre la contractaciÃ³ a travÃ©s de les empreses de treball temporal, les ETT.
# orig_file_sentence 001#1
1	El	el	DET	DET	Definite=Def|Gender=Masc|Number=Sing|PronType=Art	3	det	_	_
2	darrer	darrer	ADJ	ADJ	Gender=Masc|Number=Sing|NumType=Ord	3	amod	_	_
3	nÃºmero	nÃºmero	NOUN	NOUN	Gender=Masc|Number=Sing	13	nsubj	_	_
4	de	de	ADP	ADP	AdpType=Prep	6	case	_	_
5	l'	el	DET	DET	Definite=Def|Number=Sing|PronType=Art	6	det	_	SpaceAfter=No
6	Observatori	Observatori	PROPN	PROPN	_	3	nmod	_	MWE=Observatori_del_Mercat_de_Treball_d'_Osona|MWEPOS=PROPN
7	del	del	ADP	ADP	AdpType=Preppron|Gender=Masc|Number=Sing	8	case	_	_
8	Mercat	Mercat	PROPN	PROPN	_	6	flat	_	_
9	de	de	ADP	ADP	AdpType=Prep	10	case	_	_
10	Treball	Treball	PROPN	PROPN	_	6	flat	_	_
11	d'	d'	ADP	ADP	AdpType=Prep	12	case	_	SpaceAfter=No
12	Osona	Osona	PROPN	PROPN	_	6	flat	_	_
13	inclou	incloure	VERB	VERB	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	0	root	_	_
14	un	un	NUM	NUM	Gender=Masc|Number=Sing|NumType=Card	15	nummod	_	_
15	informe	informe	NOUN	NOUN	Gender=Masc|Number=Sing	13	obj	_	_
16	especial	especial	ADJ	ADJ	Number=Sing	15	amod	_	_
17	sobre	sobre	ADP	ADP	AdpType=Prep	19	case	_	_
18	la	el	DET	DET	Definite=Def|Gender=Fem|Number=Sing|PronType=Art	19	det	_	_
19	contractaciÃ³	contractaciÃ³	NOUN	NOUN	Gender=Fem|Number=Sing	15	nmod	_	_
20	a	a	ADP	ADP	AdpType=Prep	24	case	_	MWE=a_travÃ©s_de|MWEPOS=ADP
21	travÃ©s	travÃ©s	NOUN	NOUN	_	20	fixed	_	_
22	de	de	ADP	ADP	AdpType=Prep	20	fixed	_	_
23	les	el	DET	DET	Definite=Def|Gender=Fem|Number=Plur|PronType=Art	24	det	_	_
24	empreses	empresa	NOUN	NOUN	Gender=Fem|Number=Plur	19	nmod	_	_
25	de	de	ADP	ADP	AdpType=Prep	26	case	_	_
26	treball	treball	NOUN	NOUN	Gender=Masc|Number=Sing	24	nmod	_	_
27	temporal	temporal	ADJ	ADJ	Number=Sing	26	amod	_	SpaceAfter=No
28	,	,	PUNCT	PUNCT	PunctType=Comm	30	punct	_	_
29	les	el	DET	DET	Definite=Def|Gender=Fem|Number=Plur|PronType=Art	30	det	_	_
30	ETT	ETT	PROPN	PROPN	_	24	appos	_	SpaceAfter=No
31	.	.	PUNCT	PUNCT	PunctType=Peri	13	punct	_	_`,

with_tabs: `# sent_id = chapID01:paragID1:sentID1
# text = ÐÐµÑÐ°ÐµÐ½Ñ ÑÑÑÐ³Ð¾Ð·ÑÐ¸Ð·Ñ Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÑÑÑ ÐºÐ°ÑÐ²Ð¾Ñ .
# text[eng] = Kechai was awoken by annoying flies.
1	ÐÐµÑÐ°ÐµÐ½Ñ	ÐÐµÑÐ°Ð¹	N	N	Sem/Ant_Mal|Prop|SP|Gen|Indef	2	obj	_	ÐÐµÑÐ°ÐµÐ½Ñ
2	ÑÑÑÐ³Ð¾Ð·ÑÐ¸Ð·Ñ	ÑÑÑÐ³Ð¾Ð·ÑÐµÐ¼Ñ	V	V	TV|Ind|Prt1|ScPl3|OcSg3	0	root	_	ÑÑÑÐ³Ð¾Ð·ÑÐ¸Ð·Ñ
3	Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÑÑÑ	Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÐ¾Ð¼Ñ	PRC	Prc	V|TV|PrcPrsL|Sg|Nom|Indef	4	amod	_	Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÑÑÑ
4	ÐºÐ°ÑÐ²Ð¾Ñ	ÐºÐ°ÑÐ²Ð¾	N	N	Sem/Ani|N|Pl|Nom|Indef	2	nsubj	_	ÐºÐ°ÑÐ²Ð¾Ñ
5	.	.	CLB	CLB	CLB	2	punct	_	.`,

without_tabs: `# sent_id = chapID01:paragID1:sentID1
# text = ÐÐµÑÐ°ÐµÐ½Ñ ÑÑÑÐ³Ð¾Ð·ÑÐ¸Ð·Ñ Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÑÑÑ ÐºÐ°ÑÐ²Ð¾Ñ .
# text[eng] = Kechai was awoken by annoying flies.
1 ÐÐµÑÐ°ÐµÐ½Ñ ÐÐµÑÐ°Ð¹ N N Sem/Ant_Mal|Prop|SP|Gen|Indef 2 obj _ ÐÐµÑÐ°ÐµÐ½Ñ
2 ÑÑÑÐ³Ð¾Ð·ÑÐ¸Ð·Ñ ÑÑÑÐ³Ð¾Ð·ÑÐµÐ¼Ñ V V TV|Ind|Prt1|ScPl3|OcSg3 0 root _ ÑÑÑÐ³Ð¾Ð·ÑÐ¸Ð·Ñ
3 Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÑÑÑ Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÐ¾Ð¼Ñ PRC Prc V|TV|PrcPrsL|Sg|Nom|Indef 4 amod _ Ð½Ð°Ð»ÐºÑÑÐ°Ð²ÑÑÑÑ
4 ÐºÐ°ÑÐ²Ð¾Ñ ÐºÐ°ÑÐ²Ð¾ N N Sem/Ani|N|Pl|Nom|Indef 2 nsubj _ ÐºÐ°ÑÐ²Ð¾Ñ
5 . . CLB CLB CLB 2 punct _ .`,

from_cg3_with_semicolumn: `1	SiedzieliÅmy	siedzieÄ	vblex	_	impf|past|p1|m|pl	_	_	_	_
2	w	w	pr	_	_	_	_	_	_
3	moim	mÃ³j	prn	_	pos|mi|sg|loc	_	_	_	_
4	pokoju	pokÃ³j	n	_	mi|sg|loc	_	_	_	_
5	,	,	cm	_	_	_	_	_	_
6	palÄc	paliÄ	vblex	_	impf|pprs|adv	_	_	_	_
7	i	i	cnjcoo	_	_	_	_	_	_
8	rozmawiajÄc	rozmawiaÄ	vblex	_	impf|pprs|adv	_	_	_	_
9	o	o	pr	_	_	_	_	_	_
10	tem	to	prn	_	dem|mi|sg|loc	_	_	_	_
11	,	,	cm	_	_	_	_	_	_
12	jak	jak	rel	_	adv	_	_	_	_
13	marni	marny	adj	_	sint|mp|pl|nom	_	_	_	_
14	jesteÅmy	byÄ	vbser	_	pres|p1|pl	_	_	_	_
15	,	,	cm	_	_	_	_	_	_
16	marni	marny	adj	_	sint|mp|pl|nom	_	_	_	_
17	z	z	pr	_	_	_	_	_	_
18	lekarskiego	lekarski	adj	_	mi|sg|gen	_	_	_	_
19	punktu	punkt	n	_	mi|sg|gen	_	_	_	_
20	widzenia	widzieÄ	vblex	_	impf|ger|nt|sg|gen	_	_	_	_
21	chcÄ	chcieÄ	vblex	_	impf|pres|p1|sg	_	_	_	_
22	powiedzieÄ	powiedzieÄ	vblex	_	perf|inf	_	_	_	_
23	,	,	cm	_	_	_	_	_	_
24	naturalnie	naturalnie	adv	_	sint	_	_	_	_
25	.	.	sent	_	_	_	_	_	_`,

from_cg3_simple: `1	ÐÐ°ÑÑÐ°Ð¼ÐµÐ½	Ð¿Ð°ÑÑÐ°	n	_	ins	3	nmod	_	_
2	ÑÐ¾ÒÑÑ	ÑÐ¾ÒÑÑ	n	_	nom	3	obj	_	_
3	Ð°ÑÒÐ°Ð½Ð´Ð°	Ð°Ñ	v	_	tv|ger_past|loc	12	advcl	_	_
4	,	,	cm	_	_	12	punct	_	_
5	ÐµÐ»-Ð¶Ò±ÑÑ	ÐµÐ»-Ð¶Ò±ÑÑ	n	_	nom	7	conj	_	_
6	,	,	cm	_	_	7	punct	_	_
7	Ð¾ÑÐ°Ð½ÑÐ¼Ð´Ñ	Ð¾ÑÐ°Ð½	n	_	px1sg|acc	8	obj	_	_
8	ÒÐ¾ÑÒÐ°ÑÒÐ°	ÒÐ¾ÑÒÐ°	v	_	tv|ger|dat	12	advcl	_	_
9	,	,	cm	_	_	12	punct	_	_
10	Ð±ÑÐ·	Ð±ÑÐ·	prn	_	pers|p1|pl|nom	12	nsubj	_	_
11	ÑÐ¾ÒÑÑÒÐ°	ÑÐ¾ÒÑÑ	n	_	dat	12	nmod	_	_
12	Ð±Ð°ÑÐ´ÑÒ	Ð±Ð°Ñ	v	_	iv|ifi|p1|pl	0	root	_	_
13	.	.	sent	_	_	12	punct	_	_
`,

from_cg3_with_spans: `# text = He boued e tebr Mona er gegin.
# text[eng] = Mona eats her food here in the kitchen.
# labels = press_1986 ch_syntax p_197 to_check
1	He	he	det	_	pos|f|sp	2	det	_	_
2	boued	boued	n	_	m|sg	4	obj	_	_
3	e	e	vpart	_	obj	4	aux	_	_
4	tebr	debriÃ±	vblex	_	pri|p3|sg	0	root	_	_
5	Mona	Mona	np	_	ant|f|sg	4	nsubj	_	_
6-7	er	_	_	_	_	_	_	_	_
6	_	e	pr	_	_	8	case	_	_
7	_	an	det	_	def|sp	8	det	_	_
8	gegin	kegin	n	_	f|sg	4	obl	_	_
9	.	.	sent	_	_	4	punct	_	_
`,

rueter_long: `# sent_id = BryzhinskijMixail_Kirdazht_manu:3859
# text = ÐÐ¾ Ð·ÑÑÑ Ð²Ð°Ð»Ð³ÑÑ , Ð·ÑÑÑ Ð¿Ð°Ð½Ð¶ÑÐ½ÐµÑÑ Ð´Ñ Ð¼ÐµÐºÐµÐ² Ð¿Ð°ÑÑÑÐµ Ð¿ÐµÐºÑÑÐ½ÐµÑÑ Ð²ÐµÐ»Ðµ ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ , ÐºÑÐ¶Ð¾ ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ , ÐºÑÑÐ¾ ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ Ð´Ñ ÑÑÐµÑÑ ÑÑÑÑ ÑÐ¾Ð²Ð°Ð¼Ð¾ ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ ÑÑÑÐ²Ð° Ð»Ð¸ÑÐ¸ÑÑÐ½ÑÐµÐ½Ñ ÑÐ¾Ð²Ð¸ÑÑÐ½ÑÐµÐ½Ñ ÑÐµ ÑÐ²Ð°Ð» ÑÐµÐ¹Ð½ÐµÐ¼Ð° , ÐºÐµÐ½ÐºÑÑÐ½Ðµ ÑÐ²Ð°Ð» Ð¿ÐµÐºÑÑÐ°Ð·Ñ ÑÐ»ÐµÐ·Ñ ; Ð¿Ð°Ð½Ð¶ÑÐ½ÐµÑÑÐ·Ñ ÐºÐµÐ»ÐµÑ Ð°Ð½ÑÑÐº Ð²Ð°Ð»ÑÐºÐµ Ð¼Ð°ÑÑÐ¾ Ð´Ñ ÑÐ¾Ð¿Ð¾Ð½ÑÐ±ÐµÐ»ÐµÐ² â ÑÐ°ÐºÑÐ°Ð½Ñ Ð»Ð¸Ð²ÑÐµÐ¼Ð° ÑÐ¾Ð²Ð°Ð²ÑÐ¾Ð¼Ð° ÑÐºÐ°Ð½Ðµ , ÐºÑÐ¹Ð¼ÐµÑÑ ÑÐ°Ð³Ð¾ ÑÑÐ°ÐºÐ°Ð»Ð³Ð°Ð´ÑÑ .
# text_en = But by the time he got down the hill, opened and closed the village gate, the lane gate, the cluster gate and the one to their own home (something everyone coming or going had to do, so the gates would always be closed; they were only opened in the morning and at dusk for taking out and letting in the cattle), the wicker of clay had grown heavy again.
# text_fi = Kun KetÅ¡ai tuli mÃ¤eltÃ¤ alas, avasi ja sulki huolellisesti kylÃ¤verÃ¤jÃ¤nsÃ¤, ??aukio/kenttÃ¤verÃ¤jÃ¤n, kujaverÃ¤jÃ¤n ja oman kotiverÃ¤jÃ¤n, savikontti ehti taas alkaa painaa hÃ¤nen selkÃ¤Ã¤nsÃ¤. (Kaikkien kÃ¤vijÃ¶iden tulee tehdÃ¤ nÃ¤in, jotta verÃ¤jÃ¤t olisivat aina kiinni, verÃ¤jÃ¤thÃ¤n pidetÃ¤Ã¤n selkosen selÃ¤llÃ¤Ã¤n vain aamulla ja illansuussa, kun karjaa ajetaan laitumelle tai kotiin.)
1 ÐÐ¾ Ð½Ð¾ CCONJ CC _ 3 cc _ _
2 Ð·ÑÑÑ Ð·ÑÑÑ ADV Adv|Der/Ill|Adv|Sem/Time Derivation=Ill|AdvType=Tim 3 mark _ _
3 Ð²Ð°Ð»Ð³ÑÑ Ð²Ð°Ð»Ð³Ð¾Ð¼Ñ VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 51 advcl _ SpaceAfter=No
4 , , PUNCT CLB _ 6 punct _ _
5 Ð·ÑÑÑ Ð·ÑÑÑ ADV Adv|Der/Ill|Adv|Sem/Time Derivation=Ill|AdvType=Tim 6 mark _ _
6 Ð¿Ð°Ð½Ð¶ÑÐ½ÐµÑÑ Ð¿Ð°Ð½Ð¶ÑÐ½ÐµÐ¼Ñ VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 3 conj _ _
7 Ð´Ñ Ð´Ñ CCONJ CC _ 10 cc _ _
8 Ð¼ÐµÐºÐµÐ² Ð¼ÐµÐºÐµÐ² ADV Adv|Lat|Sg|Nom|Indef Case=Lat|Case=Nom|Definite=Ind|Number=Sing 10 advmod _ _
9 Ð¿Ð°ÑÑÑÐµ Ð¿Ð°ÑÑÑÐµ ADV Adv|Manner AdvType=Man 10 advmod _ _
10 Ð¿ÐµÐºÑÑÐ½ÐµÑÑ Ð¿ÐµÐºÑÑÐ½ÐµÐ¼Ñ VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 3 conj _ _
11 Ð²ÐµÐ»Ðµ Ð²ÐµÐ»Ðµ NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 10 obj _ _
12 ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ ÐºÐµÐ½ÐºÑ NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 11 goeswith _ SpaceAfter=No
13 , , PUNCT CLB _ 15 punct _ _
14 ÐºÑÐ¶Ð¾ ÐºÑÐ¶Ð¾ NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 12 conj _ _
15 ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ ÐºÐµÐ½ÐºÑ NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 14 goeswith _ SpaceAfter=No
16 , , PUNCT CLB _ 18 punct _ _
17 ÐºÑÑÐ¾ ÐºÑÑÐ¾ NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 12 conj _ _
18 ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ ÐºÐµÐ½ÐºÑ NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 17 goeswith _ _
19 Ð´Ñ Ð´Ñ CCONJ CC _ 23 cc _ _
20 ÑÑÐµÑÑ ÑÑÑ PRON Pron|Refl|Pl3|Gen|Variant=Short Case=Gen|Number=Plur|Person=3|PronType=Refl|Variant=Short 22 nmod _ _
21 ÑÑÑÑ ÑÑÑ NOUN N|Sem/Inanim_Cnt|SP|Ill|Indef Case=Ill|Definite=Ind|Number=Plur,Sing 20 case _ _
22 ÑÐ¾Ð²Ð°Ð¼Ð¾ ÑÐ¾Ð²Ð°Ð¼Ð¾ NOUN N|IV|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing|Valency=1 23 compound _ _
23 ÐºÐµÐ½ÐºÑÐµÐ½ÑÑ ÐºÐµÐ½ÐºÑ NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 12 conj _ _
24 ( ( PUNCT PUNCT _ 29 punct _ SpaceAfter=No
25 ÑÑÑÐ²Ð° ÑÑÑÐ²Ð° DET Det|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 26 det _ _
26 Ð»Ð¸ÑÐ¸ÑÑÐ½ÑÐµÐ½Ñ-ÑÐ¾Ð²Ð¸ÑÑÐ½ÑÐµÐ½Ñ Ð»Ð¸ÑÐ¸ÑÑÑ-ÑÐ¾Ð²Ð¸ÑÑÑ NOUN N|V|NomAg|Sg|Dat|Def Case=Dat|Definite=Def|Derivation=NomAg|Number=Sing 29 obl _ _
27 ÑÐµ ÑÐµ PRON Pron|Dem|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing|PronType=Dem 29 nsubj _ _
28 ÑÐ²Ð°Ð» ÑÐ²Ð°Ð» ADV Adv|Tot|Sem/Time_dur PronType=Tot|PronType=Tot 29 advmod _ _
29 ÑÐµÐ¹Ð½ÐµÐ¼Ð° ÑÐµÐ¹Ð½ÐµÐ¼c VERB V|TV|Oblig|Clitic=Cop|Prs|ScSg3 Valency=2|VerbForm=Oblig|Clitic=Cop|Number[subj]=Sing|Person[subj]=3|Tense=Pres 3 parataxis _ SpaceAfter=No
30 , , PUNCT CLB _ 33 punct _ _
31 ÐºÐµÐ½ÐºÑÑÐ½Ðµ ÐºÐµÐ½ÐºÑ NOUN N|Sem/Inanim_Cnt|Pl|Nom|Def Case=Nom|Definite=Def|Number=Plur 34 nsubj _ _
32 ÑÐ²Ð°Ð» ÑÐ²Ð°Ð» ADV Adv|Tot|Sem/Time_dur PronType=Tot|PronType=Tot 33 advmod _ _
33 Ð¿ÐµÐºÑÑÐ°Ð·Ñ Ð¿ÐµÐºÑÑÐ°Ð¼Ñ VERB V|Der/ÐÐ·Ñ|Ger Derivation=Ozj|VerbForm=Conv 29 ccomp _ _
34 ÑÐ»ÐµÐ·Ñ ÑÐ»ÐµÐ¼Ñ AUX V|IV|Opt|ScPl3 Mood=Opt|Number[subj]=Plur|Person[subj]=3|Valency=1 33 cop _ SpaceAfter=No
35 ; ; PUNCT CLB _ 29 punct _ _
36 Ð¿Ð°Ð½Ð¶ÑÐ½ÐµÑÑÐ·Ñ Ð¿Ð°Ð½Ð¶ÑÐ½ÐµÐ¼Ñ VERB V|Ind|Prs|ScPl3|Obj3 Mood=Ind|Number[subj]=Plur|Person[subj]=3|Tense=Pres|Obj3 29 conj _ _
37 ÐºÐµÐ»ÐµÑ ÐºÐµÐ»ÐµÑ ADV Adv Adv 36 advmod _ _
38 Ð°Ð½ÑÑÐº Ð°Ð½ÑÑÐº ADV Adv Adv 39 advmod _ _
39 Ð²Ð°Ð»ÑÐºÐµ Ð²Ð°Ð»ÑÐºÐµ NOUN N|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 36 obl _ _
40 Ð¼Ð°ÑÑÐ¾ Ð¼Ð°ÑÑÐ¾ ADP Adp|Po AdpType=Post 39 case _ _
41 Ð´Ñ Ð´Ñ CCONJ CC _ 42 cc _ _
42 ÑÐ¾Ð¿Ð¾Ð½ÑÐ±ÐµÐ»ÐµÐ² ÑÐ¾Ð¿Ð¾Ð½ÑÐ±ÐµÐ»ÐµÐ² ADV Adv|Lat Case=Lat 39 conj _ _
43 â â PUNCT CLB _ 46 punct _ _
44 ÑÐ°ÐºÑÐ°Ð½Ñ ÑÐ°ÐºÑÐ° NOUN N|Sem/Anim_Cnt|SP|Gen|Indef Case=Gen|Definite=Ind|Number=Plur,Sing 45 nmod:gobj _ _
45 Ð»Ð¸Ð²ÑÐµÐ¼Ð°-ÑÐ¾Ð²Ð°Ð²ÑÐ¾Ð¼Ð° Ð»Ð¸Ð²ÑÐµÐ¼Ð°-ÑÐ¾Ð²Ð°Ð²ÑÐ¾Ð¼Ð° NOUN N|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 36 nmod _ _
46 ÑÐºÐ°Ð½Ðµ ÑÐºÐ° NOUN N|Sem/Time|SP|Temp|Indef Case=Temp|Definite=Ind|Number=Plur,Sing 39 conj _ SpaceAfter=No
47 ) ) PUNCT PUNCT _ 29 punct _ SpaceAfter=No
48 , , PUNCT CLB _ 29 punct _ _
49 ÐºÑÐ¹Ð¼ÐµÑÑ ÐºÑÐ¹Ð¼Ðµ NOUN N|Sem/Inanim_Cnt|Sg|Nom|Def Case=Nom|Definite=Def|Number=Sing 51 nsubj _ _
50 ÑÐ°Ð³Ð¾ ÑÐ°Ð³Ð¾ ADV Adv|Sem/Time AdvType=Tim 51 advmod _ _
51 ÑÑÐ°ÐºÐ°Ð»Ð³Ð°Ð´ÑÑ ÑÑÐ°ÐºÐ°Ð»Ð³Ð°Ð´Ð¾Ð¼Ñ VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 0 root _ SpaceAfter=No
52 . . PUNCT CLB _ 51 punct _ _`,

katya_aplonova_large_arrows: `# sent_id = html/meyer_gorog-contes_bambara_10amadu_tara.dis.html:16
# text = ko ni i sera ka jiri nin bulu sÃ²rÃ² ka na ni a ye, ko cÃ¨kÃ²rÃ²ba bÃ¨ se ka furakÃ¨ o la.
1	ko	kÃ³	PART	cop	_	4	discourse	_	Gloss=QUOT
2	ni	nÃ­	SCONJ	conj	_	4	mark	_	Gloss=si
3	i	Ã­	PRON	pers	PronType=Prs	4	nsubj	_	Gloss=2.SG
4	sera	sera	VERB	v	Aspect=Perf|Valency=1|Polarity=Pos	19	advcl	_	Gloss=arriver|Morf=arriver,PFV.INTR
5	ka	kÃ 	AUX	pm	_	9	aux	_	Gloss=INF
6	jiri	jÃ­ri	NOUN	n	_	8	nmod:poss	_	Gloss=arbre
7	nin	nÃ¬n	DET	prn/dtm	PronType=Dem|Definite-Def	6	det	_	Gloss=DEM
8	bulu	bÃºlu	NOUN	n	_	9	obj	_	Gloss=feuille
9	sÃ²rÃ²	sÉÌrÉ	VERB	v	_	4	xcomp	_	Gloss=obtenir
10	ka	kÃ 	AUX	pm	_	11	aux	_	Gloss=INF
11	na	nÃ 	VERB	v	_	9	xcomp	_	Gloss=venir
12	ni	nÃ­	ADP	conj/prep	_	13	case	_	Gloss=et
13	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	11	obl	_	Gloss=3SG
14	ye	yÃ©	ADP	pp	_	13	case	_	Gloss=PP
15	,	,	PUNCT	_	_	4	punct	_	Gloss=,
16	ko	kÃ³	PART	cop	_	19	discourse	_	Gloss=QUOT
17	cÃ¨kÃ²rÃ²ba	cÉÌ.kÉrÉ.ba	NOUN	n	_	19	nsubj	_	Gloss=vieillard|Morf=vieillard,mÃ¢le,vieux,AUGM
18	bÃ¨	bÉÌ	AUX	pm	Polarity=Pos|Aspect=Imp	19	aux	_	Gloss=IPFV.AFF
19	se	sÃ©	VERB	v	_	0	root	_	Gloss=arriver
20	ka	kÃ 	AUX	pm	_	21	aux	_	Gloss=INF
21	furakÃ¨	fÃºra.kÉ	VERB	v	_	19	xcomp	_	Gloss=soigner|Morf=soigner,feuille,faire
22	o	Ã²	PRON	prn	_	21	obl	_	Gloss=ce
23	la	lÃ¡	ADP	pp	_	22	case	_	Gloss=dans
24	.	.	PUNCT	_	_	19	punct	_	Gloss=.
`,

katya_aplonova_long: `# sent_id = html/meyer_gorog-contes_bambara_10amadu_tara.dis.html:19
# text = ko u ye mÃ²gÃ² nyini a ye, min bÃ¨ a furakÃ¨ sisan ko cÃ¨ ye furakÃ¨li cogoya bÃ¨Ã¨ fÃ², ko fura nin sÃ²rÃ² ka gÃ¨lÃ¨n ko epi ko ni o ye a sÃ²rÃ² u ye ale den de ye, ni min bÃ¨ sa de furanyini fÃ¨ a ka sa nin min bÃ¨ balo o ka balo ko u kÃ²nÃ²ntÃ² bÃ¨Ã¨ ka taga fura nin nyini, ko u kÃ²nÃ²ntÃ² bÃ¨Ã¨ ka taga ko nin min seginna ka a sÃ²rÃ² fura ma na, ko a bÃ¨ o den nin haramuya ka o gÃ¨n, ka a bÃ¨ a ba fana gÃ¨n ko u ka a filÃ¨ u yÃ¨rÃ¨ ni min ma sÃ²n fana ko a bÃ¨ o gÃ¨n, o ni a ba bÃ¨Ã¨.
# label = too_long_to_cut
1	ko	kÃ³	PART	cop	_	5	discourse	_	Gloss=QUOT
2	u	Ã¹	PRON	pers	PronType=Prs|Number=Plur|Person=3	5	nsubj	_	Gloss=3PL
3	ye	yÃ©	AUX	pm	Aspect=Perf|Valency=2|Polarity=Pos	5	aux	_	Gloss=PFV.TR
4	mÃ²gÃ²	mÉÌgÉ	NOUN	n	_	5	obj	_	Gloss=homme
5	nyini	É²Ã­ni	VERB	v	_	0	root	_	Gloss=chercher
6	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	5	obl	_	Gloss=3SG
7	ye	yÃ©	ADP	pp	_	6	case	_	Gloss=PP
8	,	,	PUNCT	_	_	5	punct	_	Gloss=,
9	min	mÃ­n	PRON	prn	PronType=Rel	_	_	_	Gloss=REL
10	bÃ¨	bÉÌ	AUX	pm	Polarity=Pos|Aspect=Imp	_	_	_	Gloss=IPFV.AFF
11	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
12	furakÃ¨	fÃºra.kÉ	VERB	v	_	_	_	_	Gloss=soigner|Morf=soigner,feuille,faire
13	sisan	sÃ­san	ADV	adv/n	_	_	_	_	Gloss=maintenant
14	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
15	cÃ¨	cÉÌ	NOUN	n	_	_	_	_	Gloss=mÃ¢le
16	ye	ye	AUX	pm	Aspect=Perf|Valency=2|Polarity=Pos	_	_	_	Gloss=PFV.TR
17	furakÃ¨li	fÃºrakÉli	NOUN	n	VerbalForm=Vnoun	_	_	_	Gloss=traitement|Morf=traitement,feuille,faire,NMLZ
18	cogoya	cÃ³goya	NOUN	n	_	_	_	_	Gloss=maniÃ¨re|Morf=maniÃ¨re,maniÃ¨re,ABSTR
19	bÃ¨Ã¨	bÉÌÉ	DET	dtm	_	_	_	_	Gloss=tout
20	fÃ²	fÉÌ	VERB	v	_	_	_	_	Gloss=dire
21	,	,	PUNCT	_	_	_	_	_	Gloss=,
22	ko	kÃ³	PART	cop	_	27	discourse	_	Gloss=QUOT
23	fura	fÃºra	NOUN	n	_	25	nmod:poss	_	Gloss=feuille
24	nin	nÃ¬n	DET	dtm	PronType=Dem|Definite-Def	23	det	_	Gloss=DEM
25	sÃ²rÃ²	sÉÌrÉ	NOUN	v	_	27	nsubj	_	Gloss=obtenir
26	ka	ka	AUX	pm	Polarity=Pos	27	aux	_	Gloss=QUAL.AFF
27	gÃ¨lÃ¨n	gÉÌlÉn	VERB	vq	_	_	_	_	Gloss=dur
28	ko	kÃ³	PART	cop	_	29	discourse	_	Gloss=QUOT
29	epi	epi	CCONJ	conj	_	27	cc	_	Gloss=ETRG.FRA
30	ko	kÃ³	VERB	cop	_	37	discourse	_	Gloss=QUOT
31	ni	nÃ­	SCONJ	conj	_	35	mark	_	Gloss=si
32	o	Ã²	PRON	prn	_	35	nsubj	_	Gloss=ce
33	ye	ye	AUX	pm	Aspect=Perf|Valency=2|Polarity=Pos	35	aux	_	Gloss=PFV.TR
34	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	35	obj	_	Gloss=3SG
35	sÃ²rÃ²	sÉÌrÉ	VERB	v	_	37	advcl	_	Gloss=obtenir
36	u	Ã¹	PRON	pers	PronType=Prs|Number=Plur|Person=3	37	nsubj	_	Gloss=3PL
37	ye	yÃ©	VERB	cop	Polarity=Pos	27	parataxis	_	Gloss=EQU
38	ale	Ã lÃª	PRON	pers	PronType=Prs|Number=Sing|Person=3|PronType=Emp	39	nmod:poss	_	Gloss=3SG.EMPH
39	den	dÃ©n	NOUN	n	_	37	obl	_	Gloss=enfant
40	de	dÃ¨	PART	prt	_	39	discourse	_	Gloss=FOC
41	ye	yÃ©	ADP	pp	_	39	case	_	Gloss=PP
42	,	,	PUNCT	_	_	37	punct	_	Gloss=,
43	ni	nÃ­	SCONJ	conj	_	46	mark	_	Gloss=si
44	min	mÃ®n	PRON	prn	PronType=Rel	46	_	_	Gloss=REL
45	bÃ¨	bÉ	AUX	pm	Polarity=Pos|Aspect=Imp	46	_	_	Gloss=IPFV.AFF
46	sa	sÃ 	VERB	v	_	52	_	_	Gloss=mourir
47	de	dÃ¨	PART	prt	_	46	_	_	Gloss=FOC
48	furanyini	furaÉ²ini	NOUN	n	_	46	_	_	Gloss=feuille|Morf=feuille,chercher
49	fÃ¨	fÉÌ	ADP	pp	_	48	_	_	Gloss=par
50	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	52	_	_	Gloss=3SG
51	ka	ka	AUX	pm	Mood=Subj|Polarity=Aff	52	_	_	Gloss=SBJV
52	sa	sÃ 	VERB	v	_	37	_	_	Gloss=mourir
53	nin	nÃ­	SCONJ	conj	_	56	mark	_	Gloss=quand
54	min	mÃ®n	PRON	prn	PronType=Rel	56	_	_	Gloss=REL
55	bÃ¨	bÉ	AUX	pm	Polarity=Pos|Aspect=Imp	56	_	_	Gloss=IPFV.AFF
56	balo	bÃ¡lo	VERB	v	_	59	_	_	Gloss=vivre
57	o	Ã²	PRON	prn	_	59	_	_	Gloss=ce
58	ka	ka	AUX	pm	Mood=Subj|Polarity=Aff	59	_	_	Gloss=SBJV
59	balo	bÃ¡lo	VERB	v	_	52	_	_	Gloss=vivre
60	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
61	u	Ã¹	PRON	pers	PronType=Prs|Number=Plur|Person=3	_	_	_	Gloss=3PL
62	kÃ²nÃ²ntÃ²	kÉÌnÉntÉn	NUM	num	_	_	_	_	Gloss=neuf
63	bÃ¨Ã¨	bÉÌÉ	DET	dtm	_	_	_	_	Gloss=tout
64	ka	ka	AUX	pm	Mood=Subj|Polarity=Aff	_	_	_	Gloss=SBJV
65	taga	tÃ¡ga	VERB	v	_	59	_	_	Gloss=aller
66	fura	fÃºra	NOUN	n	_	_	_	_	Gloss=feuille
67	nin	nÃ¬n	DET	dtm	PronType=Dem|Definite-Def	_	_	_	Gloss=DEM
68	nyini	É²Ã­ni	VERB	v	_	_	_	_	Gloss=chercher
69	,	,	PUNCT	_	_	_	_	_	Gloss=,
70	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
71	u	Ã¹	PRON	pers	PronType=Prs|Number=Plur|Person=3	_	_	_	Gloss=3PL
72	kÃ²nÃ²ntÃ²	kÉÌnÉntÉn	NUM	num	_	_	_	_	Gloss=neuf
73	bÃ¨Ã¨	bÉÌÉ	DET	dtm	_	_	_	_	Gloss=tout
74	ka	ka	AUX	pm	Mood=Subj|Polarity=Aff	_	_	_	Gloss=SBJV
75	taga	tÃ¡ga	VERB	v	_	65	_	_	Gloss=aller
76	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
77	nin	nÃ­	SCONJ	conj	_	_	_	_	Gloss=quand
78	min	mÃ®n	PRON	prn	PronType=Rel	_	_	_	Gloss=REL
79	seginna	seginna	VERB	v	Aspect=Perf|Valency=1|Polarity=Pos	85	_	_	Gloss=revenir|Morf=revenir,PFV.INTR
80	ka	kÃ 	AUX	pm	_	_	_	_	Gloss=INF
81	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
82	sÃ²rÃ²	sÉÌrÉ	VERB	v	_	_	_	_	Gloss=obtenir
83	fura	fÃºra	NOUN	n	_	_	_	_	Gloss=feuille
84	ma	ma	AUX	pm	Polarity=Neg|Aspect=Perf	_	_	_	Gloss=PFV.NEG
85	na	nÃ 	VERB	v	_	75	_	_	Gloss=venir
86	,	,	PUNCT	_	_	_	_	_	Gloss=,
87	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
88	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
89	bÃ¨	bÉ	AUX	pm	Polarity=Pos|Aspect=Imp	_	_	_	Gloss=IPFV.AFF
90	o	Ã²	PRON	prn	_	_	_	_	Gloss=ce
91	den	dÃ©n	NOUN	n	_	_	_	_	Gloss=enfant
92	nin	nÃ¬n	DET	dtm	PronType=Dem|Definite-Def	_	_	_	Gloss=DEM
93	haramuya	hÃ ramuya	VERB	v	_	85	_	_	Gloss=interdire|Morf=interdire,interdire,ABSTR
94	ka	kÃ 	AUX	pm	_	_	_	_	Gloss=INF
95	o	Ã²	PRON	prn	_	_	_	_	Gloss=ce
96	gÃ¨n	gÉÌn	VERB	v	_	_	_	_	Gloss=chasser
97	,	,	PUNCT	_	_	_	_	_	Gloss=,
98	ka	kÃ 	AUX	pm	_	_	_	_	Gloss=INF
99	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
100	bÃ¨	bÉ	AUX	pm	Polarity=Pos|Aspect=Imp	_	_	_	Gloss=IPFV.AFF
101	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
102	ba	bÃ¡	NOUN	n	_	_	_	_	Gloss=mÃ¨re
103	fana	fÃ¡na	PART	prt	_	_	_	_	Gloss=aussi
104	gÃ¨n	gÉÌn	VERB	v	_	_	_	_	Gloss=chasser
105	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
106	u	Ã¹	PRON	pers	PronType=Prs|Number=Plur|Person=3	_	_	_	Gloss=3PL
107	ka	ka	AUX	pm	Mood=Subj|Polarity=Aff	_	_	_	Gloss=SBJV
108	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
109	filÃ¨	fÃ­lÉ	VERB	v	_	_	_	_	Gloss=regarder
110	u	Ã¹	PRON	pers	PronType=Prs|Number=Plur|Person=3	_	_	_	Gloss=3PL
111	yÃ¨rÃ¨	yÉÌrÉÌ	DET	dtm	_	_	_	_	Gloss=mÃªme
112	ni	nÃ­	SCONJ	conj	_	_	_	_	Gloss=si
113	min	mÃ®n	PRON	prn	PronType=Rel	_	_	_	Gloss=REL
114	ma	ma	AUX	pm	Polarity=Neg|Aspect=Perf	_	_	_	Gloss=PFV.NEG
115	sÃ²n	sÉÌn	VERB	v	_	_	_	_	Gloss=accepter
116	fana	fÃ¡na	PART	prt	_	_	_	_	Gloss=aussi
117	ko	kÃ³	PART	cop	_	_	_	_	Gloss=QUOT
118	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
119	bÃ¨	bÉ	AUX	pm	Polarity=Pos|Aspect=Imp	_	_	_	Gloss=IPFV.AFF
120	o	Ã²	PRON	prn	_	_	_	_	Gloss=ce
121	gÃ¨n	gÉÌn	VERB	v	_	_	_	_	Gloss=chasser
122	,	,	PUNCT	_	_	_	_	_	Gloss=,
123	o	Ã²	PRON	prn	_	_	_	_	Gloss=ce
124	ni	ni	CCONJ	conj	_	_	_	_	Gloss=et
125	a	Ã 	PRON	pers	PronType=Prs|Number=Sing|Person=3	_	_	_	Gloss=3SG
126	ba	bÃ¡	NOUN	n	_	_	_	_	Gloss=mÃ¨re
127	bÃ¨Ã¨	bÉÌÉ	DET	dtm	_	_	_	_	Gloss=tout
128	.	.	PUNCT	_	_	_	_	_	Gloss=.`,

ud_example_tabs: `1	They	they	PRON	PRP	Case=Nom|Number=Plur	2	nsubj	2:nsubj|4:nsubj	_
2	buy	buy	VERB	VBP	Number=Plur|Person=3|Tense=Pres	0	root	_	_
3	and	and	CONJ	CC	_	4	cc	4:cc	_
4	sell	sell	VERB	VBP	Number=Plur|Person=3|Tense=Pres	2	conj	2:conj	_
5	books	book	NOUN	NNS	Number=Plur	2	obj	2:obj|4:obj	_
6	.	.	PUNCT	.	_	2	punct	2:punct	_`,

ud_example_spaces: `1    They     they    PRON    PRP    Case=Nom|Number=Plur               2    nsubj    2:nsubj|4:nsubj _
2    buy      buy     VERB    VBP    Number=Plur|Person=3|Tense=Pres    0    root     _          _
3    and      and     CONJ    CC     _                                  4    cc       4:cc            _
4    sell     sell    VERB    VBP    Number=Plur|Person=3|Tense=Pres    2    conj     2:conj   _
5    books    book    NOUN    NNS    Number=Plur                        2    obj      2:obj|4:obj     _
6    .        .       PUNCT   .      _                                  2    punct    2:punct         _`,

ud_example_modified: `1	They	they	PRON	PRP	Case=Nom|Number=Plur	2	nsubj	2:nsubj|4:nsubj	_
2	buy	buy	VERB	VBP	Number=Plur|Person=3|Tense=Presroot	0	root	_	_
3	and	and	CONJ	CC	_	4	cc	4:cc	_
4	sell	sell	VERB	VBP	Number=Plur|Person=3|Tense=Presconj	2	_	_	_
5	books	book	NOUN	NNS	Number=Plur	2	obj	2:obj|4:obj	_
6	.	.	PUNCT	.	_	2	punct	2:punct	_`,
};

},{}],400:[function(require,module,exports){
module.exports = {

  'apertium stream': require('./apertium-stream'),
  apertiumStream: require('./apertium-stream'),
  Brackets: require('./brackets'),
  brackets: require('./brackets'),
  CG3: require('./cg3'),
  cg3: require('./cg3'),
  'CoNLL-U': require('./conllu'),
  conllu: require('./conllu'),
  'notatrix serial': require('./notatrix-serial'),
  notatrixSerial: require('./notatrix-serial'),
  Params: require('./params'),
  params: require('./params'),
  'plain text': require('./plain-text'),
  plainText: require('./plain-text'),
  SD: require('./sd'),
  sd: require('./sd'),

};

},{"./apertium-stream":396,"./brackets":397,"./cg3":398,"./conllu":399,"./notatrix-serial":401,"./params":402,"./plain-text":403,"./sd":404}],401:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],402:[function(require,module,exports){
module.exports = {
	0: [
		{ form: 'hello' },
		{ form: 'world' }
	]
};

},{}],403:[function(require,module,exports){
module.exports = {
0: 'this is a test',
1: 'this is a test.',
2: 'this is a test...',
3: 'this is a test?',
4: '\tthis is a test',
5: 'More sentences = more data; ipso facto, yes.',
parens_and_numbers: `ÐÓÒ¯Ð»ÓÑÐ»ÓÑÐ½ÐµÒ£, ÑÑÐ» Ð¸ÑÓÐ¿ÑÓÐ½ Ð ÑÑÐ¸ÑÐ½ÐµÒ£ Ð´Ó, Ð´Ð¸Ò£Ð³ÐµÐ· ÑÐ¸ÐºÐ»ÓÑÐµ ÑÑÐ´Ð°Ð½ 12 Ð¼Ð¸Ð»Ñ (ÑÐºÐ¸ 22,2 ÐºÐ¼) ÐµÑÐ°ÐºÐ»ÑÐºÑÐ° ÑÐ·ÑÑ ÐºÐ¸Ð»ÐµÑÐµÐ½Ð³ÓÐ½`,
};

},{}],404:[function(require,module,exports){
module.exports = {
0: `And Robert the fourth place .
cc(Robert, And)
orphan(Robert, place)
punct(Robert, .)
amod(place, fourth)
det(place, the)`,

1: `ROOT And Robert the fourth place .
root(ROOT, Robert)
cc(Robert, And)
orphan(Robert, place)
punct(Robert, .)
amod(place, fourth)
det(place, the)`,

2: `ROOT I love French fries .
root(ROOT, love)`,

// https://github.com/UniversalDependencies/docs/blob/pages-source/_u-dep/ccomp.md
ccomp_1: `He says that you like to swim
ccomp(says, like)
mark(like, that)`,

ccomp_2: `He says you like to swim
ccomp(says, like)`,

ccomp_3: `The boss said to start digging
ccomp(said, start)
mark(start, to)`,

ccomp_4: `We started digging
xcomp(started, digging)`,

ccomp_5: `The important thing is to keep calm.
ccomp(is, keep)
nsubj(is, thing)`,

ccomp_6: `The problem is that this has never been tried .
ccomp(is, tried)
nsubj(is, problem)`
};

},{}],405:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('./utils');
const ConverterError = utils.ConverterError;
const nx = require('./nx');

module.exports = (input, options) => {
  try {

    var sent = new nx.Sentence(input, options);
    sent.from = format => convert(sent.input, _.extend({
      interpretAs: format
    }, options));

    return sent;

  } catch (e) {

    if (e instanceof utils.ToolError || e instanceof utils.NxError)
      throw new ConverterError('FATAL: unable to convert: ' + e.message);

    throw e;
  }
};

},{"./nx":468,"./utils":479,"underscore":499}],406:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('./utils');
const DetectorError = utils.DetectorError;

let as = {

	'apertium stream': require('./formats/apertium-stream').detect,
  apertiumStream: require('./formats/apertium-stream').detect,
  Brackets: require('./formats/brackets').detect,
  brackets: require('./formats/brackets').detect,
  CG3: require('./formats/cg3').detect,
  cg3: require('./formats/cg3').detect,
  'CoNLL-U': require('./formats/conllu').detect,
  conllu: require('./formats/conllu').detect,
  'notatrix serial': require('./formats/notatrix-serial').detect,
  notatrixSerial: require('./formats/notatrix-serial').detect,
  Params: require('./formats/params').detect,
  params: require('./formats/params').detect,
  'plain text': require('./formats/plain-text').detect,
  plainText: require('./formats/plain-text').detect,
	SD: require('./formats/sd').detect,
  sd: require('./formats/sd').detect,

};

module.exports = (text, options) => {

  options = _.defaults(options, {
    suppressDetectorErrors: true,
		returnAllMatches: true,
		requireOneMatch: false,
  });

	const matches = utils.formats.map(format => {

		try {
			return as[format](text, options);
		} catch (e) {

			if (e instanceof DetectorError)
				return;

			throw e;
		}

	}).filter(utils.thin);

	if (!matches.length && !options.suppressDetectorErrors)
		throw new DetectorError('Unable to detect format', text, options);

	if (matches.length > 1 && !options.suppressDetectorErrors && options.requireOneMatch)
		throw new DetectorError('Detected multiple formats', text, options);

	return options.returnAllMatches ? matches : matches[0];
};
module.exports.as = as;

},{"./formats/apertium-stream":410,"./formats/brackets":417,"./formats/cg3":423,"./formats/conllu":429,"./formats/notatrix-serial":437,"./formats/params":444,"./formats/plain-text":451,"./formats/sd":458,"./utils":479,"underscore":499}],407:[function(require,module,exports){
'use strict';

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (text, options) => {
  throw new DetectorError('not implemented');
};

},{"../../utils":479}],408:[function(require,module,exports){
module.exports = null;

},{}],409:[function(require,module,exports){
'use strict';

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;

module.exports = (text, options) => {
  //throw new GeneratorError('not implemented');
};

},{"../../utils":479}],410:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'apertium stream',
  fields: require('./fields'),
  split: require('./splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

},{"./detector":407,"./fields":408,"./generator":409,"./parser":411,"./splitter":412}],411:[function(require,module,exports){
'use strict';

const utils = require('../../utils');
const ParserError = utils.ParserError;

module.exports = (text, options) => {
  //throw new ParserError('not implemented');
};

},{"../../utils":479}],412:[function(require,module,exports){
'use strict';

const utils = require('../../utils');
const SplitterError = utils.SplitterError;

module.exports = (text, options) => {
  //throw new SplitterError('not implemented', text, options);
};

},{"../../utils":479}],413:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (text, options) => {

  options = _.defaults(options, {
    allowEmptyString: false,
    allowTrailingWhitespace: true,
    allowLeadingWhitespace: true,
    allowNoDependencies: false,
    allowNewlines: false,
  });

  if (!text && !options.allowEmptyString)
    throw new DetectorError('Illegal Brackets: empty string', text, options);

  if (utils.isJSONSerializable(text))
    throw new DetectorError('Illegal Brackets: JSON object', text, options);

  if (/\n/.test(text) && !options.allowNewlines)
    throw new DetectorError('Illegal Brackets: contains newlines', text, options);

  // internal stuff
  let parsing = null;
  let depth = 0;
  let sawBracket = false;

  text.split('').forEach((char, i) => {

    switch (char) {

      case ('['):
        if (parsing === ']')
          throw new DetectorError('Illegal Brackets: invalid sequence "]["', text, options);

        sawBracket = true;
        depth += 1;
        break;

      case (']'):
        if (parsing === '[')
          throw new DetectorError('Illegal Brackets: invalid sequence "[]"', text, options);

        sawBracket = true;
        depth -= 1;
        break;

      case (' '):
      case ('\t'):
      case ('\n'):

        if (!options.allowLeadingWhitespace) {
          if (parsing !== null && !utils.re.whitespace.test(parsing))
            throw new DetectorError('Illegal Brackets: contains leading whitespace', text, options);
        }
        break;
    }

    parsing = char;
  });

  if (!sawBracket && !options.allowNoDependencies)
    throw new DetectorError('Illegal Brackets: contains no dependencies', text, options);

  if (depth !== 0)
    throw new DetectorError('Illegal Brackets: bracket mismatch', text, options);

  if (utils.re.whitespace.test(parsing) && !options.allowTrailingWhitespace)
    throw new DetectorError('Illegal Brackets: contains trailing whitespace', text, options);

  return 'Brackets';
};

},{"../../utils":479,"underscore":499}],414:[function(require,module,exports){
module.exports = [
  'form',
  'head',
  'deprel',
];
module.exports.hasComments = false;

},{}],415:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const getLoss = require('./get-loss')

module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {

  });

  sent.index();

  if (!sent.root)
    throw new GeneratorError('Unable to generate, could not find root');

  // build the tree structure
  let seen = new Set([ sent.root ]);
  let root = {
    token: sent.root,
    deprel: 'root',
    deps: [],
  };

  const visit = node => {

    sent.getDependents(node.token).forEach(dep => {

      if (seen.has(dep))
        throw new GeneratorError('Unable to generate, dependency structure non-linear');

      node.deps.push({
        token: dep,
        deprel: dep.deprel,
        deps: [],
      });
      seen.add(dep);

      const next = node.deps.slice(-1)[0];
      if (next)
        visit(next);
    });
  }
  visit(root);

  //console.log(root);

  if (seen.size < sent.size)
    throw new GeneratorError('Unable to generate, sentence not fully connected');

  // parse the tree into a string
  let output = '';
  const walk = node => {
    output += '[' + (node.deprel || '') + ' ';

    node.deps.forEach(dep => {
      if (dep.token.indices.absolute < node.token.indices.absolute)
        walk(dep);
    });

    output += ' ' + node.token.form + ' ';

    node.deps.forEach(dep => {
      if (dep.token.indices.absolute > node.token.indices.absolute)
        walk(dep);
    });

    output += ' ] ';
  }
  walk(root);

  // clean up the output
  output = output
    .replace(/\s+/g, ' ')
    .replace(/ \]/g, ']')
    .replace(/(\w)_(\w)/, '$1 $2')
    .trim();

  // console.log(output);

  return {
    output: output,
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"./get-loss":416,"underscore":499}],416:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const fields = require('./fields');

module.exports = sent => {

  const serial = sent.serialize();
  let losses = new Set();

  if (serial.comments.length)
    losses.add('comments');

  serial.tokens.forEach(token => {
    Object.keys(_.omit(token, fields)).forEach(field => {
      switch (field) {
        case ('uuid'):
        case ('index'):
        case ('deps'):
          break;

        default:
          losses.add(field);
      }
    })

  });

  return Array.from(losses);
};

},{"../../utils":479,"./fields":414,"underscore":499}],417:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'Brackets',
  fields: require('./fields'),
  split: require('../default-splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

},{"../default-splitter":431,"./detector":413,"./fields":414,"./generator":415,"./parser":418}],418:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');

module.exports = (text, options) => {

  //console.log();
  //console.log(text);

  options = _.defaults(options, {
    allowEmptyString: false,
  });

  try {
    detect(text, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  class Sentence {
    constructor(text, options) {
      this.input = text;
      this.options = options;
      this.parent = null;
      this.root = [];
      this.comments = [];
    }

    serialize() {

      this.root.index(0);

      return {
        input: this.input,
        options: this.options,
        comments: this.comments,
        tokens: this.root.serialize([])
      };
    }

    push(token) {
      this.root = token;
    }
  }

  class Token {
    constructor(parent) {
      this.parent = parent;

      this.deprel = null;
      this.before = [];
      this.words  = [];
      this.after  = [];
    }

    eachBefore(callback) {
      for (let i=0; i<this.before.length; i++) {
        callback(this.before[i], i);
      }
    }

    eachAfter(callback) {
      for (let i=0; i<this.after.length; i++) {
        callback(this.after[i], i);
      }
    }

    index(num) {
      this.eachBefore(before => {
        num = before.index(num);
      });
      this.num = ++num;
      this.eachAfter(after => {
        num = after.index(num)
      });

      return num;
    }

    serialize(tokens) {

      this.eachBefore(before => {
        before.serialize(tokens);
      });

      tokens.push({
        form: this.form,
        head: `${this.parent.num || 0}`,
        index: `${this.num}`,
        deprel: this.deprel,
      });

      this.eachAfter(after => {
        after.serialize(tokens);
      });

      return tokens;
    }

    get form() {
      return this.words.join('_');
    }

    push(token) {
      if (this.words.length) {
        this.after.push(token);
      } else {
        this.before.push(token);
      }
    }

    addWord(word) {
      if (!word)
        return;

      if (this.deprel) {
        this.words.push(word);
      } else {
        this.deprel = word;
      }
    }
  }

  let sent = new Sentence(text, options),
    parsing = sent,
    parent = null,
    word = '';

  _.each(text, char => {
    switch (char) {
      case ('['):
        parent = parsing;
        parsing = new Token(parent);
        if (parent && parent.push)
          parent.push(parsing)
        word = '';
        break;

      case (']'):
        if (parsing.addWord)
          parsing.addWord(word);
        parsing = parsing.parent;
        parent = parsing.parent;
        word = '';
        break;

      case (' '):
        if (parsing.addWord)
          parsing.addWord(word);
        word = '';
        break;

      default:
        word += char;
        break;
    }
  });

  //console.log(sent.serialize())
  return sent.serialize();
};

},{"../../utils":479,"./detector":413,"underscore":499}],419:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (text, options) => {

  options = _.defaults(options, {
    allowEmptyString: false,
    allowTrailingWhitespace: true,
    allowLeadingWhitespace: true
  });

  if (!text && !options.allowEmptyString)
    throw new DetectorError('Illegal CG3: empty string', text, options);

  if (utils.isJSONSerializable(text))
    throw new DetectorError('Illegal CG3: JSON object', text, options);

  // internal stuff
  let parsing = null;

  // iterate over the lines and check each one
  text.split(/\n/).forEach(line => {

    if (utils.re.whiteline.test(line)) {

      if (parsing === null) {

        if (!options.allowLeadingWhitespace)
          throw new DetectorError('Illegal CG3: contains leading whitespace', text, options);

      } else {

        if (parsing !== 'token-body' || !options.allowTrailingWhitespace)
          throw new DetectorError('Illegal CG3: contains trailing whitespace', text, options);

      }

      parsing = 'whitespace';

    } else if (utils.re.comment.test(line)) {

      if ( parsing === 'token-start'
        || parsing === 'token-body')
        throw new DetectorError(`Illegal CG3: invalid sequence ${parsing}=>comment`, text, options);

      parsing = 'comment';

    } else if (utils.re.cg3TokenStart.test(line)) {

      if (parsing === 'token-start')
        throw new DetectorError(`Illegal CG3: invalid sequence ${parsing}=>token-start`, text, options);

      parsing = 'token-start';

    } else if (utils.re.cg3TokenContent.test(line)) {

      if ( parsing === 'comment'
        || parsing === 'whitespace')
        throw new DetectorError(`Illegal CG3: invalid sequence ${parsing}=>token-body`, text, options);

      parsing = 'token-body';

    } else {

      throw new DetectorError(`Illegal CG3: unmatched line`, text, options);

    }
  });

  return 'CG3';
};

},{"../../utils":479,"underscore":499}],420:[function(require,module,exports){
module.exports = [
  'semicolon',
  'index',
  'form',
  'lemma',
  'head',
  'deprel',
  'xpostag',
  'other',
  'analyses',
];
module.exports.hasComments = true;

},{}],421:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const getLoss = require('./get-loss')

module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {
    omitIndices: false,
  });

  sent.index();

  let lines = [];
  sent.comments.forEach(comment => lines.push('# ' + comment.body));
  sent.tokens.forEach(token => {

    const push = (token, indent) => {

      if (!token.lemma)
        throw new GeneratorError(`Unable to generate, token has no lemma`, sent, options);

      indent = (token.semicolon ? ';' : '') + '\t'.repeat(indent);

      const head = token.getHead('CG3');
      const dependency = options.omitIndices
        ? null
        : '#' + token.indices.cg3 + '->' + (head == undefined ? '' : head);

      let line = [ `"${token.lemma}"` ]
        .concat(token.xpostag || token.upostag)
        .concat((token.feats || '').split('|'))
        .concat(token._misc)
        .concat(token.deprel ? '@' + token.deprel : null)
        .concat(dependency);

      line = indent + line.filter(utils.thin).join(' ');
      lines.push(line);
    };

    lines.push(`"<${token.form || utils.fallback}>"`);

    if (token._analyses && token._analyses.length) {

      token._analyses.forEach(analysis => {
        analysis.subTokens.forEach((subToken, i) => {

          push(subToken, i+1);

        });
      });

    } else {

      push(token, 1);

    }

  });

  return {
    output: lines.join('\n'),
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"./get-loss":422,"underscore":499}],422:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const fields = require('./fields');

module.exports = sent => {

  const serial = sent.serialize();
  let losses = new Set();

  const tokenCalcLoss = token => {
    Object.keys(_.omit(token, fields)).forEach(field => {
      switch (field) {
        case ('uuid'):
        case ('index'):
        case ('deps'):
        case ('feats'):
        case ('misc'):
          break;

        case ('upostag'):
          if (token.xpostag && token.upostag)
            losses.add(field);
          break;

        case ('isEmpty'):
          if (token.isEmpty)
            losses.add(field);
          break;

        default:
          losses.add(field);
      }
    });
  };

  serial.tokens.map(token => {

    tokenCalcLoss(token);

    (token.analyses || []).forEach(analysis => {

      const analysisKeys = Object.keys(analysis);
      if (analysisKeys.length > 1 || analysisKeys[0] !== 'subTokens') {
        losses.add('analyses');
      } else {
        analysis.subTokens.map(subToken => {

          tokenCalcLoss(subToken);

          if (subToken.form != undefined)
            losses.add('form');

        });
      }

    });
  });

  return Array.from(losses);
};

},{"../../utils":479,"./fields":420,"underscore":499}],423:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'CG3',
  fields: require('./fields'),
  split: require('../default-splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

},{"../default-splitter":431,"./detector":419,"./fields":420,"./generator":421,"./parser":424}],424:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');

module.exports = (text, options) => {

  function getIndentNum(str, options) {

    const count = (str, reg) => str.match(reg).length;

    if (options.indentString) {

      const regex = options.indentString instanceof RegExp
        ? options.indentString
        : new RegExp(options.indentString, 'g');

      return count(str, regex);

    } else if (options.useTabIndent) {

      return count(str, /\t/g);

    } else if (options.spacesPerTab) {

      const regex = new RegExp(` {${options.spacesPerTab}}`, 'g');
      return count(str, regex);

    } else if (options.equalizeWhitespace) {

      return count(str, /\s/g);

    } else {
      throw new ParserError('can\'t get the indent number, insufficient options set', text, options);

    }
  }

  options = _.defaults(options, {
    allowEmptyString: false,
    indentString: null,
    useTabIndent: false,
    spacesPerTab: null,
    equalizeWhitespace: true,
    coerceMultipleSpacesAfterSemicolonToTab: true,
    allowMissingIndices: true,
  });

  try {
    detect(text, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  //console.log();
  //console.log(text);

  // "tokenize" into chunks
  let i = 0, chunks = [];
  while (i < text.length) {

    const remains = text.slice(i),
      whiteline = remains.match(utils.re.whiteline),
      comment = remains.match(utils.re.comment),
      tokenStart = remains.match(utils.re.cg3TokenStart),
      tokenContent = remains.match(utils.re.cg3TokenContent);

    if (whiteline) {

      i += whiteline[0].length;

    } else if (comment) {

      chunks.push({
        type: 'comment',
        body: comment[2]
      });
      i += comment[1].length;

    } else if (tokenStart) {

      chunks.push({
        type: 'form',
        form: tokenStart[1]
      });
      i += tokenStart[0].length;

      while (utils.re.whitespace.test(text[i]) && text[i] !== '\n')
        i++;
      i++;

    } else if (tokenContent) {

      // some real BS right here, overfitting my data hard
      const indent = options.coerceMultipleSpacesAfterSemicolonToTab
        ? !!tokenContent[1]
          ? tokenContent[2].replace(/ +/, '\t')
          : tokenContent[2]
        : tokenContent[2];

      let chunk = {
        type: 'content',
        semicolon: !!tokenContent[1],
        indent: getIndentNum(indent, options),
        lemma: tokenContent[3],
        other: [],
      };
      tokenContent[5].split(/\s+/).filter(utils.thin).forEach(subChunk => {

        const dependency = subChunk.match(utils.re.cg3Dependency),
          head = subChunk.match(utils.re.cg3Head),
          index = subChunk.match(utils.re.cg3Index),
          deprel = subChunk.match(utils.re.cg3Deprel),
          other = subChunk.match(utils.re.cg3Other);

        if (dependency && (head || index)) {

          if (head) {
            if (chunk.head)
              throw new ParserError('unexpected subChunk, head already set', text, options);

            chunk.head = head[1];
          }

          if (index) {
            if (chunk.index)
              throw new ParserError('unexpected subChunk, index already set', text, options);

            chunk.index = index[1];
          }

        } else if (deprel) {

          if (chunk.deprel)
            throw new ParserError('unexpected subChunk, deprel already set', text, options);

          chunk.deprel = deprel[1];

        } else if (other) {

          chunk.other.push(other[0]);

        }
      });

      chunks.push(chunk);
      i += tokenContent[0].length;

    } else {
      throw new ParserError(`unable to match remains: ${remains}`, text, options);

    }
  }

  //console.log(chunks);

  // turn the chunks into tokens and comments
  let tokens = [];
  let comments = [];
  let expecting = ['comment', 'form'];
  let token = null;
  let analysis = null;
  let missingIndices = false;

  chunks.forEach(chunk => {

    if (expecting.indexOf(chunk.type) === -1)
      throw new ParserError(`expecting ${expecting.join('|')}, got ${chunk.type}`, text, options);

    if (chunk.type === 'comment') {

      comments.push(chunk.body);
      expecting = ['comment', 'form'];
      token = null;
      analysis = null;

    } else if (chunk.type === 'form') {

      if (analysis)
        token.analyses.push(analysis);

      if (token) {
        if (token.analyses.length === 1 && token.analyses[0].subTokens.length === 1)
          token = _.omit(_.extend(token, token.analyses[0].subTokens[0]), 'analyses');

        tokens.push(_.omit(token, 'currentIndent'));
      }

      token = {
        form: chunk.form,
        currentIndent: 0,
        analyses: [],
      };
      analysis = null;

      expecting = ['content'];

    } else if (chunk.type === 'content') {

      if (!token)
        throw new ParserError('cannot parse content chunk without a token', text, options);

      if (chunk.indent > token.currentIndent + 1)
        throw new ParserError(`invalid indent change (${token.currentIndent}=>${chunk.indent})`, text, options)

      if (chunk.indent === 1) {
        if (analysis)
          token.analyses.push(analysis);

        if (chunk.index === undefined) {
          if (!options.allowMissingIndices)
            throw new ParserError('cannot parse token without index', text, options);

          missingIndices = true;

        } else {
          if (missingIndices)
            throw new ParserError('cannot parse partially indexed CG3', text, options);
        }

        analysis = {
          subTokens: [
            {
              semicolon: chunk.semicolon,
              lemma: chunk.lemma || null,
              head: chunk.head || null,
              index: chunk.index || null,
              deprel: chunk.deprel || null,
              xpostag: chunk.other.shift() || null,
              other: chunk.other || null,
            }
          ]
        };
      } else {
        if (!analysis)
          throw new ParserError('cannot parse content chunk without an analysis', text, options);

        if (chunk.index === undefined && !options.allowMissingIndices)
          throw new ParserError('cannot parse token without index', text, options);

        analysis.subTokens.push({
          semicolon: chunk.semicolon,
          lemma: chunk.lemma || null,
          head: chunk.head || null,
          index: chunk.index || null,
          deprel: chunk.deprel || null,
          xpostag: chunk.other.shift() || null,
          other: chunk.other || null,
        });

      }

      token.currentIndent = chunk.indent;
      expecting = ['content', 'form'];

    } else {
      throw new ParserError(`unrecognized chunk type: ${chunk.type}`, text, options);

    }

  });

  if (analysis)
    token.analyses.push(analysis);

  if (token) {
    if (token.analyses.length === 1 && token.analyses[0].subTokens.length === 1)
      token = _.omit(_.extend(token, token.analyses[0].subTokens[0]), 'analyses');

    tokens.push(_.omit(token, 'currentIndent'));
  }

  if (missingIndices) {

    let index = 0;
    tokens.forEach(token => {
      if (token.analyses) {
        token.analyses.forEach(analysis => {
          analysis.subTokens.forEach(subToken => {
            subToken.index = `${++index}`;
          });
        });
      } else {
        token.index = `${++index}`;
      }
    });

  }

  //console.log(comments);
  //console.log(tokens);

  return {
    input: text,
    options: options,
    comments: comments,
    tokens: tokens,
  };
};

},{"../../utils":479,"./detector":419,"underscore":499}],425:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;


module.exports = (text, options) => {

  options = _.defaults(options, {
    allowEmptyString: false,
    requireTenParams: false,
    allowTrailingWhitespace: true,
  });

  if (!text && !options.allowEmptyString)
    throw new DetectorError(`Illegal CoNLL-U: empty string`, text, options);

  if (utils.isJSONSerializable(text))
    throw new DetectorError(`Illegal CoNLL-U: JSON object`, text, options);

  // be more or less strict about the fields we require being set
  const tokenLine = options.requireTenParams
    ? utils.re.conlluTokenLineTenParams
    : utils.re.conlluTokenLine;

  // internal stuff
  let doneComments = false;
  let doneContent = false;

  // iterate over the lines and check each one
  const lines = text.split(/\n/);
  lines.forEach((line, i) => {

    if (utils.re.comment.test(line)) {

      // can only have comments at the beginning
      if (doneComments)
        throw new DetectorError(`Illegal CoNLL-U: misplaced comment`, text, options);

    } else {

      // done parsing comments
      doneComments = true;

      if (line) {
        if (!tokenLine.test(line))
          throw new DetectorError(`Illegal CoNLL-U: unmatched line`, text, options);

        if (doneContent)
          throw new DetectorError(`Illegal CoNLL-U: misplaced whitespace`, text, options);

      } else {

        // only allow empty lines after we've looked at all the content
        if (!options.allowTrailingWhitespace)
          throw new DetectorError(`Illegal CoNLL-U: contains trailing whitespace`, text, options);

        doneContent = true;
      }

    }
  });

  return 'CoNLL-U';
};

},{"../../utils":479,"underscore":499}],426:[function(require,module,exports){
module.exports = [
  'isEmpty',
  'index',
  'form',
  'lemma',
  'upostag',
  'xpostag',
  'feats',
  'head',
  'deprel',
  'deps',
  'misc',
  'subTokens',
];
module.exports.hasComments = true;

},{}],427:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const getLoss = require('./get-loss')


module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {

  });

  sent.index();

  let lines = [];
  sent.comments.forEach(comment => {
    lines.push('# ' + comment.body);
  });
  sent.tokens.forEach(token => {

    const toString = token => {
      return [

        token.indices.conllu,
        token.form || utils.fallback,
        token.lemma || utils.fallback,
        token.upostag || utils.fallback,
        token.xpostag || utils.fallback,
        token.feats || utils.fallback,
        token.getHead('CoNLL-U') || utils.fallback,
        token.deprel || utils.fallback,
        token.getDeps('CoNLL-U') || utils.fallback,
        token.misc || utils.fallback,

      ].join('\t');
    };

    lines.push(toString(token));
    token.subTokens.forEach(subToken => {
      lines.push(toString(subToken));
    });
  });

  return {
    output: lines.join('\n'),
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"./get-loss":428,"underscore":499}],428:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const fields = require('./fields');

module.exports = sent => {

  const serial = sent.serialize();
  let losses = new Set();

  const tokenCalcLoss = token => {
    Object.keys(_.omit(token, fields)).forEach(field => {
      switch (field) {
        case ('uuid'):
        case ('index'):
        case ('other'):
          break;

        case ('analyses'):
          if (token.analyses.length > 1) {
            losses.add('analyses');
          } else {

            const analysis = token.analyses[0],
              analysisKeys = Object.keys(analysis);

            if (analysisKeys.length > 1 || analysisKeys[0] !== 'subTokens') {
              losses.add('analyses');
            } else {
              analysis.subTokens.map(tokenCalcLoss);
            }
          }
          break;

        default:
          losses.add(field);
      }
    });
  };

  serial.tokens.map(tokenCalcLoss);

  return Array.from(losses);
};

},{"../../utils":479,"./fields":426,"underscore":499}],429:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'CoNLL-U',
  fields: require('./fields'),
  split: require('../default-splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

/*
{
  semicolon: Boolean || undefined,
  isEmpty: Boolean || undefined,
  index: String || undefined,
  form: String || null || undefined,
  lemma: String || null || undefined,
  upostag: String || null || undefined,
  xpostag: String || null || undefined,
  feats: String || null || undefined,
  head: String || null || undefined,
  deprel: String || null || undefined,
  deps: String || null || undefined,
  other: Array || undefined,
  analyses: [
    subTokens: [
      semicolon: Boolean || undefined,
      isEmpty: Boolean || undefined,
      index: String || undefined,
      form: String || null || undefined,
      lemma: String || null || undefined,
      upostag: String || null || undefined,
      xpostag: String || null || undefined,
      feats: String || null || undefined,
      head: String || null || undefined,
      deprel: String || null || undefined,
      deps: String || null || undefined,
      other: Array || undefined,
    ]
  ]
}
*/

},{"../default-splitter":431,"./detector":425,"./fields":426,"./generator":427,"./parser":430}],430:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');

module.exports = (text, options) => {

  function assertNext(supStr, subStr) {

    const parseIndex = str => {
      const match = str.match(utils.re.conlluEmptyIndex);
      return match[2]
        ? {
            major: parseInt(match[1]),
            minor: parseInt(match[2]),
          }
        : {
            major: parseInt(match[1]),
            minor: null,
          };
    }

    if (supStr === null)
      return;

    const sup = parseIndex(supStr),
      sub = parseIndex(subStr);

    if (sub.minor === null) {
      if (sub.major - sup.major !== 1)
        throw new ParserError(`unexpected token index (at: ${sup.major}${sup.minor === null ? '' : '.' + sup.minor}, got: ${sup.major}${sup.minor === null ? '' : '.' + sup.minor})`);

    } else if (sup.minor === null) {
      if (sub.minor !== 1)
        throw new ParserError(`unexpected token index (at: ${sup.major}${sup.minor === null ? '' : '.' + sup.minor}, got: ${sup.major}${sup.minor === null ? '' : '.' + sup.minor})`);

    } else {
      if (sub.minor - sup.minor !== 1)
        throw new ParserError(`unexpected token index (at: ${sup.major}${sup.minor === null ? '' : '.' + sup.minor}, got: ${sup.major}${sup.minor === null ? '' : '.' + sup.minor})`);

    }
  }

  options = _.defaults(options, {
    allowEmptyString: false,
    requireTenParams: false,
    allowWhiteLines: true,
  });

  try {
    detect(text, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  //console.log();
  //console.log(text);

  // "tokenize" into chunks
  let i = 0, chunks = [];
  const lines = text.split('\n');
  const tokenRegex = options.requireTenParams
    ? utils.re.conlluTokenLineTenParams
    : utils.re.conlluTokenLine;

  lines.forEach(line => {
    const whiteline = line.match(utils.re.whiteline),
      comment = line.match(utils.re.comment),
      tokenLine = line.match(tokenRegex);

    if (whiteline) {

    } else if (comment) {

      chunks.push({
        type: 'comment',
        body: comment[2]
      });

    } else if (tokenLine) {

      let token;
      const fields = tokenLine[7].split(/\s/).filter(utils.thin);

      if (tokenLine[4]) {

        token = {
        	type: 'super-token',
          index: tokenLine[1],
        	startIndex: tokenLine[2],
        	stopIndex: tokenLine[5],
        	form: utils.re.fallback.test(fields[0]) ? null : fields[0],
        	misc: utils.re.fallback.test(fields[8]) ? null : fields[8],
        };

      } else {

        token = {
        	type: 'token',
          index: tokenLine[1],
        	isEmpty: !!tokenLine[3],
        	form: utils.re.fallback.test(fields[0]) ? null : fields[0],
        	lemma: utils.re.fallback.test(fields[1]) ? null : fields[1],
        	upostag: utils.re.fallback.test(fields[2]) ? null : fields[2],
        	xpostag: utils.re.fallback.test(fields[3]) ? null : fields[3],
        	feats: utils.re.fallback.test(fields[4]) ? null : fields[4],
        	head: utils.re.fallback.test(fields[5]) ? null : fields[5],
        	deprel: utils.re.fallback.test(fields[6]) ? null : fields[6],
        	deps: utils.re.fallback.test(fields[7]) ? null : fields[7],
        	misc: utils.re.fallback.test(fields[8]) ? null : fields[8],
        };

      }
      chunks.push(token);

    } else {
      throw new ParserError(`unable to match line: ${line}`, text, options);

    }

  });

  //console.log(chunks);

  let tokens = [];
  let comments = [];
  let expecting = ['comment', 'super-token', 'token'];
  let superToken = null;

  chunks.filter(utils.thin).forEach(chunk => {

    if (expecting.indexOf(chunk.type) === -1)
      throw new ParserError(`expecting ${expecting.join('|')}, got ${chunk.type}`, text, options);

    if (chunk.type === 'comment') {

      comments.push(chunk.body);
      expecting = ['comment', 'super-token', 'token'];

    } else if (chunk.type === 'super-token') {

      superToken = {
        form: chunk.form,
        misc: chunk.misc,
        analyses: [{
          subTokens: []
        }],
        index: chunk.index,
        currentIndex: null,
        stopIndex: chunk.stopIndex
      };

      expecting = ['token'];

    } else if (chunk.type === 'token') {

      if (superToken) {

        assertNext(superToken.currentIndex, chunk.index);
        superToken.currentIndex = chunk.index;

        superToken.analyses[0].subTokens.push(_.omit(chunk, ['type']));

        if (superToken.currentIndex === superToken.stopIndex) {

          tokens.push(_.omit(superToken, ['currentIndex', 'stopIndex']));
          superToken = null;
          expecting = ['super-token', 'token'];

        } else {
          expecting = ['token'];
        }

      } else {

        tokens.push(_.omit(chunk, ['type']));
        expecting = ['super-token', 'token'];

      }

    } else {
      throw new ParserError(`unrecognized chunk type: ${chunk.type}`, text, options);

    }
  });

  //console.log(comments);
  //console.log(tokens);

  return {
    input: text,
    options: options,
    comments: comments,
    tokens: tokens,
  };
};

},{"../../utils":479,"./detector":425,"underscore":499}],431:[function(require,module,exports){
'use strict';

const _ = require('underscore');
const utils = require('../utils');

module.exports = (text, options={}) => {

  options = _.defaults(options, {
    trimChunks: true
  });

  return text.split(utils.re.multiNewlines).map(chunk => {
    if (options.trimChunks) {
      return chunk.trim();
    } else {
      return chunk;
    }
  }).filter(utils.thin);
};

},{"../utils":479,"underscore":499}],432:[function(require,module,exports){
arguments[4][400][0].apply(exports,arguments)
},{"./apertium-stream":410,"./brackets":417,"./cg3":423,"./conllu":429,"./notatrix-serial":437,"./params":444,"./plain-text":451,"./sd":458,"dup":400}],433:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (obj, options) => {

  function restrict(obj, fields, allowUndefined=false) {
    if (obj === undefined)
      throw new DetectorError(`Illegal notatrix serial: missing field`, obj, options);

    if (_.omit(obj, Object.keys(fields)).length)
      throw new DetectorError(`Illegal notatrix serial: unexpected field`, obj, options);

    _.each(fields, (fieldType, fieldName) => {

      const value = obj[fieldName];

      switch (fieldType) {
        case ('number'):
          if (value !== undefined || !allowUndefined)
            if (isNaN(parseFloat(value)))
              throw new DetectorError(`Illegal notatrix serial: could not parse ${value} as float`, obj, options);
          break;

        case ('string'):
          if (value !== undefined || !allowUndefined)
            if (typeof value !== 'string')
              throw new DetectorError(`Illegal notatrix serial: expected 'string', got ${typeof value}`, obj, options);
          break;

        case ('string*'):
          if (value !== undefined || !allowUndefined)
            if (value !== null && typeof value !== 'string')
              throw new DetectorError(`Illegal notatrix serial: expected 'string', got ${typeof value}`, obj, options);
          break;

        case ('object'):
          // pass
          break;

        case ('array'):
          if (value !== undefined || !allowUndefined)
            if (!Array.isArray(value))
              throw new DetectorError(`Illegal notatrix serial: expected Array, got ${typeof value}`, obj, options);
          break;
      }
    });
  }

  options = _.defaults(options, {
    allowZeroTokens: false,
    allowZeroFields: false,
  });

  if (!utils.isJSONSerializable(obj))
    throw new DetectorError(`Illegal notatrix serial: not JSON object`, obj, options);

  obj = typeof obj === 'string' ? JSON.parse(obj) : obj;

  restrict(obj, utils.nxSentenceFields);
  _.each(obj.comments, comment => {
    if (typeof comment !== 'string')
      throw new DetectorError(`Illegal notatrix serial: comments should be strings`, obj, options);
  });
  _.each(obj.tokens, token => {
    restrict(token, utils.nxSentenceTokensFields, true);
  });
  if (obj.tokens.length === 0 && !options.allowZeroTokens)
    throw new DetectorError(`Illegal notatrix serial: cannot have empty token list`, obj, options);

  _.each(obj.tokens, token => {
    if (Object.keys(token).length === 0 && !options.allowZeroFields)
      throw new DetectorError(`Illegal notatrix serial: cannot have token without fields`, obj, options);

    if (token.analyses)
      _.each(token.analyses, analysis => {

        const analysisKeys = Object.keys(analysis);
        if (analysisKeys.length !== 1 || analysisKeys[0] !== 'subTokens')
          throw new DetectorError(`Illegal notatrix serial: got unexpected analyses field`, obj, options);

        _.each(analysis.subTokens, subToken => {
          restrict(subToken, utils.nxSentenceTokensFields, true);
          if (subToken.analyses !== undefined)
            throw new DetectorError(`Illegal notatrix serial: subTokens can only have one analysis`, obj, options);
        });
      });
  })
};

},{"../../utils":479,"underscore":499}],434:[function(require,module,exports){
module.exports = [];
module.exports.hasComments = true;

},{}],435:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const getLoss = require('./get-loss')


module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {

  });

  sent.index();

  return {
    output: sent.serialize(),
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"./get-loss":436,"underscore":499}],436:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const Loss = utils.Loss;
const fields = require('./fields');

module.exports = sent => {
  // do nothing, can't lose info on this one
  return [];
};

},{"../../utils":479,"./fields":434,"underscore":499}],437:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'notatrix serial',
  fields: require('./fields'),
  split: require('./splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

/*
INPUT:
{
  input: String,
  options: Object,
  comments: [
    String
  ],
  tokens: [
    (
      // #1 (default)
      {
        isEmpty: Boolean || undefined,
        index: String || undefined,
        form: String || null || undefined,
        lemma: String || null || undefined,
        upostag: String || null || undefined,
        xpostag: String || null || undefined,
        feats: String || null || undefined,
        head: (
          String
          ||
          null
          ||
          undefined
          ||
          {
            index: String,
            type: String || null,
          }
        ),
        deprel: String || null || undefined,
        deps: (
          String
          ||
          null
          ||
          undefined
          ||
          {
            index: String,
            type: String || null,
          }
        ),
        misc: String || null || undefined,
      }
      ||
      // #2 (CoNLL-U superToken)
      {
        index: String,
        form: String || null,
        misc: String || null,
        subTokens: [
          <#1>
        ]
      }
      ||
      // #3 (CG3)
      {
        form: String || null,
        analyses: [
          [
            semicolon: Boolean,
            lemma: String || null,
            head: String || null,
            index: String || null,
            deprel: String || null,
            xpostag: String || null,
            other: [
              String
            ]
          ]
        ]
      }
      ||
      // #4 (notatrix serial)
      {

      }
    )
  ]
}


OUTPUT:
{
  input: String,
  options: 'plain object',
  comments: [
    {
      type: String,
      body: String,
      value: <any>
    }
  ],
*/

},{"./detector":433,"./fields":434,"./generator":435,"./parser":438,"./splitter":439}],438:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');

module.exports = (obj, options) => {

  try {
    detect(obj, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  return obj;
};

},{"../../utils":479,"./detector":433,"underscore":499}],439:[function(require,module,exports){
'use strict';

const utils = require('../../utils');
const SplitterError = utils.SplitterError;

module.exports = (text, options) => {
  throw new SplitterError('Can\'t split notatrix serial', text, options);
};

},{"../../utils":479}],440:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (obj, options) => {

  options = _.defaults(options, {
    allowEmptyList: false,
    allowTrailingWhitespace: true,
    allowLeadingWhitespace: true
  });

  if (!utils.isJSONSerializable(obj))
    throw new DetectorError(`Illegal Params: not JSON object`, obj, options);

  obj = typeof obj === 'string' ? JSON.parse(obj) : obj;

  if (Array.isArray(obj)) {

    if (!obj.length && !options.allowEmptyList)
      throw new DetectorError(`Illegal Params: contains no tokens`, obj, options);

    obj.forEach(obj => {

      const omitted = Object.keys(_.omit(obj, utils.fields));
      if (omitted.length)
        throw new DetectorError(`Illegal Params: contains illegal keys (${omitted.join(', ')})`, obj, options);

      const picked = Object.keys(_.pick(obj, utils.fields));
      if (!picked.length)
        throw new DetectorError(`Illegal Params: missing required keys`, obj, options);

    });

  } else {

    throw new DetectorError(`Illegal Params: expected array of parameters, got ${typeof obj}`, obj, options)

  }

  return 'Params';
};

},{"../../utils":479,"underscore":499}],441:[function(require,module,exports){
module.exports = [
  'isEmpty',
  'index',
  'form',
  'lemma',
  'upostag',
  'xpostag',
  'feats',
  'head',
  'deprel',
  'deps',
  'misc',
];
module.exports.hasComments = false;

},{}],442:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const getLoss = require('./get-loss')


module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {

  });

  sent.index();

  const output = sent.tokens.map(token => {

    if (token.analysis)
      throw new GeneratorError('Unable to generate, contains ambiguous analyses or multiword tokens');

    let params = _.pick(token, utils.fields);
    params.head = token.getHead();
    params.deps = token.getDeps();

    return _.pick(params, value => value != undefined);
  });

  return {
    output: output,
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"./get-loss":443,"underscore":499}],443:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const fields = require('./fields');

module.exports = sent => {

  const serial = sent.serialize();
  let losses = new Set();

  if (serial.comments.length)
    losses.add('comments');

  serial.tokens.forEach(token => {
    Object.keys(_.omit(token, fields)).forEach(field => {
      switch (field) {
        case ('uuid'):
        case ('index'):
          break;

        default:
          losses.add(field);
      }
    })
  });

  return Array.from(losses);
};

},{"../../utils":479,"./fields":441,"underscore":499}],444:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'Params',
  fields: require('./fields'),
  split: require('./splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

},{"./detector":440,"./fields":441,"./generator":442,"./parser":445,"./splitter":446}],445:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');

module.exports = (obj, options) => {

  try {
    detect(obj, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  return {
    input: JSON.stringify(obj),
    options: options,
    comments: [],
    tokens: obj.map((token, i) => {
      token.index = `${i}`;
      return token;
    }),
  };
};

},{"../../utils":479,"./detector":440,"underscore":499}],446:[function(require,module,exports){
'use strict';

const utils = require('../../utils');
const SplitterError = utils.SplitterError;

module.exports = (text, options) => {
  throw new SplitterError('Can\'t split Params', text, options);
};

},{"../../utils":479}],447:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (text, options) => {

  options = _.defaults(options, {
    allowEmptyString: true,
    allowNewlines: false,
    bracketsAllowanceTreshold: 0.2, // set to <0 or >1 to avoid
  });

  /*
  if (!text && !options.allowEmptyString)
    throw new DetectorError(`Illegal plain text: empty string`, text, options);
    */

  if (utils.isJSONSerializable(text))
    throw new DetectorError(`Illegal plain text: JSON object`, text, options);

  if (/\n/.test(text) && !options.allowNewlines)
    throw new DetectorError(`Illegal plain text: contains newlines`, text, options);

  if (options.bracketsAllowanceTreshold >= 0) {

    const numWords = text.split(utils.re.whitespace).length;
    const numBrackets = (text.match(/[\[\]]/g) || []).length;
    const ratio = numBrackets / numWords;

    if (ratio > options.bracketsAllowanceTreshold)
      throw new DetectorError(`Illegal plain text: contains too many brackets (${ratio})`, text, options);
  }

  return 'plain text';
};

},{"../../utils":479,"underscore":499}],448:[function(require,module,exports){
module.exports = [
  'form',
];
module.exports.hasComments = false;

},{}],449:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const getLoss = require('./get-loss')


module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {

  });

  sent.index();

  const output = sent.tokens.map(token => {

    return token.isSuperToken
      ? token.subTokens.map(subToken => subToken.value).join(' ')
      : token.form;

  }).join(' ').replace(utils.re.spaceBeforePunctuation, '$1');

  return {
    output: output,
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"./get-loss":450,"underscore":499}],450:[function(require,module,exports){
arguments[4][443][0].apply(exports,arguments)
},{"../../utils":479,"./fields":448,"dup":443,"underscore":499}],451:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'plain text',
  fields: require('./fields'),
  split: require('./splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

},{"./detector":447,"./fields":448,"./generator":449,"./parser":452,"./splitter":453}],452:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');

module.exports = (text, options) => {

  options = _.defaults(options, {
    allowEmptyString: true,
  });

  text = text || '';

  try {
    detect(text, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  //console.log();
  //console.log(text);

  let chunks = [];
  let word = '';

  _.each(text, (char, i) => {

    if (utils.re.whitespace.test(char)) {

      chunks.push(word);
      word = '';

    } else if (utils.re.punctuation.test(char)) {

      if (!utils.re.allPunctuation.test(word)) {
        chunks.push(word);
        word = '';
      }
      word += char;

    } else {
      word += char;

    }
  });

  chunks.push(word);

  //console.log(chunks);

  let tokens = chunks.filter(utils.thin).map((chunk, i) => {
    return {
      form: chunk,
      index: `${i}`,
    };
  });

  //console.log(comments);
  //console.log(tokens);

  return {
    input: text,
    options: options,
    comments: [],
    tokens: tokens,
  };
};

},{"../../utils":479,"./detector":447,"underscore":499}],453:[function(require,module,exports){
'use strict';

const _ = require('underscore');
const utils = require('../../utils');

module.exports = (text, options={}) => {

  options = _.defaults(options, {
    trimChunks: true
  });

  return text.split(utils.re.sentenceThenPunctuation).map(chunk => {
    if (options.trimChunks) {
      return chunk.trim();
    } else {
      return chunk;
    }
  }).filter(utils.thin);
};

},{"../../utils":479,"underscore":499}],454:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const DetectorError = utils.DetectorError;

module.exports = (text, options) => {

  options = _.defaults(options, {
    allowEmptyString: false,
    allowLeadingWhitespace: true,
    allowBookendWhitespace: true,
    allowTrailingWhitespace: true,
    allowNoDependencies: false,
  });

  if (!text && !options.allowEmptyString)
    throw new DetectorError(`Illegal SD: empty string`, text, options);

  if (utils.isJSONSerializable(text))
    throw new DetectorError(`Illegal SD: JSON object`, text, options);

  // be more or less strict about whitespace
  const dependencyRegex = options.allowBookendWhitespace
    ? utils.re.sdDependency
    : utils.re.sdDependencyNoWhitespace;

  // internal stuff
  let parsingDeps = false;
  let parsingWhitespace = false;
  let parsedDeps = 0;

  const lines = text.split(/\n/);
  lines.forEach((line, i) => {

    if (utils.re.whiteline.test(line)) {
      if (parsingDeps) {
        if (!options.allowTrailingWhitespace)
          throw new DetectorError(`Illegal SD: contains trailing whitespace`, text, options);

      } else {
        if (!options.allowLeadingWhitespace)
          throw new DetectorError(`Illegal SD: contains leading whitespace`, text, options);

      }
    }

    if (utils.re.comment.test(line)) {

    } else if (!parsingDeps) {

      if (dependencyRegex.test(line))
        throw new DetectorError(`Illegal SD: missing text line`, text, options);

      parsingDeps = true;

    } else if (!dependencyRegex.test(line)) {

      throw new DetectorError(`Illegal SD: expected dependency line`, text, options);

    } else {

      parsedDeps += 1;

    }
  });

  if (parsedDeps === 0 && !options.allowNoDependencies)
    throw new DetectorError(`Illegal SD: contains no dependencies`, text, options);

  return 'SD';
};

},{"../../utils":479,"underscore":499}],455:[function(require,module,exports){
module.exports = [
  'form',
  'head',
  'deprel',
];
module.exports.hasComments = true;

},{}],456:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const GeneratorError = utils.GeneratorError;
const generateText = require('../plain-text').generate;
const getLoss = require('./get-loss')

module.exports = (sent, options) => {

  if (!sent || sent.name !== 'Sentence')
    throw new GeneratorError(`Unable to generate, input not a Sentence`, sent, options);

  options = _.defaults(options, sent.options, {

  });

  sent.index();

  let lines = [];
  sent.comments.forEach(comment => {
    lines.push('# ' + comment.body);
  });

  lines.push(generateText(sent).output);

  if (sent.root)
    lines.push(`root(ROOT, ${sent.root.form})`);

  sent.tokens.forEach(token => {

    if (token._head && token.deprel && token._head.name !== 'RootToken')
      lines.push(`${token.deprel}(${token._head.form}, ${token.form})`);

  });

  return {
    output: lines.join('\n'),
    loss: getLoss(sent),
  };
};

},{"../../utils":479,"../plain-text":451,"./get-loss":457,"underscore":499}],457:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const fields = require('./fields');

module.exports = sent => {

  const serial = sent.serialize();
  let losses = new Set();

  serial.tokens.forEach(token => {
    Object.keys(_.omit(token, fields)).forEach(field => {
      switch (field) {
        case ('uuid'):
        case ('index'):
        case ('deps'):
          break;

        default:
          losses.add(field);
      }
    })
  });

  return Array.from(losses);
};

},{"../../utils":479,"./fields":455,"underscore":499}],458:[function(require,module,exports){
'use strict';

module.exports = {

  name: 'SD',
  fields: require('./fields'),
  split: require('../default-splitter'),
  detect: require('./detector'),
  parse: require('./parser'),
  generate: require('./generator'),

};

},{"../default-splitter":431,"./detector":454,"./fields":455,"./generator":456,"./parser":459}],459:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../../utils');
const ParserError = utils.ParserError;
const detect = require('./detector');
const parseText = require('../plain-text').parse;

module.exports = (text, options) => {

  function getTokenIndexFromString(tokens, token) {
    for (let i=0; i<tokens.length; i++) {
      if (tokens[i].form.toLowerCase() === token.toLowerCase())
        return i;
    }

    return null;
  }

  //console.log();
  //console.log(text);

  options = _.defaults(options, {
    allowEmptyString: false,
    allowBookendWhitespace: true,
    allowWhiteLines: true,
  });

  try {
    detect(text, options);
  } catch (e) {
    if (e instanceof utils.DetectorError)
      throw new ParserError(e.message);

    throw e;
  }

  const lines = text.split('\n');
  const depRegex = options.allowBookendWhitespace
    ? utils.re.sdDependencyNoWhitespace
    : utils.re.sdDependency;

  let chunks = [];
  lines.forEach(line => {

    const whiteline = line.match(utils.re.whiteline),
      comment = line.match(utils.re.comment),
      dep = line.match(depRegex);

    if (whiteline) {

    } else if (comment) {

      chunks.push({
        type: 'comment',
        body: comment[2]
      });

    } else if (dep) {

      chunks.push({
        type: 'dependency',
        deprel: dep[1],
        head: dep[2],
        dep: dep[3]
      });

    } else {

      chunks.push({
        type: 'text',
        body: line,
      });

    }

  });

  //console.log(chunks);

  let tokens;
  let comments = [];
  let expecting = ['comment', 'text'];

  chunks.forEach(chunk => {

    if (expecting.indexOf(chunk.type) === -1)
      throw new ParserError(`expecting ${expecting.join('|')}, got ${chunk.type}`, text, options);

    if (chunk.type === 'comment') {

      comments.push(chunk.body);
      expecting = ['comment', 'text'];

    } else if (chunk.type === 'text') {

      tokens = parseText(chunk.body).tokens;
      expecting = ['dependency'];

    } else if (chunk.type === 'dependency') {

      let index = getTokenIndexFromString(tokens, chunk.dep);
      if (index === null)
        throw new ParserError(`unable to find token with form ${chunk.dep}`, text, options);

      tokens[index].head = '' + getTokenIndexFromString(tokens, chunk.head); // get the index, cast to str
      tokens[index].deprel = chunk.deprel;
      expecting = ['dependency'];

    } else {
      throw new ParserError(`unrecognized chunk type: ${chunk.type}`, text, options);

    }
  });

  //console.log(comments);
  //console.log(tokens);

  return {
    input: text,
    options: options,
    comments: comments,
    tokens: tokens,
  };
};

},{"../../utils":479,"../plain-text":451,"./detector":454,"underscore":499}],460:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('./utils');
const GeneratorError = utils.GeneratorError;

let as = {

	'apertium stream': require('./formats/apertium-stream').generate,
  apertiumStream: require('./formats/apertium-stream').generate,
  Brackets: require('./formats/brackets').generate,
  brackets: require('./formats/brackets').generate,
  CG3: require('./formats/cg3').generate,
  cg3: require('./formats/cg3').generate,
  'CoNLL-U': require('./formats/conllu').generate,
  conllu: require('./formats/conllu').generate,
  'notatrix serial': require('./formats/notatrix-serial').generate,
  notatrixSerial: require('./formats/notatrix-serial').generate,
  Params: require('./formats/params').generate,
  params: require('./formats/params').generate,
  'plain text': require('./formats/plain-text').generate,
  plainText: require('./formats/plain-text').generate,
	SD: require('./formats/sd').generate,
  sd: require('./formats/sd').generate,

};

module.exports = as;

},{"./formats/apertium-stream":410,"./formats/brackets":417,"./formats/cg3":423,"./formats/conllu":429,"./formats/notatrix-serial":437,"./formats/params":444,"./formats/plain-text":451,"./formats/sd":458,"./utils":479,"underscore":499}],461:[function(require,module,exports){
'use strict';

const _ = require('underscore');
const nx = require('./nx');
const utils = require('./utils');
const errors = require('./utils/errors');

module.exports = _.extend({

  constants: utils.constants,
  formats: require('./formats'),
  regex: utils.regex,
  data: require('../data'),

  detect: require('./detector'),
  generate: require('./generator'),
  parse: require('./parser'),
  split: require('./splitter'),
  convert: require('./converter'),

}, nx, errors);

},{"../data":400,"./converter":405,"./detector":406,"./formats":432,"./generator":460,"./nx":468,"./parser":474,"./splitter":475,"./utils":479,"./utils/errors":477,"underscore":499}],462:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const AnalysisError = utils.AnalysisError;

const NxBaseClass = require('./base-class');
const SubToken = require('./sub-token');

class Analysis extends NxBaseClass {
  constructor(serial, options) {

    super('Analysis');
    this._subTokens = (serial.subTokens || []).map(sub => new SubToken(sub, options));

  }

  get subTokens() {
    return this._subTokens;
  }

}

module.exports = Analysis;

},{"../utils":479,"./base-class":463,"./sub-token":471,"underscore":499}],463:[function(require,module,exports){
class NxBaseClass {
  constructor(name) {
    this.name = name;
  }
};

module.exports = NxBaseClass;

},{}],464:[function(require,module,exports){
'use strict';

const _ = require('underscore');
const uuid = require('uuid/v4');

const utils = require('../utils');
const BaseTokenError = utils.BaseTokenError;

const NxBaseClass = require('./base-class');
const DependencySet = require('./dep-set');

class BaseToken extends NxBaseClass {
  constructor(name, options) {

    super(name);

    this.uuid = uuid();
    this.options = options;

    this._feats_init = false;
    this._misc_init = false;

    this._head = undefined;
    this._deps = new DependencySet(options);

    this.indices = {
      conllu: null,
      cg3: null,
      cytoscape: null,
    };
  }

  walk(callback) {
    let i = 0;
    if (this._analyses)
      return this._analyses.map(analysis => {
        return analysis._subTokens.map(subToken => {
          return callback(subToken, ++i);
        });
      });

    return null;
  }

  hashFields(...fields) {

    fields = _.flatten(fields);

    let hash = _.intersection(fields, [
      'form',
      'lemma',
      'upostag',
      'xpostag',
      'feats',
      'deprel',
      'misc',
      'isEmpty',
      'semicolon',
    ]).map(field => `<${this[field] || field}>`).join('|');

    if (fields.indexOf('indices') > -1)
      hash += `|${_.map(this.indices, index => `{${index}}`).join('')}`;

    if (fields.indexOf('head') > -1)
      hash += `|(h:${this.head.token.indices.absolute}:${h.deprel})`;

    if (fields.indexOf('deps') > -1)
      hash += `|(d:${this.mapDeps(d => `${d.token.indices.absolute}:${d.deprel}`).join('|') || ''})`;

    if (fields.indexOf('analyses') > -1 || fields.indexOf('subTokens') > -1)
      hash += `|[s:${this.walk(t => t.hashFields(fields)) || ''}]`;

    return hash;
  }

  serialize() {
    let serial = {

      uuid: this.uuid,
      form: this.form,
      index: this.indices.absolute,

      semicolon: this.semicolon,
      isEmpty: this.isEmpty,
      lemma: this.lemma,
      upostag: this.upostag,
      xpostag: this.xpostag,
      feats: this.feats,
      deprel: this.deprel,
      misc: this.misc,
      other: this.misc,

      head: this.getHead('serial'),
      deps: this.getDeps('serial'),

    };

    if (this._analyses && this._analyses.length)
      serial.analyses = this._analyses.map(analysis => {
        return {
          subTokens: analysis._subTokens.map(subToken => subToken.serialize()),
        };
      });

    serial = _.pick(serial, value => value !== undefined);

    return serial;
  }

  get isSuperToken() {
    return !!(this._analyses || []).reduce((total, analysis) => {
      return total += analysis._subTokens.length;
    }, 0);
  }

  get value() {
    return this.form || this.lemma;
  }

  get feats() {
    return this._feats_init
      ? this._feats.length
        ? this._feats.join('|')
        : null
      : undefined;
  }

  set feats(feats) {
    if (feats === undefined)
      return;

    this._feats_init = true;
    this._feats = (feats || '').split('|').filter(utils.thin);
  }

  get misc() {
    return this._misc_init
      ? this._misc.length
        ? this._misc.join('|')
        : null
      : undefined;
  }

  set misc(misc) { // [(serial.misc || ''), (serial.other || []).join('|')].join('|');
    if (misc === undefined)
      return;

    this._misc_init = true;
    this._misc = (misc || '').split('|').filter(utils.thin);
  }

  set other(other) {
    if (other === undefined)
      return;

    this._misc_init = true;
    this._misc = (other || []).filter(utils.thin);
  }

  getHead(format) {
    if (format === 'CoNLL-U') {
      return this._head ? `${this._head.indices.conllu}` : null;
    } else if (format === 'CG3') {
      return this._head ? `${this._head.indices.cg3}` : null;
    } else {
      return this._head ? `${this._head.indices.absolute}` : undefined;
    }
  }

  getDeps(format) {
    return this._deps.toString(format, 'deps');
  }

  addDep(token, deprel) {

    if (!(token instanceof BaseToken))
      throw new BaseTokenError('cannot add dep unless it is a token');

    if (token === this)
      throw new BaseTokenError('token cannot be its own dep');

    if (this.options.useTokenDeprel)
      deprel = deprel || this.deprel;

    this._deps.add(token, deprel);

  }

  removeDep(token) {

    if (!(token instanceof BaseToken))
      throw new BaseTokenError('cannot remove dep unless it is a token');

    if (token === this)
      throw new BaseTokenError('token cannot remove its own dep');

    this._deps.remove(token);
  }

  modifyDep(token, deprel) {
    const done = this._deps.modify(token, deprel);

    if (done) {
      token.modifyHead(this, deprel);
      return true;
    }

    return false;
  }

  mapDeps(callback) {
    return this._deps.map(callback);
  }
}

module.exports = BaseToken;

},{"../utils":479,"./base-class":463,"./dep-set":467,"underscore":499,"uuid/v4":503}],465:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const NxBaseClass = require('./base-class');

class Comment extends NxBaseClass {
  constructor(body) {
    super('Comment');

    this.type = 'normal';
    this.body = body;

    const label = body.match(utils.re.commentLabel),
      sentId = body.match(utils.re.commentSentId);

    if (label) {

      let labels = [];
      label[3].split(/\s/).forEach(label => {
        if (label && labels.indexOf(label) === -1)
          labels.push(label)
      });

      this.type = 'label';
      this.labels = labels;

    } else if (sentId) {

      this.type = 'sent-id';
      this.id = sentId[2];

    }
  }

  serialize() {
    return this.body;
  }
}

module.exports = Comment;

},{"../utils":479,"./base-class":463,"underscore":499}],466:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],467:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const DependencyError = utils.DependencyError;
const NxBaseClass = require('./base-class');


class DependencySet extends NxBaseClass {
  constructor(options) {
    super('DependencySet');

    this.options = options;
    this.items = new Array();
  }

  get length() {
    return this.items.length;
  }

  map(callback) {
    return this.items.map(callback);
  }

  add(token, deprel=null) {

    if (token.isSuperToken)
      throw new DependencyError('superTokens cannot have dependency relations');

    let found = false;
    for (let i=0; i<this.length; i++) {
      const item = this.items[i];
      if (item.token === token)
        found = true;
    }

    if (!found)
      this.items.push({
        token: token,
        deprel: deprel,
      });

    return found;
  }

  remove(token) {

    for (let i=0; i<this.length; i++) {
      const item = this.items[i];
      if (item.token === token)
        return this.items.splice(i, 1);
    }

    return null;
  }

  modify(token, deprel=null) {

    for (let i=0; i<this.length; i++) {
      const item = this.items[i];
      if (item.token === token) {
        let change = item.deprel !== deprel;
        item.deprel = deprel;
        return change;
      }
    }

    return false;
  }

  toString(format, type) {

    const standard = index => {

      const items = type === 'head' && !this.options.showEnhancedDependencies
        ? this.items.slice(0)
        : this.items;

      const showDeprel = (type === 'deps');

      const print = item => item.token.indices.conllu == undefined
        ? null
        : showDeprel && item.deprel && (item.deprel !== 'root' || this.options.showRootDeprel)
          ? `${ item.token.indices[index] }:${ item.deprel }`
          : `${ item.token.indices[index] }`;

      return items.map(print).filter(utils.thin).join('|');
    };

    if (format === 'CoNLL-U') {

      return standard('conllu') || null;

    } else if (format === 'cytoscape') {

      throw new Error('not implemented');

    } else if (format === 'serial') {

      return standard('absolute') || undefined;

    } else {

      const item = this.items.slice(0)[0];
      if (item == undefined)
        return null;

      return item.token.indices.cg3;

    }
  }
}

module.exports = DependencySet;

},{"../utils":479,"./base-class":463,"underscore":499}],468:[function(require,module,exports){
module.exports = {

  NxBaseClass: require('./base-class'),
  Corpus: require('./corpus'),
  Sentence: require('./sentence'),
  Comment: require('./comment'),
  BaseToken: require('./base-token'),
  RootToken: require('./root'),
  Token: require('./token'),
  Analysis: require('./analysis'),
  SubToken: require('./sub-token'),
  DependencySet: require('./dep-set'),

};

},{"./analysis":462,"./base-class":463,"./base-token":464,"./comment":465,"./corpus":466,"./dep-set":467,"./root":469,"./sentence":470,"./sub-token":471,"./token":472}],469:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const BaseToken = require('./base-token');

class RootToken extends BaseToken {
  constructor() {

    super('RootToken', {});

    this.indices = {
      conllu: 0,
      cg3: 0,
      cytoscape: 0,
    };
  }
}

module.exports = RootToken;

},{"../utils":479,"./base-token":464,"underscore":499}],470:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const SentenceError = utils.SentenceError;
const parse = require('../parser');
const generate = require('../generator');

const NxBaseClass = require('./base-class');
const Comment = require('./comment');
const BaseToken = require('./base-token');
const Token = require('./token');
const RootToken = require('./root');
const update = require('./update');

class Sentence extends NxBaseClass {
  constructor(serial, options) {

    super('Sentence');

    this.to = (format, options) => generate[format](this, options);

    serial = serial || '';
    options = options || {};
    options = _.defaults(options, {
      interpretAs: null,
      addHeadOnModifyFailure: true,
      depsShowDeprel: true,
      showRootDeprel: true,
      enhanced: false,
      useTokenDeprel: true,
    });

    if (options.interpretAs) {

      // interpret as a particular format if passed option
      serial = parse.as[options.interpretAs](serial, options);

    } else {

      // otherwise, get an array of possible interpretations
      serial = parse(serial, options);

      // choose one of them if possible
      if (serial.length === 0) {
        throw new SentenceError('Unable to parse input', this);
      } else if (serial.length === 1) {
        serial = serial[0];
      } else {
        throw new SentenceError(
          `Unable to disambiguate input interpretations (${serial.length})`, this);
      }

    }

    this.input = serial.input;
    this.options = serial.options;
    this.comments = serial.comments.map(com => new Comment(com, options));
    this.tokens = serial.tokens.map(tok => new Token(tok, options));
    this.root = undefined;

    this.attach();
  }

  serialize() {
    return {
      input: this.input,
      options: this.options,
      comments: this.comments.map(com => com.serialize()),
      tokens: this.tokens.map(token => token.serialize()),
    };
  }

  iterate(callback) {
    for (let i=0; i<this.tokens.length; i++) {

      const token = this.tokens[i];
      callback(token, i, null, null);

      for (let j=0; j<token._analyses.length; j++) {
        for (let k=0; k<token._analyses[j]._subTokens.length; k++) {

          const subToken = token._analyses[j]._subTokens[k];
          callback(subToken, i, j, k);

        }
      }
    }
  }

  query(predicate) {

    let matches = [];
    this.iterate(token => {
      if (predicate(token))
        matches.push(token);
    });

    return matches;
  }

  getDependents(token) {
    return this.query(t => {

      if (!t._head)
        return;

      return t._head.indices.absolute === token.indices.absolute;

    });
  }

  getByIndices(tokenId, analysisId=null, subTokenId=null) {

    if (!this.tokens[tokenId])
      return null;

    if (analysisId === null)
      return this.tokens[tokenId];

    if (!this.tokens[tokenId]._analyses[analysisId])
      return null;

    if (subTokenId === null)
      return this.tokens[tokenId]._analyses[analysisId];

    return this.tokens[tokenId]._analyses[analysisId]._subTokens[subTokenId] || null;
  }

  index() {

    let absolute = 0,
      majorToken = null,
      superToken = null,
      empty = 0,
      conllu = 0,
      cg3 = 0,
      cytoscape = -1;

    this.iterate((token, i, j, k) => {

      token.indices.absolute = ++absolute;

      if (!token._analyses || !token._analyses.length)
        token.indices.cg3 = ++cg3;

      if (!token.isSuperToken && superToken && superToken.analysis === j)
        token.indices.cytoscape = ++cytoscape;

      if (token.subTokens && token.subTokens.length === 0)
        token.indices.cytoscape = ++cytoscape;

      if (j === null || k === null) {

        majorToken = token;

        if (superToken) {
          superToken.token.indices.conllu = superToken.start + '-' + superToken.stop;
          superToken = null;
        }

        if (token.subTokens.length) {
          superToken = {
            token: token,
            start: null,
            stop: null,
            analysis: token._i,
          };
        } else {

          if (token.isEmpty) {
            empty += 1;
          } else {
            empty = 0;
            conllu += 1;
          }

          token.indices.conllu = empty ? conllu + '.' + empty : conllu;
        }

      } else {

        if (majorToken._i === j) {

          if (token.isEmpty) {
            empty += 1;
          } else {
            empty = 0;
            conllu += 1;
          }

          token.indices.conllu = empty ? conllu + '.' + empty : conllu;
        }

        if (superToken) {
          if (superToken.start === null) {
            superToken.start = empty ? conllu + '.' + empty : conllu;
          } else {
            superToken.stop = empty ? conllu + '.' + empty : conllu;
          }
        }
      }
    });

    if (superToken) {
      superToken.token.indices.conllu = `${superToken.start}-${superToken.stop}`;
      superToken = null;
    }

    this.size = absolute;
  }

  setRoot(token) {
    if (!(token instanceof BaseToken))
      throw new SentenceError(`cannot set ${token} as root`);

    if (this.root)
      throw new SentenceError(`root is already set`);

    this.root = token;
  }

  attach() {
    this.iterate((token, i, j, k) => {

      const head = token.serial.head;

      if (head === '0' || head === 0) {

        token._head = new RootToken();
        token.deprel = 'root';
        this.setRoot(token);

      } else if (head) {

        const query = this.query(token => token.serial.index === head);
        if (query.length !== 1) {
          console.log(token.serial)
          throw new SentenceError(`cannot locate token with serial index "${head}"`);
        }

        token._head = query[0];
        token.deprel = token.deprel || utils.guessDeprel(head, token);

      }

      (token.serial.deps || '').split('|').forEach(fullDep => {

        fullDep = fullDep.split(':');
        const dep = fullDep[0];
        const deprel = fullDep[1] || null;

        if (dep === '0') {

        } else if (dep) {

          const query = this.query(token => token.serial.index === dep);
          if (query.length !== 1)
            throw new SentenceError(`cannot locate token with serial index "${dep}"`);

          token.addDep(query[0], deprel);
        }
      });

    });

    this.iterate(token => { delete token.serial });

    this.index();
  }

  update(serial, options) {
    try {

      const sent = new Sentence(serial, options);
      update(this, sent, options);

    } catch(e) {

      if (e instanceof utils.ToolError || utils.NxError)
        throw new SentenceError('Unable to update: ' + e.message);

      throw e;
    }
  }

  getCytoscapeEles(format) {
    this.index();

    function toSubscript(str) {
      const subscripts = { 0:'â', 1:'â', 2:'â', 3:'â', 4:'â', 5:'â',
        6:'â', 7:'â', 8:'â', 9:'â', '-':'â', '(':'â', ')':'â' };

      if (str == null)
        return '';

      return str.split('').map((char) => {
        return (subscripts[char] || char);
      }).join('');
    }

    function getIndex(token, format) {
      return format === 'CoNLL-U'
        ? token.indices.conllu
        : format === 'CG3'
          ? token.indices.cg3
          : token.indices.absolute;
    }

    let eles = [];

    this.iterate(token => {

      if (token.indices.cytoscape == null && !token.isSuperToken)
        return;

      let id = getIndex(token, format);
      let num = token.indices.absolute - 1;
      let clump = token.indices.cytoscape;
      let pos = format === 'CG3'
        ? token.xpostag || token.upostag
        : token.upostag || token.xpostag;

      if (token.isSuperToken) {

        eles.push({ // multiword label
          data: {
            id: `multiword-${id}`,
            num: num,
            clump: clump,
            name: `multiword`,
            label: `${token.form} ${toSubscript(`${id}`)}`,
            /*length: `${token.form.length > 3
              ? token.form.length * 0.7
              : token.form.length}em`*/
          },
          classes: 'multiword'
        });

      } else {

        let parent = token.name === 'SubToken'
          ? 'multiword-' + getIndex(this.getSuperToken(token), format)
          : undefined;

        eles.push({ // "number" node
          data: {
            id: `num-${id}`,
            num: num,
            clump: clump,
            name: 'number',
            label: id,
            pos: pos,
            parent: parent,
            token: token,
          },
          classes: 'number'
        }, { // "form" node
          data: {
            id: `form-${id}`,
            num: num,
            clump: clump,
            name: 'form',
            attr: 'form',
            form: token.form,
            label: token.form || '',
            length: `${(token.form || '').length > 3
              ? (token.form || '').length * 0.7
              : (token.form || '').length}em`,
            state: `normal`,
            parent: `num-${id}`,
            token: token,
          },
          classes: `form${this.root === token ? ' root' : ''}`,
        }, { // "pos" node
          data: {
            id: `pos-node-${id}`,
            num: num,
            clump: clump,
            name: `pos-node`,
            attr: format === 'CG3' ? `xpostag` : `upostag`,
            pos: pos,
            label: pos || '',
            length: `${(pos || '').length * 0.7 + 1}em`,
            token: token,
          },
          classes: 'pos'
        }, { // "pos" edge
          data: {
            id: `pos-edge-${id}`,
            num: num,
            clump: clump,
            name: `pos-edge`,
            pos: pos,
            source: `form-${id}`,
            target: `pos-node-${id}`
          },
          classes: 'pos'
        });

        const getDependencyEdges = (format, head, token, deprel) => {

          if (head.name === 'RootToken')
            return;

          let headId = getIndex(head, format);

          eles.push({
            data: {
              id: `dep_${id}_${headId}`,
              name: `dependency`,
              attr: `deprel`,
              deprel: deprel,
              source: `form-${headId}`,
              sourceToken: head,
              target: `form-${id}`,
              targetToken: token,
              length: `${(deprel || '').length / 3}em`,
              label: null, // NB overwrite this before use
              ctrl: null   // NB overwrite this before use
            },
            classes: null  // NB overwrite this before use
          });
        };

        if (this.options.enhanced) {
          token.mapDeps((h, d) => getDependencyEdges(format, h, token, d));
        } else if (token._head) {
          getDependencyEdges(format, token._head, token, token.deprel);
        }
      }
    });

    return eles;
  }

  enhance() {
    this.options.enhanced = true;

    this.iterate(token => {
      if (!token._head)
        return;

      token.addDep(token._head, token.deprel);

    })
  }

  getSuperToken(token) {

    let superToken = null;

    this.iterate(tok => {
      if (!tok._analyses)
        return;

      tok._analyses.forEach(ana => {
        if (!ana._subTokens)
          return;

        ana._subTokens.forEach(sub => {
          if (sub === token)
            superToken = tok;

        });
      });
    });

    return superToken;
  }
}

module.exports = Sentence;

},{"../generator":460,"../parser":474,"../utils":479,"./base-class":463,"./base-token":464,"./comment":465,"./root":469,"./token":472,"./update":473,"underscore":499}],471:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const SubTokenError = utils.SubTokenError;

const BaseToken = require('./base-token');
const DependencySet = require('./dep-set');
const RootToken = require('./root');

class SubToken extends BaseToken {
  constructor(serial, options) {

    super('SubToken', options);
    this.uuid = serial.uuid || this.uuid;

    this.semicolon = serial.semicolon;
    this.isEmpty = serial.isEmpty;
    this.form = serial.form;
    this.lemma = serial.lemma;
    this.upostag = serial.upostag;
    this.xpostag = serial.xpostag;
    this.feats = serial.feats;
    this.deprel = serial.deprel;
    this.misc = serial.misc;
    this.other = serial.other;

    this.serial = {
      index: serial.index,
      head: serial.head,
      deps: serial.deps
    };
  }
}

module.exports = SubToken;

},{"../utils":479,"./base-token":464,"./dep-set":467,"./root":469,"underscore":499}],472:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const TokenError = utils.TokenError;

const BaseToken = require('./base-token');
const Analysis = require('./analysis');
const DependencySet = require('./dep-set');
const RootToken = require('./root');

class Token extends BaseToken {
  constructor(serial, options) {

    super('Token', options);
    this.uuid = serial.uuid || this.uuid;

    this.semicolon = serial.semicolon;
    this.isEmpty = serial.isEmpty;
    this.form = serial.form;
    this.lemma = serial.lemma;
    this.upostag = serial.upostag;
    this.xpostag = serial.xpostag;
    this.feats = serial.feats;
    this.deprel = serial.deprel;
    this.misc = serial.misc;
    this.other = serial.other;

    this._analyses = (serial.analyses || []).map(ana => new Analysis(ana, options));
    this._i = (this._analyses.length ? 0 : null);

    this.serial = {
      index: serial.index,
      head: serial.head,
      deps: serial.deps
    };
  }

  get analysis() {
    if (this._i === null)
      return null;

    return this._analyses[this._i];
  }

  get subTokens() {
    return this.analysis ? this.analysis.subTokens : [];
  }
}

module.exports = Token;

},{"../utils":479,"./analysis":462,"./base-token":464,"./dep-set":467,"./root":469,"underscore":499}],473:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('../utils');
const SentenceError = utils.SentenceError;
const formats = require('../formats');
const detect = require('../detector');

function debug(show, ...args) {
  if (show)
    console.log('d>', ...args);
}

function compareFields(fields, t1, t2, maxDistance) {
  debug(false, `comparing fields at maxDistance: ${maxDistance}`);


  /*
  const compare = field => {
    debug(false, `comparing "${field}" (${t1[field]}, ${t2[field]})`);

    if (field === 'analyses' && (t1._analyses || t2._analyses)) {

      console.log('analyses', t1.analyses === t2.analyses, t1._analyses);

    } else if (field === 'head') {

      let unmatched = {
        old: new Set(),
        new: new Set(),
      };
      let matched = {
        old: new Set(),
        new: new Set(),
      };
      t1.mapHeads((h1, d1) => {
        t2.mapHeads((h2, d2) => {

        });
      });

      console.log('head', t1._heads.toString('serial', 'dep'), t2._heads.toString('serial', 'dep'));

    } else if (field === 'deps') {

      console.log('deps', t1._deps.toString('serial', 'dep'), t2._deps.toString('serial', 'dep'));

    } else if (t1[field] !== t2[field]) {
      if (field === 'analyses') {

        console.log(t1.analyses, t2.analyses)

      }
      //console.log(field, t1.indices.absolute, t2.indices.absolute)
      distance += 1;
    }
  }
  */

  var distance = 0;

  fields = fields.filter(field => t1[field] !== undefined);
  const combinations = utils.combine(fields, fields.length - maxDistance);

  [].forEach(combination => {

  });

  return distance;

  console.log(fields, utils.combine(fields, fields.length - maxDistance));

  const h1 = t1.hashFields(fields, 'indices'),
    h2 = t2.hashFields(fields, 'indices');

  if (h1 === h2)
    return true;

  console.log();
  console.log('h1', h1);
  console.log('h2', h2);
  console.log();
  return false;

  debug(false, `distance: ${distance}`)
  return distance <= maxDistance;
}

function compareIndices(_arg, t1, t2, maxDistance) {
  debug(false, `comparing fields at maxDistance: ${maxDistance}`);

  let distance = 0;
  ['conllu', 'cg3', 'cytoscape', 'absolute'].forEach(indexName => {

    debug(false, `comparing "${indexName}" (${t1.indices[indexName]}, ${t2.indices[indexName]})`);
    if (t1.indices[indexName] !== t2.indices[indexName])
      distance += 1;

  });

  debug(false, `distance: ${distance}`)
  return distance <= maxDistance;
}

function updateToken(fields, t1, t2) {
  debug(false, `updating`);

  fields.forEach(field => {
    debug(false, `trying to update "${field}"`);

    switch (field) {
      case ('subTokens'):
        if (t1.subTokens.length || t2.subTokens.length) {
          throw new Error('not implemented');
        } else {
          // pass
        }
        break;

      default:
        debug(false, `updating (${t1[field]} => ${t2[field]})`);
        t1[field] = t2[field];
    }
  });
}




























function getDistance(fields, t1, t2) {

  fields = fields.filter(field => t1[field] !== undefined);
  for (let dist=0; dist<fields.length; dist++) {

    let match = false;
    utils.combine(fields, fields.length - dist).forEach(comb => {

      const hash1 = t1.hashFields(comb),
        hash2 = t2.hashFields(comb);

      if (hash1 === hash2)
        match = true;
    });

    if (match)
      return dist;
  }
  return Infinity;
}

function getMatches(s, t, ...fields) {

  fields = _.flatten(fields);

  let s_unmatched = new Set((s.map(token => `${token.indices.absolute}`)));
  let t_unmatched = new Set((t.map(token => `${token.indices.absolute}`)));

  // build distances between nodes
  let rawDistances = {};
  s.forEach(t1 => {

    const i1 = t1.indices.absolute;
    rawDistances[i1] = {};

    t.forEach(t2 => {

      const i2 = t2.indices.absolute;
      rawDistances[i1][i2] = getDistance(fields, t1, t2);

    });
  });

  //console.log(rawDistances);

  let neighbors = {};
  _.each(rawDistances, (targets, source) => {

    neighbors[source] = [];

    let min = Infinity;
    _.each(targets, distance => {
      min = Math.min(distance, min);
    });
    if (min < Infinity)
      _.each(targets, (distance, target) => {
        if (distance === min)
          neighbors[source].push(target);
      });

  });

  //console.log(neighbors);

  const lookup = (prefix, index) => key[`${prefix}_${index}`];

  let matches = new Set();

  _.each(neighbors, (neighbors, index) => {
    if (neighbors.length === 1) {

      matches.add([`${index}`, `${neighbors[0]}`]);
      s_unmatched.delete(`${index}`);
      t_unmatched.delete(`${neighbors[0]}`);

    }
  });

  return {
    matches,
    s_unmatched,
    t_unmatched,
  };
}

function updateMatches(s_key, t_key, matches, fields) {

  matches.forEach(match => {

    const s_token = s_key[match[0]];
    const t_token = t_key[match[1]];
    //console.log('updating', match[0], match[1]);

    fields.forEach(field => {

      switch (field) {
        case ('analyses'):

          //console.log('begin analyses evaluations');
          if (s_token._analyses === undefined || t_token.analyses === undefined)
            break;

          let s_analyses = s_token._analyses.slice();
          let t_analyses = t_token._analyses.slice();

          for (let i = 0; i<s_analyses.length; i++)
            matchAndUpdate(
              s_key,
              s_analyses[i]._subTokens,
              t_key,
              t_analyses[i]._subTokens,
              fields);
          //console.log('end anlyses evaluations');

          break;

        case ('subTokens'):

          //console.log('begin subToken evaluations');
          if (s_token._analyses === undefined || t_token.analyses === undefined)
            break;

          let s = s_token.subTokens.slice();
          let t = t_token.subTokens.slice();
          matchAndUpdate(s_key, s, t_key, t, fields);
          //console.log('end subToken evaluations');

          break;

        default:
          //if (s_token[field] !== t_token[field])
            //console.log('change!!!', field, s_token[field], t_token[field]);
          s_token[field] = t_token[field];
      }
    });
  });
}

function matchAndUpdate(s_key, s, t_key, t, fields) {

  //console.log('matching on fields');
  let m = getMatches(s, t, fields);
  //console.log(m);
  updateMatches(s_key, t_key, m.matches, fields);

  if (m.s_unmatched.size || m.t_unmatched.size) {

    let s = [], t = [];

    m.s_unmatched.forEach(i => s.push(s_key[i]));
    m.t_unmatched.forEach(i => t.push(t_key[i]));

    //console.log('matching on fields and indices')
    const m2 = getMatches(s, t, fields, 'indices');
    //console.log(m2);
    updateMatches(s_key, t_key, m2.matches, fields);

    if (m2.s_unmatched.size || m2.t_unmatched.size) {

      throw new Error('unable to find match')

    }
  }
}

module.exports = (original, update, options) => {

  debug(false, 'original input:', original.input);
  debug(false, 'update input:', update.input);

  // the input format of the new guy
  let format = detect(update.input, _.extend({
    requireOneFormat: true,
  }, options));
  debug(false, 'detected update as format:', format);
  format = formats[format];

  /*
  let unmatched = {
    old: new Set(),
    new: new Set(),
  };
  let matched = {
    old: new Set(),
    new: new Set(),
  };
  */

  if (format.hasComments) {
    debug(false, '\n\ncomparing comments\n');
    let i = 0, j = 0;
    while (data.comments.new.unmatched.size) {

      throw new Error('not implemented');

      /*
      const s1Comment = this.comments[i];
      const s2Comment = sent.comments[i];

      if (commentsEqual(s1Comment, s2Comment)) {
        throw new Error('not implemented')
      } else {
        throw new Error('not implemented')
      }
      */
    }
  } else {
    debug(false, 'using original comments');
    // don't change anything
  }









  // build a hash table and a list of tokens for each sentence
  let s_key = {}, s = [], t_key = {}, t = [];

  original.iterate(token => {

    s_key[token.indices.absolute] = token;
    s.push(token);

  });
  update.iterate(token => {

    t_key[token.indices.absolute] = token;
    t.push(token)

  });

  // try to find matches between the items
  matchAndUpdate(s_key, s, t_key, t, format.fields);

  return;















  const iterate = (predicate, dist) => {
    debug(true, 'iterating at distance', dist);

    original.iterate(t1 => {
      update.iterate(t2 => {

        if (!matched.old.has(t1) && !matched.new.has(t2))
          if (predicate(format.fields, t1, t2, dist)) {

            debug(false, 'same', t1.form, t2.form);
            matched.old.add(t1);
            matched.new.add(t2);
            unmatched.old.delete(t1);
            unmatched.new.delete(t2);
            updateToken(format.fields, t1, t2);

          } else {

            debug(false, 'different', t1.form, t2.form);
            unmatched.old.add(t1);
            unmatched.new.add(t2);

          }

      });
    });
  };

  debug(false, )
  debug(true, `comparing tokens on fields to find exact matches`);
  iterate(compareFields, 0);

  if (!unmatched.old.size && !unmatched.new.size)
    return;

  debug(false, )
  debug(true, `comparing tokens on fields to find close matches`);
  for (let i=1; i<format.fields.length; i++) {

    iterate(compareFields, i);
    if (!unmatched.old.size && !unmatched.new.size)
      return;

  }

  unmatched.old.forEach(e => debug(true, e.indices));
  unmatched.new.forEach(e => debug(true, e.indices));

  debug(false, )
  debug(true, `comparing tokens on indices to find close matches`);
  for (let i=0; i<4; i++) {

    iterate(compareIndices, i);
    if (!unmatched.old.size && !unmatched.new.size)
      return;

  }

  debug(true, unmatched);
  throw new Error('can\'t find a match');
};

  /*

  let distance = 0;
  while (data.tokens.new.unmatched.size) {
    debug()
    debug(`\tevaluating at maxDistance: ${distance}`);
    debug()

    for (let i=0; i<data.old.tokens.length; i++) {
      for (let j=0; j<data.new.tokens.length; j++) {

        if (data.tokens.old.unmatched.has(i) && data.tokens.new.unmatched.has(j))
          if (compareFields(data, i, j, distance)) {
            debug('same');

            data.tokens.old.unmatched.delete(i);
            data.tokens.old.matched.add(i);
            data.tokens.new.unmatched.delete(j);
            data.tokens.new.matched.add(j);

            updateToken(data, i, j);

          } else {
            debug('different');
          }

      }
    }

    distance++;
  }

  return data;
};


/*


// some helper functions

function commentsEqual(c1, c2) {
  throw new Error('not implemented');
}

function tokensIdentical(t1, t2) {

  let matches = 0,
    mismatches = 0;

  newFormat.fields.forEach(field => {

    debug(`comparing "${field}" (1: "${t1[field]}", 2: "${t2[field]}")`);
    if (t1[field] === t2[field]) {
      matches += 1;
    } else {
      mismatches += 1;
    }
  });

  debug(matches, mismatches);

  if (matches > 0 && mismatches === 0) {
    debug('tokens equal')
    return true;
  }
}

function updateToken(t1, t2) {
  newFormat.fields.forEach(field => {
    debug(`updating "${field}" : "${t1[field]}" => "${t2[field]}"`)
    t1[field] = t2[field];
  });
}


// the new guy

const numComments = Math.max(this.comments.length, sent.comments.length);
if (newFormat.hasComments) {
  debug('comparing comments');
  for (let i=0; i<numTokens; i++) {
    const s1Comment = this.comments[i];
    const s2Comment = sent.comments[i];

    if (commentsEqual(s1Comment, s2Comment)) {
      throw new Error('not implemented')
    } else {
      throw new Error('not implemented')
    }
  }
} else {
  debug('using original comments');
  // don't change anything
}

debug('comparing tokens');
const numTokens = Math.max(this.tokens.length, sent.tokens.length);
let i1 = 0,
  oldMatches = new Set();
  i2 = 0,
  newMatches = new Set();

while (i1 < numTokens && i2 < numTokens) {

  const t1 = this.tokens[i1];
  const t2 = sent.tokens[i2];

  if (tokensIdentical(t1, t2)) {

    debug(`updating (${i1}, ${i2})`);
    oldMatches.add(i1);
    newMatches.add(i2);
    updateToken(t1, t2);

  } else {



  }

  i1++;
  i2++;
}


*/

},{"../detector":406,"../formats":432,"../utils":479,"underscore":499}],474:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('./utils');
const ParserError = utils.ParserError;

let as = {

	'apertium stream': require('./formats/apertium-stream').parse,
  apertiumStream: require('./formats/apertium-stream').parse,
  Brackets: require('./formats/brackets').parse,
  brackets: require('./formats/brackets').parse,
  CG3: require('./formats/cg3').parse,
  cg3: require('./formats/cg3').parse,
  'CoNLL-U': require('./formats/conllu').parse,
  conllu: require('./formats/conllu').parse,
  'notatrix serial': require('./formats/notatrix-serial').parse,
  notatrixSerial: require('./formats/notatrix-serial').parse,
  Params: require('./formats/params').parse,
  params: require('./formats/params').parse,
  'plain text': require('./formats/plain-text').parse,
  plainText: require('./formats/plain-text').parse,
	SD: require('./formats/sd').parse,
  sd: require('./formats/sd').parse,

};

module.exports = (text, options) => {

	options = _.defaults(options, {
    suppressDetectorErrors: true,
		suppressParserErrors: true,
		returnAllPossibilities: true,
  });

	const possibilities = utils.formats.map(format => {

		try {
			return as[format](text, options);
		} catch (e) {

			if (e instanceof ParserError && options.suppressParserErrors)
				return;

			throw e;
		}

	}).filter(utils.thin);

	if (!possibilities.length && !options.suppressDetectorErrors)
		throw new DetectorError('Unable to detect format', text, options);

	return options.returnAllPossibilities ? possibilities : possibilities[0];

};
module.exports.as = as;

},{"./formats/apertium-stream":410,"./formats/brackets":417,"./formats/cg3":423,"./formats/conllu":429,"./formats/notatrix-serial":437,"./formats/params":444,"./formats/plain-text":451,"./formats/sd":458,"./utils":479,"underscore":499}],475:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const utils = require('./utils');
const defaultSplitter = require('./formats/default-splitter');
const detector = require('./detector');
const SplitterError = utils.SplitterError;

let as = {

	'apertium stream': require('./formats/apertium-stream').split,
  apertiumStream: require('./formats/apertium-stream').split,
  Brackets: require('./formats/brackets').split,
  brackets: require('./formats/brackets').split,
  CG3: require('./formats/cg3').split,
  cg3: require('./formats/cg3').split,
  'CoNLL-U': require('./formats/conllu').split,
  conllu: require('./formats/conllu').split,
  'notatrix serial': require('./formats/notatrix-serial').split,
  notatrixSerial: require('./formats/notatrix-serial').split,
  Params: require('./formats/params').split,
  params: require('./formats/params').split,
  'plain text': require('./formats/plain-text').split,
  plainText: require('./formats/plain-text').split,
	SD: require('./formats/sd').split,
  sd: require('./formats/sd').split,

};

module.exports = (text, options) => {

	let fromDefault = new Set();
	const splitAsDefault = defaultSplitter(text, options);
	splitAsDefault.forEach(line => {
		detector(line, options).forEach(format => fromDefault.add(format));
	});

	let fromPlainText = new Set();
	const splitAsPlainText = as.plainText(text, options);
	splitAsPlainText.forEach(line => {
		detector(line, options).forEach(format => fromPlainText.add(format));
	});

	if (fromPlainText.size === 1 && fromPlainText.has('plain text'))
		return splitAsPlainText;

	return splitAsDefault;
};
module.exports.as = as;
module.exports.onNewlines = require('./formats/default-splitter');

},{"./detector":406,"./formats/apertium-stream":410,"./formats/brackets":417,"./formats/cg3":423,"./formats/conllu":429,"./formats/default-splitter":431,"./formats/notatrix-serial":437,"./formats/params":444,"./formats/plain-text":451,"./formats/sd":458,"./utils":479,"underscore":499}],476:[function(require,module,exports){
'use strict';

module.exports = {

  fields: [
    'index',
    'form',
    'lemma',
    'upostag',
    'xpostag',
    'feats',
    'head',
    'deprel',
    'deps',
    'misc'
  ],

  formats: [
    //'apertium stream',
    'Brackets',
    'CG3',
    'CoNLL-U',
    'notatrix serial',
    'Params',
    'plain text',
    'SD'
  ],

  nxSentenceFields: {
    input: 'string',
    options: 'object',
    comments: 'array',
    tokens: 'array',
  },

  nxSentenceTokensFields: {
    semicolon: 'boolean',
    isEmpty: 'boolean',
    index: 'number',
    form: 'string*',
    lemma: 'string*',
    upostag: 'string*',
    xpostag: 'string*',
    feats: 'string*',
    head: 'string*',
    deprel: 'string*',
    deps: 'string*',
    analyses: 'array',
  },

  nxAllOptions: {

  },

  fallback: '_',

};

},{}],477:[function(require,module,exports){
'use strict';

class NotatrixError extends Error {
  constructor(...args) {
    super(...args);
  }
}

class InvalidCG3Error extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}

class InvalidCoNLLUError extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}


class ToolError extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}

class SplitterError extends ToolError {
  constructor(message, text, options) {
    super(message);

    this.name = 'SplitterError';
    this.text = text;
    this.options = options;
  }
}

class DetectorError extends ToolError {
  constructor(message, text, options) {
    super(message);

    this.name = 'DetectorError';
    this.text = text;
    this.options = options;
  }
}

class ParserError extends ToolError {
  constructor(message, text, options) {
    super(message);

    this.name = 'ParserError';
    this.text = text;
    this.options = options;
  }
}

class GeneratorError extends ToolError {
  constructor(message, nx, options) {
    super(message);

    this.name = 'GeneratorError';
    this.nx = nx;
    this.options = options;
  }
}

class ConverterError extends ToolError {
  constructor(message) {
    super(message);

    this.name = 'ConverterError';
  }
}



class NxError extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}

class CorpusError extends NxError {
  constructor(message, nx) {
    super(message);

    this.name = 'CorpusError';
    this.nx = nx;
  }
}

class SentenceError extends NxError {
  constructor(message, nx) {
    super(message);

    this.name = 'SentenceError';
    this.nx = nx;
  }
}

class BaseTokenError extends NxError {
  constructor(...args) {
    super(...args);
    this.name = 'BaseTokenError';
  }
}

class TokenError extends BaseTokenError {
  constructor(message, nx) {
    super(message);

    this.name = 'TokenError';
    this.nx = nx;
  }
}

class AnalysisError extends NxError {
  constructor(message, nx) {
    super(message);

    this.name = 'AnalysisError';
    this.nx = nx;
  }
}

class SubTokenError extends BaseTokenError {
  constructor(message, nx) {
    super(message);

    this.name = 'SubTokenError';
    this.nx = nx;
  }
}

class DependencyError extends NxError {
  constructor(message) {
    super(message);

    this.name = 'DependencyError';
  }
}



module.exports = {

  NotatrixError,
  InvalidCG3Error,
  InvalidCoNLLUError,

  ToolError,
  SplitterError,
  DetectorError,
  ParserError,
  GeneratorError,
  ConverterError,

  NxError,
  CorpusError,
  SentenceError,
  BaseTokenError,
  TokenError,
  AnalysisError,
  SubTokenError,
  DependencyError,

};

},{}],478:[function(require,module,exports){
'use strict';

function combine(arr, k) {

  if (k > arr.length || k <= 0)
    return [];

  if (k === arr.length)
    return [arr];

  if (k === 1)
    return arr.map(e => [e]);

  let combs = [];
  for (let i = 0; i < arr.length - k + 1; i++) {

    const head = arr.slice(i, i+1);
    const tailCombs = combine(arr.slice(i+1), k-1);
    tailCombs.forEach(tailComb => {
      combs.push(head.concat(tailComb));
    });

  }
  return combs;
}

module.exports = {

  isJSONSerializable: obj => {

    if (typeof obj === 'string') {

      try {
        JSON.parse(obj);
      } catch (e) {
        return false;
      }

    } else {

      try {
        JSON.stringify(obj);
      } catch (e) {
        return false;
      }

    }

    return true;
  },

  noop: arg => arg,

  thin: arg => !!arg ? arg : undefined,

  combine,

  guessDeprel: (dependent, head, context) => undefined,

};

},{}],479:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const constants = require('./constants');
const errors = require('./errors');
const funcs = require('./funcs');
const regex = require('./regex');

module.exports = _.extend({ re: regex }, errors, constants, funcs);

},{"./constants":476,"./errors":477,"./funcs":478,"./regex":480,"underscore":499}],480:[function(require,module,exports){
module.exports = {

  multiNewlines: /\n{2,}/g,
  punctuation: /[.,!?;]+/g,
  allPunctuation: /^[.,!?;]+$/,
  sentenceThenPunctuation: /([^.!?]*[.!?]*)/g,
  spaceBeforePunctuation: /\s+([.,!?;]+)/g,
  comment: /^(#\s*(.*))(\n|$)/,
  conlluTokenLine: /^((\d+(\.\d+)?)(\-(\d+(\.\d+)?))?)(.+)/,
  conlluTokenLineTenParams: /^((\d+(\.\d+)?)(\-(\d+(\.\d+)?))?)((\s+\S+){8,9})/,
  conlluEmptyIndex: /^(\d+)(\.\d+)?/,
  cg3TokenStart: /^["']<((.|\\")*)>["']/,
  cg3TokenContent: /^(;?)(\s+)"((.|\\")*)"((\s+[\w@#\->:=]+)*)/,
  cg3Dependency: /#?\d+(->\d*)?$/,
  cg3Head: /#\d+->(\d*)$/,
  cg3Index: /#(\d+)/,
  cg3Deprel: /^@(.*)/,
  cg3Other: /([^;].*(:.+)?)/,
  whitespace: /(\s+)/,
  whiteline: /^(\s*)(\n|$)/,
  sdDependency: /^\s*([\w.]+)\(([\w.]+),\s*([\w.]+)\)\s*$/,
  sdDependencyNoWhitespace: /^([\w.]+)\(([\w.]+),\s*([\w.]+)\)$/,
  fallback: /^_$/,
  commentLabel: /(\s*)(labels?|tags?)\s*=\s*(\w.*)/,
  commentSentId: /(\s*)sent.?id\s*=\s*(\w*)/i,

};

},{}],481:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],482:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],483:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],484:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":485,"./socket":487,"./url":488,"debug":489,"socket.io-parser":492}],485:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":486,"./socket":487,"backo2":41,"component-bind":48,"component-emitter":49,"debug":489,"engine.io-client":375,"indexof":393,"socket.io-parser":492}],486:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

},{}],487:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');
var hasBin = require('has-binary2');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};

},{"./on":486,"component-bind":48,"component-emitter":49,"debug":489,"has-binary2":389,"parseqs":481,"socket.io-parser":492,"to-array":498}],488:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":489,"parseuri":482}],489:[function(require,module,exports){
arguments[4][384][0].apply(exports,arguments)
},{"./debug":490,"_process":483,"dup":384}],490:[function(require,module,exports){
arguments[4][385][0].apply(exports,arguments)
},{"dup":385,"ms":395}],491:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":493,"isarray":496}],492:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}

},{"./binary":491,"./is-buffer":493,"component-emitter":49,"debug":494,"isarray":496}],493:[function(require,module,exports){
(function (global){

module.exports = isBuf;

var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';

var isView = (function () {
  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
    return global.ArrayBuffer.isView;
  } else {
    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
  }
})();

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],494:[function(require,module,exports){
arguments[4][384][0].apply(exports,arguments)
},{"./debug":495,"_process":483,"dup":384}],495:[function(require,module,exports){
arguments[4][385][0].apply(exports,arguments)
},{"dup":385,"ms":395}],496:[function(require,module,exports){
arguments[4][390][0].apply(exports,arguments)
},{"dup":390}],497:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":483,"timers":497}],498:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],499:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because weâre not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result â either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functionâs
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6âs "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherâYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objectâs
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],500:[function(require,module,exports){
/*
Simple Javascript undo and redo.
https://github.com/ArthurClemens/Javascript-Undo-Manager
*/

;(function() {

	'use strict';

    function removeFromTo(array, from, to) {
        array.splice(from,
            !to ||
            1 + to - from + (!(to < 0 ^ from >= 0) && (to < 0 || -1) * array.length));
        return array.length;
    }

    var UndoManager = function() {

        var commands = [],
            index = -1,
            limit = 0,
            isExecuting = false,
            callback,
            
            // functions
            execute;

        execute = function(command, action) {
            if (!command || typeof command[action] !== "function") {
                return this;
            }
            isExecuting = true;

            command[action]();

            isExecuting = false;
            return this;
        };

        return {

            /*
            Add a command to the queue.
            */
            add: function (command) {
                if (isExecuting) {
                    return this;
                }
                // if we are here after having called undo,
                // invalidate items higher on the stack
                commands.splice(index + 1, commands.length - index);

                commands.push(command);
                
                // if limit is set, remove items from the start
                if (limit && commands.length > limit) {
                    removeFromTo(commands, 0, -(limit+1));
                }
                
                // set the current index to the end
                index = commands.length - 1;
                if (callback) {
                    callback();
                }
                return this;
            },

            /*
            Pass a function to be called on undo and redo actions.
            */
            setCallback: function (callbackFunc) {
                callback = callbackFunc;
            },

            /*
            Perform undo: call the undo function at the current index and decrease the index by 1.
            */
            undo: function () {
                var command = commands[index];
                if (!command) {
                    return this;
                }
                execute(command, "undo");
                index -= 1;
                if (callback) {
                    callback();
                }
                return this;
            },

            /*
            Perform redo: call the redo function at the next index and increase the index by 1.
            */
            redo: function () {
                var command = commands[index + 1];
                if (!command) {
                    return this;
                }
                execute(command, "redo");
                index += 1;
                if (callback) {
                    callback();
                }
                return this;
            },

            /*
            Clears the memory, losing all stored states. Reset the index.
            */
            clear: function () {
                var prev_size = commands.length;

                commands = [];
                index = -1;

                if (callback && (prev_size > 0)) {
                    callback();
                }
            },

            hasUndo: function () {
                return index !== -1;
            },

            hasRedo: function () {
                return index < (commands.length - 1);
            },

            getCommands: function () {
                return commands;
            },

            getIndex: function() {
                return index;
            },
            
            setLimit: function (l) {
                limit = l;
            }
        };
    };

	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// AMD. Register as an anonymous module.
		define(function() {
			return UndoManager;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = UndoManager;
	} else {
		window.UndoManager = UndoManager;
	}

}());

},{}],501:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

},{}],502:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],503:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":501,"./lib/rng":502}],504:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}]},{},[12])(12)
});
