(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.data = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/fn/regexp/escape":3,"core-js/shim":326,"regenerator-runtime/runtime":2}],2:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":24,"../../modules/core.regexp.escape":129}],4:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],5:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":19}],6:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":43,"./_wks":127}],7:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],8:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":52}],9:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":112,"./_to-length":116,"./_to-object":117}],10:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":112,"./_to-length":116,"./_to-object":117}],11:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":40}],12:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":112,"./_to-iobject":115,"./_to-length":116}],13:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":16,"./_ctx":26,"./_iobject":48,"./_to-length":116,"./_to-object":117}],14:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":4,"./_iobject":48,"./_to-length":116,"./_to-object":117}],15:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":50,"./_is-object":52,"./_wks":127}],16:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":15}],17:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":4,"./_invoke":47,"./_is-object":52}],18:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":19,"./_wks":127}],19:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],20:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":7,"./_ctx":26,"./_descriptors":30,"./_for-of":40,"./_iter-define":56,"./_iter-step":58,"./_meta":66,"./_object-create":71,"./_object-dp":72,"./_redefine-all":91,"./_set-species":98,"./_validate-collection":124}],21:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":11,"./_classof":18}],22:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":7,"./_an-object":8,"./_array-methods":13,"./_for-of":40,"./_has":42,"./_is-object":52,"./_meta":66,"./_redefine-all":91,"./_validate-collection":124}],23:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":7,"./_export":34,"./_fails":36,"./_for-of":40,"./_global":41,"./_inherit-if-required":46,"./_is-object":52,"./_iter-detect":57,"./_meta":66,"./_redefine":92,"./_redefine-all":91,"./_set-to-string-tag":99}],24:[function(require,module,exports){
var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],25:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":72,"./_property-desc":90}],26:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":4}],27:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":36}],28:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":8,"./_to-primitive":118}],29:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],30:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":36}],31:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":41,"./_is-object":52}],32:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],33:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":78,"./_object-keys":81,"./_object-pie":82}],34:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":24,"./_ctx":26,"./_global":41,"./_hide":43,"./_redefine":92}],35:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":127}],36:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],37:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":29,"./_fails":36,"./_hide":43,"./_redefine":92,"./_wks":127}],38:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":8}],39:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":26,"./_is-array":50,"./_is-object":52,"./_to-length":116,"./_wks":127}],40:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":8,"./_ctx":26,"./_is-array-iter":49,"./_iter-call":54,"./_to-length":116,"./core.get-iterator-method":128}],41:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],42:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],43:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":30,"./_object-dp":72,"./_property-desc":90}],44:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":41}],45:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":30,"./_dom-create":31,"./_fails":36}],46:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":52,"./_set-proto":97}],47:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],48:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":19}],49:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":59,"./_wks":127}],50:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":19}],51:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":52}],52:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],53:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":19,"./_is-object":52,"./_wks":127}],54:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":8}],55:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":43,"./_object-create":71,"./_property-desc":90,"./_set-to-string-tag":99,"./_wks":127}],56:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":34,"./_hide":43,"./_iter-create":55,"./_iterators":59,"./_library":60,"./_object-gpo":79,"./_redefine":92,"./_set-to-string-tag":99,"./_wks":127}],57:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":127}],58:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],59:[function(require,module,exports){
module.exports = {};

},{}],60:[function(require,module,exports){
module.exports = false;

},{}],61:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],62:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":65}],63:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],64:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],65:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],66:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":36,"./_has":42,"./_is-object":52,"./_object-dp":72,"./_uid":122}],67:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":34,"./_shared":101,"./es6.map":159,"./es6.weak-map":265}],68:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":19,"./_global":41,"./_task":111}],69:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":4}],70:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":36,"./_iobject":48,"./_object-gops":78,"./_object-keys":81,"./_object-pie":82,"./_to-object":117}],71:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":8,"./_dom-create":31,"./_enum-bug-keys":32,"./_html":44,"./_object-dps":73,"./_shared-key":100}],72:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":8,"./_descriptors":30,"./_ie8-dom-define":45,"./_to-primitive":118}],73:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":8,"./_descriptors":30,"./_object-dp":72,"./_object-keys":81}],74:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":36,"./_global":41,"./_library":60}],75:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":30,"./_has":42,"./_ie8-dom-define":45,"./_object-pie":82,"./_property-desc":90,"./_to-iobject":115,"./_to-primitive":118}],76:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":77,"./_to-iobject":115}],77:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":32,"./_object-keys-internal":80}],78:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],79:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":42,"./_shared-key":100,"./_to-object":117}],80:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":12,"./_has":42,"./_shared-key":100,"./_to-iobject":115}],81:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":32,"./_object-keys-internal":80}],82:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],83:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":24,"./_export":34,"./_fails":36}],84:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":81,"./_object-pie":82,"./_to-iobject":115}],85:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":8,"./_global":41,"./_object-gopn":77,"./_object-gops":78}],86:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":41,"./_string-trim":109,"./_string-ws":110}],87:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":41,"./_string-trim":109,"./_string-ws":110}],88:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],89:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":8,"./_is-object":52,"./_new-promise-capability":69}],90:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],91:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":92}],92:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":24,"./_global":41,"./_has":42,"./_hide":43,"./_uid":122}],93:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],94:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],95:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":4,"./_ctx":26,"./_export":34,"./_for-of":40}],96:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":34}],97:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":8,"./_ctx":26,"./_is-object":52,"./_object-gopd":75}],98:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":30,"./_global":41,"./_object-dp":72,"./_wks":127}],99:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":42,"./_object-dp":72,"./_wks":127}],100:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":101,"./_uid":122}],101:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":24,"./_global":41,"./_library":60}],102:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":4,"./_an-object":8,"./_wks":127}],103:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":36}],104:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":29,"./_to-integer":114}],105:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":29,"./_is-regexp":53}],106:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":29,"./_export":34,"./_fails":36}],107:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":29,"./_string-repeat":108,"./_to-length":116}],108:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":29,"./_to-integer":114}],109:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":29,"./_export":34,"./_fails":36,"./_string-ws":110}],110:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],111:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":19,"./_ctx":26,"./_dom-create":31,"./_global":41,"./_html":44,"./_invoke":47}],112:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":114}],113:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":114,"./_to-length":116}],114:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],115:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":29,"./_iobject":48}],116:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":114}],117:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":29}],118:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":52}],119:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":7,"./_array-copy-within":9,"./_array-fill":10,"./_array-includes":12,"./_array-methods":13,"./_classof":18,"./_ctx":26,"./_descriptors":30,"./_export":34,"./_fails":36,"./_global":41,"./_has":42,"./_hide":43,"./_is-array-iter":49,"./_is-object":52,"./_iter-detect":57,"./_iterators":59,"./_library":60,"./_object-create":71,"./_object-dp":72,"./_object-gopd":75,"./_object-gopn":77,"./_object-gpo":79,"./_property-desc":90,"./_redefine-all":91,"./_set-species":98,"./_species-constructor":102,"./_to-absolute-index":112,"./_to-index":113,"./_to-integer":114,"./_to-length":116,"./_to-object":117,"./_to-primitive":118,"./_typed":121,"./_typed-buffer":120,"./_uid":122,"./_wks":127,"./core.get-iterator-method":128,"./es6.array.iterator":140}],120:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":7,"./_array-fill":10,"./_descriptors":30,"./_fails":36,"./_global":41,"./_hide":43,"./_library":60,"./_object-dp":72,"./_object-gopn":77,"./_redefine-all":91,"./_set-to-string-tag":99,"./_to-index":113,"./_to-integer":114,"./_to-length":116,"./_typed":121}],121:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":41,"./_hide":43,"./_uid":122}],122:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],123:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":41}],124:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":52}],125:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":24,"./_global":41,"./_library":60,"./_object-dp":72,"./_wks-ext":126}],126:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":127}],127:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":41,"./_shared":101,"./_uid":122}],128:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":18,"./_core":24,"./_iterators":59,"./_wks":127}],129:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":34,"./_replacer":93}],130:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":6,"./_array-copy-within":9,"./_export":34}],131:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":103}],132:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":6,"./_array-fill":10,"./_export":34}],133:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":103}],134:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":6,"./_array-methods":13,"./_export":34}],135:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":6,"./_array-methods":13,"./_export":34}],136:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":103}],137:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":25,"./_ctx":26,"./_export":34,"./_is-array-iter":49,"./_iter-call":54,"./_iter-detect":57,"./_to-length":116,"./_to-object":117,"./core.get-iterator-method":128}],138:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":12,"./_export":34,"./_strict-method":103}],139:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":34,"./_is-array":50}],140:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":6,"./_iter-define":56,"./_iter-step":58,"./_iterators":59,"./_to-iobject":115}],141:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":34,"./_iobject":48,"./_strict-method":103,"./_to-iobject":115}],142:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":34,"./_strict-method":103,"./_to-integer":114,"./_to-iobject":115,"./_to-length":116}],143:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":103}],144:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":25,"./_export":34,"./_fails":36}],145:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":14,"./_export":34,"./_strict-method":103}],146:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":14,"./_export":34,"./_strict-method":103}],147:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":19,"./_export":34,"./_fails":36,"./_html":44,"./_to-absolute-index":112,"./_to-length":116}],148:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":13,"./_export":34,"./_strict-method":103}],149:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":4,"./_export":34,"./_fails":36,"./_strict-method":103,"./_to-object":117}],150:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":98}],151:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":34}],152:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":27,"./_export":34}],153:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":34,"./_fails":36,"./_to-object":117,"./_to-primitive":118}],154:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":28,"./_hide":43,"./_wks":127}],155:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":92}],156:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":17,"./_export":34}],157:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":52,"./_object-dp":72,"./_object-gpo":79,"./_wks":127}],158:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":30,"./_object-dp":72}],159:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":23,"./_collection-strong":20,"./_validate-collection":124}],160:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":34,"./_math-log1p":63}],161:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":34}],162:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":34}],163:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":34,"./_math-sign":65}],164:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":34}],165:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":34}],166:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":34,"./_math-expm1":61}],167:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":34,"./_math-fround":62}],168:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":34}],169:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":34,"./_fails":36}],170:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":34}],171:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":34,"./_math-log1p":63}],172:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":34}],173:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":34,"./_math-sign":65}],174:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":34,"./_fails":36,"./_math-expm1":61}],175:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":34,"./_math-expm1":61}],176:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":34}],177:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":19,"./_descriptors":30,"./_fails":36,"./_global":41,"./_has":42,"./_inherit-if-required":46,"./_object-create":71,"./_object-dp":72,"./_object-gopd":75,"./_object-gopn":77,"./_redefine":92,"./_string-trim":109,"./_to-primitive":118}],178:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":34}],179:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":34,"./_global":41}],180:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":34,"./_is-integer":51}],181:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":34}],182:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":34,"./_is-integer":51}],183:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":34}],184:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":34}],185:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":34,"./_parse-float":86}],186:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":34,"./_parse-int":87}],187:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":5,"./_export":34,"./_fails":36,"./_string-repeat":108,"./_to-integer":114}],188:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":5,"./_export":34,"./_fails":36}],189:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":34,"./_object-assign":70}],190:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":34,"./_object-create":71}],191:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":30,"./_export":34,"./_object-dps":73}],192:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":30,"./_export":34,"./_object-dp":72}],193:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":52,"./_meta":66,"./_object-sap":83}],194:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":75,"./_object-sap":83,"./_to-iobject":115}],195:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":76,"./_object-sap":83}],196:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":79,"./_object-sap":83,"./_to-object":117}],197:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":52,"./_object-sap":83}],198:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":52,"./_object-sap":83}],199:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":52,"./_object-sap":83}],200:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":34,"./_same-value":94}],201:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":81,"./_object-sap":83,"./_to-object":117}],202:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":52,"./_meta":66,"./_object-sap":83}],203:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":52,"./_meta":66,"./_object-sap":83}],204:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":34,"./_set-proto":97}],205:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":18,"./_redefine":92,"./_wks":127}],206:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":34,"./_parse-float":86}],207:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":34,"./_parse-int":87}],208:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":4,"./_an-instance":7,"./_classof":18,"./_core":24,"./_ctx":26,"./_export":34,"./_for-of":40,"./_global":41,"./_is-object":52,"./_iter-detect":57,"./_library":60,"./_microtask":68,"./_new-promise-capability":69,"./_perform":88,"./_promise-resolve":89,"./_redefine-all":91,"./_set-species":98,"./_set-to-string-tag":99,"./_species-constructor":102,"./_task":111,"./_user-agent":123,"./_wks":127}],209:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":4,"./_an-object":8,"./_export":34,"./_fails":36,"./_global":41}],210:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":4,"./_an-object":8,"./_bind":17,"./_export":34,"./_fails":36,"./_global":41,"./_is-object":52,"./_object-create":71}],211:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":8,"./_export":34,"./_fails":36,"./_object-dp":72,"./_to-primitive":118}],212:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":8,"./_export":34,"./_object-gopd":75}],213:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":8,"./_export":34,"./_iter-create":55}],214:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":8,"./_export":34,"./_object-gopd":75}],215:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":8,"./_export":34,"./_object-gpo":79}],216:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":8,"./_export":34,"./_has":42,"./_is-object":52,"./_object-gopd":75,"./_object-gpo":79}],217:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":34}],218:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":8,"./_export":34}],219:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":34,"./_own-keys":85}],220:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":8,"./_export":34}],221:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":34,"./_set-proto":97}],222:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":8,"./_export":34,"./_has":42,"./_is-object":52,"./_object-dp":72,"./_object-gopd":75,"./_object-gpo":79,"./_property-desc":90}],223:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":30,"./_fails":36,"./_flags":38,"./_global":41,"./_inherit-if-required":46,"./_is-regexp":53,"./_object-dp":72,"./_object-gopn":77,"./_redefine":92,"./_set-species":98,"./_wks":127}],224:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":30,"./_flags":38,"./_object-dp":72}],225:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":37}],226:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":37}],227:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":37}],228:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":37,"./_is-regexp":53}],229:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":8,"./_descriptors":30,"./_fails":36,"./_flags":38,"./_redefine":92,"./es6.regexp.flags":224}],230:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":23,"./_collection-strong":20,"./_validate-collection":124}],231:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":106}],232:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":106}],233:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":106}],234:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":106}],235:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":34,"./_string-at":104}],236:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":34,"./_fails-is-regexp":35,"./_string-context":105,"./_to-length":116}],237:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":106}],238:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":106}],239:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":106}],240:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":34,"./_to-absolute-index":112}],241:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":34,"./_fails-is-regexp":35,"./_string-context":105}],242:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":106}],243:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":56,"./_string-at":104}],244:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":106}],245:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":34,"./_to-iobject":115,"./_to-length":116}],246:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":34,"./_string-repeat":108}],247:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":106}],248:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":34,"./_fails-is-regexp":35,"./_string-context":105,"./_to-length":116}],249:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":106}],250:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":106}],251:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":106}],252:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":109}],253:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":8,"./_descriptors":30,"./_enum-keys":33,"./_export":34,"./_fails":36,"./_global":41,"./_has":42,"./_hide":43,"./_is-array":50,"./_is-object":52,"./_library":60,"./_meta":66,"./_object-create":71,"./_object-dp":72,"./_object-gopd":75,"./_object-gopn":77,"./_object-gopn-ext":76,"./_object-gops":78,"./_object-keys":81,"./_object-pie":82,"./_property-desc":90,"./_redefine":92,"./_set-to-string-tag":99,"./_shared":101,"./_to-iobject":115,"./_to-primitive":118,"./_uid":122,"./_wks":127,"./_wks-define":125,"./_wks-ext":126}],254:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":8,"./_export":34,"./_fails":36,"./_global":41,"./_is-object":52,"./_set-species":98,"./_species-constructor":102,"./_to-absolute-index":112,"./_to-length":116,"./_typed":121,"./_typed-buffer":120}],255:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":34,"./_typed":121,"./_typed-buffer":120}],256:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],257:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],258:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],259:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],260:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],261:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],262:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],263:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":119}],264:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":119}],265:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":13,"./_collection":23,"./_collection-weak":22,"./_fails":36,"./_is-object":52,"./_meta":66,"./_object-assign":70,"./_redefine":92,"./_validate-collection":124}],266:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":23,"./_collection-weak":22,"./_validate-collection":124}],267:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":4,"./_add-to-unscopables":6,"./_array-species-create":16,"./_export":34,"./_flatten-into-array":39,"./_to-length":116,"./_to-object":117}],268:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":6,"./_array-species-create":16,"./_export":34,"./_flatten-into-array":39,"./_to-integer":114,"./_to-length":116,"./_to-object":117}],269:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":6,"./_array-includes":12,"./_export":34}],270:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":19,"./_export":34,"./_global":41,"./_microtask":68}],271:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":19,"./_export":34}],272:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":34,"./_global":41}],273:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":95}],274:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":96}],275:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":21,"./_export":34}],276:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":34}],277:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":34}],278:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":34}],279:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":34,"./_math-fround":62,"./_math-scale":64}],280:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":34}],281:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":34}],282:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":34}],283:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":34}],284:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":34}],285:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":34,"./_math-scale":64}],286:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":34}],287:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":34}],288:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":4,"./_descriptors":30,"./_export":34,"./_object-dp":72,"./_object-forced-pam":74,"./_to-object":117}],289:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":4,"./_descriptors":30,"./_export":34,"./_object-dp":72,"./_object-forced-pam":74,"./_to-object":117}],290:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":34,"./_object-to-array":84}],291:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":25,"./_export":34,"./_object-gopd":75,"./_own-keys":85,"./_to-iobject":115}],292:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":30,"./_export":34,"./_object-forced-pam":74,"./_object-gopd":75,"./_object-gpo":79,"./_to-object":117,"./_to-primitive":118}],293:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":30,"./_export":34,"./_object-forced-pam":74,"./_object-gopd":75,"./_object-gpo":79,"./_to-object":117,"./_to-primitive":118}],294:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":34,"./_object-to-array":84}],295:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":4,"./_an-instance":7,"./_an-object":8,"./_core":24,"./_export":34,"./_for-of":40,"./_global":41,"./_hide":43,"./_microtask":68,"./_redefine-all":91,"./_set-species":98,"./_wks":127}],296:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":24,"./_export":34,"./_global":41,"./_promise-resolve":89,"./_species-constructor":102}],297:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":34,"./_new-promise-capability":69,"./_perform":88}],298:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":8,"./_metadata":67}],299:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":8,"./_metadata":67}],300:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":8,"./_array-from-iterable":11,"./_metadata":67,"./_object-gpo":79,"./es6.set":230}],301:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":67,"./_object-gpo":79}],302:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":8,"./_metadata":67}],303:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":67}],304:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":67,"./_object-gpo":79}],305:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":8,"./_metadata":67}],306:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":4,"./_an-object":8,"./_metadata":67}],307:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":95}],308:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":96}],309:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":21,"./_export":34}],310:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":34,"./_string-at":104}],311:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":29,"./_export":34,"./_flags":38,"./_is-regexp":53,"./_iter-create":55,"./_to-length":116}],312:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":34,"./_string-pad":107,"./_user-agent":123}],313:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":34,"./_string-pad":107,"./_user-agent":123}],314:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":109}],315:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":109}],316:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":125}],317:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":125}],318:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":34,"./_global":41}],319:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":95}],320:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":96}],321:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":95}],322:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":96}],323:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":41,"./_hide":43,"./_iterators":59,"./_object-keys":81,"./_redefine":92,"./_wks":127,"./es6.array.iterator":140}],324:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":34,"./_task":111}],325:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":34,"./_global":41,"./_user-agent":123}],326:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":24,"./modules/es6.array.copy-within":130,"./modules/es6.array.every":131,"./modules/es6.array.fill":132,"./modules/es6.array.filter":133,"./modules/es6.array.find":135,"./modules/es6.array.find-index":134,"./modules/es6.array.for-each":136,"./modules/es6.array.from":137,"./modules/es6.array.index-of":138,"./modules/es6.array.is-array":139,"./modules/es6.array.iterator":140,"./modules/es6.array.join":141,"./modules/es6.array.last-index-of":142,"./modules/es6.array.map":143,"./modules/es6.array.of":144,"./modules/es6.array.reduce":146,"./modules/es6.array.reduce-right":145,"./modules/es6.array.slice":147,"./modules/es6.array.some":148,"./modules/es6.array.sort":149,"./modules/es6.array.species":150,"./modules/es6.date.now":151,"./modules/es6.date.to-iso-string":152,"./modules/es6.date.to-json":153,"./modules/es6.date.to-primitive":154,"./modules/es6.date.to-string":155,"./modules/es6.function.bind":156,"./modules/es6.function.has-instance":157,"./modules/es6.function.name":158,"./modules/es6.map":159,"./modules/es6.math.acosh":160,"./modules/es6.math.asinh":161,"./modules/es6.math.atanh":162,"./modules/es6.math.cbrt":163,"./modules/es6.math.clz32":164,"./modules/es6.math.cosh":165,"./modules/es6.math.expm1":166,"./modules/es6.math.fround":167,"./modules/es6.math.hypot":168,"./modules/es6.math.imul":169,"./modules/es6.math.log10":170,"./modules/es6.math.log1p":171,"./modules/es6.math.log2":172,"./modules/es6.math.sign":173,"./modules/es6.math.sinh":174,"./modules/es6.math.tanh":175,"./modules/es6.math.trunc":176,"./modules/es6.number.constructor":177,"./modules/es6.number.epsilon":178,"./modules/es6.number.is-finite":179,"./modules/es6.number.is-integer":180,"./modules/es6.number.is-nan":181,"./modules/es6.number.is-safe-integer":182,"./modules/es6.number.max-safe-integer":183,"./modules/es6.number.min-safe-integer":184,"./modules/es6.number.parse-float":185,"./modules/es6.number.parse-int":186,"./modules/es6.number.to-fixed":187,"./modules/es6.number.to-precision":188,"./modules/es6.object.assign":189,"./modules/es6.object.create":190,"./modules/es6.object.define-properties":191,"./modules/es6.object.define-property":192,"./modules/es6.object.freeze":193,"./modules/es6.object.get-own-property-descriptor":194,"./modules/es6.object.get-own-property-names":195,"./modules/es6.object.get-prototype-of":196,"./modules/es6.object.is":200,"./modules/es6.object.is-extensible":197,"./modules/es6.object.is-frozen":198,"./modules/es6.object.is-sealed":199,"./modules/es6.object.keys":201,"./modules/es6.object.prevent-extensions":202,"./modules/es6.object.seal":203,"./modules/es6.object.set-prototype-of":204,"./modules/es6.object.to-string":205,"./modules/es6.parse-float":206,"./modules/es6.parse-int":207,"./modules/es6.promise":208,"./modules/es6.reflect.apply":209,"./modules/es6.reflect.construct":210,"./modules/es6.reflect.define-property":211,"./modules/es6.reflect.delete-property":212,"./modules/es6.reflect.enumerate":213,"./modules/es6.reflect.get":216,"./modules/es6.reflect.get-own-property-descriptor":214,"./modules/es6.reflect.get-prototype-of":215,"./modules/es6.reflect.has":217,"./modules/es6.reflect.is-extensible":218,"./modules/es6.reflect.own-keys":219,"./modules/es6.reflect.prevent-extensions":220,"./modules/es6.reflect.set":222,"./modules/es6.reflect.set-prototype-of":221,"./modules/es6.regexp.constructor":223,"./modules/es6.regexp.flags":224,"./modules/es6.regexp.match":225,"./modules/es6.regexp.replace":226,"./modules/es6.regexp.search":227,"./modules/es6.regexp.split":228,"./modules/es6.regexp.to-string":229,"./modules/es6.set":230,"./modules/es6.string.anchor":231,"./modules/es6.string.big":232,"./modules/es6.string.blink":233,"./modules/es6.string.bold":234,"./modules/es6.string.code-point-at":235,"./modules/es6.string.ends-with":236,"./modules/es6.string.fixed":237,"./modules/es6.string.fontcolor":238,"./modules/es6.string.fontsize":239,"./modules/es6.string.from-code-point":240,"./modules/es6.string.includes":241,"./modules/es6.string.italics":242,"./modules/es6.string.iterator":243,"./modules/es6.string.link":244,"./modules/es6.string.raw":245,"./modules/es6.string.repeat":246,"./modules/es6.string.small":247,"./modules/es6.string.starts-with":248,"./modules/es6.string.strike":249,"./modules/es6.string.sub":250,"./modules/es6.string.sup":251,"./modules/es6.string.trim":252,"./modules/es6.symbol":253,"./modules/es6.typed.array-buffer":254,"./modules/es6.typed.data-view":255,"./modules/es6.typed.float32-array":256,"./modules/es6.typed.float64-array":257,"./modules/es6.typed.int16-array":258,"./modules/es6.typed.int32-array":259,"./modules/es6.typed.int8-array":260,"./modules/es6.typed.uint16-array":261,"./modules/es6.typed.uint32-array":262,"./modules/es6.typed.uint8-array":263,"./modules/es6.typed.uint8-clamped-array":264,"./modules/es6.weak-map":265,"./modules/es6.weak-set":266,"./modules/es7.array.flat-map":267,"./modules/es7.array.flatten":268,"./modules/es7.array.includes":269,"./modules/es7.asap":270,"./modules/es7.error.is-error":271,"./modules/es7.global":272,"./modules/es7.map.from":273,"./modules/es7.map.of":274,"./modules/es7.map.to-json":275,"./modules/es7.math.clamp":276,"./modules/es7.math.deg-per-rad":277,"./modules/es7.math.degrees":278,"./modules/es7.math.fscale":279,"./modules/es7.math.iaddh":280,"./modules/es7.math.imulh":281,"./modules/es7.math.isubh":282,"./modules/es7.math.rad-per-deg":283,"./modules/es7.math.radians":284,"./modules/es7.math.scale":285,"./modules/es7.math.signbit":286,"./modules/es7.math.umulh":287,"./modules/es7.object.define-getter":288,"./modules/es7.object.define-setter":289,"./modules/es7.object.entries":290,"./modules/es7.object.get-own-property-descriptors":291,"./modules/es7.object.lookup-getter":292,"./modules/es7.object.lookup-setter":293,"./modules/es7.object.values":294,"./modules/es7.observable":295,"./modules/es7.promise.finally":296,"./modules/es7.promise.try":297,"./modules/es7.reflect.define-metadata":298,"./modules/es7.reflect.delete-metadata":299,"./modules/es7.reflect.get-metadata":301,"./modules/es7.reflect.get-metadata-keys":300,"./modules/es7.reflect.get-own-metadata":303,"./modules/es7.reflect.get-own-metadata-keys":302,"./modules/es7.reflect.has-metadata":304,"./modules/es7.reflect.has-own-metadata":305,"./modules/es7.reflect.metadata":306,"./modules/es7.set.from":307,"./modules/es7.set.of":308,"./modules/es7.set.to-json":309,"./modules/es7.string.at":310,"./modules/es7.string.match-all":311,"./modules/es7.string.pad-end":312,"./modules/es7.string.pad-start":313,"./modules/es7.string.trim-left":314,"./modules/es7.string.trim-right":315,"./modules/es7.symbol.async-iterator":316,"./modules/es7.symbol.observable":317,"./modules/es7.system.global":318,"./modules/es7.weak-map.from":319,"./modules/es7.weak-map.of":320,"./modules/es7.weak-set.from":321,"./modules/es7.weak-set.of":322,"./modules/web.dom.iterable":323,"./modules/web.immediate":324,"./modules/web.timers":325}],327:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],328:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const NotatrixError = require('./errors').NotatrixError;

/**
 * convert a string to subscripts (for ele labels)
 *
 * @param {String} str string to be subscripted
 * @return {String}
 */
function toSubscript(str) {
  const subscripts = { 0:'', 1:'', 2:'', 3:'', 4:'', 5:'',
    6:'', 7:'', 8:'', 9:'', '-':'', '(':'', ')':'' };

  return str.split('').map((char) => {
    return (subscripts[char] || char);
  }).join('');
}

/**
 * strip whitespace from a string
 *
 * @param {String} str
 * @return {String}
 */
function sanitize(str) {
  return (str || '').replace(/\s/g, '');
}

/**
 * take a string possibly given in enhanced notation and extract the head
 *   and deprel
 *
 * e.g. `2:ccomp|3:nsubj` => `[
 *   { token: 2, deprel: 'ccomp' },
 *   { token: 3, deprel: 'nsubj' } ]`
 *
 * @param {String} str
 * @return {Array} [[Object]]
 */
function parseEnhancedString(str) {

  // strip whitespace in input
  str = sanitize(str);

  // keep our heads here
  let heads = [];

  // iterate over "|"-delimited chunks
  _.each(str.split('|'), head => {
    head = head.split(':');

    // ignore it if we don't parse a head
    if (head[0])
      heads.push({
        token: head[0],
        deprel: head[1]
      });
  });
  return heads;
}

/**
 * automatically add PUNCT pos tags to strings that consist of only punctuation
 *
 * NOTE: only has an effect if sentence-level options help.upostag|help.xpostag
 *   are set to true (default: true)
 *
 * @param {Analysis} ana the analysis to evaluate for
 * @param {String} string
 * @return {undefined}
 */
function evaluatePunctPos(ana, string) {
  if (puncts.test(string)) {
    if (ana.sentence.options.help.upostag && !ana.upostag)
      ana.upostag = 'PUNCT';

    if (ana.sentence.options.help.xpostag && !ana.xpostag)
      ana.xpostag = 'PUNCT';
  }
}

/**
 * helper function for Analysis::cg3 [get] ... actually does the work of
 *   deciding how we want to display the information contained in an analysis
 *
 * @param {Analysis} ana
 * @param {Number} tabs current indent level
 * @return {String}
 */
function cg3FormatOutput(analysis, tabs) {

  let indent = new Array(tabs).fill('\t').join('');
  let tags = analysis.xpostag ? ` ${analysis.xpostag.replace(/;/g, ' ')}` : '';
  let misc = analysis.misc ? ` ${analysis.misc.replace(/;/g, ' ')}` : '';
  let deprel = analysis.deprel ? ` @${analysis.deprel}` : '';
  let id = analysis.id ? ` #${analysis.id}->` : '';
  let head = (id && analysis.head) ? `${analysis.head}` : ``;
  let dependency = analysis.sentence.options.showEmptyDependencies || analysis.head
    ? `${id}${head}`
    : ``;

  return `${indent}"${analysis.lemma}"${tags}${misc}${deprel}${dependency}`;
}


// placeholder for CoNLL-U export in `undefined` fields
const fallback = '_';
// setteable fields
const fields = [
  // NB: 'id' is not kept here
  'form',
  'lemma',
  'upostag',
  'xpostag',
  'feats',
  'head',
  'deprel',
  'deps',
  'misc'
];
// supported punctuation characters
const puncts = /[.,!?]/;

/**
 * this class contains all the information associated with an analysis, including
 *   a value for each of form, lemma, upostag, xpostag, feats, head, deprel,
 *   deps, & misc ... also keeps an array of subTokens and an index
 */
class Analysis {
  constructor(token, params) {

    // require token param
    if (!token)
      throw new NotatrixError('missing required arg: Token');

    // used to make sure we only add the head/deps strings on first pass, since
    //   we'll eventually call attach() whenever we're constructing like this
    this.initializing = true;

    // pointers to parents
    this.token = token;
    this.sentence = token.sentence;

    // internal arrays of Analyses
    this._heads = [];
    this._deps = [];

    // internal index (see Sentence::index and Token::index), don't change this!
    this.id = null;

    // array of Tokens
    this.subTokens = [];

    // iterate over passed params
    _.each(params, (value, key) => {
      if (value === undefined || fields.indexOf(key) === -1) {
        // delete invalid parameters
        delete params[key];
      } else {
        // save valid ones (using our setters defined below)
        this[key] = value;
      }
    });

    // save updated params (mostly for debugging purposes)
    this.params = params || {};

    // safe to unset this now
    this.initializing = false;

  }

  /**
   * @return {Number} total number of subTokens for this analysis
   */
  get length() {
    return this.subTokens.length;
  }

  // manipulate subTokens array

  /**
   * get subToken at the given index or null
   *
   * @param {Number} index
   * @return {(null|Token)}
   */
  getSubToken(index) {
    return this.subTokens[index] || null;
  }

  /**
   * insert a subToken BEFORE the given index
   *
   * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted
   *   to fit the bounds. this means that you can call this with `index=-Infinity`
   *   to push to the front of the subTokens array or with `index=Infinity` to push
   *   to the end
   *
   * @param {Number} index
   * @param {Token} token
   * @return {Analysis}
   *
   * @throws {NotatrixError} if given invalid index or analysis (see below)
   */
  insertSubTokenAt(index, token) {

    // enforce only indices that can be cast as Numbers
    index = parseFloat(index); // catch Infinity
    if (isNaN(index))
      throw new NotatrixError('unable to insert subToken: unable to cast index to int');

    // enforce token is a Token
    if (!token)
      throw new NotatrixError('unable to insert subToken: no subToken provided');

    // enforce token is a Token
    if (token.__proto__ !== this.token.__proto__) // hacky, but don't have access to Token class
      throw new NotatrixError('unable to insert subToken: not instance of Token');

    // enforce not trying to add a superToken as a subToken
    if (token.isSuperToken)
      throw new NotatrixError('unable to insert subToken: token has subTokens');

    // enforce not trying to add a subToken of some other token
    if (token.isSubToken)
      throw new NotatrixError('unable to insert subToken: token is already a subToken')

    // enforce not trying to add a subToken to a subToken
    if (this.isSubToken)
      throw new NotatrixError('unable to insert subToken: this is already a subToken');

    // bounds checking
    index = index < 0 ? 0
      : index > this.length ? this.length
      : parseInt(index);

    // set the superToken pointer on the token
    token.superToken = this;

    // array insertion
    this.subTokens = this.subTokens.slice(0, index)
      .concat(token)
      .concat(this.subTokens.slice(index));

    // chaining
    return this;
  }

  /**
   * remove a subToken at the given index
   *
   * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be
   *   adjusted to fit the bounds. this means that you can call this with
   *   `index=-Infinity` to remove the first element of the subTokens array or
   *   with `index=Infinity` to remove the last
   *
   * @param {Number} index
   * @return {(null|Token)}
   *
   * @throws {NotatrixError} if given invalid index
   */
  removeSubTokenAt(index) {

    // can't remove if we have an empty array
    if (!this.length)
      return null;

    index = parseFloat(index); // catch Infinity
    if (isNaN(index))
      throw new NotatrixError('unable to remove subToken: unable to cast index to int');

    // bounds checking
    index = index < 0 ? 0
      : index > this.length - 1 ? this.length - 1
      : parseInt(index);

    // unlink heads and deps from the token to be removed
    this.sentence.forEach(token => {
      token.analysis
        .eachHead(head => {
          if (head === this[index])
            token.analysis.removeHead(head);
        })
        .eachDep(dep => {
          if (dep === this[index])
            token.analysis.removeDep(dep);
        });
    });

    // remove the superToken pointer from the removed token
    this.subTokens[index].superToken = null;

    // array splicing, return spliced element
    return this.subTokens.splice(index, 1)[0];
  }

  /**
   * move a subToken from sourceIndex to targetIndex
   *
   * NOTE: if either index is out of bounds (<0 or >length - 1), then it will
   *   be adjusted to fit the bounds. this means that you can call this with
   *   `sourceIndex=-Infinity` to select the first element of the subTokens array
   *   or with `sourceIndex=Infinity` to select the last
   *
   * @param {Number} sourceIndex
   * @param {Number} targetIndex
   * @return {Analysis}
   *
   * @throws {NotatrixError} if given invalid sourceIndex or targetIndex
   */
  moveSubTokenAt(sourceIndex, targetIndex) {

    sourceIndex = parseFloat(sourceIndex);
    targetIndex = parseFloat(targetIndex);
    if (isNaN(sourceIndex) || isNaN(targetIndex))
      throw new NotatrixError('unable to move subToken: unable to cast indices to ints');

    // bounds checking
    sourceIndex = sourceIndex < 0 ? 0
      : sourceIndex > this.length - 1 ? this.length - 1
      : parseInt(sourceIndex);
    targetIndex = targetIndex < 0 ? 0
      : targetIndex > this.length - 1 ? this.length - 1
      : parseInt(targetIndex);

    if (sourceIndex === targetIndex) {
      // do nothing
    } else {

      // array splice and insert
      let subToken = this.subTokens.splice(sourceIndex, 1);
      this.subTokens = this.subTokens.slice(0, targetIndex)
        .concat(subToken)
        .concat(this.subTokens.slice(targetIndex));

    }

    // chaining
    return this;
  }

  /**
   * push a subToken to the end of the subTokens array ... sugar for
   *   Analysis::insertSubTokenAt(Infinity, analysis)
   *
   * @param {Token} token
   * @return {Analysis}
   */
  pushSubToken(token) {
    return this.insertSubTokenAt(Infinity, token);
  }

  /**
   * pop a subToken from the end of the subTokens array ... sugar for
   *   Analysis::removeSubTokenAt(Infinity)
   *
   * @return {(null|Analysis)}
   */
  popSubToken() {
    return this.removeSubTokenAt(Infinity);
  }

  // external formats

  /**
   * get a serial version of the internal analysis representation
   *
   * @return {Object}
   */
  get nx() {

    // serialize "values" (getter/setter version of fields)
    let values = {};
    _.each(fields, field => {
      values[field] = this[field];
    });

    // serialize other data
    return {
      id: this.id,
      num: this.num,
      params: this.params,
      values: values,
      subTokens: this.subTokens.map(subToken => {
        return subToken.nx;
      })
    };

  }

  /**
   * deserialize an internal representation
   *
   * @param {(String|Object)} nx JSON string or object
   * @return {undefined}
   */
  set nx(nx) {

    // parse the JSON if it's a string
    nx = (typeof nx === 'string')
      ? JSON.parse(nx)
      : nx;

    this.params = nx.params;
    _.each(nx.values, (value, key) => {
      this[key] = value;
    });

  }

  /**
   * static method allowing us to construct a new Analysis directly from an
   *   Nx string and bind it to a token
   *
   * @param {Token} token
   * @param {String} serial
   * @return {Analysis}
   */
  static fromNx(token, serial) {
    let analysis = new Analysis(token);
    analysis.nx = serial;
    return analysis;
  }


  /**
   * get a plain-text formatted string of the analysis
   *
   * @return {String}
   */
  get text() {

    // first check if we have a form
    if (this.form && this.form !== fallback)
      return this.form;

    // fall back to using lemma
    if (this.lemma && this.lemma !== fallback)
      return this.lemma;

    // if set, fall back to our fallback (defined above)
    if (this.sentence.fallbackOnText)
      return fallback;

    // otherwise just give an empty string
    return '';
  }

  /**
   * get a CoNLL-U formatted string representing the analysis
   *
   * @return {String}
   *
   * @throws {NotatrixError} if id has not been set
   */
  get conllu() {

    // reindex just in case since this is crucial
    this.sentence.index();

    // we can't output CoNLL-U for analyses that aren't indexed, since that
    //   means they're not in the current analysis
    if (this.id === null || this.id === undefined)
      throw new NotatrixError('analysis is not currently indexed');

    // return a tab-delimited string with the information contained in each field
    //   and the index out front
    return `${this.id}\t${
      _.map(fields, field => {

        // if we have no data for a field, use our fallback to maintain
        //   the correct matrix structure
        return this[field] || fallback;

      }).join('\t')
    }`;
  }

  /**
   * get a CG3 formatted string representing the analysis
   *
   * @return {String}
   */
  get cg3() {

    // reindex just in case since this is crucial
    this.sentence.index();

    // either output this analysis or its subTokens
    if (this.isSuperToken) {
      return this.subTokens.map((subToken, i) => {

        // recall subTokens get hanging indents
        return cg3FormatOutput(subToken.analysis, i + 1);

      }).join('\n');
    } else {

      // regular tokens get an index of 1
      return cg3FormatOutput(this, 1);

    }
  }

  /**
   * get an array of nodes relating to this analysis for export to an external
   *   graphing library (e.g. Cytoscape, D3)
   *
   * @return {Array}
   */
  get eles() {
    let eles = [];

    if (this.isCurrent) {

      if (this.isSuperToken) {

        eles.push({ // multiword label
          data: {
            id: `multiword-${this.id}`,
            num: this.num,
            clump: this.clump,
            name: `multiword`,
            label: `${this.form} ${toSubscript(this.id)}`,
            /*length: `${this.form.length > 3
              ? this.form.length * 0.7
              : this.form.length}em`*/
          },
          classes: 'multiword'
        }/*, {

        } */);

        _.each(this.subTokens, subToken => {
          eles = eles.concat(subToken.eles);
        });

      } else {

        eles.push({ // "number" node
          data: {
            id: `num-${this.id}`,
            num: this.num,
            clump: this.clump,
            name: 'number',
            label: this.id,
            pos: this.pos,
            parent: this.superToken ? `multiword-${this.superToken.id}` : undefined,
            analysis: this
          },
          classes: 'number'
        }, { // "form" node
          data: {
            id: `form-${this.id}`,
            num: this.num,
            clump: this.clump,
            name: `form`,
            attr: `form`,
            form: this.form,
            label: this.form,
            length: `${this.form.length > 3
              ? this.form.length * 0.7
              : this.form.length}em`,
            state: `normal`,
            parent: `num-${this.id}`,
            analysis: this
          },
          classes: `form${this.head == 0 ? ' root' : ''}`
        }, { // "pos" node
          data: {
            id: `pos-node-${this.id}`,
            num: this.num,
            clump: this.clump,
            name: `pos-node`,
            attr: `upostag`,
            label: this.pos || '',
            length: `${(this.pos || '').length * 0.7 + 1}em`,
            analysis: this
          },
          classes: 'pos'
        }, { // "pos" edge
          data: {
            id: `pos-edge-${this.id}`,
            num: this.num,
            clump: this.clump,
            name: `pos-edge`,
            source: `form-${this.id}`,
            target: `pos-node-${this.id}`
          },
          classes: 'pos'
        });

        this.eachHead((head, deprel) => {
          deprel = deprel || '';

          if (!head || !head.id) // ROOT
            return;

          eles.push({
            data: {
              id: `dep_${this.id}_${head.id}`,
              name: `dependency`,
              attr: `deprel`,
              source: `form-${this.id}`,
              sourceAnalysis: this,
              target: `form-${head.id}`,
              targetAnalysis: head,
              length: `${deprel.length / 3}em`,
              label: null, // NB overwrite this before use
              ctrl: null   // NB overwrite this before use
            },
            classes: null  // NB overwrite this before use
          });

        });
      }
    }

    return eles;
  }

  // array-field (heads & deps) manipulators

  /**
   * iterate over the `head`s for this analysis and apply a callback to each
   *
   * @param {Function} callback
   * @return {Analysis}
   */
  eachHead(callback) {
    _.each(this._heads, (head, i) => {
      callback(head.token, head.deprel, i);
    });

    // chaining
    return this;
  }

  /**
   * add a head on the given token with a dependency relation
   *
   * @param {Analysis} head pointer directly to the analysis
   * @param {String} deprel
   * @return {Analysis}
   */
  addHead(head, deprel) {
    if (!(head instanceof Analysis))
      throw new NotatrixError('can\'t add head: not Analysis instance');

    // first try to change an existing one (don't want duplicate heads)
    if (this.changeHead(head, deprel))
      return this;

    // get rid of "empty" value
    if (this._heads.length === 1 && this._heads[0].token === '_')
      this._heads = [];

    // otherwise push a new one
    this._heads.push({
      token: head,
      deprel: deprel
    });

    // if applicable, add to the head's deps field too
    if (this.sentence.options.help.head)
      head._deps.push({
        token: this,
        deprel: deprel
      });

    // chaining
    return this;
  }

  /**
   * remove a head from the given analysis if it exists
   *
   * @param {Analysis} head
   * @return {Analysis}
   */
  removeHead(head) {
    if (!(head instanceof Analysis))
      throw new NotatrixError('can\'t remove head: not Analysis instance');

    // remove from _heads
    let removing = -1;
    this.eachHead((token, deprel, i) => {
      if (token === head)
        removing = i;
    });
    if (removing > -1)
      this._heads.splice(removing, 1);

    // if applicable, also remove from head's _deps
    removing = -1
    if (this.sentence.options.help.head)
      head.eachDep((token, deprel, i) => {
        if (token === this)
          removing = i;
      });
    if (removing > -1)
      head._deps.splice(removing, 1);

    // chaining
    return this;
  }

  /**
   * change the dependency relation for a given head ... returns null if unable
   *   to make the change
   *
   * @param {Analysis} head
   * @param {String} deprel
   * @return {(Analysis|null)}
   */
  changeHead(head, deprel) {
    if (!(head instanceof Analysis))
      throw new NotatrixError('can\'t change head: not Analysis instance');

    // change for this head
    let done = false;
    this.eachHead((token, _deprel, i) => {
      if (token === head) {
        this._heads[i].deprel = deprel || _deprel;
        done = true;
      }
    });

    // if applicable, change for the head's dep too
    if (this.sentence.options.help.head)
      head.eachDep((token, _deprel, i) => {
        if (token === this)
          head._deps[i].deprel = deprel || _deprel;
      });

    return done ? this : null;
  }

  /**
   * iterate over the `deps`s for this analysis and apply a callback to each
   *
   * @param {Function} callback
   * @return {Analysis}
   */
  eachDep(callback) {
    _.each(this._deps, (dep, i) => {
      callback(dep.token, dep.deprel, i);
    });

    // chaining
    return this;
  }

  /**
   * add a dep on the given token with a dependency relation
   *
   * @param {Analysis} dep pointer directly to the analysis
   * @param {String} deprel
   * @return {Analysis}
   */
  addDep(dep, deprel) {
    if (!(dep instanceof Analysis))
      throw new NotatrixError('can\'t add dep: not Analysis instance');

    // first try to change an existing one (don't want duplicate deps)
    if (this.changeDep(dep, deprel))
      return this;

    // get rid of "empty" value
    if (this._deps.length === 1 && this._deps[0].token === '_')
      this._deps = [];

    // otherwise push a new one
    this._deps.push({
      token: dep,
      deprel: deprel
    });

    // if applicable, add to the dep's head field too
    if (this.sentence.options.help.deps)
      dep._heads.push({
        token: this,
        deprel: deprel
      });

    // chaining
    return this;
  }

  /**
   * remove a dep from the given analysis if it exists
   *
   * @param {Analysis} dep
   * @return {Analysis}
   */
  removeDep(dep) {
    if (!(dep instanceof Analysis))
      throw new NotatrixError('can\'t remove dep: not Analysis instance');

    // remove from _deps
    let removing = -1;
    this.eachDep((token, deprel, i) => {
      if (token === dep)
        removing = i;
    });
    if (removing > -1)
      this._deps.splice(removing, 1);

    // if applicable, also remove from dep's _heads
    removing = -1
    if (this.sentence.options.help.deps)
      dep.eachHead((token, deprel, i) => {
        if (token === this)
          removing = i;
      });
    if (removing > -1)
      dep._heads.splice(removing, 1);

    // chaining
    return this;
  }

  /**
   * change the dependency relation for a given dep ... returns null if unable
   *   to make the change
   *
   * @param {Analysis} dep
   * @param {String} deprel
   * @return {(Analysis|null)}
   */
  changeDep(dep, deprel) {
    if (!(dep instanceof Analysis))
      throw new NotatrixError('can\'t change dep: not Analysis instance');

    // change for this dep
    let done = false;
    this.eachDep((token, _deprel, i) => {
      if (token === dep) {
        this._deps[i].deprel = deprel || _deprel;
        done = true;
      }
    });

    // if applicable, change for the dep's head too
    if (this.sentence.options.help.deps)
      dep.eachHead((token, _deprel, i) => {
        if (token === this)
          dep._heads[i].deprel = deprel || _deprel;
      });

    return done ? this : null;
  }

  // field getters and setters

  /**
   * get the `form` ... if none defined, `help.form` setting `= true` (default:
   *   `true`), and `lemma` is set, return `lemma` instead
   *
   * @return {(String|undefined)}
   */
  get form() {
    return this.sentence.options.help.form
      ? this._form || this._lemma
      : this._form;
  }

  /**
   * set the `form` ... if the form is just punctuation, possibly set the pos tags
   *   to `PUNCT` (see {@link evaluatePunctPos})
   *
   * @return {undefined}
   */
  set form(form) {
    form = sanitize(form);
    evaluatePunctPos(this, form);
    this._form = form;
  }

  /**
   * get the `lemma` ... if none defined, `help.lemma` setting `= true` (default:
   *   `true`), and `form` is set, return `form` instead
   *
   * @return {(String|undefined)}
   */
  get lemma() {
    return this.isSuperToken
      ? null
      : this.sentence.options.help.lemma
        ? this._lemma || this._form
        : this._lemma;
  }

  /**
   * set the `lemma` ... if the lemma is just punctuation, possibly set the pos tags
   *   to `PUNCT` (see {@link evaluatePunctPos})
   *
   * @return {undefined}
   */
  set lemma(lemma) {
    lemma = sanitize(lemma);
    evaluatePunctPos(this, lemma);
    this._lemma = lemma;
  }

  /**
   * get the `pos`, which is just `upostag || xpostag`
   *
   * @return {(String|undefined)}
   */
  get pos() {
    return this.upostag || this.xpostag;
  }

  /**
   * get the `upostag`
   *
   * @return {(String|undefined)}
   */
  get upostag() {
    return this.isSuperToken
      ? null
      : this._upostag;
  }

  /**
   * set the `upostag`
   *
   * @return {undefined}
   */
  set upostag(upostag) {
    this._upostag = sanitize(upostag);
  }

  /**
   * get the `xpostag`
   *
   * @return {(String|undefined)}
   */
  get xpostag() {
    return this.isSuperToken
      ? null
      : this._xpostag;
  }

  /**
   * set the `xpostag`
   *
   * @return {undefined}
   */
  set xpostag(xpostag) {
    this._xpostag = sanitize(xpostag);
  }

  /**
   * get the `feats`
   *
   * @return {(String|undefined)}
   */
  get feats() {
    return this.isSuperToken
      ? null
      : this._feats;
  }

  /**
   * set the `feats`
   *
   * @return {undefined}
   */
  set feats(feats) {
    this._feats = sanitize(feats);
  }

  /**
   * get the `head` ... if the `showEnhanced` setting `= true` (default: `true`)
   *   will return a `|`-delimited list of `index`:`deprel` pairs
   *
   * @return {(String)}
   */
  get head() {
    if (this.isSuperToken)
      return null;

    if (this.sentence.options.showEnhanced) {
      let heads = [];
      this.eachHead((token, deprel) => {
        if (token === this.sentence.getById(token.id) || !this.sentence.options.help.head) {
          heads.push(`${token.id || token}${deprel ? `:${deprel}` : ''}`);
        } else {
          heads.push(`${token}${deprel ? `:${deprel}` : ''}`);
        }
      });
      return heads.join('|') || null;

    } else {
      return this._heads.length
        ? this._heads[0].id || this._heads[0]
        : null;
    }
  }

  /**
   * set the `head` ... if the `Analysis` is `initializing`, just save a plain
   *   string, otherwise try to get the head by index (see {@link Sentence#getById})
   *
   * @return {undefined}
   */
  set head(heads) {

    heads = heads || [];
    if (typeof heads === 'string')
      heads = parseEnhancedString(heads);

    this._heads = heads.map(head => {
      return this.initializing
        ? {
            token: head.token,
            deprel: head.deprel
          }
        : {
            token: this.sentence.getById(head.token) || head.token,
            deprel: head.deprel
          };
    }).filter(head => {
      if (head.token !== fallback)
        return head;
    });
  }

  /**
   * get the `deprel`
   *
   * @return {(String|undefined)}
   */
  get deprel() {
    return this.isSuperToken
      ? null
      : this._deprel;
  }

  /**
   * set the `deprel`
   *
   * @return {undefined}
   */
  set deprel(deprel) {
    this._deprel = sanitize(deprel);
  }

  /**
   * get the `deps` returns a `|`-delimited list of `index`:`deprel` pairs
   *
   * @return {(String)}
   */
  get deps() {
    if (this.isSuperToken)
      return null;

    // don't worry about enhanced stuff for deps (always can be multiple)
    let deps = [];
    this.eachDep((token, deprel) => {
      if (token === this.sentence.getById(token.id) || !this.sentence.options.help.deps) {
        deps.push(`${token.id || token}${deprel ? `:${deprel}` : ''}`);
      } else {
        deps.push(`${token}${deprel ? `:${deprel}` : ''}`);
      }
    });
    return deps.join('|') || null;
  }

  /**
   * set the `deps` ... if the `Analysis` is `initializing`, just save a plain
   *   string, otherwise try to get the dep by index (see {@link Sentence#getById})
   *
   * @return {undefined}
   */
  set deps(deps) {

    deps = deps || [];
    if (typeof deps === 'string')
      deps = parseEnhancedString(deps);

    this._deps = deps.map(dep => {
      return this.initializing
        ? {
            token: dep.token,
            deprel: dep.deprel
          }
        : {
            token: this.sentence.getById(dep.token) || dep.token,
            deprel: dep.deprel
          };
    }).filter(dep => {
      if (dep.token !== fallback)
        return dep;
    });
  }

  /**
   * get the `misc`
   *
   * @return {(String|undefined)}
   */
  get misc() {
    // superTokens can have "misc" field
    return this._misc;
  }

  /**
   * set the `misc`
   *
   * @return {undefined}
   */
  set misc(misc) {
    this._misc = sanitize(misc);
  }

  // bool stuff

  /**
   * returns this analysis's superToken if it exists
   *
   * @return {(Token|null)}
   */
  get superToken() {
    return this.token.superToken;
  }

  /**
   * returns true iff this analysis is a subToken of some other token
   *
   * @return {Boolean}
   */
  get isSubToken() {
    return this.superToken !== null;
  }

  /**
   * returns true iff this analysis has subTokens
   *
   * @return {Boolean}
   */
  get isSuperToken() {
    return this.subTokens.length > 0;
  }

  /**
   * returns true iff this analysis is the current analysis
   *
   * @return {Boolean}
   */
  get isCurrent() {
    return this.token.analysis === this;
  }
}

/**
 * Proxy so that we can get subTokens using Array-like syntax
 *
 * NOTE: usage: `ana[8]` would return the analysis of the subToken at index 8
 * NOTE: if `name` is not a Number, fall through to normal object
 *
 * @return {Mixed}
 * @name Analysis#get
 */
Analysis.prototype.__proto__ = new Proxy(Analysis.prototype.__proto__, {

  // default getter, called any time we use Analysis.name or Analysis[name]
  get(target, name, receiver) {

    // Symbols can't be cast to floats, so check here to avoid errors
    if (typeof name === 'symbol')
      return this[name];

    // cast, catch Infinity
    let id = parseFloat(name);
    if (!isNaN(id)) {

      // if we got a number, return analysis of subToken at that index
      id = parseInt(id);
      let token = receiver.subTokens[id];
      return token ? token.analysis : null;

    } else {

      // fall through to normal getting
      return this[name];

    }
  }
});

// expose to application
module.exports = Analysis;

},{"./errors":329,"underscore":335}],329:[function(require,module,exports){
'use strict';

class NotatrixError extends Error {
  constructor(...args) {
    super(...args);
  }
}

class InvalidCG3Error extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}

class InvalidCoNLLUError extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}

class TransformationError extends NotatrixError {
  constructor(...args) {
    super(...args);
  }
}


module.exports = {

  NotatrixError: NotatrixError,
  InvalidCG3Error: InvalidCG3Error,
  InvalidCoNLLUError: InvalidCoNLLUError,
  TransformationError: TransformationError

};

},{}],330:[function(require,module,exports){
'use strict';

module.exports = {

  Error: require('./errors'),
  Sentence: require('./sentence'),
  Token: require('./token'),
  Analysis: require('./analysis')

};

},{"./analysis":328,"./errors":329,"./sentence":331,"./token":332}],331:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const NotatrixError       = require('./errors').NotatrixError;
const InvalidCG3Error     = require('./errors').InvalidCG3Error;
const InvalidCoNLLUError  = require('./errors').InvalidCoNLLUError

const Token = require('./token');
const Analysis = require('./analysis');

// define all the regex we use in this module here
const regex = {
  comment: /^\W*\#/,
  commentContent: /^\W*\#\W*(.*)/,
  superToken: /^\W*[0-9.]+\-[0-9.]+/,
  empty: /^\W*[0-9]+\.[0-9]+/,
  cg3TokenStart: /^"<(.|\\")*>"/,
  cg3TokenContent: /^;?\s+"(.|\\")*"/
}

const fallback = '_';

/**
 * this class contains all the information associated with a sentence, including
 *   an comments array, a tokens array, and a list of options/settings that apply
 *   to all subelements of this sentence
 */
class Sentence {

  constructor(paramsList, options) {

    // handle only receiving one arg better
    if (options === undefined && !Array.isArray(paramsList)) {
      options = paramsList;
      paramsList = undefined;
    }

    // save sentence-wide settings here
    this.options = _.defaults(options, {
      help: {
        form: true,
        lemma: true,
        upostag: true,
        xpostag: true,
        head: true,
        deps: true
      },
      prettyOutput: true,
      showEnhanced: true,
      showEmptyDependencies: true,
      catchInvalid: true,
      fallbackOnText: false
    });

    // the actual data
    this.comments = [];
    this.tokens = [];

    // try parsing a list of parameters
    if (paramsList)
      this.params = paramsList;

  }
  /**
   * @return {Number} total number of tokens/subTokens in this sentence
   */
  get length() {

    let acc = 0;
    this.forEach(token => {
      acc++;
    });
    return acc;
  }
  /**
   * loop through every token in the sentence and apply a callback
   *
   * @param {Function} callback function to be applied to every token
   * @return {Sentence}
   */
  forEach(callback) {

    let t = 0;
    for (let i=0; i<this.tokens.length; i++) {
      const token = this.tokens[i];
      callback(token, t);
      t++;
      for (let j=0; j<token.subTokens.length; j++) {
        callback(token.subTokens[j], t);
        t++;
      }
    }

    // chaining
    return this;
  }
  /**
   * loop through the tokens in the sentence and return the superToken and
   *   subToken indices
   * @param {Token} tok token to search for
   * @return {(Object|null)}
   */
  getIndices(tok) {

    let superTokenId = -1,
      subTokenId = -1,
      analysisId = 0,
      found = false,
      isSubToken = false;

    tok.sentence.forEach(token => {

      if (found)
        return;


      if (token.isSubToken) {
        subTokenId++;
        isSubToken = true;
      } else {
        superTokenId++;
        subTokenId = -1;
        isSubToken = false;
      }

      if (token === tok)
        found = true;

    });

    return superTokenId === -1
      ? null
      : {
          super: superTokenId,
          sub: isSubToken ? subTokenId : null
        };
  }


  /**
   * return the comment at the given index, or null
   *
   * @param {Number} index
   * @return {(String|null)}
   */
  getComment(index) {
    return this.comments[index] || null;
  }

  /**
   * return the token at the given index (note: this is regular token OR subToken),
   *   or null.  to choose by superToken index, use Sentence[index] syntax.  this
   *   function assumes only the current analysis is desired.
   *
   * @param {Number} index
   * @return {(Token|null)}
   */
  getToken(index) {
    let t = 0, token = null;
    this.forEach((tok, t) => {
      if (t === index)
        token = tok;
    });
    return token;
  }

  /**
   * return the current analysis of the token that matches a given index string
   *
   * NOTE: tokens outside the current analysis will have id=null and cannot be retrieved
   *   with this function
   *
   * @param {String} index
   * @return {(Analysis|null)}
   */
  getById(index) {
    for (let i=0; i<this.tokens.length; i++) {
      const token = this.tokens[i];
      if (token.analysis.id == index)
        return token.analysis;
      for (let j=0; j<token.subTokens.length; j++) {
        const subToken = token.subTokens[j];
        if (subToken.analysis.id == index)
          return subToken.analysis;
      }
    }
    return null;
  }

  // manipulate token array

  /**
   * insert a token AFTER the given token
   *
   * NOTE: if only passed 1 arg, it will insert a token constructed from
   *   the params { form: 'inserted' }
   *
   * @param {Token} atToken
   * @param {(Token|null)} newToken
   * @return {Sentence}
   *
   * @throws {NotatrixError} if given invalid token for first param
   */
  insertTokenBefore(atToken, newToken) {

    if (!(atToken instanceof Token))
      throw new NotatrixError('unable to insert token: not instance of Token');

    if (!(newToken instanceof Token))
      newToken = Token.fromParams(this, { form: 'inserted' });

    const indices = this.getIndices(atToken);
    if (indices === null)
      return null;

    return indices.sub === null
      ? this.insertTokenAt(indices.super, newToken)
      : this[indices.super].insertSubTokenAt(indices.sub, newToken);
  }

  /**
   * insert a token AFTER the given token
   *
   * NOTE: if only passed 1 arg, it will insert a token constructed from
   *   the params { form: 'inserted' }
   *
   * @param {Token} atToken
   * @param {(Token|null)} newToken
   * @return {Sentence}
   *
   * @throws {NotatrixError} if given invalid token for first param
   */
  insertTokenAfter(atToken, newToken) {

    if (!(atToken instanceof Token))
      throw new NotatrixError('unable to insert token: not instance of Token');

    if (!(newToken instanceof Token))
      newToken = Token.fromParams(this, { form: 'inserted' });

    const indices = this.getIndices(atToken);
    if (indices === null)
      return null;

    return indices.sub === null
      ? this.insertTokenAt(indices.super + 1, newToken)
      : this[indices.super].insertSubTokenAt(indices.sub + 1, newToken);
  }

  /**
   * insert an analysis BEFORE the given analysis
   *
   * NOTE: if only passed 1 arg, it will insert an analysis constructed from
   *   the params { form: 'inserted' }
   *
   * @param {Analysis} atAnalysis
   * @param {(Analysis|null)} newAnalysis
   * @return {Sentence}
   *
   * @throws {NotatrixError} if given invalid analysis for first param
   */
  insertAnalysisBefore(atAnalysis, newAnalysis) {

    if (!(atAnalysis instanceof Analysis))
      throw new NotatrixError('unable to insert analysis: not instance of Analysis');

    if (!(newAnalysis instanceof Analysis))
      newAnalysis = Token.fromParams(this, { form: 'inserted' }).analysis;

    const indices = this.getIndices(atAnalysis.token);
    if (indices === null)
      return null;

    const token = indices.sub === null
      ? this[indices.super].token
      : this[indices.super][indices.sub].token;

    let analysisId = -1;
    token.forEach((ana, i) => {
      if (ana === atAnalysis)
        analysisId = i;
    });

    if (analysisId > -1)
      return token.insertAnalysisAt(analysisId, newAnalysis);
  }

  /**
   * insert an analysis AFTER the given analysis
   *
   * NOTE: if only passed 1 arg, it will insert an analysis constructed from
   *   the params { form: 'inserted' }
   *
   * @param {Analysis} atAnalysis
   * @param {(Analysis|null)} newAnalysis
   * @return {Sentence}
   *
   * @throws {NotatrixError} if given invalid analysis for first param
   */
  insertAnalysisAfter(atAnalysis, newAnalysis) {

    if (!(atAnalysis instanceof Analysis))
      throw new NotatrixError('unable to insert analysis: not instance of Analysis');

    if (!(newAnalysis instanceof Analysis))
      newAnalysis = Token.fromParams(this, { form: 'inserted' }).analysis;

    const indices = this.getIndices(atAnalysis.token);
    if (indices === null)
      return null;

    const token = indices.sub === null
      ? this[indices.super].token
      : this[indices.super][indices.sub].token;

    let analysisId = -1;
    token.forEach((ana, i) => {
      if (ana === atAnalysis)
        analysisId = i;
    });

    if (analysisId > -1)
      return token.insertAnalysisAt(analysisId + 1, newAnalysis);
  }

  /**
   * insert a token BEFORE the given index
   *
   * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted
   *   to fit the bounds. this means that you can call this with `index=-Infinity`
   *   to push to the front of the tokens array or with `index=Infinity` to push
   *   to the end
   *
   * @param {Number} index
   * @param {Token} token
   * @return {Sentence}
   *
   * @throws {NotatrixError} if given invalid index or token
   */
  insertTokenAt(index, token) {
    index = parseFloat(index); // catch Infinity
    if (isNaN(index))
      throw new NotatrixError('unable to insert token: unable to cast index to int');

    if (!(token instanceof Token))
      throw new NotatrixError('unable to insert token: not instance of Token');

    // bounds checking
    index = index < 0 ? 0
      : index > this.length ? this.length
      : parseInt(index);

    // array insertion
    this.tokens = this.tokens.slice(0, index)
      .concat(token)
      .concat(this.tokens.slice(index));

    // chaining
    return this;
  }

  /**
   * remove a token at the given index
   *
   * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be
   *   adjusted to fit the bounds. this means that you can call this with
   *   `index=-Infinity` to remove the first element of the tokens array or
   *   with `index=Infinity` to remove the last
   *
   * @param {Number} index
   * @return {(Token|null)}
   *
   * @throws {NotatrixError} if given invalid index
   */
  removeTokenAt(index) {
    // can't remove if we have an empty sentence
    if (!this.tokens.length)
      return null;

    index = parseFloat(index); // catch Infinity
    if (isNaN(index))
      throw new NotatrixError('unable to remove token: unable to cast index to int');

    // bounds checking
    index = index < 0 ? 0
      : index > this.tokens.length - 1 ? this.tokens.length - 1
      : parseInt(index);

    // unlink heads and deps from the token to be removed
    this.forEach(token => {
      token.analysis
        .eachHead(head => {
          if (head === this[index])
            token.analysis.removeHead(head);
        })
        .eachDep(dep => {
          if (dep === this[index])
            token.analysis.removeDep(dep);
        });
    });

    // array splicing, return spliced element
    return this.tokens.splice(index, 1)[0];
  }

  /**
   * move a token from sourceIndex to targetIndex
   *
   * NOTE: if either index is out of bounds (<0 or >length - 1), then it will
   *   be adjusted to fit the bounds. this means that you can call this with
   *   `sourceIndex=-Infinity` to select the first element of the tokens array
   *   or with `sourceIndex=Infinity` to select the last
   *
   * @param {Number} sourceIndex
   * @param {Number} targetIndex
   * @return {Sentence}
   *
   * @throws {NotatrixError} if given invalid sourceIndex or targetIndex
   */
  moveTokenAt(sourceIndex, targetIndex) {
    sourceIndex = parseFloat(sourceIndex);
    targetIndex = parseFloat(targetIndex);
    if (isNaN(sourceIndex) || isNaN(targetIndex))
      throw new NotatrixError('unable to move token: unable to cast indices to ints');

    // bounds checking
    sourceIndex = sourceIndex < 0 ? 0
      : sourceIndex > this.tokens.length - 1 ? this.tokens.length - 1
      : parseInt(sourceIndex);
    targetIndex = targetIndex < 0 ? 0
      : targetIndex > this.tokens.length - 1 ? this.tokens.length - 1
      : parseInt(targetIndex);

    if (sourceIndex === targetIndex) {
      // do nothing
    } else {

      // array splice and insert
      let token = this.tokens.splice(sourceIndex, 1);
      this.tokens = this.tokens.slice(0, targetIndex)
        .concat(token)
        .concat(this.tokens.slice(targetIndex));

    }

    // chaining
    return this;
  }

  /**
   * push a token to the end of the tokens array ... sugar for
   *   Sentence::insertTokenAt(Infinity, token)
   *
   * @param {Token} token
   * @return {Sentence}
   */
  pushToken(token) {
    return this.insertTokenAt(Infinity, token);
  }

  /**
   * pop a token from the end of the tokens array ... sugar for
   *   Sentence::removeTokenAt(Infinity)
   *
   * @return {(Token|null)}
   */
  popToken() {
    return this.removeTokenAt(Infinity);
  }

  // external formats

  /**
   * returns the % (as a number in [0,1]) annotation of the sentence
   *
   * @return {Number}
   */
  get progress() {

    let done = 0,
      total = 0;

    this.forEach(token => {

      total += 2;

      if (!token.analysis)
        return;

      if (token.analysis.head && token.analysis.head !== fallback)
        done++;
      if (token.analysis.pos && token.analysis.head !== fallback)
        done++;

      token.analysis.eachHead(head => {

        total++;
        if (head.deprel && head.deprel !== fallback)
          done++;

      });
    });

    return total ? done / total : 1;
  }

  /**
   * get a serial version of the internal sentence representation
   *
   * @return {String}
   */
  get nx() {
    // update indices
    this.index();

    // serialize tokens
    let tokens = [];
    for (let i=0; i<this.tokens.length; i++) {
      tokens.push(this.tokens[i].nx);
    }

    // serialize other data
    return JSON.stringify({
      comments: this.comments,
      options: this.options,
      tokens: tokens
    }, null, this.options.prettyOutput ? 2 : 0);
  }

  /**
   * deserialize an internal representation
   *
   * @param {(String|Object)} nx JSON string or object
   * @return {String}
   */
  set nx(nx) {

    // parse the JSON if it's a string
    nx = (typeof nx === 'string')
      ? JSON.parse(nx)
      : nx;

    this.options = nx.options;
    this.comments = nx.comments;
    this.tokens = nx.tokens.map(tokenNx => {
      return Token.fromNx(this, tokenNx);
    });

    return this.attach().nx;
  }

  /**
   * static method allowing us to construct a new Sentence directly from an
   *   Nx string
   *
   * @param {String} serial
   * @param {Object} options (optional)
   * @return {Sentence}
   */
  static fromNx(serial, options) {
    let sent = new Sentence(options);
    sent.nx = serial;
    return sent;
  }

  /**
   * get a plain-text formatted string of the sentence's current analysis text
   *
   * @return {String}
   */
  get text() {
    // only care about tokens (not comments or settings)
    let tokens = [];
    this.forEach(token => {
      if (!token.isSubToken && !token.isEmpty)
        tokens.push(token.text);
    });
    return tokens.join(' ');
  }

  /**
   * parse a Plain text formatted string and save its contents to the sentence
   *
   * @param {String} text
   * @return {String}
   */
  set text(text) {

    // insert a space before final punctuation
    text = text.trim().replace(/([.,?!]+)$/, ' $1');

    // split on whitespace and add form-only tokens
    _.map(text.split(/\s/), chunk => {
      this.pushToken( Token.fromParams(this, { form: chunk }) );
    });

    return this.text;
  }

  /**
   * static method allowing us to construct a new Sentence directly from a
   *   text string
   *
   * @param {String} serial
   * @param {Object} options (optional)
   * @return {Sentence}
   */
  static fromText(serial, options) {
    let sent = new Sentence(options);
    sent.text = serial;
    return sent;
  }

  /**
   * get a CoNLL-U formatted string representing the sentence's current analysis
   *
   * @return {(String|null)}
   */
  get conllu() {
    // comments first
    const comments = _.map(this.comments, comment => {
      return `# ${comment}`;
    });

    try {

      let tokens = [];
      this.forEach(token => {
        tokens.push(token.conllu);
      });
      return comments.concat(tokens).join('\n');

    } catch (e) {

      // if the sentence contains ambiguous analyses, we will get an error,
      // so catch only those types of errors here
      if (!(e instanceof InvalidCoNLLUError) || !this.options.catchInvalid)
        throw e;

      // if sentence is ambiguous
      return null;
    }
  }

  /**
   * parse a CoNLL-U formatted string and save its contents to the sentence
   *
   * @param {String} conllu
   * @return {String}
   */
  set conllu(conllu) {
    // clear existing data
    this.comments = [];
    this.tokens = [];

    // split on newlines
    const lines = conllu.trim().split('\n');
    for (let i=0; i<lines.length; i++) {

      // extract comments
      if (regex.comment.test(lines[i])) {
        this.comments.push(
          lines[i].match(regex.commentContent)[1] );

      // extract tokens
      } else if (regex.superToken.test(lines[i])) {

        // the top-level token
        const superToken = Token.fromConllu(this, lines[i]);

        // check which subTokens belong to this superToken
        const k = i;
        const subTokenIndices = lines[i]
          .match(regex.superToken)[0]
          .trim()
          .split('-')
          .map(str => { return parseInt(str); });

        // push them all to the superToken's current analysis
        for (let j=0; j<=(subTokenIndices[1] - subTokenIndices[0]); j++) {
          superToken.analysis.pushSubToken( Token.fromConllu(this, lines[j + k + 1]) );
          i++;
        }

        // push the superToken to the sentence
        this.pushToken(superToken);

      } else {

        // regular (non-super) tokens pushed to sentence here
        if (lines[i].trim().length)
          this.pushToken( Token.fromConllu(this, lines[i]) );

      }
    }

    // attach heads and return CoNLL-U string
    return this.attach().conllu;
  }

  /**
   * static method allowing us to construct a new Sentence directly from a
   *   CoNLL-U string
   *
   * @param {String} serial
   * @param {Object} options (optional)
   * @return {Sentence}
   */
  static fromConllu(serial, options) {
    let sent = new Sentence(options);
    sent.conllu = serial;
    return sent;
  }

  /**
   * get a CG3 formatted string representing all of the sentence's analyses
   *
   * @return {(String|null)}
   */
  get cg3() {
    // comments first
    const comments = _.map(this.comments, comment => {
      return `# ${comment}`;
    });

    try {

      let tokens = [];
      for (let i=0; i<this.tokens.length; i++) { // iterate over superTokens
        tokens.push(this.tokens[i].cg3);
      }
      return comments.concat(tokens).join('\n');

    } catch (e) {

      // if the sentence is not analyzeable as CG3, we'll get an error
      // NOTE: this doesn't currently happen under any circumstances
      if (!(e instanceof InvalidCG3Error) || !this.options.catchInvalid)
        throw e;

      return null;
    }
  }

  /**
   * parse a CG3 formatted string and save its contents to the sentence
   *
   * @param {String} conllu
   * @return {String}
   */
  set cg3(cg3) {
    // clear existing data
    this.comments = [];
    this.tokens = [];

    // since this parsing is more complicated than CoNLL-U parsing, keep this
    //   array of lines for the current token we're parsing
    // NOTE: CG3 tokens are separated by lines of the form `/^"<EXAMPLE>"/`
    //   and lines beginning with one/more indent give data for that token
    let tokenLines = [];

    // split on newlines
    const lines = cg3.trim().split('\n');
    for (let i=0; i<lines.length; i++) {

      // decide what the current line is
      let isToken = regex.cg3TokenStart.test(lines[i]);
      let isContent = regex.cg3TokenContent.test(lines[i]);

      // current line is the start of a new token
      if (isToken) {

        // if we already have stuff in our tokenLines buffer, parse it as a token
        if (tokenLines.length)
          this.tokens.push(Token.fromCG3(this, tokenLines));

        // reset tokenLines buffer
        tokenLines = [ lines[i] ];

      } else {

        // add content lines to tokenLines buffer
        if (tokenLines.length && isContent) {
          tokenLines.push(lines[i]);

        // push comment
        } else {
          this.comments.push(lines[i].match(regex.commentContent)[1]);
        }
      }
    }

    // clear tokenLines buffer
    if (tokenLines.length)
      this.tokens.push(Token.fromCG3(this, tokenLines));

    // attach heads and return CG3 string
    return this.attach().cg3;
  }

  /**
   * static method allowing us to construct a new Sentence directly from a
   *   CG3 string
   *
   * @param {String} serial
   * @param {Object} options (optional)
   * @return {Sentence}
   */
  static fromCG3(serial, options) {
    let sent = new Sentence(options);
    sent.cg3 = serial;
    return sent;
  }

  /**
   * get an array of token parameters representing the sentence
   *
   * NOTE: fails (returns null) if we have subTokens or ambiguous analyses
   *
   * @return {(Array|null)}
   */
  get params() {
    try {

      let params = [];
      this.forEach(token => {

        if (token.isSuperToken || token.isSubToken)
          throw new InvalidCoNLLUError();
        if (token.isAmbiguous)
          throw new InvalidCG3Error();

        params.push(token.params);
      });
      return params;

    } catch (e) {
      if (e instanceof InvalidCoNLLUError && this.options.catchInvalid) {
        console.warn('cannot get params for this sentence: contains MultiWordTokens');
        return null;

      } else if (e instanceof InvalidCG3Error && this.options.catchInvalid) {
        console.warn('cannot get params for this sentence: contains ambiguous analyses');
        return null;

      } else {
        // throw other errors
        throw e;
      }
    }
  }

  /**
   * parse an array of token parameters and save contents to the sentence
   *
   * @param {Array} paramsList
   * @return {(Array|null)}
   */
  set params(paramsList) {
    // can only parse arrays
    if (!(paramsList instanceof Array))
      return null;

    // clear existing data
    this.comments = [];
    this.tokens = [];

    // push a new token for each set of parameters
    _.each(paramsList, params => {
      this.tokens.push(Token.fromParams(this, params));
    });

    // attach heads and return validated parameter list
    return this.attach().params;
  }

  /**
   * static method allowing us to construct a new Sentence directly from an
   *   array of parameters
   *
   * @param {Array} paramsList
   * @param {Object} options (optional)
   * @return {Sentence}
   */
  static fromParams(paramsList, options) {
    let sent = new Sentence(options);
    sent.params = paramsList;
    return sent;
  }

  /**
   * get an array of the elements of this sentence, useful for exporting the data
   *   to visualization libraries such as Cytoscape or D3
   *
   * @return {Array}
   */
  get eles() {

    // just in case, since it's critical
    this.index();

    let eles = [];
    this.forEach(token => {
      eles = eles.concat(token.eles);
    });

    return eles;
  }

  clean() {
    throw new Error('Sentence::clean is not implemented'); // TODO
  }

  /**
   * iterate through the tokens and set an appropriate index for each (following
   *   CoNLL-U indexing scheme with, e.g. 1 for regular token, 1-2 for superToken,
   *   1.1 for "empty" token)
   *
   * @return {Sentence}
   */
  index() {
    // track "overall" index number (id) and "empty" index number and "absolute" num
    // NOTE: CoNLL-U indices start at 1 (0 is root), so we will increment this
    //   index before using it (see Token::index)
    let id = 0, empty = 0, num = 0, clump = 0;
    _.each(this.tokens, token => {
      // allow each token to return counters for the next guy
      [id, empty, num, clump] = token.index(id, empty, num, clump);
    });

    // chaining
    return this;
  }

  /**
   * iterate through the tokens and try to convert a plain string index to a
   *   head to the actual token given by that index (called after parsing
   *   CoNLL-U, CG3, or params)
   *
   * @return {Sentence}
   */
  attach() {
    // reindex in case we're out of date (valid index is crucial here)
    this.index();
    this.forEach(token => {
      token.analysis.head = token.analysis.head;
      token.analysis.deps = token.analysis.deps;
    });

    // chaining
    return this;
  }


  /**
   * iterate through the tokens and determine if they could be converted into
   *   a CoNLL-U formatted string
   *
   * NOTE: currently, only returns false if it contains one/more ambiguous analyses
   *
   * @return {Boolean}
   */
  get isValidConllu() {
    let valid = true;
    this.forEach(token => {
      if (token.isAmbiguous)
        valid = false;
    });
    return valid;
  }

  /**
   * iterate through the tokens and determine if they could be converted into
   *   a CG3 formatted string
   *
   * NOTE: currently, always returns true (see update below)
   *
   * @return {Boolean}
   */
  get isValidCG3() {
    let valid = true;
    this.forEach(token => {
      /*
      UPDATE 6/9/18: apparently CG3 can handle all this stuff, it's just a bit lossy
        (e.g. subTokens won't have their own `form` and `empty` tokens won't show up)

      if (token.isSubToken || token.isSuperToken || token.isEmpty)
        valid = false;
      */
    });
    return valid;
  }
}

/**
 * Proxy so that we can get tokens using Array-like syntax
 *
 * NOTE: usage: `sent[8]` would return the analysis of the token at index 8
 * NOTE: if `name` is not a Number, fall through to normal object
 *
 * @return {Mixed}
 * @name Sentence#get
 */
Sentence.prototype.__proto__ = new Proxy(Sentence.prototype.__proto__, {

  // default getter, called any time we use Sentence.name or Sentence[name]
  get(target, name, receiver) {

    // Symbols can't be cast to floats, so check here to avoid errors
    if (typeof name === 'symbol')
      return this[name];

    // cast, catch Infinity
    let id = parseFloat(name);
    if (!isNaN(id)) {

      // if we got a number, return analysis at that index
      id = parseInt(id);
      let token = receiver.tokens[id];
      return token ? token.analysis : null;

    } else {

      // fall through to normal getting
      return this[name];

    }
  }
});

// expose to application
module.exports = Sentence;

},{"./analysis":328,"./errors":329,"./token":332,"underscore":335}],332:[function(require,module,exports){
'use strict';

const _ = require('underscore');

const NotatrixError       = require('./errors').NotatrixError;
const InvalidCG3Error     = require('./errors').InvalidCG3Error;
const InvalidCoNLLUError  = require('./errors').InvalidCoNLLUError

const Analysis = require('./analysis');


/**
 * helper function to split on whitespace
 *
 * @param {String} str
 * @return {Array}
 */
function split(str) {
  return (str || '').split(/\s+/);
}

/**
 * helper function to count the number of leading `\t` characters in a string
 *
 * @param {String} line
 * @return {Number}
 */
function getIndent(line) {

  let chars = line.split(''),
    i = 0;

  while (chars[i++] === '\t')
    true; // do nothing

  return i - 1;
}

// CG3 parser helper functions

/**
 * extract the `form` parameter from a given string
 *
 * @param {String} line
 * @return {(undefined|String)}
 */
function cg3StringGetForm(line) {

  return cg3Regex.form.test(line)
    ? line.match(cg3Regex.form)[1]
    : undefined
}

/**
 * extract all the other (not `form`) tags from a given string
 *
 * @param {String} line
 * @return {Object}
 */
function cg3StringGetTags(line) {

  // initialize things
  let lemma, xpostag = [],
    head, deprel, deps, misc = [];

  // get lemma
  if (cg3Regex.lemma.test(line))
    lemma = line.match(cg3Regex.lemma)[1];

  // only consider line after lemma (if it exists)
  line = lemma ? line.slice(line.indexOf(lemma) + lemma.length + 1).trim() : line;

  // split on whitespace
  let chunks = split(line);

  // iterate over each chunk
  for (let j=0; j<chunks.length; j++) {

    // try to extract deprel
    if (cg3Regex.deprel.test(chunks[j])) {
      deprel = chunks[j].match(cg3Regex.deprel)[1];

    // try to extract head
    } else if (cg3Regex.dependency.test(chunks[j])) {
      head = chunks[j].match(cg3Regex.dependency)[2];

    // try to extract misc, track with array (can be multiple)
    } else if (cg3Regex.misc.test(chunks[j])) {
      misc.push(chunks[j]);

    // try to extract tags (and save to xpostag), track with an array (can be multiple)
    } else {
      xpostag.push(chunks[j]);
    }
  }

  // return our extracted data
  return {
    lemma: lemma,
    xpostag: xpostag.join(';') || undefined,
    head: head,
    deprel: deprel,
    deps: deps,
    misc: misc.join(';') || undefined
  };
}

/**
 * parse an array of strings representing a CG3 analysis ... recall that in CG3,
 *   subTokens have an increasingly hanging indent from their superToken
 *
 * @param {Token} token token to attach the analyses to
 * @param {Array} lines [[String]]
 * @return {undefined}
 */
function cg3StringParseAnalysis(token, lines) {

  if (lines.length === 2) {

    // no subTokens
    let tags = cg3StringGetTags(lines[1]); // extract tags
    tags.form = cg3StringGetForm(lines[0]); // extract the form
    token.pushAnalysis(new Analysis(token, tags)); // save to token

  } else {

    // has subTokens
    let analysis = new Analysis(token, {
      form: cg3StringGetForm(lines[0]) // superToken only save form
    });

    // for each subToken
    for (let i=1; i<lines.length; i++) {
      let tags = cg3StringGetTags(lines[i]); // extract tags
      let subToken = new Token(token.sentence, tags);  // make new subToken
      analysis.pushSubToken( subToken ); // attach to this analysis
    }
    token.pushAnalysis(analysis); // save to token

  }
}

// define all the CG3-parsing regex here
const cg3Regex = {
  form: /^"<((.|\\")*)>"/,
  lemma: /["\]](.*)["\]](\s|$)/,
  head: /->(.*)$/,
  dependency: /^#(.+)->(.*)/,
  deprel: /^@(.*)/,
  misc: /.+:.*/
};

/**
 * this class contains all the information associated with a token, including
 *   a possible superToken, an array of possible analyses, an index to the
 *   current analysis, and a Boolean representing whether it is an "empty" token
 */
class Token {
  constructor(sent, params) {

    // require sentence param
    if (!sent)
      throw new NotatrixError('missing required arg: Sentence')

    // pointer to parent
    this.sentence = sent;

    // internal stuff
    this.superToken = null;
    this.analyses = []; // array of analyses
    this._current = null; // index of current analysis in array
    this._isEmpty = false; // used for CoNLL-U "empty" tokens

    // try parsing an analysis from params
    if (params)
      this.analysis = new Analysis(this, params);
  }

  /**
   *
   * @return {Number} total number of analyses in this token
   */
  get length() {

    return this.analyses.length;
  }

  /**
   * loop through every analysis in the sentence and apply a callback
   *
   * @param {Function} callback function to be applied to every analysis
   * @return {Token}
   */
  forEach(callback) {

    for (let i=0; i<this.length; i++) {
      callback(this.analyses[i], i);
    }

    // chaining
    return this;
  }

  // keeping track of ambiguous analyses

  /**
   * decrement the _current counter by one (set "previous" analysis as current)
   *
   * @return {Token}
   */
  prev() {

    // if no analyses set whatsoever
    if (this._current === null)
      return null;

    // if we're not already at the first one
    if (this._current > 0)
      this._current--;

    // chaining
    return this;
  }

  /**
   * increment the _current counter by one (set "next" analysis as current)
   *
   * @return {Token}
   */
  next() {

    // if no analyses set whatsoever
    if (this._current === null)
      return null;

    // if we're not already at the last one
    if (this._current < this.length - 1)
      this._current++;

    // chaining
    return this;
  }

  /**
   * return the _current index
   *
   * @return {Number}
   */
  get current() {

    return this._current;
  }

  /**
   * set the _current index to the given index if possible
   *
   * @param {Number} current
   * @return {Number}
   */
  set current(current) {

    // force cast to int
    current = parseInt(current);
    if (isNaN(current))
      return this.current;

    // bounds checking
    if (current < 0)
      return this.current;
    if (current > this.length - 1)
      return this.current;

    // set and return it
    this._current = current;
    return this.current;
  }

  // manipulate analyses array

  /**
   * insert an analysis BEFORE the given index
   *
   * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted
   *   to fit the bounds. this means that you can call this with `index=-Infinity`
   *   to push to the front of the analyses array or with `index=Infinity` to push
   *   to the end
   *
   * @param {Number} index
   * @param {Analysis} analysis
   * @return {Token}
   *
   * @throws {NotatrixError} if given invalid index or analysis
   */
  insertAnalysisAt(index, analysis) {

    index = parseFloat(index); // catch Infinity
    if (isNaN(index))
      throw new NotatrixError('unable to insert subToken: unable to cast index to int');

    if (!(analysis instanceof Analysis))
      throw new NotatrixError('unable to insert analysis: not instance of Analysis');

    // if we had no analyses, make this the first
    if (this.current === null)
      this._current = 0;

    // bounds checking
    index = index < 0 ? 0
      : index > this.length ? this.length
      : parseInt(index);

    // set the parent pointer on the analysis
    analysis.token = this;

    // array insertion
    this.analyses = this.analyses.slice(0, index)
      .concat(analysis)
      .concat(this.analyses.slice(index));

    // chaining
    return this;
  }

  /**
   * remove an analysis at the given index
   *
   * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be
   *   adjusted to fit the bounds. this means that you can call this with
   *   `index=-Infinity` to remove the first element of the analyses array or
   *   with `index=Infinity` to remove the last
   *
   * @param {Number} index
   * @return {(null|Analysis)}
   *
   * @throws {NotatrixError} if given invalid index
   */
  removeAnalysisAt(index) {

    // can't remove if we have an empty array
    if (!this.length)
      return null;

    index = parseFloat(index); // catch Infinity
    if (isNaN(index))
      throw new NotatrixError('unable to remove subToken: unable to cast index to int');

    // bounds checking
    index = index < 0 ? 0
      : index > this.length - 1 ? this.length - 1
      : parseInt(index);

    // go to previous analysis if we just deleted our current one or before it
    if (this.current >= index)
      this.prev();

    // if we now have an empty array, update _current
    if (this.length === 1)
      this._current = null;

    // array splicing, return spliced element
    return this.analyses.splice(index, 1)[0];
  }

  /**
   * move an analysis from sourceIndex to targetIndex
   *
   * NOTE: if either index is out of bounds (<0 or >length - 1), then it will
   *   be adjusted to fit the bounds. this means that you can call this with
   *   `sourceIndex=-Infinity` to select the first element of the analyses array
   *   or with `sourceIndex=Infinity` to select the last
   *
   * @param {Number} sourceIndex
   * @param {Number} targetIndex
   * @return {Token}
   *
   * @throws {NotatrixError} if given invalid sourceIndex or targetIndex
   */
  moveAnalysisAt(sourceIndex, targetIndex) {

    sourceIndex = parseFloat(sourceIndex);
    targetIndex = parseFloat(targetIndex);
    if (isNaN(sourceIndex) || isNaN(targetIndex))
      throw new NotatrixError('unable to move analysis: unable to cast indices to ints');

    // bounds checking
    sourceIndex = sourceIndex < 0 ? 0
      : sourceIndex > this.length - 1 ? this.length - 1
      : parseInt(sourceIndex);
    targetIndex = targetIndex < 0 ? 0
      : targetIndex > this.length - 1 ? this.length - 1
      : parseInt(targetIndex);

    if (sourceIndex === targetIndex) {
      // do nothing
    } else {

      // array splice and insert
      let analysis = this.analyses.splice(sourceIndex, 1);
      this.analyses = this.analyses.slice(0, targetIndex)
        .concat(analysis)
        .concat(this.analyses.slice(targetIndex));

    }

    // chaining
    return this;
  }

  /**
   * push an analysis to the end of the analyses array ... sugar for
   *   Token::insertAnalysisAt(Infinity, analysis)
   *
   * @param {Analysis} analysis
   * @return {Token}
   */
  pushAnalysis(analysis) {
    return this.insertAnalysisAt(Infinity, analysis);
  }

  /**
   * pop an analysis from the end of the analyses array ... sugar for
   *   Token::insertRemoveAt(Infinity)
   *
   * @return {(null|Analysis)}
   */
  popAnalysis() {
    return this.removeAnalysisAt(Infinity);
  }

  // token combining, merging, splitting

  combineWith(token) {

  }
  mergeWith(token) {
    if (!(token instanceof Token))
      throw new NotatrixError('unable to merge: not instance of Token');

    if (this === token)
      throw new NotatrixError('unable to merge: can\'t merge with self');

    if (this.isSuperToken || token.isSuperToken)
      throw new NotatrixError('unable to merge: can\'t merge superTokens');

    if (this.superToken !== token.superToken)
      throw new NotatrixError('unable to merge: can\'t merge tokens with different superTokens');

    const dist = Math.abs(this.analysis.clump - token.analysis.clump);
    if (dist !== 1)
      throw new NotatrixError('unable to merge: tokens must be adjacent');

    if (this.analysis === null || token.analysis === null)
      throw new NotatrixError('unable to merge: tokens must have at least one analysis');

    // combine the form and lemma fields
    this.analysis.form = ((this.analysis.form || '') + (token.analysis.form || '')) || null;
    this.analysis.lemma = ((this.analysis.lemma || '') + (token.analysis.lemma || '')) || null;

    // take one of these fields
    this.upostag = this.upostag || token.upostag || null;
    this.xpostag = this.xpostag || token.xpostag || null;
    this.feats = this.feats || token.feats || null;
    this.misc = this.misc || token.misc || null;

    // remove the token
    if (token.isSubToken) {

      const indices = this.sentence.getIndices(token);
      this.superToken.removeSubTokenAt(indices.sub);

    } else {

      const indices = this.sentence.getIndices(token);
      this.sentence.removeTokenAt(indices.super);

    }

    this.sentence.index();
    return this; // chaining
  }
  split() {

  }

  // internal format

  /**
   * get the current analysis for the token or null if none exist
   *
   * @return {(null|Analysis)}
   */
  get analysis() {

    if (this.current === null)
      return null;
    return this.analyses[this.current];
  }

  /**
   * set the current analysis for the token
   *
   * NOTE: if there is already an analysis, overwrite
   *
   * @param {Analysis} analysis
   * @return {Token}
   *
   * @throws {NotatrixError} if given invalid analysis
   */
  set analysis(analysis) {

    if (!(analysis instanceof Analysis))
      throw new NotatrixError('unable to set analysis: not instance of Analysis');

    if (this.analysis === null) {
      // push to front if we have no analyses
      this.insertAnalysisAt(0, analysis);

    } else {
      // otherwise overwrite
      analysis.token = this;
      this.analyses[this.current] = analysis;
    }

    return this;
  }


  /**
   * if we have a current analysis, return its subTokens
   *
   * @return {(null|Array)}
   */
  get subTokens() {

    if (this.analysis === null)
      return null;
    return this.analysis.subTokens;
  }

  // external format stuff

  /**
   * iterate over this token and its subTokens (if we have any) for the current
   *   analysis, using the `id` and `empty` params to set indices
   *
   * @param {Number} id "overall" index
   * @param {Number} empty
   * @return {Array} [Number, Number]
   *
   * @throws {NotatrixError} if given invalid id or empty
   */
  index(id, empty, num, clump) {

    id = parseInt(id);
    empty = parseInt(empty);
    num = parseInt(num);
    clump = parseInt(clump);

    if (isNaN(id) || isNaN(empty) || isNaN(num) || isNaN(clump))
      throw new NotatrixError('can\'t index tokens using non-integers, make sure to call Sentence.index()')

    // if no analysis, nothing to do
    if (this.analysis === null)
      return [id, empty, num, clump];

    // iterate over analyses
    this.forEach(analysis => {

      // only set the "id" and "empty" indices on the current analysis
      if (analysis.isCurrent) {
        if (this.isSuperToken) {

          // save the absolute index
          this.analysis.num = num;
          this.analysis.clump = null;
          num++;

          // index subTokens
          _.each(this.analysis.subTokens, subToken => {
            if (subToken.isEmpty) {
              empty++; // incr empty counter
              subToken.analysis.id = `${id}.${empty}` // dot syntax
            } else {
              id++; // incr regular counter
              subToken.analysis.id = `${id}`; // vanilla syntax
              empty = 0; // reset empty counter
            }

            // save the absolute index
            subToken.forEach(analysis => {
              analysis.num = num;
              num++;
              analysis.clump = clump;
              clump++;
            });
          });

          // set special superToken index scheme
          const firstSubAnalysis = this.subTokens[0].analysis;
          const lastSubAnalysis = this.subTokens[this.analysis.length - 1].analysis;
          this.analysis.id = `${firstSubAnalysis.id}-${lastSubAnalysis.id}`;

        } else {

          // save the absolute index
          this.analysis.num = num;
          num++;
          this.analysis.clump = clump;
          clump++;

          if (this.isEmpty) {
            empty++; // incr empty counter
            this.analysis.id = `${id}.${empty}` // dot syntax
          } else {
            id++; // incr regular counter
            this.analysis.id = `${id}`; // vanilla syntax
            empty = 0; // reset empty counter
          }
        }

      } else {

        // save the absolute index
        this.analysis.num = num;
        num++;

        // non-current analyses get "id" and "empty" indices set to null
        analysis.id = null;
        _.each(analysis.subTokens, subToken => {
          subToken.analysis.id = null;

          subToken.forEach(analysis => {

            // save the absolute index
            this.analysis.num = num;
            num++;

          });
        });
      }
    });

    // return updated indices
    return [id, empty, num, clump];
  }

  /**
   * get a serial version of the internal token representation
   *
   * @return {Object}
   */
  get nx() {

    // serialize analyses
    let analyses = [];
    this.forEach(analysis => {
      analyses.push(analysis.nx);
    });

    // serialize other data
    return {
      current: this.current,
      isEmpty: this.isEmpty,
      analyses: analyses
    };
  }

  /**
   * deserialize an internal representation
   *
   * @param {(String|Object)} nx JSON string or object
   * @return {undefined}
   */
  set nx(nx) {

    // parse the JSON if it's a string
    nx = (typeof nx === 'string')
      ? JSON.parse(nx)
      : nx;

    this.analyses = nx.analyses.map(analysisNx => {

      let analysis = Analysis.fromNx(this, analysisNx);
      analysis.subTokens = analysisNx.subTokens.map(subTokenNx => {
        return Token.fromNx(this.sentence, subTokenNx);
      });
      return analysis;

    });
    this.current = nx.current;
    this._isEmpty = nx.isEmpty;

  }

  /**
   * static method allowing us to construct a new Token directly from an
   *   Nx string and bind it to a sentence
   *
   * @param {Sentence} sent
   * @param {String} serial
   * @return {Token}
   */
  static fromNx(sent, serial) {
    let token = new Token(sent);
    token.nx = serial;
    return token;
  }

  /**
   * get a plain-text formatted string of the current analysis text
   *
   * @return {String}
   *
   * @throws {NotatrixError} if no analysis
   */
  get text() {

    if (this.analysis === null)
      throw new NotatrixError('no analysis to get text for');

    return this.analysis.text || '';
  }

  /**
   * get a CoNLL-U formatted string representing the current analysis
   *
   * @return {String}
   *
   * @throws {NotatrixError} if no analysis
   * @throws {InvalidCoNLLUError} if ambiguous
   */
  get conllu() {

    if (this.analysis === null)
      throw new NotatrixError('no analysis to get CoNLL-U for');

    if (this.isAmbiguous)
      throw new InvalidCoNLLUError('Token is ambiguous, can\'t be converted to CoNNL-U');

    return this.analysis.conllu;
  }

  /**
   * parse a CoNLL-U formatted string and save its contents to the current analysis
   *
   * @param {String} serial
   * @return {undefined}
   */
  set conllu(serial) {
    // split serial string on whitespace
    const fields = split(serial);

    // check if serial index indicates an "empty" token
    this._isEmpty = /\./.test(fields[0]);

    // generate an analysis from the fields
    this.analysis = new Analysis(this, {
      form: fields[1],
      lemma: fields[2],
      upostag: fields[3],
      xpostag: fields[4],
      feats: fields[5],
      head: fields[6],
      deprel: fields[7],
      deps: fields[8],
      misc: fields[9]
    });
  }

  /**
   * static method allowing us to construct a new Token directly from a
   *   CoNLL-U string and bind it to a sentence
   *
   * @param {Sentence} sent
   * @param {String} serial
   * @return {Token}
   */
  static fromConllu(sent, serial) {
    let token = new Token(sent);
    token.conllu = serial;
    return token;
  }

  /**
   * get a CG3 formatted string representing the current analysis
   *
   * @return {String}
   *
   * @throws {NotatrixError} if no analysis
   */
  get cg3() {
    if (this.analysis === null)
      throw new NotatrixError('no analysis to get CG3 for');

    // the form goes on its own line, with each analysis below
    return [ `"<${this.analysis.form}>"` ].concat(
      this.analyses.map(analysis => {
        return analysis.cg3;
      })
    ).join('\n');
  }

  /**
   * parse a CG3 formatted string and save its contents to the current analysis
   *
   * @param {Array} tokenLines generated in Sentence::cg3 [set] by splitting
   *   a serial string on newlines
   * @return {undefined}
   */
  set cg3(tokenLines) {
    // again, we have complicated parsing here ... first make sure we get an
    //   array of the important information (minimally the form on the first line)
    let analysis = [ tokenLines[0] ];

    // iterate over the strings
    for (let i=1; i<tokenLines.length; i++) {

      let line = tokenLines[i];
      if (/^;/.test(line)) {
        // strip leading semicolons
        line = line.replace(/^;/, '');
        // TODO: save this information somewhere
      }

      // determine line indent
      let indent = getIndent(line);

      // if we're back at indent=1 and we already have stuff in our analysis
      //   buffer, parse it as an analysis
      if (indent === 1 && i > 1) {
        // parse as analysis
        cg3StringParseAnalysis(this, analysis);
        // reset buffer
        analysis = [ tokenLines[0] ];
      }

      // add to buffer
      analysis.push(line);
    }

    // parse and clear buffer
    cg3StringParseAnalysis(this, analysis);
  }

  /**
   * static method allowing us to construct a new Token directly from a
   *   CG3 string
   *
   * @param {Sentence} sent
   * @param {Array} tokenLines
   * @return {Token}
   */
  static fromCG3(sent, tokenLines) {
    let token = new Token(sent);
    token.cg3 = tokenLines;
    return token;
  }

  /**
   * get the token parameters for the current analysis
   *
   * @return {Object}
   *
   * @throws {NotatrixError} if no analysis
   */
  get params() {
    if (this.analysis === null)
      throw new NotatrixError('no analysis to get params for');

    return this.analysis.params;
  }

  /**
   * set a set of parameters as the current analysis
   *
   * @param {Object} params
   * @return {Object}
   */
  set params(params) {
    this.analysis = new Analysis(this, params);
    return this.params;
  }

  /**
   * static method allowing us to construct a new Token directly from a set
   *   of parameters
   *
   * @param {Sentence} sent
   * @param {Object} params
   * @return {Token}
   */
  static fromParams(sent, params) {
    let token = new Token(sent);
    token.params = params;
    return token;
  }

  /**
   * get an array of elements for exporting to external visualization libraries
   *   for all the analyses of this token
   *
   * @return {Array}
   */
  get eles() {
    let eles = [];
    this.forEach(analysis => {
      eles = eles.concat(analysis.eles);
    });

    return eles;
  }

  // bool stuff

  /**
   * returns true iff this token is a subToken of some other token
   *
   * @return {Boolean}
   */
  get isSubToken() {
    return this.superToken !== null;
  }

  /**
   * returns true iff this token has subTokens
   *
   * @return {Boolean}
   */
  get isSuperToken() {
    return this.analysis ? this.analysis.isSuperToken : null;
  }

  /**
   * returns true iff this token or its superToken is an "empty" token
   *
   * @return {Boolean}
   */
  get isEmpty() {
    return this.isSubToken ? this.superToken.token.isEmpty : this._isEmpty;
  }

  /**
   * return true iff this token has more than one analysis
   *
   * @return {Boolean}
   */
  get isAmbiguous() {
    return this.length > 1;
  }
}

// expose to application
module.exports = Token;

},{"./analysis":328,"./errors":329,"underscore":335}],333:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],334:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":333,"timers":334}],335:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because were not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],336:[function(require,module,exports){
/*
Simple Javascript undo and redo.
https://github.com/ArthurClemens/Javascript-Undo-Manager
*/

;(function() {

	'use strict';

    function removeFromTo(array, from, to) {
        array.splice(from,
            !to ||
            1 + to - from + (!(to < 0 ^ from >= 0) && (to < 0 || -1) * array.length));
        return array.length;
    }

    var UndoManager = function() {

        var commands = [],
            index = -1,
            limit = 0,
            isExecuting = false,
            callback,

            // functions
            execute;

        execute = function(command, action) {
            if (!command || typeof command[action] !== "function") {
                return this;
            }
            isExecuting = true;

            command[action]();

            isExecuting = false;
            return this;
        };

        return {

            /*
            Add a command to the queue.
            */
            add: function (command) {
                if (isExecuting) {
                    return this;
                }
                // if we are here after having called undo,
                // invalidate items higher on the stack
                commands.splice(index + 1, commands.length - index);

                commands.push(command);

                // if limit is set, remove items from the start
                if (limit && commands.length > limit) {
                    removeFromTo(commands, 0, -(limit+1));
                }

                // set the current index to the end
                index = commands.length - 1;
                if (callback) {
                    callback();
                }
                return this;
            },

            /*
            Pass a function to be called on undo and redo actions.
            */
            setCallback: function (callbackFunc) {
                callback = callbackFunc;
            },

            /*
            Perform undo: call the undo function at the current index and decrease the index by 1.
            */
            undo: function () {
                var command = commands[index];
                if (!command) {
                    return this;
                }
                execute(command, "undo");
                index -= 1;
                if (callback) {
                    callback();
                }
                return this;
            },

            /*
            Perform redo: call the redo function at the next index and increase the index by 1.
            */
            redo: function () {
                var command = commands[index + 1];
                if (!command) {
                    return this;
                }
                execute(command, "redo");
                index += 1;
                if (callback) {
                    callback();
                }
                return this;
            },

            /*
            Clears the memory, losing all stored states. Reset the index.
            */
            clear: function () {
                var prev_size = commands.length;

                commands = [];
                index = -1;

                if (callback && (prev_size > 0)) {
                    callback();
                }
            },

            hasUndo: function () {
                return index !== -1;
            },

            hasRedo: function () {
                return index < (commands.length - 1);
            },

            getCommands: function () {
                return commands;
            },

            getIndex: function() {
                return index;
            },

            setLimit: function (l) {
                limit = l;
            }
        };
    };

	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// AMD. Register as an anonymous module.
		define(function() {
			return UndoManager;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = UndoManager;
	} else {
		window.UndoManager = UndoManager;
	}

}());

},{}],337:[function(require,module,exports){
'use strict';

module.exports = {
  unableToConvertToConllu: function unableToConvertToConllu() {},

  unableToConvertToCG3: function unableToConvertToCG3() {}
};

},{}],338:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cfg = require('./config');

/*
 * Logger object
 *
 * Tries to abstract away some of the complexity of logging.  If we can consistently
 * call the logger for errors, debugging, etc. instead of directly calling console.log,
 * then this will eventually make it easier to hide excessive stuff in production.
 *
 * Also, sending everything to one consistent place makes maintenance simpler.
 *
 * NOTE: in /standalone/lib/annotator.js, we set `window.log = new Logger()`, so
 *   to use this, call (for example) `log.warn("Some message")`.
 *
 * NOTE: to log "normally", without any of this special formatting, use Logger.out()
 *
 * @param {String} levelName:   one of 'CRITICAL', 'ERROR', 'WARN', 'INFO', 'DEBUG'
 *   used to set when the logger will actually display the message.  for example,
 *   if levelName='WARN', and you call `log.info("Some message")`, this won't be
 *   printed
 *
 * @param {Function} writer:    where to redirect the formatted message, default
 *   is console.error
 */

var Log = function () {
  function Log(levelName) {
    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console.log;

    _classCallCheck(this, Log);

    this._write = writer;
    this.colors = {
      'CRITICAL': 'red',
      'ERROR': 'orange',
      'WARN': 'yellow',
      'INFO': 'green',
      'DEBUG': 'blue',
      'OK': 'green'
    };

    this.level = levelName || cfg.defaultLoggingLevel;

    // try to override the l20n logging
    try {
      L20N_LOGGING = levelName === 'DEBUG';
    } catch (e) {
      if (!(e instanceof ReferenceError)) throw e;
    }
  }

  /*
   * change the logging level
   */


  _createClass(Log, [{
    key: 'toString',


    /*
     * Override prototype toString() method
     */
    value: function toString() {
      return 'Logger (level=' + this._levelName + ')';
    }

    /*
     * `private` method
     * format a message to be printed
     *
     * @param {String} message:   message to be printed
     * @param {String} tag:    keyword to appear between the timestamp (if present)
     *   and the message (default=null implies no tag shown)
     * @param {Boolean} showTimestamp:  set to `false` to suppress the current time
     *   from being output
     *
     * @return {String} formatted message
     */

  }, {
    key: '_format',
    value: function _format(message) {
      var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var showTimestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;


      var title = '',
          raw = '';
      if (showTimestamp) {
        var date = new Date();
        title += '[' + date + '] ';
        raw += '[' + date + '] ';
      }
      var css = [];
      if (tag !== null) {
        title += '%c' + tag + '%c: ';
        raw += tag + ': ';
        css = css.concat(['color:' + (this.colors[tag] || 'black') + ';', 'color:black']);
      }
      title += message.match(/\n/) === null // title should only be 1 line
      ? message : message.split('\n')[0] + ' [...]';
      raw += message;

      return { title: title, raw: raw, css: css };
    }

    /*
     * `private` method
     * helper function for the below functions ... decides whether or not a message
     * should be written out
     *
     * @param {Number} level:     integer representing the output priority level
     * @param {String} tag:       keyword to appear between the timestamp (if present)
     *   and the message (default=null implies no tag shown)
     * @param {String} message:   message to be printed (default='')
     * @param {Boolean} showTimestamp:  set to `false` to suppress the current time
     *   from being output
     *
     * @return <none>
     */

  }, {
    key: '_handle',
    value: function _handle(level, tag) {
      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var writer = arguments[3];

      if (level <= this._level) {
        var _console;

        var formatted = this._format(message, tag, true);
        writer = writer || this._write;
        (_console = console).groupCollapsed.apply(_console, [formatted.title].concat(_toConsumableArray(formatted.css)));
        writer(formatted.raw);
        console.trace();
        console.groupEnd();
      }
    }

    /*
     * `public` methods
     * call these functions to use this class's functionality (see above for details)
     *
     * @param {String} message:   message to be printed
     *
     * @return <none>
     */

  }, {
    key: 'critical',
    value: function critical(message) {
      this._handle(0, 'CRITICAL', message, console.error);
    }
  }, {
    key: 'error',
    value: function error(message) {
      this._handle(1, 'ERROR', message, console.error);
    }
  }, {
    key: 'warn',
    value: function warn(message) {
      this._handle(2, 'WARN', message, console.warn);
    }
  }, {
    key: 'info',
    value: function info(message) {
      this._handle(3, 'INFO', message, console.info);
    }
  }, {
    key: 'debug',
    value: function debug(message) {
      this._handle(4, 'DEBUG', message, console.log);
    }

    /*
     * `public` method
     * log normally (always and without special formatting)
     *
     * @param {...various} args:    zero or more things to be written out
     *
     * @return <none>
     */

  }, {
    key: 'out',
    value: function out(message, tag) {
      var formatted = this._format(message, tag, false);
      if (formatted.css.length) {
        this._write(formatted.title, formatted.css);
      } else {
        this._write(formatted.raw);
      }
    }
  }, {
    key: 'level',
    set: function set(levelName) {
      this._levelName = levelName;
      this._level = ['CRITICAL', 'ERROR', 'WARN', 'INFO', 'DEBUG'].indexOf(levelName);

      if (this._level === -1) {
        this.out('Unrecognized Logger levelName "' + levelName + '", setting level to CRITICAL.');
        this._levelName = 'CRITICAL';
        this._level = 0;
      }

      this.out('logging level set to ' + this._levelName, 'OK');
    }
  }]);

  return Log;
}();

module.exports = Log;

},{"./config":339}],339:[function(require,module,exports){
'use strict';

module.exports = {
	defaultFilename: 'ud-annotatrix-corpus',
	defaultSentence: '',
	defaultInsertedSentence: '',
	defaultLoggingLevel: 'ERROR',
	defaultEdgeHeight: 40,
	defaultEdgeCoeff: 1,

	localStorageKey: 'ud-annotatrix',
	saveInterval: 100000 // msecs
};

},{}],340:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');
var nx = require('notatrix');

var detectFormat = require('./detect');
var alerts = require('./alerts');
var errors = require('./errors');

/**
 *  convert2<FORMAT>() functions will try to detect the format of any input and
 *    then convert it into <FORMAT> ... they will all fail (return null) if they
 *    detect an Unknown input format
 *
 *    @param {String} text Arbitrary input text
 *    @return {String||null} in <FORMAT>, where <FORMAT> one of
 *      - plain text
 *      - CoNLL-U
 *      - CG3
 *
 *  these functions mostly rely on converting things into CoNLL-U and then reconverting
 *  if necessary ... these are the 'public' functions for the application (called
 *  when the user clicks on one of the converter tabs)
 */

/**
 * Takes a string representing some format, returns the string in
 * plain text or NULL if there was an error
 * @param {String} text Input text
 * @return {String}     Sentence in plain text format
 */
function convert2PlainText(text) {
  log.debug('called convert2PlainText(' + text + ')');

  text = text; // || a.sentence;
  var format = detectFormat(text);

  log.debug('convert2PlainText(): got format: ' + format);
  switch (format) {
    case 'Unknown':
      log.warn('convert2PlainText(): failed to convert: Unknown input type');
      return null;
    case 'plain text':
      log.info('convert2PlainText(): received plain text');
      return text;
    case 'Brackets':
      return conllu2PlainText(brackets2Conllu(text));
    case 'SD':
      return conllu2PlainText(sd2Conllu(text));
    case 'CoNLL-U':
      return conllu2PlainText(text);
    case 'CG3':
      return conllu2PlainText(cg32Conllu(text));
  }
}

/**
 * Takes a string representing some format, returns the string in
 * CoNLL-U or NULL if there was an error
 * @param {String} text Input text
 * @return {String}     Sentence in CoNLL-U format
 */
function convert2Conllu(text) {
  log.debug('called convert2conllu(' + text + ')');

  text = text; // || a.sentence;
  var format = detectFormat(text);

  log.debug('convert2conllu(): got format: ' + format + ', text: ' + text);
  switch (format) {
    case 'Unknown':
      log.warn('convert2conllu(): failed to convert Unknown to plain text');
      return null;
    case 'plain text':
      return cleanConllu(plainText2Conllu(text));
    case 'Brackets':
      return cleanConllu(brackets2Conllu(text));
    case 'SD':
      return cleanConllu(sd2Conllu(text));
    case 'CoNLL-U':
      log.info('convert2conllu(): received CoNLL-U');
      return cleanConllu(text);
    case 'CG3':
      return cg32Conllu(text);
  }
}

/**
 * Takes a string representing some format, returns the string in
 * CG3 or NULL if there was an error
 * @param {String} text Input text
 * @return {String}     Sentence in CG3 format
 */
function convert2CG3(text) {
  log.debug('called convert2CG3(' + text + ')');

  text = text; // || a.sentence;
  var format = detectFormat(text);

  log.debug('convert2CG3(): got format: ' + format);
  switch (format) {
    case 'Unknown':
      log.warn('convert2CG3(): failed to convert Unknown to plain text');
      return null;
    case 'plain text':
      return conllu2CG3(plainText2Conllu(text));
    case 'Brackets':
      return conllu2CG3(brackets2Conllu(text));
    case 'SD':
      return conllu2CG3(sd2Conllu(text));
    case 'CoNLL-U':
      return conllu2CG3(text);
    case 'CG3':
      log.info('convert2CG3(): received CG3');
      return text;
  }
}

/**
 *  Helper functions for the convert2<FORMAT> functions described above ... these
 *  handle the implementation of the conversions between specific formats
 */

/**
 * Takes a plain text sentence, returns a sentence in CoNLL-U format.
 * @param {String} text Input text (sentence)
 * @return {String}     Sentence in CoNLL-U format
 */
function plainText2Conllu(text) {
  log.debug('called plainText2Conllu(' + text + ')');
  log.debug('plainText2Conllu(): detected format: ' + detectFormat(text));

  // TODO: if there's punctuation in the middle of a sentence,
  // indices shift when drawing an arc
  // punctuation
  text = text.replace(/([^ ])([.?!;:,])/g, '$1 $2');

  /* get it into this form:
   *
   * # sent_id = _
   * # text = $text
   * 1    $textLine0
   * 2    $textLine1 [...]
   *
   */
  var sent = new nx.Sentence();
  sent.conllu = text.split(' ').map(function (token, i) {
    return i + 1 + '\t' + token; // enumerating tokens
  }).join('\n');

  return sent.conllu;
}

/**
 * Takes a string in CG, converts it to CoNLL-U format.
 * @param {String} text Input string(CG format)
 */
function sd2Conllu(text) {
  log.debug('called sd2Conllu(' + text + ')');

  /* Takes a string in CG, returns a string in conllu. */
  var inputLines = text.split('\n');
  var tokenId = 1,
      tokenToId = {},
      // convert from a token to an index
  heads = [],
      // e.g. heads[1] = 3
  deprels = []; // e.g. deprels[1] = nsubj

  // first enumerate the tokens
  _.each(inputLines[0].split(' '), function (token, i) {
    tokenToId[token] = tokenId;
    tokenId += 1;
  });

  // When there are two surface forms that are the same, you have to specify the one you
  // are referring to.
  //
  // e.g.
  // the bear eats the crisps.
  // det(bear, the-1)
  // det(crisps, the-4)
  // nsubj(eats, bear)
  //
  // In fact, these numbers are optional for all, so det(bear-2, the-1) would also be valid

  // now process the dependency relations
  _.each(inputLines, function (line, i) {
    if (line.indexOf(',') > -1) {
      // not root node
      var deprel = '',
          headToken = '',
          depToken = '',
          reading = 'deprel'; // reading \elem [ 'deprel', 'head', 'dep' ]

      for (var j = 0, l = line.length; j < l; j++) {
        var word = line[j];

        switch (reading) {
          case 'deprel':
            if (word === '(') {
              reading = 'head';
            } else {
              deprel += word;
            }
            break;
          case 'head':
            if (word === ',') {
              reading = 'dep';
            } else {
              headToken += word;
            }
            break;
          case 'dep':
            if (!(line[j - 1] === ',' && word === ' ' || word === ')')) depToken += word;
            break;
        }
      }

      var depId = void 0,
          headId = void 0;
      if (depToken.search(/-[0-9]+/) > 0) depId = parseInt(depToken.split('-')[1]);
      if (headToken.search(/-[0-9]+/) > 0) headId = parseInt(headToken.split('-')[1]);

      log.debug('sd2Conllu(): ' + depToken + ' \u2192 ' + headToken + ' @' + deprel + ' | ' + tokenToId[depToken] + ' : tokenToId[headToken] // ' + depId + ' \u2192 ' + headId);
      heads[depId] = headId;
      deprels[depId] = deprel;
    }
  });

  tokenId = 0;
  var sent = new nx.Sentence();
  sent.params = inputLines[0].split(' ').map(function (token) {
    tokenId++;

    return {
      form: token,
      head: heads[tokenId],
      deprel: deprels[tokenId]
    };
  });

  return sent.conllu;
}

/**
 * Takes a string in CoNLL-U, converts it to plain text.
 * @param {String} text Input string
 * @return {String}     Plain text
 */
function conllu2PlainText(text) {
  log.debug('called conllu2PlainText(' + text + ')');

  if (!text) return null;

  var sent = new nx.Sentence();
  sent.conllu = text;
  return sent.text;
}

/**
 * Takes a string in Brackets, converts it to CoNLL-U.
 * @param {String} text Input string
 * @return {String}     CoNLL-U
 */
function brackets2Conllu(text) {

  /**
   * first parse the sentence into a tree
   */
  function parse(text) {
    var Token = function () {
      function Token(parent) {
        _classCallCheck(this, Token);

        this.parent = parent;

        this.deprel = null;
        this.before = [];
        this.words = [];
        this.after = [];
      }

      _createClass(Token, [{
        key: 'eachBefore',
        value: function eachBefore(callback) {
          for (var i = 0; i < this.before.length; i++) {
            callback(this.before[i], i);
          }
        }
      }, {
        key: 'eachAfter',
        value: function eachAfter(callback) {
          for (var i = 0; i < this.after.length; i++) {
            callback(this.after[i], i);
          }
        }
      }, {
        key: 'tokenize',
        value: function tokenize(sent) {

          this.eachBefore(function (before) {
            sent = before.tokenize(sent);
          });

          var token = nx.Token.fromParams(sent, {
            form: this.words.join('-'),
            deprel: this.deprel
          });
          sent.insertTokenAt(Infinity, token);

          this.eachAfter(function (after) {
            sent = after.tokenize(sent);
          });

          this.analysis = token.analysis;

          return sent;
        }
      }, {
        key: 'dependize',
        value: function dependize(sent, id) {
          var _this = this;

          this.eachBefore(function (before) {
            sent = before.dependize(sent, _this.analysis.id);
          });

          var head = sent.getById(id);
          if (head) this.analysis.addHead(head, this.deprel);

          this.eachAfter(function (after) {
            sent = after.dependize(sent, _this.analysis.id);
          });

          return sent;
        }
      }, {
        key: 'toString',
        value: function toString() {
          return '[' + this.deprel + (this.before.length ? ' ' + this.before.map(function (token) {
            return token.toString();
          }).join(' ') : '') + ' ' + this.words.join(' ') + (this.after.length ? ' ' + this.after.map(function (token) {
            return token.toString();
          }).join(' ') : '') + ']';
        }
      }, {
        key: 'push',
        value: function push(token) {
          if (this.words.length) {
            this.after.push(token);
          } else {
            this.before.push(token);
          }
        }
      }, {
        key: 'addWord',
        value: function addWord(word) {
          if (!word) return;

          if (this.deprel) {
            this.words.push(word);
          } else {
            this.deprel = word;
          }
        }
      }]);

      return Token;
    }();

    var Sentence = function () {
      function Sentence() {
        _classCallCheck(this, Sentence);

        this.parent = null;
        this.root = [];
        this.comments = [];
      }

      _createClass(Sentence, [{
        key: 'encode',
        value: function encode() {
          var sent = new nx.Sentence();

          sent = this.root.tokenize(sent);
          sent.index();
          sent = this.root.dependize(sent, 0);
          sent.comments = this.comments;

          return sent;
        }
      }, {
        key: 'toString',
        value: function toString() {
          return '' + this.root.toString();
        }
      }, {
        key: 'push',
        value: function push(token) {
          this.root = token;
        }
      }]);

      return Sentence;
    }();

    var sent = new Sentence(),
        parsing = sent,
        parent = null,
        word = '';

    try {
      _.each(text, function (char) {
        switch (char) {
          case '[':
            parent = parsing;
            parsing = new Token(parent);
            if (parent && parent.push) parent.push(parsing);
            word = '';
            break;

          case ']':
            if (parsing.addWord) parsing.addWord(word);
            parsing = parsing.parent;
            parent = parsing.parent;
            word = '';
            break;

          case ' ':
            if (parsing.addWord) parsing.addWord(word);
            word = '';
            break;

          default:
            word += char;
            break;
        }
      });

      return sent;
    } catch (e) {

      if (!(e instanceof errors.ParseError)) throw e;

      return null;
    }
  }

  var parsed = parse(text);
  var encoded = parsed.encode();

  return encoded.conllu;
}

/**
 * Takes a string in CG3, converts it to CoNLL-U.
 * @param {String} CGtext CG3 string
 * @return {String}     CoNLL-U
 */
function cg32Conllu(CGtext) {
  log.debug('called cg32Conllu(' + CGtext + ')');

  if (!CGtext) return null;

  /* Takes a string in CG3, returns a string in CoNLL-U. */

  // remove extra spaces before newline before processing text
  var sent = new nx.Sentence({ catchInvalid: false });
  sent.cg3 = CGtext.replace(/ +\n/, '\n');

  try {
    return sent.conllu;
  } catch (e) {

    if (e instanceof nx.Error.InvalidCoNLLUError) {
      alerts.unableToConvertToConllu();
      return null;
    }

    throw e;
  }
}

/**
 * Takes a string in CoNLL-U, converts it to CG3.
 * @param {String} conlluText CoNLL-U string
 * @param {String} indent     indentation unit (default:'\t')
 * @return {String}     CG3
 */
function conllu2CG3(conlluText) {
  log.debug('called conllu2CG3(' + conlluText);

  if (!conlluText) return null;

  var sent = new nx.Sentence({ catchInvalid: false });
  sent.conllu = conlluText;

  try {
    return sent.cg3;
  } catch (e) {

    if (e instanceof nx.Error.InvalidCG3Error) {
      alerts.unableToConvertToCG3();
      return null;
    }

    throw e;
  }
}

/**
 * return a CG3 analysis for a token
 *  - helper function for conllu2CG3() and onEnter()
 */
function getCG3Analysis(i, token) {
  log.debug('called conllu2CG3:getCG3Analysis(i: ' + i + ', token: ' + JSON.stringify(token) + ')');

  var lemma = token.lemma ? '"' + token.lemma + '"' : '""',
      // lemma should have "" if blank (#228)
  pos = token.upostag || token.xpostag || '_',
      feats = token.feats ? ' ' + token.feats.replace(/\|/g, ' ') : '',
      deprel = token.deprel ? ' @' + token.deprel : ' @x',
      // is it really what we want by default?
  head = token.head || '',
      cgToken = lemma + ' ' + pos + feats + deprel + ' #' + token.id + '->' + head;

  log.debug('got cgToken: ' + cgToken);
  return cgToken;
};

/**
 * Cleans up CoNNL-U content.
 * @param {String} content Content of input area
 * @return {String}     Cleaned up content
 */
function cleanConllu(content) {
  log.debug('called cleanConllu(' + content + ')');

  if (!content) return null;

  // if we don't find any tabs, then convert >1 space to tabs
  // TODO: this should probably go somewhere else, and be more
  // robust, think about vietnamese D:
  var res = content.search('\n');
  if (res < 0) return content;

  /*
  // maybe someone is just trying to type conllu directly...
  res = (content.match(/_/g) || []).length;
  if (res <= 2)
      return content; */

  // If we don't find any tabs, then we want to replace multiple spaces with tabs
  var spaceToTab = true; //(content.search('\t') < 0);
  var newContent = content.trim().split('\n').map(function (line) {
    line = line.trim();

    // If there are no spaces and the line isn't a comment,
    // then replace more than one space with a tab
    if (line[0] !== '#' && spaceToTab) line = line.replace(/[ \t]+/g, '\t');

    return line;
  }).join('\n');

  // If there are >1 CoNLL-U format sentences is in the input, treat them as such
  // conlluMultiInput(newContent); // TODO: move this one also inside of this func, and make a separate func for calling them all at the same time

  //if (newContent !== content)
  //$('#text-data').val(newContent);

  return newContent;
}

module.exports = {
  to: {
    plainText: convert2PlainText,
    conllu: convert2Conllu,
    cg3: convert2CG3
  }
};

},{"./alerts":337,"./detect":343,"./errors":345,"notatrix":330,"underscore":335}],341:[function(require,module,exports){
'use strict';

// is defined in a js file, because fetch doesn't work offline in chrome

var ACTIVE_COLOR = '#2653c9',
    NORMAL_COLOR = '#7fa2ff',
    FANCY_COLOR = '#cc22fc',
    POS_COLOR = '#afa2ff',
    ST_COLOR = '#bcd2ff',
    MOVING_COLOR = '#00f';

var CY_STYLE = [{
  'selector': '*.disabled',
  'style': {
    'opacity': 0.4 /*
                   'background-color': '#f00',
                   'color': '#0ff'*/
  }
}, {
  'selector': 'node',
  'style': {
    'height': 20,
    'background-color': NORMAL_COLOR,
    'shape': 'roundrectangle',
    'text-valign': 'center',
    'text-halign': 'center',
    'border-color': '#000',
    'border-width': 1
  }
}, {
  'selector': 'node.form',
  'style': {
    'width': 'data(length)',
    'label': 'data(label)'
  }
}, {
  'selector': 'node.multiword',
  'style': {
    'background-color': ST_COLOR,
    'text-background-color': NORMAL_COLOR,
    'text-background-opacity': 0.9,
    'text-border-color': '#000',
    'text-border-opacity': 0.9,
    'text-border-width': '1px',
    'text-background-shape': 'roundrectangle',
    'text-valign': 'top',
    'label': 'data(label)'
  }
}, {
  'selector': 'node.multiword-active',
  'style': {
    'background-color': ACTIVE_COLOR
  }
}, {
  'selector': 'node.form.arc-source, node.form.arc-target',
  'style': {
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.form.root',
  'style': {
    'font-weight': 'bold',
    //'text-border-width': '2em',
    'border-width': '2px'
  }
}, {
  'selector': 'node.form.activated',
  'style': {
    'background-color': ACTIVE_COLOR
  }
}, {
  'selector': 'node.form.activated.retokenize',
  'style': {
    'background-color': POS_COLOR,
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.form.merge',
  'style': {
    'background-color': POS_COLOR,
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.form.supertoken',
  'style': {
    'background-color': POS_COLOR,
    'border-color': FANCY_COLOR
  }
}, {
  'selector': 'node.pos',
  'style': {
    'width': 'data(length)',
    'label': 'data(label)',
    'background-color': POS_COLOR
  }
}, {
  'selector': 'edge',
  'style': {
    'width': 3,
    'opacity': 0.766,
    'line-color': '#111',
    'control-point-weights': '0.2 0.25 0.75 0.8'
  }
}, {
  'selector': 'edge.incomplete',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#aaa',
    'line-color': '#aaa',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'arrow-scale': '1.5',
    'edge-distances': 'node-position',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.incomplete.vertical',
  'style': {
    'text-margin-y': 0,
    'text-background-opacity': 1,
    'text-background-color': 'white',
    'text-background-shape': 'roundrectangle',
    'text-border-color': 'black',
    'text-border-width': 1,
    'text-border-opacity': 1,
    'control-point-weights': '0.15 0.45 0.55 0.85',
    'text-margin-x': 'data(length)',
    'source-distance-from-node': 10,
    'target-distance-from-node': 10
  }
}, {
  'selector': 'edge.incomplete.horizontal',
  'style': {
    'text-margin-y': -10,
    'text-margin-x': 0,
    'text-background-opacity': 0,
    'text-border-opacity': 0,
    'control-point-weights': '0 0.25 0.75 1',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0
  }
}, {
  'selector': 'edge.error',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#d11',
    'line-color': '#d11',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'arrow-scale': '1.5',
    'edge-distances': 'node-position',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.enhanced',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#045',
    'line-color': '#045',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'edge-distances': 'node-position',
    'arrow-scale': '1.5',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.dependency',
  'style': {
    'target-arrow-shape': 'triangle',
    'target-arrow-color': '#111',
    'text-margin-y': -10,
    'curve-style': 'unbundled-bezier',
    'control-point-distances': 'data(ctrl)',
    'control-point-weights': '0 0.25 0.75 1',
    'edge-distances': 'node-position',
    'label': 'data(label)',
    'text-events': 'yes'
  }
}, {
  'selector': 'edge.dependency.selected',
  'style': {
    'line-color': FANCY_COLOR,
    'target-arrow-color': FANCY_COLOR
  }
}, { 'selector': 'edge.pos',
  'style': {
    'curve-style': 'haystack'
  }
}, {
  'selector': 'node.number',
  'style': {
    'background-opacity': 0,
    'border-opacity': 0,
    'padding': 0,
    'text-background-color': POS_COLOR,
    'text-background-opacity': 0.9,
    'text-border-color': '#000',
    'text-border-opacity': 0.9,
    'text-border-width': '1px',
    'text-background-shape': 'roundrectangle',
    'text-halign': 'right',
    'label': 'data(label)',
    'events': 'no'
  }
}, {
  'selector': 'edge.moving',
  'style': {
    'line-color': MOVING_COLOR,
    'target-arrow-color': MOVING_COLOR
  }
}];

module.exports = CY_STYLE;

},{}],342:[function(require,module,exports){
(function (global,setImmediate){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["cytoscape"] = factory();else root["cytoscape"] = factory();
})(typeof self !== 'undefined' ? self : undefined, function () {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 20);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      /*global HTMLElement DocumentTouch */

      var window = __webpack_require__(3);
      var navigator = window ? window.navigator : null;
      var document = window ? window.document : null;

      var typeofstr = _typeof('');
      var typeofobj = _typeof({});
      var typeoffn = _typeof(function () {});
      var typeofhtmlele = typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement);

      var instanceStr = function instanceStr(obj) {
        return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;
      };

      var is = {
        defined: function defined(obj) {
          return obj != null; // not undefined or null
        },

        string: function string(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == typeofstr;
        },

        fn: function fn(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeoffn;
        },

        array: function array(obj) {
          return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
        },

        plainObject: function plainObject(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj && !is.array(obj) && obj.constructor === Object;
        },

        object: function object(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj;
        },

        number: function number(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(1) && !isNaN(obj);
        },

        integer: function integer(obj) {
          return is.number(obj) && Math.floor(obj) === obj;
        },

        bool: function bool(obj) {
          return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(true);
        },

        htmlElement: function htmlElement(obj) {
          if ('undefined' === typeofhtmlele) {
            return undefined;
          } else {
            return null != obj && obj instanceof HTMLElement;
          }
        },

        elementOrCollection: function elementOrCollection(obj) {
          return is.element(obj) || is.collection(obj);
        },

        element: function element(obj) {
          return instanceStr(obj) === 'collection' && obj._private.single;
        },

        collection: function collection(obj) {
          return instanceStr(obj) === 'collection' && !obj._private.single;
        },

        core: function core(obj) {
          return instanceStr(obj) === 'core';
        },

        style: function style(obj) {
          return instanceStr(obj) === 'style';
        },

        stylesheet: function stylesheet(obj) {
          return instanceStr(obj) === 'stylesheet';
        },

        event: function event(obj) {
          return instanceStr(obj) === 'event';
        },

        thread: function thread(obj) {
          return instanceStr(obj) === 'thread';
        },

        fabric: function fabric(obj) {
          return instanceStr(obj) === 'fabric';
        },

        emptyString: function emptyString(obj) {
          if (obj === undefined || obj === null) {
            // null is empty
            return true;
          } else if (obj === '' || obj.match(/^\s+$/)) {
            return true; // empty string is empty
          }

          return false; // otherwise, we don't know what we've got
        },

        nonemptyString: function nonemptyString(obj) {
          if (obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/)) {
            return true;
          }

          return false;
        },

        domElement: function domElement(obj) {
          if (typeof HTMLElement === 'undefined') {
            return false; // we're not in a browser so it doesn't matter
          } else {
            return obj instanceof HTMLElement;
          }
        },

        boundingBox: function boundingBox(obj) {
          return is.plainObject(obj) && is.number(obj.x1) && is.number(obj.x2) && is.number(obj.y1) && is.number(obj.y2);
        },

        promise: function promise(obj) {
          return is.object(obj) && is.fn(obj.then);
        },

        touch: function touch() {
          return window && ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);
        },

        gecko: function gecko() {
          return window && (typeof InstallTrigger !== 'undefined' || 'MozAppearance' in document.documentElement.style);
        },

        webkit: function webkit() {
          return window && (typeof webkitURL !== 'undefined' || 'WebkitAppearance' in document.documentElement.style);
        },

        chromium: function chromium() {
          return window && typeof chrome !== 'undefined';
        },

        khtml: function khtml() {
          return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
        },

        khtmlEtc: function khtmlEtc() {
          return is.khtml() || is.webkit() || is.chromium();
        },

        ms: function ms() {
          return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
        },

        windows: function windows() {
          return navigator && navigator.appVersion.match(/Win/i);
        },

        mac: function mac() {
          return navigator && navigator.appVersion.match(/Mac/i);
        },

        linux: function linux() {
          return navigator && navigator.appVersion.match(/Linux/i);
        },

        unix: function unix() {
          return navigator && navigator.appVersion.match(/X11/i);
        }
      };

      module.exports = is;

      /***/
    },
    /* 1 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*global console */

      var is = __webpack_require__(0);
      var math = __webpack_require__(2);

      var util = {

        MAX_INT: Number.MAX_SAFE_INTEGER || 9007199254740991,

        trueify: function trueify() {
          return true;
        },

        falsify: function falsify() {
          return false;
        },

        zeroify: function zeroify() {
          return 0;
        },

        noop: function noop() {},

        error: function error(msg) {
          /* eslint-disable */
          if (console.error) {
            console.error.apply(console, arguments);

            if (console.trace) {
              console.trace();
            }
          } else {
            console.log.apply(console, arguments);

            if (console.trace) {
              console.trace();
            }
          }
          /* eslint-enable */
        },

        clone: function clone(obj) {
          return this.extend({}, obj);
        },

        // gets a shallow copy of the argument
        copy: function copy(obj) {
          if (obj == null) {
            return obj;
          }if (is.array(obj)) {
            return obj.slice();
          } else if (is.plainObject(obj)) {
            return this.clone(obj);
          } else {
            return obj;
          }
        },

        copyArray: function copyArray(arr) {
          return arr.slice();
        },

        clonePosition: function clonePosition(pos) {
          return { x: pos.x, y: pos.y };
        },

        uuid: function uuid(a, b // placeholders
        ) {
          for ( // loop :)
          b = a = ''; // b - result , a - numeric letiable
          a++ < 36; //
          b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
          ? //  return a random number or 4
          (a ^ 15 // if "a" is not 15
          ? // genetate a random number from 0 to 15
          8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
          : 4 //  otherwise 4
          ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
          ) {}
          return b;
        }

      };

      util.makeBoundingBox = math.makeBoundingBox.bind(math);

      util._staticEmptyObject = {};

      util.staticEmptyObject = function () {
        return util._staticEmptyObject;
      };

      util.extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
        var args = arguments;

        for (var i = 1; i < args.length; i++) {
          var obj = args[i];

          if (obj == null) {
            continue;
          }

          var keys = Object.keys(obj);

          for (var j = 0; j < keys.length; j++) {
            var k = keys[j];

            tgt[k] = obj[k];
          }
        }

        return tgt;
      };

      util.assign = util.extend;

      util.default = function (val, def) {
        if (val === undefined) {
          return def;
        } else {
          return val;
        }
      };

      util.removeFromArray = function (arr, ele, manyCopies) {
        for (var i = arr.length; i >= 0; i--) {
          if (arr[i] === ele) {
            arr.splice(i, 1);

            if (!manyCopies) {
              break;
            }
          }
        }
      };

      util.clearArray = function (arr) {
        arr.splice(0, arr.length);
      };

      util.push = function (arr, otherArr) {
        for (var i = 0; i < otherArr.length; i++) {
          var el = otherArr[i];

          arr.push(el);
        }
      };

      util.getPrefixedProperty = function (obj, propName, prefix) {
        if (prefix) {
          propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
        }

        return obj[propName];
      };

      util.setPrefixedProperty = function (obj, propName, prefix, value) {
        if (prefix) {
          propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
        }

        obj[propName] = value;
      };

      [__webpack_require__(21), __webpack_require__(22), { memoize: __webpack_require__(13) }, __webpack_require__(23), __webpack_require__(24), __webpack_require__(25), __webpack_require__(27)].forEach(function (req) {
        util.extend(util, req);
      });

      module.exports = util;

      /***/
    },
    /* 2 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = {};

      math.arePositionsSame = function (p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      };

      math.copyPosition = function (p) {
        return { x: p.x, y: p.y };
      };

      math.modelToRenderedPosition = function (p, zoom, pan) {
        return {
          x: p.x * zoom + pan.x,
          y: p.y * zoom + pan.y
        };
      };

      math.renderedToModelPosition = function (p, zoom, pan) {
        return {
          x: (p.x - pan.x) / zoom,
          y: (p.y - pan.y) / zoom
        };
      };

      math.array2point = function (arr) {
        return {
          x: arr[0],
          y: arr[1]
        };
      };

      math.deg2rad = function (deg) {
        return Math.PI * deg / 180;
      };

      math.getAngleFromDisp = function (dispX, dispY) {
        return Math.atan2(dispY, dispX) - Math.PI / 2;
      };

      math.log2 = Math.log2 || function (n) {
        return Math.log(n) / Math.log(2);
      };

      math.signum = function (x) {
        if (x > 0) {
          return 1;
        } else if (x < 0) {
          return -1;
        } else {
          return 0;
        }
      };

      math.dist = function (p1, p2) {
        return Math.sqrt(math.sqdist(p1, p2));
      };

      math.sqdist = function (p1, p2) {
        var dx = p2.x - p1.x;
        var dy = p2.y - p1.y;

        return dx * dx + dy * dy;
      };

      // from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves
      math.qbezierAt = function (p0, p1, p2, t) {
        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
      };

      math.qbezierPtAt = function (p0, p1, p2, t) {
        return {
          x: math.qbezierAt(p0.x, p1.x, p2.x, t),
          y: math.qbezierAt(p0.y, p1.y, p2.y, t)
        };
      };

      math.lineAt = function (p0, p1, t, d) {
        var vec = {
          x: p1.x - p0.x,
          y: p1.y - p0.y
        };

        var vecDist = math.dist(p0, p1);

        var normVec = {
          x: vec.x / vecDist,
          y: vec.y / vecDist
        };

        t = t == null ? 0 : t;

        d = d != null ? d : t * vecDist;

        return {
          x: p0.x + normVec.x * d,
          y: p0.y + normVec.y * d
        };
      };

      math.lineAtDist = function (p0, p1, d) {
        return math.lineAt(p0, p1, undefined, d);
      };

      // get angle at A via cosine law
      math.triangleAngle = function (A, B, C) {
        var a = math.dist(B, C);
        var b = math.dist(A, C);
        var c = math.dist(A, B);

        return Math.acos((a * a + b * b - c * c) / (2 * a * b));
      };

      math.bound = function (min, val, max) {
        return Math.max(min, Math.min(max, val));
      };

      // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
      math.makeBoundingBox = function (bb) {
        if (bb == null) {
          return {
            x1: Infinity,
            y1: Infinity,
            x2: -Infinity,
            y2: -Infinity,
            w: 0,
            h: 0
          };
        } else if (bb.x1 != null && bb.y1 != null) {
          if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
            return {
              x1: bb.x1,
              y1: bb.y1,
              x2: bb.x2,
              y2: bb.y2,
              w: bb.x2 - bb.x1,
              h: bb.y2 - bb.y1
            };
          } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
            return {
              x1: bb.x1,
              y1: bb.y1,
              x2: bb.x1 + bb.w,
              y2: bb.y1 + bb.h,
              w: bb.w,
              h: bb.h
            };
          }
        }
      };

      math.updateBoundingBox = function (bb1, bb2) {
        // update bb1 with bb2 bounds

        bb1.x1 = Math.min(bb1.x1, bb2.x1);
        bb1.x2 = Math.max(bb1.x2, bb2.x2);
        bb1.w = bb1.x2 - bb1.x1;

        bb1.y1 = Math.min(bb1.y1, bb2.y1);
        bb1.y2 = Math.max(bb1.y2, bb2.y2);
        bb1.h = bb1.y2 - bb1.y1;
      };

      math.expandBoundingBoxByPoint = function (bb, x, y) {
        bb.x1 = Math.min(bb.x1, x);
        bb.x2 = Math.max(bb.x2, x);
        bb.w = bb.x2 - bb.x1;

        bb.y1 = Math.min(bb.y1, y);
        bb.y2 = Math.max(bb.y2, y);
        bb.h = bb.y2 - bb.y1;
      };

      math.expandBoundingBox = function (bb, padding) {
        bb.x1 -= padding;
        bb.x2 += padding;
        bb.y1 -= padding;
        bb.y2 += padding;
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

        return bb;
      };

      math.boundingBoxesIntersect = function (bb1, bb2) {
        // case: one bb to right of other
        if (bb1.x1 > bb2.x2) {
          return false;
        }
        if (bb2.x1 > bb1.x2) {
          return false;
        }

        // case: one bb to left of other
        if (bb1.x2 < bb2.x1) {
          return false;
        }
        if (bb2.x2 < bb1.x1) {
          return false;
        }

        // case: one bb above other
        if (bb1.y2 < bb2.y1) {
          return false;
        }
        if (bb2.y2 < bb1.y1) {
          return false;
        }

        // case: one bb below other
        if (bb1.y1 > bb2.y2) {
          return false;
        }
        if (bb2.y1 > bb1.y2) {
          return false;
        }

        // otherwise, must have some overlap
        return true;
      };

      math.inBoundingBox = function (bb, x, y) {
        return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
      };

      math.pointInBoundingBox = function (bb, pt) {
        return this.inBoundingBox(bb, pt.x, pt.y);
      };

      math.boundingBoxInBoundingBox = function (bb1, bb2) {
        return math.inBoundingBox(bb1, bb2.x1, bb2.y1) && math.inBoundingBox(bb1, bb2.x2, bb2.y2);
      };

      math.roundRectangleIntersectLine = function (x, y, nodeX, nodeY, width, height, padding) {

        var cornerRadius = this.getRoundRectangleRadius(width, height);

        var halfWidth = width / 2;
        var halfHeight = height / 2;

        // Check intersections with straight line segments
        var straightLineIntersections = void 0;

        // Top segment, left to right
        {
          var topStartX = nodeX - halfWidth + cornerRadius - padding;
          var topStartY = nodeY - halfHeight - padding;
          var topEndX = nodeX + halfWidth - cornerRadius + padding;
          var topEndY = topStartY;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Right segment, top to bottom
        {
          var rightStartX = nodeX + halfWidth + padding;
          var rightStartY = nodeY - halfHeight + cornerRadius - padding;
          var rightEndX = rightStartX;
          var rightEndY = nodeY + halfHeight - cornerRadius + padding;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Bottom segment, left to right
        {
          var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
          var bottomStartY = nodeY + halfHeight + padding;
          var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
          var bottomEndY = bottomStartY;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Left segment, top to bottom
        {
          var leftStartX = nodeX - halfWidth - padding;
          var leftStartY = nodeY - halfHeight + cornerRadius - padding;
          var leftEndX = leftStartX;
          var leftEndY = nodeY + halfHeight - cornerRadius + padding;

          straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        }

        // Check intersections with arc segments
        var arcIntersections = void 0;

        // Top Left
        {
          var topLeftCenterX = nodeX - halfWidth + cornerRadius;
          var topLeftCenterY = nodeY - halfHeight + cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        // Top Right
        {
          var topRightCenterX = nodeX + halfWidth - cornerRadius;
          var topRightCenterY = nodeY - halfHeight + cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        // Bottom Right
        {
          var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
          var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        // Bottom Left
        {
          var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
          var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
          arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);

          // Ensure the intersection is on the desired quarter of the circle
          if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }

        return []; // if nothing
      };

      math.inLineVicinity = function (x, y, lx1, ly1, lx2, ly2, tolerance) {
        var t = tolerance;

        var x1 = Math.min(lx1, lx2);
        var x2 = Math.max(lx1, lx2);
        var y1 = Math.min(ly1, ly2);
        var y2 = Math.max(ly1, ly2);

        return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
      };

      math.inBezierVicinity = function (x, y, x1, y1, x2, y2, x3, y3, tolerance) {

        var bb = {
          x1: Math.min(x1, x3, x2) - tolerance,
          x2: Math.max(x1, x3, x2) + tolerance,
          y1: Math.min(y1, y3, y2) - tolerance,
          y2: Math.max(y1, y3, y2) + tolerance
        };

        // if outside the rough bounding box for the bezier, then it can't be a hit
        if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
          // console.log('bezier out of rough bb')
          return false;
        } else {
          // console.log('do more expensive check');
          return true;
        }
      };
      math.solveQuadratic = function (a, b, c, val) {
        c -= val;

        var r = b * b - 4 * a * c;

        if (r < 0) {
          return [];
        }

        var sqrtR = Math.sqrt(r);
        var denom = 2 * a;
        var root1 = (-b + sqrtR) / denom;
        var root2 = (-b - sqrtR) / denom;

        return [root1, root2];
      };

      math.solveCubic = function (a, b, c, d, result) {

        // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
        // r is the real component, i is the imaginary component

        // An implementation of the Cardano method from the year 1545
        // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

        b /= a;
        c /= a;
        d /= a;

        var discriminant = void 0,
            q = void 0,
            r = void 0,
            dum1 = void 0,
            s = void 0,
            t = void 0,
            term1 = void 0,
            r13 = void 0;

        q = (3.0 * c - b * b) / 9.0;
        r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
        r /= 54.0;

        discriminant = q * q * q + r * r;
        result[1] = 0;
        term1 = b / 3.0;

        if (discriminant > 0) {
          s = r + Math.sqrt(discriminant);
          s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
          t = r - Math.sqrt(discriminant);
          t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
          result[0] = -term1 + s + t;
          term1 += (s + t) / 2.0;
          result[4] = result[2] = -term1;
          term1 = Math.sqrt(3.0) * (-t + s) / 2;
          result[3] = term1;
          result[5] = -term1;
          return;
        }

        result[5] = result[3] = 0;

        if (discriminant === 0) {
          r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
          result[0] = -term1 + 2.0 * r13;
          result[4] = result[2] = -(r13 + term1);
          return;
        }

        q = -q;
        dum1 = q * q * q;
        dum1 = Math.acos(r / Math.sqrt(dum1));
        r13 = 2.0 * Math.sqrt(q);
        result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
        result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
        result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);

        return;
      };

      math.sqdistToQuadraticBezier = function (x, y, x1, y1, x2, y2, x3, y3) {

        // Find minimum distance by using the minimum of the distance
        // function between the given point and the curve

        // This gives the coefficients of the resulting cubic equation
        // whose roots tell us where a possible minimum is
        // (Coefficients are divided by 4)

        var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

        var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

        var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

        var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

        // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

        var roots = [];

        // Use the cubic solving algorithm
        this.solveCubic(a, b, c, d, roots);

        var zeroThreshold = 0.0000001;

        var params = [];

        for (var index = 0; index < 6; index += 2) {
          if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
            params.push(roots[index]);
          }
        }

        params.push(1.0);
        params.push(0.0);

        var minDistanceSquared = -1;

        var curX = void 0,
            curY = void 0,
            distSquared = void 0;
        for (var i = 0; i < params.length; i++) {
          curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;

          curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;

          distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
          // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
          if (minDistanceSquared >= 0) {
            if (distSquared < minDistanceSquared) {
              minDistanceSquared = distSquared;
            }
          } else {
            minDistanceSquared = distSquared;
          }
        }

        return minDistanceSquared;
      };

      math.sqdistToFiniteLine = function (x, y, x1, y1, x2, y2) {
        var offset = [x - x1, y - y1];
        var line = [x2 - x1, y2 - y1];

        var lineSq = line[0] * line[0] + line[1] * line[1];
        var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

        var dotProduct = offset[0] * line[0] + offset[1] * line[1];
        var adjSq = dotProduct * dotProduct / lineSq;

        if (dotProduct < 0) {
          return hypSq;
        }

        if (adjSq > lineSq) {
          return (x - x2) * (x - x2) + (y - y2) * (y - y2);
        }

        return hypSq - adjSq;
      };

      math.pointInsidePolygonPoints = function (x, y, points) {
        var x1 = void 0,
            y1 = void 0,
            x2 = void 0,
            y2 = void 0;
        var y3 = void 0;

        // Intersect with vertical line through (x, y)
        var up = 0;
        // let down = 0;
        for (var i = 0; i < points.length / 2; i++) {
          x1 = points[i * 2];
          y1 = points[i * 2 + 1];

          if (i + 1 < points.length / 2) {
            x2 = points[(i + 1) * 2];
            y2 = points[(i + 1) * 2 + 1];
          } else {
            x2 = points[(i + 1 - points.length / 2) * 2];
            y2 = points[(i + 1 - points.length / 2) * 2 + 1];
          }

          if (x1 == x && x2 == x) {
            // then ignore
          } else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {

            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

            if (y3 > y) {
              up++;
            }

            // if( y3 < y ){
            // down++;
            // }
          } else {
            continue;
          }
        }

        if (up % 2 === 0) {
          return false;
        } else {
          return true;
        }
      };

      math.pointInsidePolygon = function (x, y, basePoints, centerX, centerY, width, height, direction, padding) {

        //let direction = arguments[6];
        var transformedPoints = new Array(basePoints.length);

        // Gives negative angle
        var angle = void 0;

        if (direction[0] != null) {
          angle = Math.atan(direction[1] / direction[0]);

          if (direction[0] < 0) {
            angle = angle + Math.PI / 2;
          } else {
            angle = -angle - Math.PI / 2;
          }
        } else {
          angle = direction;
        }

        var cos = Math.cos(-angle);
        var sin = Math.sin(-angle);

        //    console.log("base: " + basePoints);
        for (var i = 0; i < transformedPoints.length / 2; i++) {
          transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);

          transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);

          transformedPoints[i * 2] += centerX;
          transformedPoints[i * 2 + 1] += centerY;
        }

        var points = void 0;

        if (padding > 0) {
          var expandedLineSet = this.expandPolygon(transformedPoints, -padding);

          points = this.joinLines(expandedLineSet);
        } else {
          points = transformedPoints;
        }

        return math.pointInsidePolygonPoints(x, y, points);
      };

      math.joinLines = function (lineSet) {

        var vertices = new Array(lineSet.length / 2);

        var currentLineStartX = void 0,
            currentLineStartY = void 0,
            currentLineEndX = void 0,
            currentLineEndY = void 0;
        var nextLineStartX = void 0,
            nextLineStartY = void 0,
            nextLineEndX = void 0,
            nextLineEndY = void 0;

        for (var i = 0; i < lineSet.length / 4; i++) {
          currentLineStartX = lineSet[i * 4];
          currentLineStartY = lineSet[i * 4 + 1];
          currentLineEndX = lineSet[i * 4 + 2];
          currentLineEndY = lineSet[i * 4 + 3];

          if (i < lineSet.length / 4 - 1) {
            nextLineStartX = lineSet[(i + 1) * 4];
            nextLineStartY = lineSet[(i + 1) * 4 + 1];
            nextLineEndX = lineSet[(i + 1) * 4 + 2];
            nextLineEndY = lineSet[(i + 1) * 4 + 3];
          } else {
            nextLineStartX = lineSet[0];
            nextLineStartY = lineSet[1];
            nextLineEndX = lineSet[2];
            nextLineEndY = lineSet[3];
          }

          var intersection = this.finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);

          vertices[i * 2] = intersection[0];
          vertices[i * 2 + 1] = intersection[1];
        }

        return vertices;
      };

      math.expandPolygon = function (points, pad) {

        var expandedLineSet = new Array(points.length * 2);

        var currentPointX = void 0,
            currentPointY = void 0,
            nextPointX = void 0,
            nextPointY = void 0;

        for (var i = 0; i < points.length / 2; i++) {
          currentPointX = points[i * 2];
          currentPointY = points[i * 2 + 1];

          if (i < points.length / 2 - 1) {
            nextPointX = points[(i + 1) * 2];
            nextPointY = points[(i + 1) * 2 + 1];
          } else {
            nextPointX = points[0];
            nextPointY = points[1];
          }

          // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

          // Assume CCW polygon winding

          var offsetX = nextPointY - currentPointY;
          var offsetY = -(nextPointX - currentPointX);

          // Normalize
          var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
          var normalizedOffsetX = offsetX / offsetLength;
          var normalizedOffsetY = offsetY / offsetLength;

          expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
          expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
          expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
          expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
        }

        return expandedLineSet;
      };

      math.intersectLineEllipse = function (x, y, centerX, centerY, ellipseWradius, ellipseHradius) {

        var dispX = centerX - x;
        var dispY = centerY - y;

        dispX /= ellipseWradius;
        dispY /= ellipseHradius;

        var len = Math.sqrt(dispX * dispX + dispY * dispY);

        var newLength = len - 1;

        if (newLength < 0) {
          return [];
        }

        var lenProportion = newLength / len;

        return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
      };

      math.checkInEllipse = function (x, y, width, height, centerX, centerY, padding) {
        x -= centerX;
        y -= centerY;

        x /= width / 2 + padding;
        y /= height / 2 + padding;

        return x * x + y * y <= 1;
      };

      // Returns intersections of increasing distance from line's start point
      math.intersectLineCircle = function (x1, y1, x2, y2, centerX, centerY, radius) {

        // Calculate d, direction vector of line
        var d = [x2 - x1, y2 - y1]; // Direction vector of line
        var f = [x1 - centerX, y1 - centerY];

        var a = d[0] * d[0] + d[1] * d[1];
        var b = 2 * (f[0] * d[0] + f[1] * d[1]);
        var c = f[0] * f[0] + f[1] * f[1] - radius * radius;

        var discriminant = b * b - 4 * a * c;

        if (discriminant < 0) {
          return [];
        }

        var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
        var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);

        var tMin = Math.min(t1, t2);
        var tMax = Math.max(t1, t2);
        var inRangeParams = [];

        if (tMin >= 0 && tMin <= 1) {
          inRangeParams.push(tMin);
        }

        if (tMax >= 0 && tMax <= 1) {
          inRangeParams.push(tMax);
        }

        if (inRangeParams.length === 0) {
          return [];
        }

        var nearIntersectionX = inRangeParams[0] * d[0] + x1;
        var nearIntersectionY = inRangeParams[0] * d[1] + y1;

        if (inRangeParams.length > 1) {

          if (inRangeParams[0] == inRangeParams[1]) {
            return [nearIntersectionX, nearIntersectionY];
          } else {

            var farIntersectionX = inRangeParams[1] * d[0] + x1;
            var farIntersectionY = inRangeParams[1] * d[1] + y1;

            return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
          }
        } else {
          return [nearIntersectionX, nearIntersectionY];
        }
      };

      math.findCircleNearPoint = function (centerX, centerY, radius, farX, farY) {

        var displacementX = farX - centerX;
        var displacementY = farY - centerY;
        var distance = Math.sqrt(displacementX * displacementX + displacementY * displacementY);

        var unitDisplacementX = displacementX / distance;
        var unitDisplacementY = displacementY / distance;

        return [centerX + unitDisplacementX * radius, centerY + unitDisplacementY * radius];
      };

      math.findMaxSqDistanceToOrigin = function (points) {
        var maxSqDistance = 0.000001;
        var sqDistance = void 0;

        for (var i = 0; i < points.length / 2; i++) {

          sqDistance = points[i * 2] * points[i * 2] + points[i * 2 + 1] * points[i * 2 + 1];

          if (sqDistance > maxSqDistance) {
            maxSqDistance = sqDistance;
          }
        }

        return maxSqDistance;
      };

      math.midOfThree = function (a, b, c) {
        if (b <= a && a <= c || c <= a && a <= b) {
          return a;
        } else if (a <= b && b <= c || c <= b && b <= a) {
          return b;
        } else {
          return c;
        }
      };

      // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
      math.finiteLinesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {

        var dx13 = x1 - x3;
        var dx21 = x2 - x1;
        var dx43 = x4 - x3;

        var dy13 = y1 - y3;
        var dy21 = y2 - y1;
        var dy43 = y4 - y3;

        var ua_t = dx43 * dy13 - dy43 * dx13;
        var ub_t = dx21 * dy13 - dy21 * dx13;
        var u_b = dy43 * dx21 - dx43 * dy21;

        if (u_b !== 0) {
          var ua = ua_t / u_b;
          var ub = ub_t / u_b;

          var flptThreshold = 0.001;
          var min = 0 - flptThreshold;
          var max = 1 + flptThreshold;

          if (min <= ua && ua <= max && min <= ub && ub <= max) {
            return [x1 + ua * dx21, y1 + ua * dy21];
          } else {
            if (!infiniteLines) {
              return [];
            } else {
              return [x1 + ua * dx21, y1 + ua * dy21];
            }
          }
        } else {
          if (ua_t === 0 || ub_t === 0) {

            // Parallel, coincident lines. Check if overlap

            // Check endpoint of second line
            if (this.midOfThree(x1, x2, x4) === x4) {
              return [x4, y4];
            }

            // Check start point of second line
            if (this.midOfThree(x1, x2, x3) === x3) {
              return [x3, y3];
            }

            // Endpoint of first line
            if (this.midOfThree(x3, x4, x2) === x2) {
              return [x2, y2];
            }

            return [];
          } else {

            // Parallel, non-coincident
            return [];
          }
        }
      };

      // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
      // intersect a node polygon (pts transformed)
      //
      // math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
      // intersect the points (no transform)
      math.polygonIntersectLine = function (x, y, basePoints, centerX, centerY, width, height, padding) {

        var intersections = [];
        var intersection = void 0;

        var transformedPoints = new Array(basePoints.length);

        var doTransform = true;
        if (arguments.length === 5) {
          doTransform = false;
        }

        var points = void 0;

        if (doTransform) {
          for (var i = 0; i < transformedPoints.length / 2; i++) {
            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
          }

          if (padding > 0) {
            var expandedLineSet = math.expandPolygon(transformedPoints, -padding);

            points = math.joinLines(expandedLineSet);
          } else {
            points = transformedPoints;
          }
        } else {
          points = basePoints;
        }

        var currentX = void 0,
            currentY = void 0,
            nextX = void 0,
            nextY = void 0;

        for (var _i = 0; _i < points.length / 2; _i++) {

          currentX = points[_i * 2];
          currentY = points[_i * 2 + 1];

          if (_i < points.length / 2 - 1) {
            nextX = points[(_i + 1) * 2];
            nextY = points[(_i + 1) * 2 + 1];
          } else {
            nextX = points[0];
            nextY = points[1];
          }

          intersection = this.finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

          if (intersection.length !== 0) {
            intersections.push(intersection[0], intersection[1]);
          }
        }

        return intersections;
      };

      math.shortenIntersection = function (intersection, offset, amount) {

        var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];

        var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);

        var lenRatio = (length - amount) / length;

        if (lenRatio < 0) {
          lenRatio = 0.00001;
        }

        return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
      };

      math.generateUnitNgonPointsFitToSquare = function (sides, rotationRadians) {
        var points = math.generateUnitNgonPoints(sides, rotationRadians);
        points = math.fitPolygonToSquare(points);

        return points;
      };

      math.fitPolygonToSquare = function (points) {
        var x = void 0,
            y = void 0;
        var sides = points.length / 2;
        var minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;

        for (var i = 0; i < sides; i++) {
          x = points[2 * i];
          y = points[2 * i + 1];

          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        // stretch factors
        var sx = 2 / (maxX - minX);
        var sy = 2 / (maxY - minY);

        for (var _i2 = 0; _i2 < sides; _i2++) {
          x = points[2 * _i2] = points[2 * _i2] * sx;
          y = points[2 * _i2 + 1] = points[2 * _i2 + 1] * sy;

          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        if (minY < -1) {
          for (var _i3 = 0; _i3 < sides; _i3++) {
            y = points[2 * _i3 + 1] = points[2 * _i3 + 1] + (-1 - minY);
          }
        }

        return points;
      };

      math.generateUnitNgonPoints = function (sides, rotationRadians) {

        var increment = 1.0 / sides * 2 * Math.PI;
        var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;

        startAngle += rotationRadians;

        var points = new Array(sides * 2);

        var currentAngle = void 0;
        for (var i = 0; i < sides; i++) {
          currentAngle = i * increment + startAngle;

          points[2 * i] = Math.cos(currentAngle); // x
          points[2 * i + 1] = Math.sin(-currentAngle); // y
        }

        return points;
      };

      math.getRoundRectangleRadius = function (width, height) {

        // Set the default radius, unless half of width or height is smaller than default
        return Math.min(width / 4, height / 4, 8);
      };

      math.getCutRectangleCornerLength = function () {
        return 8;
      };

      math.bezierPtsToQuadCoeff = function (p0, p1, p2) {
        return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
      };

      math.getBarrelCurveConstants = function (width, height) {
        // get curve width, height, and control point position offsets as a percentage of node height / width
        return {
          heightOffset: Math.min(15, 0.05 * height),
          widthOffset: Math.min(100, 0.25 * width),
          ctrlPtOffsetPct: 0.05
        };
      };

      module.exports = math;

      /***/
    },
    /* 3 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

      /***/
    },
    /* 4 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      // use this module to cherry pick functions into your prototype
      // (useful for functions shared between the core and collections, for example)

      // e.g.
      // let foo = define.foo({ /* params... */ })

      var util = __webpack_require__(1);

      var define = {};

      [__webpack_require__(44), __webpack_require__(46), __webpack_require__(47)].forEach(function (m) {
        util.assign(define, m);
      });

      module.exports = define;

      /***/
    },
    /* 5 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      /*!
      Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
      Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
      Licensed under The MIT License (http://opensource.org/licenses/MIT)
      */

      /*  promise states [Promises/A+ 2.1]  */
      var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */
      var STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */
      var STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */

      /*  promise object constructor  */
      var api = function api(executor) {
        /*  optionally support non-constructor/plain-function call  */
        if (!(this instanceof api)) return new api(executor);

        /*  initialize object  */
        this.id = 'Thenable/1.0.7';
        this.state = STATE_PENDING; /*  initial state  */
        this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */
        this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */
        this.onFulfilled = []; /*  initial handlers  */
        this.onRejected = []; /*  initial handlers  */

        /*  provide optional information-hiding proxy  */
        this.proxy = {
          then: this.then.bind(this)
        };

        /*  support optional executor function  */
        if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
      };

      /*  promise API methods  */
      api.prototype = {
        /*  promise resolving methods  */
        fulfill: function fulfill(value) {
          return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
        },
        reject: function reject(value) {
          return deliver(this, STATE_REJECTED, 'rejectReason', value);
        },

        /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
        then: function then(onFulfilled, onRejected) {
          var curr = this;
          var next = new api(); /*  [Promises/A+ 2.2.7]  */
          curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */
          curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */
          execute(curr);
          return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */
        }
      };

      /*  deliver an action  */
      var deliver = function deliver(curr, state, name, value) {
        if (curr.state === STATE_PENDING) {
          curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
          curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
          execute(curr);
        }
        return curr;
      };

      /*  execute all handlers  */
      var execute = function execute(curr) {
        if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
      };

      /*  execute particular set of handlers  */
      var execute_handlers = function execute_handlers(curr, name, value) {
        /* global setImmediate: true */
        /* global setTimeout: true */

        /*  short-circuit processing  */
        if (curr[name].length === 0) return;

        /*  iterate over all handlers, exactly once  */
        var handlers = curr[name];
        curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
        var func = function func() {
          for (var i = 0; i < handlers.length; i++) {
            handlers[i](value);
          } /*  [Promises/A+ 2.2.5]  */
        };

        /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */
        if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
      };

      /*  generate a resolver function  */
      var resolver = function resolver(cb, next, method) {
        return function (value) {
          if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
            next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
          else {
              var result;
              try {
                result = cb(value);
              } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
              catch (e) {
                next.reject(e); /*  [Promises/A+ 2.2.7.2]  */
                return;
              }
              resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */
            }
        };
      };

      /*  "Promise Resolution Procedure"  */ /*  [Promises/A+ 2.3]  */
      var resolve = function resolve(promise, x) {
        /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */
        if (promise === x || promise.proxy === x) {
          promise.reject(new TypeError('cannot resolve promise with itself'));
          return;
        }

        /*  surgically check for a "then" method
          (mainly to just call the "getter" of "then" only once)  */
        var then;
        if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function') {
          try {
            then = x.then;
          } /*  [Promises/A+ 2.3.3.1, 3.5]  */
          catch (e) {
            promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */
            return;
          }
        }

        /*  handle own Thenables    [Promises/A+ 2.3.2]
          and similar "thenables" [Promises/A+ 2.3.3]  */
        if (typeof then === 'function') {
          var resolved = false;
          try {
            /*  call retrieved "then" method */ /*  [Promises/A+ 2.3.3.3]  */
            then.call(x,
            /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */
            function (y) {
              if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
              if (y === x) /*  [Promises/A+ 3.6]  */
                promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
            },

            /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */
            function (r) {
              if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
              promise.reject(r);
            });
          } catch (e) {
            if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */
              promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */
          }
          return;
        }

        /*  handle other values  */
        promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
      };

      // so we always have Promise.all()
      api.all = function (ps) {
        return new api(function (resolveAll, rejectAll) {
          var vals = new Array(ps.length);
          var doneCount = 0;

          var fulfill = function fulfill(i, val) {
            vals[i] = val;
            doneCount++;

            if (doneCount === ps.length) {
              resolveAll(vals);
            }
          };

          for (var i = 0; i < ps.length; i++) {
            (function (i) {
              var p = ps[i];
              var isPromise = p != null && p.then != null;

              if (isPromise) {
                p.then(function (val) {
                  fulfill(i, val);
                }, function (err) {
                  rejectAll(err);
                });
              } else {
                var val = p;
                fulfill(i, val);
              }
            })(i);
          }
        });
      };

      api.resolve = function (val) {
        return new api(function (resolve, reject) {
          resolve(val);
        });
      };

      api.reject = function (val) {
        return new api(function (resolve, reject) {
          reject(val);
        });
      };

      module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

      /***/
    },
    /* 6 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var newQuery = __webpack_require__(10);

      var Selector = function Selector(selector) {
        var self = this;

        self._private = {
          selectorText: selector,
          invalid: true
        };

        if (selector == null || is.string(selector) && selector.match(/^\s*$/)) {

          self.length = 0;
        } else if (selector === '*' || selector === 'edge' || selector === 'node') {

          // make single, group-only selectors cheap to make and cheap to filter

          self[0] = newQuery();
          self[0].group = selector === '*' ? selector : selector + 's';
          self[0].groupOnly = true;
          self[0].length = 1;
          self._private.invalid = false;
          self.length = 1;
        } else if (is.elementOrCollection(selector)) {

          var collection = selector.collection();

          self[0] = newQuery();
          self[0].collection = collection;
          self[0].length = 1;
          self.length = 1;
        } else if (is.fn(selector)) {

          self[0] = newQuery();
          self[0].filter = selector;
          self[0].length = 1;
          self.length = 1;
        } else if (is.string(selector)) {
          if (!self.parse(selector)) {
            return;
          }
        } else {
          util.error('A selector must be created from a string; found ', selector);
          return;
        }

        self._private.invalid = false;
      };

      var selfn = Selector.prototype;

      selfn.valid = function () {
        return !this._private.invalid;
      };

      selfn.invalid = function () {
        return this._private.invalid;
      };

      selfn.text = function () {
        return this._private.selectorText;
      };

      selfn.size = function () {
        return this.length;
      };

      selfn.eq = function (i) {
        return this[i];
      };

      selfn.sameText = function (otherSel) {
        return this.text() === otherSel.text();
      };

      selfn.toString = selfn.selector = function () {

        if (this._private.toStringCache != null) {
          return this._private.toStringCache;
        }

        var i = void 0;
        var str = '';

        var clean = function clean(obj) {
          if (obj == null) {
            return '';
          } else {
            return obj;
          }
        };

        var cleanVal = function cleanVal(val) {
          if (is.string(val)) {
            return '"' + val + '"';
          } else {
            return clean(val);
          }
        };

        var space = function space(val) {
          return ' ' + val + ' ';
        };

        var queryToString = function queryToString(query) {
          var str = '';
          var j = void 0,
              sel = void 0;

          if (query.subject === query) {
            str += '$';
          }

          var group = clean(query.group);
          str += group.substring(0, group.length - 1);

          for (j = 0; j < query.data.length; j++) {
            var data = query.data[j];

            if (data.value) {
              str += '[' + data.field + space(clean(data.operator)) + cleanVal(data.value) + ']';
            } else {
              str += '[' + clean(data.operator) + data.field + ']';
            }
          }

          for (j = 0; j < query.meta.length; j++) {
            var meta = query.meta[j];
            str += '[[' + meta.field + space(clean(meta.operator)) + cleanVal(meta.value) + ']]';
          }

          for (j = 0; j < query.colonSelectors.length; j++) {
            sel = query.colonSelectors[i];
            str += sel;
          }

          for (j = 0; j < query.ids.length; j++) {
            sel = '#' + query.ids[i];
            str += sel;
          }

          for (j = 0; j < query.classes.length; j++) {
            sel = '.' + query.classes[j];
            str += sel;
          }

          if (query.source != null && query.target != null) {
            str = queryToString(query.source) + ' -> ' + queryToString(query.target);
          }

          if (query.connectedNodes != null) {
            var n = query.connectedNodes;

            str = queryToString(n[0]) + ' <-> ' + queryToString(n[1]);
          }

          if (query.parent != null) {
            str = queryToString(query.parent) + ' > ' + str;
          }

          if (query.ancestor != null) {
            str = queryToString(query.ancestor) + ' ' + str;
          }

          if (query.child != null) {
            str += ' > ' + queryToString(query.child);
          }

          if (query.descendant != null) {
            str += ' ' + queryToString(query.descendant);
          }

          return str;
        };

        for (i = 0; i < this.length; i++) {
          var query = this[i];

          str += queryToString(query);

          if (this.length > 1 && i < this.length - 1) {
            str += ', ';
          }
        }

        this._private.toStringCache = str;

        return str;
      };

      [__webpack_require__(50), __webpack_require__(53)].forEach(function (p) {
        return util.assign(selfn, p);
      });

      module.exports = Selector;

      /***/
    },
    /* 7 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Map = __webpack_require__(28);
      var Set = __webpack_require__(8);

      var Element = __webpack_require__(14);

      // factory for generating edge ids when no id is specified for a new element
      var idFactory = {
        generate: function generate(cy, element, tryThisId) {
          var id = tryThisId != null ? tryThisId : util.uuid();

          while (cy.hasElementWithId(id)) {
            id = util.uuid();
          }

          return id;
        }
      };

      // represents a set of nodes, edges, or both together
      var Collection = function Collection(cy, elements, options) {
        if (cy === undefined || !is.core(cy)) {
          util.error('A collection must have a reference to the core');
          return;
        }

        var map = new Map();
        var createdElements = false;

        if (!elements) {
          elements = [];
        } else if (elements.length > 0 && is.plainObject(elements[0]) && !is.element(elements[0])) {
          createdElements = true;

          // make elements from json and restore all at once later
          var eles = [];
          var elesIds = new Set();

          for (var i = 0, l = elements.length; i < l; i++) {
            var json = elements[i];

            if (json.data == null) {
              json.data = {};
            }

            var data = json.data;

            // make sure newly created elements have valid ids
            if (data.id == null) {
              data.id = idFactory.generate(cy, json);
            } else if (cy.hasElementWithId(data.id) || elesIds.has(data.id)) {
              continue; // can't create element if prior id already exists
            }

            var ele = new Element(cy, json, false);
            eles.push(ele);
            elesIds.add(data.id);
          }

          elements = eles;
        }

        this.length = 0;

        for (var _i = 0, _l = elements.length; _i < _l; _i++) {
          var element = elements[_i];
          if (element == null) {
            continue;
          }

          var id = element._private.data.id;

          if (options == null || options.unique && !map.has(id)) {
            map.set(id, {
              index: this.length,
              ele: element
            });

            this[this.length] = element;
            this.length++;
          }
        }

        this._private = {
          cy: cy,
          map: map
        };

        // restore the elements if we created them from json
        if (createdElements) {
          this.restore();
        }
      };

      // Functions
      ////////////////////////////////////////////////////////////////////////////////////////////////////

      // keep the prototypes in sync (an element has the same functions as a collection)
      // and use elefn and elesfn as shorthands to the prototypes
      var elesfn = Element.prototype = Collection.prototype;

      elesfn.instanceString = function () {
        return 'collection';
      };

      elesfn.spawn = function (cy, eles, opts) {
        if (!is.core(cy)) {
          // cy is optional
          opts = eles;
          eles = cy;
          cy = this.cy();
        }

        return new Collection(cy, eles, opts);
      };

      elesfn.spawnSelf = function () {
        return this.spawn(this);
      };

      elesfn.cy = function () {
        return this._private.cy;
      };

      elesfn.renderer = function () {
        return this._private.cy.renderer();
      };

      elesfn.element = function () {
        return this[0];
      };

      elesfn.collection = function () {
        if (is.collection(this)) {
          return this;
        } else {
          // an element
          return new Collection(this._private.cy, [this]);
        }
      };

      elesfn.unique = function () {
        return new Collection(this._private.cy, this, { unique: true });
      };

      elesfn.hasElementWithId = function (id) {
        return this._private.map.has(id);
      };

      elesfn.getElementById = function (id) {
        var cy = this._private.cy;
        var entry = this._private.map.get(id);

        return entry ? entry.ele : new Collection(cy); // get ele or empty collection
      };

      elesfn.$id = elesfn.getElementById;

      elesfn.poolIndex = function () {
        var cy = this._private.cy;
        var eles = cy._private.elements;
        var id = this._private.data.id;

        return eles._private.map.get(id).index;
      };

      elesfn.json = function (obj) {
        var ele = this.element();
        var cy = this.cy();

        if (ele == null && obj) {
          return this;
        } // can't set to no eles

        if (ele == null) {
          return undefined;
        } // can't get from no eles

        var p = ele._private;

        if (is.plainObject(obj)) {
          // set

          cy.startBatch();

          if (obj.data) {
            ele.data(obj.data);
          }

          if (obj.position) {
            ele.position(obj.position);
          }

          // ignore group -- immutable

          var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
            var obj_k = obj[k];

            if (obj_k != null && obj_k !== p[k]) {
              if (obj_k) {
                ele[trueFnName]();
              } else {
                ele[falseFnName]();
              }
            }
          };

          checkSwitch('removed', 'remove', 'restore');

          checkSwitch('selected', 'select', 'unselect');

          checkSwitch('selectable', 'selectify', 'unselectify');

          checkSwitch('locked', 'lock', 'unlock');

          checkSwitch('grabbable', 'grabify', 'ungrabify');

          if (obj.classes != null) {
            ele.classes(obj.classes);
          }

          cy.endBatch();

          return this;
        } else if (obj === undefined) {
          // get

          var json = {
            data: util.copy(p.data),
            position: util.copy(p.position),
            group: p.group,
            removed: p.removed,
            selected: p.selected,
            selectable: p.selectable,
            locked: p.locked,
            grabbable: p.grabbable,
            classes: null
          };

          json.classes = '';

          var i = 0;
          p.classes.forEach(function (cls) {
            return json.classes += i++ === 0 ? cls : ' ' + cls;
          });

          return json;
        }
      };

      elesfn.jsons = function () {
        var jsons = [];

        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var json = ele.json();

          jsons.push(json);
        }

        return jsons;
      };

      elesfn.clone = function () {
        var cy = this.cy();
        var elesArr = [];

        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var json = ele.json();
          var clone = new Element(cy, json, false); // NB no restore

          elesArr.push(clone);
        }

        return new Collection(cy, elesArr);
      };
      elesfn.copy = elesfn.clone;

      elesfn.restore = function (notifyRenderer) {
        var self = this;
        var cy = self.cy();
        var cy_p = cy._private;

        if (notifyRenderer === undefined) {
          notifyRenderer = true;
        }

        // create arrays of nodes and edges, since we need to
        // restore the nodes first
        var nodes = [];
        var edges = [];
        var elements = void 0;
        for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
          var ele = self[_i2];

          if (!ele.removed()) {
            // don't need to handle this ele
            continue;
          }

          // keep nodes first in the array and edges after
          if (ele.isNode()) {
            // put to front of array if node
            nodes.push(ele);
          } else {
            // put to end of array if edge
            edges.push(ele);
          }
        }

        elements = nodes.concat(edges);

        var i = void 0;
        var removeFromElements = function removeFromElements() {
          elements.splice(i, 1);
          i--;
        };

        // now, restore each element
        for (i = 0; i < elements.length; i++) {
          var _ele = elements[i];

          var _private = _ele._private;
          var data = _private.data;

          // the traversal cache should start fresh when ele is added
          _ele.clearTraversalCache();

          // set id and validate
          if (data.id === undefined) {
            data.id = idFactory.generate(cy, _ele);
          } else if (is.number(data.id)) {
            data.id = '' + data.id; // now it's a string
          } else if (is.emptyString(data.id) || !is.string(data.id)) {
            util.error('Can not create element with invalid string ID `' + data.id + '`');

            // can't create element if it has empty string as id or non-string id
            removeFromElements();
            continue;
          } else if (cy.hasElementWithId(data.id)) {
            util.error('Can not create second element with ID `' + data.id + '`');

            // can't create element if one already has that id
            removeFromElements();
            continue;
          }

          var id = data.id; // id is finalised, now let's keep a ref

          if (_ele.isNode()) {
            // extra checks for nodes
            var pos = _private.position;

            // make sure the nodes have a defined position

            if (pos.x == null) {
              pos.x = 0;
            }

            if (pos.y == null) {
              pos.y = 0;
            }
          }

          if (_ele.isEdge()) {
            // extra checks for edges

            var edge = _ele;
            var fields = ['source', 'target'];
            var fieldsLength = fields.length;
            var badSourceOrTarget = false;
            for (var j = 0; j < fieldsLength; j++) {

              var field = fields[j];
              var val = data[field];

              if (is.number(val)) {
                val = data[field] = '' + data[field]; // now string
              }

              if (val == null || val === '') {
                // can't create if source or target is not defined properly
                util.error('Can not create edge `' + id + '` with unspecified ' + field);
                badSourceOrTarget = true;
              } else if (!cy.hasElementWithId(val)) {
                // can't create edge if one of its nodes doesn't exist
                util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
                badSourceOrTarget = true;
              }
            }

            if (badSourceOrTarget) {
              removeFromElements();continue;
            } // can't create this

            var src = cy.getElementById(data.source);
            var tgt = cy.getElementById(data.target);

            src._private.edges.push(edge);
            tgt._private.edges.push(edge);

            edge._private.source = src;
            edge._private.target = tgt;
          } // if is edge

          // create mock ids / indexes maps for element so it can be used like collections
          _private.map = new Map();
          _private.map.set(id, { ele: _ele, index: 0 });

          _private.removed = false;
          cy.addToPool(_ele);
        } // for each element

        // do compound node sanity checks
        for (var _i3 = 0; _i3 < nodes.length; _i3++) {
          // each node
          var node = nodes[_i3];
          var _data = node._private.data;

          if (is.number(_data.parent)) {
            // then automake string
            _data.parent = '' + _data.parent;
          }

          var parentId = _data.parent;

          var specifiedParent = parentId != null;

          if (specifiedParent) {
            var parent = cy.getElementById(parentId);

            if (parent.empty()) {
              // non-existant parent; just remove it
              _data.parent = undefined;
            } else {
              var selfAsParent = false;
              var ancestor = parent;
              while (!ancestor.empty()) {
                if (node.same(ancestor)) {
                  // mark self as parent and remove from data
                  selfAsParent = true;
                  _data.parent = undefined; // remove parent reference

                  // exit or we loop forever
                  break;
                }

                ancestor = ancestor.parent();
              }

              if (!selfAsParent) {
                // connect with children
                parent[0]._private.children.push(node);
                node._private.parent = parent[0];

                // let the core know we have a compound graph
                cy_p.hasCompoundNodes = true;
              }
            } // else
          } // if specified parent
        } // for each node

        if (elements.length > 0) {
          var restored = new Collection(cy, elements);

          for (var _i4 = 0; _i4 < restored.length; _i4++) {
            var _ele2 = restored[_i4];

            if (_ele2.isNode()) {
              continue;
            }

            // adding an edge invalidates the traversal caches for the parallel edges
            _ele2.parallelEdges().clearTraversalCache();

            // adding an edge invalidates the traversal cache for the connected nodes
            _ele2.source().clearTraversalCache();
            _ele2.target().clearTraversalCache();
          }

          var toUpdateStyle = void 0;

          if (cy_p.hasCompoundNodes) {
            toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
          } else {
            toUpdateStyle = restored;
          }

          toUpdateStyle.dirtyCompoundBoundsCache().updateStyle(notifyRenderer);

          if (notifyRenderer) {
            restored.emitAndNotify('add');
          } else {
            restored.emit('add');
          }
        }

        return self; // chainability
      };

      elesfn.removed = function () {
        var ele = this[0];
        return ele && ele._private.removed;
      };

      elesfn.inside = function () {
        var ele = this[0];
        return ele && !ele._private.removed;
      };

      elesfn.remove = function (notifyRenderer) {
        var self = this;
        var removed = [];
        var elesToRemove = [];
        var elesToRemoveIds = {};
        var cy = self._private.cy;

        if (notifyRenderer === undefined) {
          notifyRenderer = true;
        }

        // add connected edges
        function addConnectedEdges(node) {
          var edges = node._private.edges;
          for (var i = 0; i < edges.length; i++) {
            add(edges[i]);
          }
        }

        // add descendant nodes
        function addChildren(node) {
          var children = node._private.children;

          for (var i = 0; i < children.length; i++) {
            add(children[i]);
          }
        }

        function add(ele) {
          var alreadyAdded = elesToRemoveIds[ele.id()];
          if (ele.removed() || alreadyAdded) {
            return;
          } else {
            elesToRemoveIds[ele.id()] = true;
          }

          if (ele.isNode()) {
            elesToRemove.push(ele); // nodes are removed last

            addConnectedEdges(ele);
            addChildren(ele);
          } else {
            elesToRemove.unshift(ele); // edges are removed first
          }
        }

        // make the list of elements to remove
        // (may be removing more than specified due to connected edges etc)

        for (var i = 0, l = self.length; i < l; i++) {
          var ele = self[i];

          add(ele);
        }

        function removeEdgeRef(node, edge) {
          var connectedEdges = node._private.edges;

          util.removeFromArray(connectedEdges, edge);

          // removing an edges invalidates the traversal cache for its nodes
          node.clearTraversalCache();
        }

        function removeParallelRefs(edge) {
          // removing an edge invalidates the traversal caches for the parallel edges
          edge.parallelEdges().clearTraversalCache();
        }

        var alteredParents = [];
        alteredParents.ids = {};

        function removeChildRef(parent, ele) {
          ele = ele[0];
          parent = parent[0];

          var children = parent._private.children;
          var pid = parent.id();

          util.removeFromArray(children, ele);

          if (!alteredParents.ids[pid]) {
            alteredParents.ids[pid] = true;
            alteredParents.push(parent);
          }
        }

        self.dirtyCompoundBoundsCache();

        cy.removeFromPool(elesToRemove); // remove from core pool

        for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
          var _ele3 = elesToRemove[_i5];

          // mark as removed
          _ele3._private.removed = true;

          // add to list of removed elements
          removed.push(_ele3);

          if (_ele3.isEdge()) {
            // remove references to this edge in its connected nodes
            var src = _ele3.source()[0];
            var tgt = _ele3.target()[0];

            removeEdgeRef(src, _ele3);
            removeEdgeRef(tgt, _ele3);
            removeParallelRefs(_ele3);
          } else {
            // remove reference to parent
            var parent = _ele3.parent();

            if (parent.length !== 0) {
              removeChildRef(parent, _ele3);
            }
          }
        }

        // check to see if we have a compound graph or not
        var elesStillInside = cy._private.elements;
        cy._private.hasCompoundNodes = false;
        for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
          var _ele4 = elesStillInside[_i6];

          if (_ele4.isParent()) {
            cy._private.hasCompoundNodes = true;
            break;
          }
        }

        var removedElements = new Collection(this.cy(), removed);
        if (removedElements.size() > 0) {
          // must manually notify since trigger won't do this automatically once removed

          if (notifyRenderer) {
            this.cy().notify({
              type: 'remove',
              eles: removedElements
            });
          }

          removedElements.emit('remove');
        }

        // the parents who were modified by the removal need their style updated
        for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
          var _ele5 = alteredParents[_i7];

          if (!_ele5.removed()) {
            _ele5.updateStyle();
          }
        }

        return new Collection(cy, removed);
      };

      elesfn.move = function (struct) {
        var cy = this._private.cy;

        if (struct.source !== undefined || struct.target !== undefined) {
          var srcId = struct.source;
          var tgtId = struct.target;
          var srcExists = cy.hasElementWithId(srcId);
          var tgtExists = cy.hasElementWithId(tgtId);

          if (srcExists || tgtExists) {
            var jsons = this.jsons();

            this.remove();

            for (var i = 0; i < jsons.length; i++) {
              var json = jsons[i];
              var ele = this[i];

              if (json.group === 'edges') {
                if (srcExists) {
                  json.data.source = srcId;
                }

                if (tgtExists) {
                  json.data.target = tgtId;
                }

                json.scratch = ele._private.scratch;
              }
            }

            return cy.add(jsons);
          }
        } else if (struct.parent !== undefined) {
          // move node to new parent
          var parentId = struct.parent;
          var parentExists = parentId === null || cy.hasElementWithId(parentId);

          if (parentExists) {
            var _jsons = this.jsons();
            var descs = this.descendants();
            var descsEtcJsons = descs.union(descs.union(this).connectedEdges()).jsons();

            this.remove(); // NB: also removes descendants and their connected edges

            for (var _i8 = 0; _i8 < _jsons.length; _i8++) {
              var _json = _jsons[_i8];
              var _ele6 = this[_i8];

              if (_json.group === 'nodes') {
                _json.data.parent = parentId === null ? undefined : parentId;

                _json.scratch = _ele6._private.scratch;
              }
            }

            return cy.add(_jsons.concat(descsEtcJsons));
          }
        }

        return this; // if nothing done
      };

      [__webpack_require__(29), __webpack_require__(43), __webpack_require__(48), __webpack_require__(49), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(62), __webpack_require__(63), __webpack_require__(64), __webpack_require__(7), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69)].forEach(function (props) {
        util.extend(elesfn, props);
      });

      module.exports = Collection;

      /***/
    },
    /* 8 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /* global Set */

      var undef = true ? 'undefined' : _typeof(undefined);

      var ObjectSet = function () {
        function ObjectSet(arrayOrObjectSet) {
          _classCallCheck(this, ObjectSet);

          this._obj = Object.create(null);

          if (arrayOrObjectSet != null) {
            var arr = void 0;

            if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
              arr = arrayOrObjectSet.toArray();
            } else {
              arr = arrayOrObjectSet;
            }

            for (var i = 0; i < arr.length; i++) {
              this.add(arr[i]);
            }
          }
        }

        _createClass(ObjectSet, [{
          key: 'instanceString',
          value: function instanceString() {
            return 'set';
          }
        }, {
          key: 'add',
          value: function add(val) {
            this._obj[val] = 1;
          }
        }, {
          key: 'delete',
          value: function _delete(val) {
            this._obj[val] = 0;
          }
        }, {
          key: 'clear',
          value: function clear() {
            this._obj = Object.create(null);
          }
        }, {
          key: 'has',
          value: function has(val) {
            return this._obj[val] === 1;
          }
        }, {
          key: 'toArray',
          value: function toArray() {
            var _this = this;

            return Object.keys(this._obj).filter(function (key) {
              return _this.has(key);
            });
          }
        }, {
          key: 'forEach',
          value: function forEach(callback, thisArg) {
            return this.toArray().forEach(callback, thisArg);
          }
        }, {
          key: 'size',
          get: function get() {
            return this.toArray().length;
          }
        }]);

        return ObjectSet;
      }();

      // TODO use the stdlib Set in future...
      // module.exports = typeof Set !== undef ? Set : ObjectSet;


      module.exports = ObjectSet;

      /***/
    },
    /* 9 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = __webpack_require__(32);

      /***/
    },
    /* 10 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      // storage for parsed queries

      var newQuery = function newQuery() {
        return {
          classes: [],
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      module.exports = newQuery;

      /***/
    },
    /* 11 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Event = __webpack_require__(16);

      var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")
      var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

      var defaults = {
        qualifierCompare: function qualifierCompare(q1, q2) {
          return q1 === q2;
        },
        eventMatches: function eventMatches() /*context, listener, eventObj*/{
          return true;
        },
        eventFields: function eventFields() /*context*/{
          return {};
        },
        callbackContext: function callbackContext(context /*, listener, eventObj*/) {
          return context;
        },
        beforeEmit: function beforeEmit() /* context, listener, eventObj */{},
        afterEmit: function afterEmit() /* context, listener, eventObj */{},
        bubble: function bubble() /*context*/{
          return false;
        },
        parent: function parent() /*context*/{
          return null;
        },
        context: undefined
      };

      function Emitter(opts) {
        util.assign(this, defaults, opts);

        this.listeners = [];
        this.emitting = 0;
      }

      var p = Emitter.prototype;

      var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
        if (is.fn(qualifier)) {
          callback = qualifier;
          qualifier = null;
        }

        if (confOverrides) {
          if (conf == null) {
            conf = confOverrides;
          } else {
            conf = util.assign({}, conf, confOverrides);
          }
        }

        var eventList = events.split(/\s+/);

        for (var i = 0; i < eventList.length; i++) {
          var evt = eventList[i];

          if (is.emptyString(evt)) {
            continue;
          }

          var match = evt.match(eventRegex); // type[.namespace]

          if (match) {
            var type = match[1];
            var namespace = match[2] ? match[2] : null;
            var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

            if (ret === false) {
              break;
            } // allow exiting early
          }
        }
      };

      var makeEventObj = function makeEventObj(self, obj) {
        return new Event(obj.type, util.assign(obj, self.eventFields(self.context)));
      };

      var forEachEventObj = function forEachEventObj(self, handler, events) {
        if (is.event(events)) {
          handler(self, events);

          return;
        } else if (is.plainObject(events)) {
          handler(self, makeEventObj(self, events));

          return;
        }

        var eventList = events.split(/\s+/);

        for (var i = 0; i < eventList.length; i++) {
          var evt = eventList[i];

          if (is.emptyString(evt)) {
            continue;
          }

          var match = evt.match(eventRegex); // type[.namespace]

          if (match) {
            var type = match[1];
            var namespace = match[2] ? match[2] : null;
            var eventObj = makeEventObj(self, {
              type: type,
              namespace: namespace,
              target: self.context
            });

            handler(self, eventObj);
          }
        }
      };

      p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
        forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
          if (is.fn(callback)) {
            self.listeners.push({
              event: event, // full event string
              callback: callback, // callback to run
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              qualifier: qualifier, // a restriction on whether to match this emitter
              conf: conf // additional configuration
            });
          }
        }, events, qualifier, callback, conf, confOverrides);

        return this;
      };

      p.one = function (events, qualifier, callback, conf) {
        return this.on(events, qualifier, callback, conf, { one: true });
      };

      p.removeListener = p.off = function (events, qualifier, callback, conf) {
        var _this = this;

        if (this.emitting !== 0) {
          this.listeners = util.copyArray(this.listeners);
        }

        var listeners = this.listeners;

        var _loop = function _loop(i) {
          var listener = listeners[i];

          forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {
            if (listener.type === type && (!namespace || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
              listeners.splice(i, 1);

              return false;
            }
          }, events, qualifier, callback, conf);
        };

        for (var i = listeners.length - 1; i >= 0; i--) {
          _loop(i);
        }

        return this;
      };

      p.emit = p.trigger = function (events, extraParams, manualCallback) {
        var listeners = this.listeners;
        var numListenersBeforeEmit = listeners.length;

        this.emitting++;

        if (!is.array(extraParams)) {
          extraParams = [extraParams];
        }

        forEachEventObj(this, function (self, eventObj) {
          if (manualCallback != null) {
            listeners = [{
              event: eventObj.event,
              type: eventObj.type,
              namespace: eventObj.namespace,
              callback: manualCallback
            }];

            numListenersBeforeEmit = listeners.length;
          }

          var _loop2 = function _loop2(i) {
            var listener = listeners[i];

            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
              var args = [eventObj];

              if (extraParams != null) {
                util.push(args, extraParams);
              }

              self.beforeEmit(self.context, listener, eventObj);

              if (listener.conf && listener.conf.one) {
                self.listeners = self.listeners.filter(function (l) {
                  return l !== listener;
                });
              }

              var context = self.callbackContext(self.context, listener, eventObj);
              var ret = listener.callback.apply(context, args);

              self.afterEmit(self.context, listener, eventObj);

              if (ret === false) {
                eventObj.stopPropagation();
                eventObj.preventDefault();
              }
            } // if listener matches
          };

          for (var i = 0; i < numListenersBeforeEmit; i++) {
            _loop2(i);
          } // for listener

          if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
            self.parent(self.context).emit(eventObj, extraParams);
          }
        }, events);

        this.emitting--;

        return this;
      };

      module.exports = Emitter;

      /***/
    },
    /* 12 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);
      var util = __webpack_require__(1);
      var Collection = __webpack_require__(7);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);
      var define = __webpack_require__(4);

      var Core = function Core(opts) {
        var cy = this;

        opts = util.extend({}, opts);

        var container = opts.container;

        // allow for passing a wrapped jquery object
        // e.g. cytoscape({ container: $('#cy') })
        if (container && !is.htmlElement(container) && is.htmlElement(container[0])) {
          container = container[0];
        }

        var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
        reg = reg || {};

        if (reg && reg.cy) {
          reg.cy.destroy();

          reg = {}; // old instance => replace reg completely
        }

        var readies = reg.readies = reg.readies || [];

        if (container) {
          container._cyreg = reg;
        } // make sure container assoc'd reg points to this cy
        reg.cy = cy;

        var head = window !== undefined && container !== undefined && !opts.headless;
        var options = opts;
        options.layout = util.extend({ name: head ? 'grid' : 'null' }, options.layout);
        options.renderer = util.extend({ name: head ? 'canvas' : 'null' }, options.renderer);

        var defVal = function defVal(def, val, altVal) {
          if (val !== undefined) {
            return val;
          } else if (altVal !== undefined) {
            return altVal;
          } else {
            return def;
          }
        };

        var _p = this._private = {
          container: container, // html dom ele container
          ready: false, // whether ready has been triggered
          options: options, // cached options
          elements: new Collection(this), // elements in the graph
          listeners: [], // list of listeners
          aniEles: new Collection(this), // elements being animated
          scratch: {}, // scratch object for core
          layout: null,
          renderer: null,
          destroyed: false, // whether destroy was called
          notificationsEnabled: true, // whether notifications are sent to the renderer
          minZoom: 1e-50,
          maxZoom: 1e50,
          zoomingEnabled: defVal(true, options.zoomingEnabled),
          userZoomingEnabled: defVal(true, options.userZoomingEnabled),
          panningEnabled: defVal(true, options.panningEnabled),
          userPanningEnabled: defVal(true, options.userPanningEnabled),
          boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
          autolock: defVal(false, options.autolock, options.autolockNodes),
          autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
          autounselectify: defVal(false, options.autounselectify),
          styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
          zoom: is.number(options.zoom) ? options.zoom : 1,
          pan: {
            x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
            y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
          },
          animation: { // object for currently-running animations
            current: [],
            queue: []
          },
          hasCompoundNodes: false
        };

        this.createEmitter();

        // set selection type
        var selType = options.selectionType;
        if (selType === undefined || selType !== 'additive' && selType !== 'single') {
          // then set default

          _p.selectionType = 'single';
        } else {
          _p.selectionType = selType;
        }

        // init zoom bounds
        if (is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom) {
          _p.minZoom = options.minZoom;
          _p.maxZoom = options.maxZoom;
        } else if (is.number(options.minZoom) && options.maxZoom === undefined) {
          _p.minZoom = options.minZoom;
        } else if (is.number(options.maxZoom) && options.minZoom === undefined) {
          _p.maxZoom = options.maxZoom;
        }

        var loadExtData = function loadExtData(extData, next) {
          var anyIsPromise = extData.some(is.promise);

          if (anyIsPromise) {
            return Promise.all(extData).then(next); // load all data asynchronously, then exec rest of init
          } else {
            next(extData); // exec synchronously for convenience
          }
        };

        // start with the default stylesheet so we have something before loading an external stylesheet
        if (_p.styleEnabled) {
          cy.setStyle([]);
        }

        // create the renderer
        cy.initRenderer(util.extend({
          hideEdgesOnViewport: options.hideEdgesOnViewport,
          textureOnViewport: options.textureOnViewport,
          wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
          motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
          motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
          pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
          desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
          touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
        }, options.renderer));

        var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
          cy.notifications(false);

          // remove old elements
          var oldEles = cy.mutableElements();
          if (oldEles.length > 0) {
            oldEles.remove();
          }

          if (elements != null) {
            if (is.plainObject(elements) || is.array(elements)) {
              cy.add(elements);
            }
          }

          cy.one('layoutready', function (e) {
            cy.notifications(true);
            cy.emit(e); // we missed this event by turning notifications off, so pass it on

            cy.notify({
              type: 'load',
              eles: cy.mutableElements()
            });

            cy.one('load', onload);
            cy.emit('load');
          }).one('layoutstop', function () {
            cy.one('done', ondone);
            cy.emit('done');
          });

          var layoutOpts = util.extend({}, cy._private.options.layout);
          layoutOpts.eles = cy.elements();

          cy.layout(layoutOpts).run();
        };

        loadExtData([options.style, options.elements], function (thens) {
          var initStyle = thens[0];
          var initEles = thens[1];

          // init style
          if (_p.styleEnabled) {
            cy.style().append(initStyle);
          }

          // initial load
          setElesAndLayout(initEles, function () {
            // onready
            cy.startAnimationLoop();
            _p.ready = true;

            // if a ready callback is specified as an option, the bind it
            if (is.fn(options.ready)) {
              cy.on('ready', options.ready);
            }

            // bind all the ready handlers registered before creating this instance
            for (var i = 0; i < readies.length; i++) {
              var fn = readies[i];
              cy.on('ready', fn);
            }
            if (reg) {
              reg.readies = [];
            } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

            cy.emit('ready');
          }, options.done);
        });
      };

      var corefn = Core.prototype; // short alias

      util.extend(corefn, {
        instanceString: function instanceString() {
          return 'core';
        },

        isReady: function isReady() {
          return this._private.ready;
        },

        isDestroyed: function isDestroyed() {
          return this._private.destroyed;
        },

        ready: function ready(fn) {
          if (this.isReady()) {
            this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
          } else {
            this.on('ready', fn);
          }

          return this;
        },

        destroy: function destroy() {
          var cy = this;
          if (cy.isDestroyed()) return;

          cy.stopAnimationLoop();

          cy.destroyRenderer();

          this.emit('destroy');

          cy._private.destroyed = true;

          return cy;
        },

        hasElementWithId: function hasElementWithId(id) {
          return this._private.elements.hasElementWithId(id);
        },

        getElementById: function getElementById(id) {
          return this._private.elements.getElementById(id);
        },

        selectionType: function selectionType() {
          return this._private.selectionType;
        },

        hasCompoundNodes: function hasCompoundNodes() {
          return this._private.hasCompoundNodes;
        },

        headless: function headless() {
          return this._private.options.renderer.name === 'null';
        },

        styleEnabled: function styleEnabled() {
          return this._private.styleEnabled;
        },

        addToPool: function addToPool(eles) {
          this._private.elements.merge(eles);

          return this; // chaining
        },

        removeFromPool: function removeFromPool(eles) {
          this._private.elements.unmerge(eles);

          return this;
        },

        container: function container() {
          return this._private.container;
        },

        options: function options() {
          return util.copy(this._private.options);
        },

        json: function json(obj) {
          var cy = this;
          var _p = cy._private;
          var eles = cy.mutableElements();

          if (is.plainObject(obj)) {
            // set

            cy.startBatch();

            if (obj.elements) {
              var idInJson = {};

              var updateEles = function updateEles(jsons, gr) {
                for (var i = 0; i < jsons.length; i++) {
                  var json = jsons[i];
                  var id = json.data.id;
                  var ele = cy.getElementById(id);

                  idInJson[id] = true;

                  if (ele.length !== 0) {
                    // existing element should be updated
                    ele.json(json);
                  } else {
                    // otherwise should be added
                    if (gr) {
                      cy.add(util.extend({ group: gr }, json));
                    } else {
                      cy.add(json);
                    }
                  }
                }
              };

              if (is.array(obj.elements)) {
                // elements: []
                updateEles(obj.elements);
              } else {
                // elements: { nodes: [], edges: [] }
                var grs = ['nodes', 'edges'];
                for (var i = 0; i < grs.length; i++) {
                  var gr = grs[i];
                  var elements = obj.elements[gr];

                  if (is.array(elements)) {
                    updateEles(elements, gr);
                  }
                }
              }

              // elements not specified in json should be removed
              eles.stdFilter(function (ele) {
                return !idInJson[ele.id()];
              }).remove();
            }

            if (obj.style) {
              cy.style(obj.style);
            }

            if (obj.zoom != null && obj.zoom !== _p.zoom) {
              cy.zoom(obj.zoom);
            }

            if (obj.pan) {
              if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
                cy.pan(obj.pan);
              }
            }

            var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

            for (var _i = 0; _i < fields.length; _i++) {
              var f = fields[_i];

              if (obj[f] != null) {
                cy[f](obj[f]);
              }
            }

            cy.endBatch();

            return this; // chaining
          } else if (obj === undefined) {
            // get
            var json = {};

            json.elements = {};
            eles.forEach(function (ele) {
              var group = ele.group();

              if (!json.elements[group]) {
                json.elements[group] = [];
              }

              json.elements[group].push(ele.json());
            });

            if (this._private.styleEnabled) {
              json.style = cy.style().json();
            }

            json.zoomingEnabled = cy._private.zoomingEnabled;
            json.userZoomingEnabled = cy._private.userZoomingEnabled;
            json.zoom = cy._private.zoom;
            json.minZoom = cy._private.minZoom;
            json.maxZoom = cy._private.maxZoom;
            json.panningEnabled = cy._private.panningEnabled;
            json.userPanningEnabled = cy._private.userPanningEnabled;
            json.pan = util.copy(cy._private.pan);
            json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
            json.renderer = util.copy(cy._private.options.renderer);
            json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
            json.textureOnViewport = cy._private.options.textureOnViewport;
            json.wheelSensitivity = cy._private.options.wheelSensitivity;
            json.motionBlur = cy._private.options.motionBlur;

            return json;
          }
        },

        scratch: define.data({
          field: 'scratch',
          bindingEvent: 'scratch',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'scratch',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true
        }),

        removeScratch: define.removeData({
          field: 'scratch',
          event: 'scratch',
          triggerFnName: 'trigger',
          triggerEvent: true
        })

      });

      corefn.$id = corefn.getElementById;

      [__webpack_require__(70), __webpack_require__(71), __webpack_require__(79), __webpack_require__(80), __webpack_require__(81), __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(85), __webpack_require__(94)].forEach(function (props) {
        util.extend(corefn, props);
      });

      module.exports = Core;

      /***/
    },
    /* 13 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = function memoize(fn, keyFn) {
        if (!keyFn) {
          keyFn = function keyFn() {
            if (arguments.length === 1) {
              return arguments[0];
            } else if (arguments.length === 0) {
              return 'undefined';
            }

            var args = [];

            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }

            return args.join('$');
          };
        }

        var memoizedFn = function memoizedFn() {
          var self = this;
          var args = arguments;
          var ret = void 0;
          var k = keyFn.apply(self, args);
          var cache = memoizedFn.cache;

          if (!(ret = cache[k])) {
            ret = cache[k] = fn.apply(self, args);
          }

          return ret;
        };

        memoizedFn.cache = {};

        return memoizedFn;
      };

      /***/
    },
    /* 14 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Set = __webpack_require__(8);

      // represents a node or an edge
      var Element = function Element(cy, params, restore) {
        restore = restore === undefined || restore ? true : false;

        if (cy === undefined || params === undefined || !is.core(cy)) {
          util.error('An element must have a core reference and parameters set');
          return;
        }

        var group = params.group;

        // try to automatically infer the group if unspecified
        if (group == null) {
          if (params.data && params.data.source != null && params.data.target != null) {
            group = 'edges';
          } else {
            group = 'nodes';
          }
        }

        // validate group
        if (group !== 'nodes' && group !== 'edges') {
          util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
          return;
        }

        // make the element array-like, just like a collection
        this.length = 1;
        this[0] = this;

        // NOTE: when something is added here, add also to ele.json()
        var _p = this._private = {
          cy: cy,
          single: true, // indicates this is an element
          data: params.data || {}, // data object
          position: params.position || {}, // (x, y) position pair
          autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
          autoHeight: undefined,
          autoPadding: undefined,
          compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read
          listeners: [], // array of bound listeners
          group: group, // string; 'nodes' or 'edges'
          style: {}, // properties as set by the style
          rstyle: {}, // properties for style sent from the renderer to the core
          styleCxts: [], // applied style contexts from the styler
          removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
          selected: params.selected ? true : false, // whether it's selected
          selectable: params.selectable === undefined ? true : params.selectable ? true : false, // whether it's selectable
          locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
          grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
          grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false, // whether the element can be grabbed
          active: false, // whether the element is active from user interaction
          classes: new Set(), // map ( className => true )
          animation: { // object for currently-running animations
            current: [],
            queue: []
          },
          rscratch: {}, // object in which the renderer can store information
          scratch: params.scratch || {}, // scratch objects
          edges: [], // array of connected edges
          children: [], // array of children
          parent: null, // parent ref
          traversalCache: {}, // cache of output of traversal functions
          backgrounding: false // whether background images are loading
        };

        // renderedPosition overrides if specified
        if (params.renderedPosition) {
          var rpos = params.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          _p.position = {
            x: (rpos.x - pan.x) / zoom,
            y: (rpos.y - pan.y) / zoom
          };
        }

        if (is.string(params.classes)) {
          var classes = params.classes.split(/\s+/);
          for (var i = 0, l = classes.length; i < l; i++) {
            var cls = classes[i];
            if (!cls || cls === '') {
              continue;
            }

            _p.classes.add(cls);
          }
        }

        if (params.style || params.css) {
          cy.style().applyBypass(this, params.style || params.css);
        }

        this.createEmitter();

        if (restore === undefined || restore) {
          this.restore();
        }
      };

      module.exports = Element;

      /***/
    },
    /* 15 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var stateSelectors = [{
        selector: ':selected',
        matches: function matches(ele) {
          return ele.selected();
        }
      }, {
        selector: ':unselected',
        matches: function matches(ele) {
          return !ele.selected();
        }
      }, {
        selector: ':selectable',
        matches: function matches(ele) {
          return ele.selectable();
        }
      }, {
        selector: ':unselectable',
        matches: function matches(ele) {
          return !ele.selectable();
        }
      }, {
        selector: ':locked',
        matches: function matches(ele) {
          return ele.locked();
        }
      }, {
        selector: ':unlocked',
        matches: function matches(ele) {
          return !ele.locked();
        }
      }, {
        selector: ':visible',
        matches: function matches(ele) {
          return ele.visible();
        }
      }, {
        selector: ':hidden',
        matches: function matches(ele) {
          return !ele.visible();
        }
      }, {
        selector: ':transparent',
        matches: function matches(ele) {
          return ele.transparent();
        }
      }, {
        selector: ':grabbed',
        matches: function matches(ele) {
          return ele.grabbed();
        }
      }, {
        selector: ':free',
        matches: function matches(ele) {
          return !ele.grabbed();
        }
      }, {
        selector: ':removed',
        matches: function matches(ele) {
          return ele.removed();
        }
      }, {
        selector: ':inside',
        matches: function matches(ele) {
          return !ele.removed();
        }
      }, {
        selector: ':grabbable',
        matches: function matches(ele) {
          return ele.grabbable();
        }
      }, {
        selector: ':ungrabbable',
        matches: function matches(ele) {
          return !ele.grabbable();
        }
      }, {
        selector: ':animated',
        matches: function matches(ele) {
          return ele.animated();
        }
      }, {
        selector: ':unanimated',
        matches: function matches(ele) {
          return !ele.animated();
        }
      }, {
        selector: ':parent',
        matches: function matches(ele) {
          return ele.isParent();
        }
      }, {
        selector: ':childless',
        matches: function matches(ele) {
          return ele.isChildless();
        }
      }, {
        selector: ':child',
        matches: function matches(ele) {
          return ele.isChild();
        }
      }, {
        selector: ':orphan',
        matches: function matches(ele) {
          return ele.isOrphan();
        }
      }, {
        selector: ':nonorphan',
        matches: function matches(ele) {
          return ele.isChild();
        }
      }, {
        selector: ':loop',
        matches: function matches(ele) {
          return ele.isLoop();
        }
      }, {
        selector: ':simple',
        matches: function matches(ele) {
          return ele.isSimple();
        }
      }, {
        selector: ':active',
        matches: function matches(ele) {
          return ele.active();
        }
      }, {
        selector: ':inactive',
        matches: function matches(ele) {
          return !ele.active();
        }
      }, {
        selector: ':backgrounding',
        matches: function matches(ele) {
          return ele.backgrounding();
        }
      }, {
        selector: ':nonbackgrounding',
        matches: function matches(ele) {
          return !ele.backgrounding();
        }
      }].sort(function (a, b) {
        // n.b. selectors that are starting substrings of others must have the longer ones first
        return util.sort.descending(a.selector, b.selector);
      });

      var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
        var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || function () {
          var selToFn = {};
          var s = void 0;

          for (var i = 0; i < stateSelectors.length; i++) {
            s = stateSelectors[i];

            selToFn[s.selector] = s.matches;
          }

          return selToFn;
        }();

        return lookup[sel](ele);
      };

      var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
        return s.selector;
      }).join('|') + ')';

      module.exports = { stateSelectors: stateSelectors, stateSelectorMatches: stateSelectorMatches, stateSelectorRegex: stateSelectorRegex };

      /***/
    },
    /* 16 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*!
      Event object based on jQuery events, MIT license
      
      https://jquery.org/license/
      https://tldrlegal.com/license/mit-license
      https://github.com/jquery/jquery/blob/master/src/event.js
      */

      var Event = function Event(src, props) {
        this.recycle(src, props);
      };

      function returnFalse() {
        return false;
      }

      function returnTrue() {
        return true;
      }

      // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
      Event.prototype = {
        instanceString: function instanceString() {
          return 'event';
        },

        recycle: function recycle(src, props) {
          this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

          if (src != null && src.preventDefault) {
            // Browser Event object
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
          } else if (src != null && src.type) {
            // Plain object containing all event details
            props = src;
          } else {
            // Event string
            this.type = src;
          }

          // Put explicitly provided properties onto the event object
          if (props != null) {
            // more efficient to manually copy fields we use
            this.originalEvent = props.originalEvent;
            this.type = props.type != null ? props.type : this.type;
            this.cy = props.cy;
            this.target = props.target;
            this.position = props.position;
            this.renderedPosition = props.renderedPosition;
            this.namespace = props.namespace;
            this.layout = props.layout;
          }

          if (this.cy != null && this.position != null && this.renderedPosition == null) {
            // create a rendered position based on the passed position
            var pos = this.position;
            var zoom = this.cy.zoom();
            var pan = this.cy.pan();

            this.renderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          // Create a timestamp if incoming event doesn't have one
          this.timeStamp = src && src.timeStamp || Date.now();
        },

        preventDefault: function preventDefault() {
          this.isDefaultPrevented = returnTrue;

          var e = this.originalEvent;
          if (!e) {
            return;
          }

          // if preventDefault exists run it on the original event
          if (e.preventDefault) {
            e.preventDefault();
          }
        },

        stopPropagation: function stopPropagation() {
          this.isPropagationStopped = returnTrue;

          var e = this.originalEvent;
          if (!e) {
            return;
          }

          // if stopPropagation exists run it on the original event
          if (e.stopPropagation) {
            e.stopPropagation();
          }
        },

        stopImmediatePropagation: function stopImmediatePropagation() {
          this.isImmediatePropagationStopped = returnTrue;
          this.stopPropagation();
        },

        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
      };

      module.exports = Event;

      /***/
    },
    /* 17 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
       *  and z-index (low to high).  These styles affect how this applies:
       *
       *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
       *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
       *      root to leaves of the compound graph.  The last drawn is `top`.
       *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
       *      `manual` ignores this convention and draws based on the `z-index` value setting.
       *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
       *      `z-index` will be drawn on top of an element with a lower `z-index`.
       */

      var util = __webpack_require__(1);

      var zIndexSort = function zIndexSort(a, b) {
        var cy = a.cy();
        var hasCompoundNodes = cy.hasCompoundNodes();

        function getDepth(ele) {
          var style = ele.pstyle('z-compound-depth');
          if (style.value === 'auto') {
            return hasCompoundNodes ? ele.zDepth() : 0;
          } else if (style.value === 'bottom') {
            return -1;
          } else if (style.value === 'top') {
            return util.MAX_INT;
          }
          // 'orphan'
          return 0;
        }
        var depthDiff = getDepth(a) - getDepth(b);
        if (depthDiff !== 0) {
          return depthDiff;
        }

        function getEleDepth(ele) {
          var style = ele.pstyle('z-index-compare');
          if (style.value === 'auto') {
            return ele.isNode() ? 1 : 0;
          }
          // 'manual'
          return 0;
        }
        var eleDiff = getEleDepth(a) - getEleDepth(b);
        if (eleDiff !== 0) {
          return eleDiff;
        }

        var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;
        if (zDiff !== 0) {
          return zDiff;
        }
        // compare indices in the core (order added to graph w/ last on top)
        return a.poolIndex() - b.poolIndex();
      };

      module.exports = zIndexSort;

      /***/
    },
    /* 18 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var Style = function Style(cy) {

        if (!(this instanceof Style)) {
          return new Style(cy);
        }

        if (!is.core(cy)) {
          util.error('A style must have a core reference');
          return;
        }

        this._private = {
          cy: cy,
          coreStyle: {}
        };

        this.length = 0;

        this.resetToDefault();
      };

      var styfn = Style.prototype;

      styfn.instanceString = function () {
        return 'style';
      };

      // remove all contexts
      styfn.clear = function () {
        for (var i = 0; i < this.length; i++) {
          this[i] = undefined;
        }
        this.length = 0;

        var _p = this._private;

        _p.newStyle = true;

        return this; // chaining
      };

      styfn.resetToDefault = function () {
        this.clear();
        this.addDefaultStylesheet();

        return this;
      };

      // builds a style object for the 'core' selector
      styfn.core = function () {
        return this._private.coreStyle;
      };

      // create a new context from the specified selector string and switch to that context
      styfn.selector = function (selectorStr) {
        // 'core' is a special case and does not need a selector
        var selector = selectorStr === 'core' ? null : new Selector(selectorStr);

        var i = this.length++; // new context means new index
        this[i] = {
          selector: selector,
          properties: [],
          mappedProperties: [],
          index: i
        };

        return this; // chaining
      };

      // add one or many css rules to the current context
      styfn.css = function () {
        var self = this;
        var args = arguments;

        switch (args.length) {
          case 1:
            var map = args[0];

            for (var i = 0; i < self.properties.length; i++) {
              var prop = self.properties[i];
              var mapVal = map[prop.name];

              if (mapVal === undefined) {
                mapVal = map[util.dash2camel(prop.name)];
              }

              if (mapVal !== undefined) {
                this.cssRule(prop.name, mapVal);
              }
            }

            break;

          case 2:
            this.cssRule(args[0], args[1]);
            break;

          default:
            break; // do nothing if args are invalid
        }

        return this; // chaining
      };
      styfn.style = styfn.css;

      // add a single css rule to the current context
      styfn.cssRule = function (name, value) {
        // name-value pair
        var property = this.parse(name, value);

        // add property to current context if valid
        if (property) {
          var i = this.length - 1;
          this[i].properties.push(property);
          this[i].properties[property.name] = property; // allow access by name as well

          if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
            this._private.hasPie = true;
          }

          if (property.mapped) {
            this[i].mappedProperties.push(property);
          }

          // add to core style if necessary
          var currentSelectorIsCore = !this[i].selector;
          if (currentSelectorIsCore) {
            this._private.coreStyle[property.name] = property;
          }
        }

        return this; // chaining
      };

      styfn.append = function (style) {
        if (is.stylesheet(style)) {
          style.appendToStyle(this);
        } else if (is.array(style)) {
          this.appendFromJson(style);
        } else if (is.string(style)) {
          this.appendFromString(style);
        } // you probably wouldn't want to append a Style, since you'd duplicate the default parts

        return this;
      };

      // static function
      Style.fromJson = function (cy, json) {
        var style = new Style(cy);

        style.fromJson(json);

        return style;
      };

      Style.fromString = function (cy, string) {
        return new Style(cy).fromString(string);
      };

      [__webpack_require__(86), __webpack_require__(87), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(91), __webpack_require__(92), __webpack_require__(93)].forEach(function (props) {
        util.extend(styfn, props);
      });

      Style.types = styfn.types;
      Style.properties = styfn.properties;

      module.exports = Style;

      /***/
    },
    /* 19 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var fullFpsTime = 1000 / 60; // assume 60 frames per second

      module.exports = {
        setupDequeueing: function setupDequeueing(opts) {
          return function setupDequeueingImpl() {
            var self = this;
            var r = this.renderer;

            if (self.dequeueingSetup) {
              return;
            } else {
              self.dequeueingSetup = true;
            }

            var queueRedraw = util.debounce(function () {
              r.redrawHint('eles', true);
              r.redrawHint('drag', true);

              r.redraw();
            }, opts.deqRedrawThreshold);

            var dequeue = function dequeue(willDraw, frameStartTime) {
              var startTime = util.performanceNow();
              var avgRenderTime = r.averageRedrawTime;
              var renderTime = r.lastRedrawTime;
              var deqd = [];
              var extent = r.cy.extent();
              var pixelRatio = r.getPixelRatio();

              while (true) {
                var now = util.performanceNow();
                var duration = now - startTime;
                var frameDuration = now - frameStartTime;

                if (renderTime < fullFpsTime) {
                  // if we're rendering faster than the ideal fps, then do dequeueing
                  // during all of the remaining frame time

                  var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

                  if (frameDuration >= opts.deqFastCost * timeAvailable) {
                    break;
                  }
                } else {
                  if (willDraw) {
                    if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                      break;
                    }
                  } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
                    break;
                  }
                }

                var thisDeqd = opts.deq(self, pixelRatio, extent);

                if (thisDeqd.length > 0) {
                  for (var i = 0; i < thisDeqd.length; i++) {
                    deqd.push(thisDeqd[i]);
                  }
                } else {
                  break;
                }
              }

              // callbacks on dequeue
              if (deqd.length > 0) {
                opts.onDeqd(self, deqd);

                if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
                  queueRedraw();
                }
              }
            };

            var priority = opts.priority || util.noop;

            r.beforeRender(dequeue, priority(self));
          };
        }
      };

      /***/
    },
    /* 20 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Core = __webpack_require__(12);
      var extension = __webpack_require__(95);
      var Stylesheet = __webpack_require__(138);

      var cytoscape = function cytoscape(options) {
        // jshint ignore:line
        // if no options specified, use default
        if (options === undefined) {
          options = {};
        }

        // create instance
        if (is.plainObject(options)) {
          return new Core(options);
        }

        // allow for registration of extensions
        else if (is.string(options)) {
            return extension.apply(extension, arguments);
          }
      };

      // e.g. cytoscape.use( require('cytoscape-foo'), bar )
      cytoscape.use = function (ext) {
        var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

        args.unshift(cytoscape); // cytoscape is first arg to ext

        ext.apply(null, args);

        return this;
      };

      // replaced by build system
      cytoscape.version = __webpack_require__(139);

      // expose public apis (mostly for extensions)
      cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

      module.exports = cytoscape;

      /***/
    },
    /* 21 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      module.exports = {
        // get [r, g, b] from #abc or #aabbcc
        hex2tuple: function hex2tuple(hex) {
          if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
            return;
          }

          var shortHex = hex.length === 4;
          var r = void 0,
              g = void 0,
              b = void 0;
          var base = 16;

          if (shortHex) {
            r = parseInt(hex[1] + hex[1], base);
            g = parseInt(hex[2] + hex[2], base);
            b = parseInt(hex[3] + hex[3], base);
          } else {
            r = parseInt(hex[1] + hex[2], base);
            g = parseInt(hex[3] + hex[4], base);
            b = parseInt(hex[5] + hex[6], base);
          }

          return [r, g, b];
        },

        // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
        hsl2tuple: function hsl2tuple(hsl) {
          var ret = void 0;
          var h = void 0,
              s = void 0,
              l = void 0,
              a = void 0,
              r = void 0,
              g = void 0,
              b = void 0;
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }

          var m = new RegExp('^' + this.regex.hsla + '$').exec(hsl);
          if (m) {

            // get hue
            h = parseInt(m[1]);
            if (h < 0) {
              h = (360 - -1 * h % 360) % 360;
            } else if (h > 360) {
              h = h % 360;
            }
            h /= 360; // normalise on [0, 1]

            s = parseFloat(m[2]);
            if (s < 0 || s > 100) {
              return;
            } // saturation is [0, 100]
            s = s / 100; // normalise on [0, 1]

            l = parseFloat(m[3]);
            if (l < 0 || l > 100) {
              return;
            } // lightness is [0, 100]
            l = l / 100; // normalise on [0, 1]

            a = m[4];
            if (a !== undefined) {
              a = parseFloat(a);

              if (a < 0 || a > 1) {
                return;
              } // alpha is [0, 1]
            }

            // now, convert to rgb
            // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
            if (s === 0) {
              r = g = b = Math.round(l * 255); // achromatic
            } else {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p = 2 * l - q;
              r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
              g = Math.round(255 * hue2rgb(p, q, h));
              b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
            }

            ret = [r, g, b, a];
          }

          return ret;
        },

        // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
        rgb2tuple: function rgb2tuple(rgb) {
          var ret = void 0;

          var m = new RegExp('^' + this.regex.rgba + '$').exec(rgb);
          if (m) {
            ret = [];

            var isPct = [];
            for (var i = 1; i <= 3; i++) {
              var channel = m[i];

              if (channel[channel.length - 1] === '%') {
                isPct[i] = true;
              }
              channel = parseFloat(channel);

              if (isPct[i]) {
                channel = channel / 100 * 255; // normalise to [0, 255]
              }

              if (channel < 0 || channel > 255) {
                return;
              } // invalid channel value

              ret.push(Math.floor(channel));
            }

            var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
            var allArePct = isPct[1] && isPct[2] && isPct[3];
            if (atLeastOneIsPct && !allArePct) {
              return;
            } // must all be percent values if one is

            var alpha = m[4];
            if (alpha !== undefined) {
              alpha = parseFloat(alpha);

              if (alpha < 0 || alpha > 1) {
                return;
              } // invalid alpha value

              ret.push(alpha);
            }
          }

          return ret;
        },

        colorname2tuple: function colorname2tuple(color) {
          return this.colors[color.toLowerCase()];
        },

        color2tuple: function color2tuple(color) {
          return (is.array(color) ? color : null) || this.colorname2tuple(color) || this.hex2tuple(color) || this.rgb2tuple(color) || this.hsl2tuple(color);
        },

        colors: {
          // special colour names
          transparent: [0, 0, 0, 0], // NB alpha === 0

          // regular colours
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          grey: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        }
      };

      /***/
    },
    /* 22 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      module.exports = {
        // has anything been set in the map
        mapEmpty: function mapEmpty(map) {
          var empty = true;

          if (map != null) {
            return Object.keys(map).length === 0;
          }

          return empty;
        },

        // pushes to the array at the end of a map (map may not be built)
        pushMap: function pushMap(options) {
          var array = this.getMap(options);

          if (array == null) {
            // if empty, put initial array
            this.setMap(this.extend({}, options, {
              value: [options.value]
            }));
          } else {
            array.push(options.value);
          }
        },

        // sets the value in a map (map may not be built)
        setMap: function setMap(options) {
          var obj = options.map;
          var key = void 0;
          var keys = options.keys;
          var l = keys.length;

          for (var i = 0; i < l; i++) {
            var _key = keys[i];

            if (is.plainObject(_key)) {
              this.error('Tried to set map with object key');
            }

            if (i < keys.length - 1) {

              // extend the map if necessary
              if (obj[_key] == null) {
                obj[_key] = {};
              }

              obj = obj[_key];
            } else {
              // set the value
              obj[_key] = options.value;
            }
          }
        },

        // gets the value in a map even if it's not built in places
        getMap: function getMap(options) {
          var obj = options.map;
          var keys = options.keys;
          var l = keys.length;

          for (var i = 0; i < l; i++) {
            var key = keys[i];

            if (is.plainObject(key)) {
              this.error('Tried to get map with object key');
            }

            obj = obj[key];

            if (obj == null) {
              return obj;
            }
          }

          return obj;
        },

        // deletes the entry in the map
        deleteMap: function deleteMap(options) {
          var obj = options.map;
          var keys = options.keys;
          var l = keys.length;
          var keepChildren = options.keepChildren;

          for (var i = 0; i < l; i++) {
            var key = keys[i];

            if (is.plainObject(key)) {
              this.error('Tried to delete map with object key');
            }

            var lastKey = i === options.keys.length - 1;
            if (lastKey) {

              if (keepChildren) {
                // then only delete child fields not in keepChildren
                var children = Object.keys(obj);

                for (var j = 0; j < children.length; j++) {
                  var child = children[j];

                  if (!keepChildren[child]) {
                    obj[child] = undefined;
                  }
                }
              } else {
                obj[key] = undefined;
              }
            } else {
              obj = obj[key];
            }
          }
        }
      };

      /***/
    },
    /* 23 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

      var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
      var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

      var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
      var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

      var hex3 = '\\#[0-9a-fA-F]{3}';
      var hex6 = '\\#[0-9a-fA-F]{6}';

      module.exports = {
        regex: {
          number: number,
          rgba: rgba,
          rgbaNoBackRefs: rgbaNoBackRefs,
          hsla: hsla,
          hslaNoBackRefs: hslaNoBackRefs,
          hex3: hex3,
          hex6: hex6
        }
      };

      /***/
    },
    /* 24 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var memoize = __webpack_require__(13);
      var is = __webpack_require__(0);

      module.exports = {

        camel2dash: memoize(function (str) {
          return str.replace(/([A-Z])/g, function (v) {
            return '-' + v.toLowerCase();
          });
        }),

        dash2camel: memoize(function (str) {
          return str.replace(/(-\w)/g, function (v) {
            return v[1].toUpperCase();
          });
        }),

        prependCamel: memoize(function (prefix, str) {
          return prefix + str[0].toUpperCase() + str.substring(1);
        }, function (prefix, str) {
          return prefix + '$' + str;
        }),

        capitalize: function capitalize(str) {
          if (is.emptyString(str)) {
            return str;
          }

          return str.charAt(0).toUpperCase() + str.substring(1);
        }

      };

      /***/
    },
    /* 25 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);
      var performance = window ? window.performance : null;

      var util = {};

      var pnow = performance && performance.now ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };

      var raf = function () {
        if (window) {
          if (window.requestAnimationFrame) {
            return function (fn) {
              window.requestAnimationFrame(fn);
            };
          } else if (window.mozRequestAnimationFrame) {
            return function (fn) {
              window.mozRequestAnimationFrame(fn);
            };
          } else if (window.webkitRequestAnimationFrame) {
            return function (fn) {
              window.webkitRequestAnimationFrame(fn);
            };
          } else if (window.msRequestAnimationFrame) {
            return function (fn) {
              window.msRequestAnimationFrame(fn);
            };
          }
        }

        return function (fn) {
          if (fn) {
            setTimeout(function () {
              fn(pnow());
            }, 1000 / 60);
          }
        };
      }();

      util.requestAnimationFrame = function (fn) {
        raf(fn);
      };

      util.performanceNow = pnow;

      util.debounce = __webpack_require__(26);

      util.now = function () {
        return Date.now();
      };

      module.exports = util;

      /***/
    },
    /* 26 */
    /***/function (module, exports) {

      /**
       * lodash (Custom Build) <https://lodash.com/>
       * Build: `lodash modularize exports="npm" -o ./`
       * Copyright jQuery Foundation and other contributors <https://jquery.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */

      /** Used as the `TypeError` message for "Functions" methods. */
      var FUNC_ERROR_TEXT = 'Expected a function';

      /** Used as references for various `Number` constants. */
      var NAN = 0 / 0;

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]';

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Built-in method references without a dependency on `root`. */
      var freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof2(global)) == 'object' && global && global.Object === Object && global;

      /** Detect free variable `self`. */
      var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof2(self)) == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var objectToString = objectProto.toString;

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max,
          nativeMin = Math.min;

      /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */
      var now = function now() {
        return root.Date.now();
      };

      /**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */
      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          // Reset any `maxWait` timer.
          lastInvokeTime = time;
          // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
          // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              result = wait - timeSinceLastCall;

          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.
          return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }

        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              // Handle invocations in a tight loop.
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
        return !!value && (type == 'object' || type == 'function');
      }

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object';
      }

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }

      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }

      module.exports = debounce;

      /***/
    },
    /* 27 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function ascending(a, b) {
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      }

      function descending(a, b) {
        return -1 * ascending(a, b);
      }

      module.exports = {
        sort: {
          ascending: ascending,
          descending: descending
        }
      };

      /***/
    },
    /* 28 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function ObjectMap() {
        this._obj = {};
      }

      var p = ObjectMap.prototype;

      p.set = function (key, val) {
        this._obj[key] = val;
      };

      p.delete = function (key) {
        this._obj[key] = null;
      };

      p.has = function (key) {
        return this._obj[key] != null;
      };

      p.get = function (key) {
        return this._obj[key];
      };

      // TODO use the stdlib Map in future...
      // module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;
      module.exports = ObjectMap;

      /***/
    },
    /* 29 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var elesfn = {};

      [__webpack_require__(30), __webpack_require__(31), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), __webpack_require__(42)].forEach(function (props) {
        util.extend(elesfn, props);
      });

      module.exports = elesfn;

      /***/
    },
    /* 30 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var defineSearch = function defineSearch(params) {
        params = {
          bfs: params.bfs || !params.dfs,
          dfs: params.dfs || !params.bfs
        };

        // from pseudocode on wikipedia
        return function searchFn(roots, fn, directed) {
          var options;
          if (is.plainObject(roots) && !is.elementOrCollection(roots)) {
            options = roots;
            roots = options.roots || options.root;
            fn = options.visit;
            directed = options.directed;
          }

          directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
          fn = is.fn(fn) ? fn : function () {};

          var cy = this._private.cy;
          var v = roots = is.string(roots) ? this.filter(roots) : roots;
          var Q = [];
          var connectedNodes = [];
          var connectedBy = {};
          var id2depth = {};
          var V = {};
          var j = 0;
          var found;
          var nodes = this.nodes();
          var edges = this.edges();

          // enqueue v
          for (var i = 0; i < v.length; i++) {
            if (v[i].isNode()) {
              Q.unshift(v[i]);

              if (params.bfs) {
                V[v[i].id()] = true;

                connectedNodes.push(v[i]);
              }

              id2depth[v[i].id()] = 0;
            }
          }

          while (Q.length !== 0) {
            var v = params.bfs ? Q.shift() : Q.pop();

            if (params.dfs) {
              if (V[v.id()]) {
                continue;
              }

              V[v.id()] = true;

              connectedNodes.push(v);
            }

            var depth = id2depth[v.id()];
            var prevEdge = connectedBy[v.id()];
            var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not(v)[0];
            var ret;

            ret = fn(v, prevEdge, prevNode, j++, depth);

            if (ret === true) {
              found = v;
              break;
            }

            if (ret === false) {
              break;
            }

            var vwEdges = v.connectedEdges(directed ? function (ele) {
              return ele.data('source') === v.id();
            } : undefined).intersect(edges);
            for (var i = 0; i < vwEdges.length; i++) {
              var e = vwEdges[i];
              var w = e.connectedNodes(function (n) {
                return n.id() !== v.id();
              }).intersect(nodes);

              if (w.length !== 0 && !V[w.id()]) {
                w = w[0];

                Q.push(w);

                if (params.bfs) {
                  V[w.id()] = true;

                  connectedNodes.push(w);
                }

                connectedBy[w.id()] = e;

                id2depth[w.id()] = id2depth[v.id()] + 1;
              }
            }
          }

          var connectedEles = [];

          for (var i = 0; i < connectedNodes.length; i++) {
            var node = connectedNodes[i];
            var edge = connectedBy[node.id()];

            if (edge) {
              connectedEles.push(edge);
            }

            connectedEles.push(node);
          }

          return {
            path: cy.collection(connectedEles, { unique: true }),
            found: cy.collection(found)
          };
        };
      };

      // search, spanning trees, etc
      var elesfn = {
        breadthFirstSearch: defineSearch({ bfs: true }),
        depthFirstSearch: defineSearch({ dfs: true })
      };

      // nice, short mathemathical alias
      elesfn.bfs = elesfn.breadthFirstSearch;
      elesfn.dfs = elesfn.depthFirstSearch;

      module.exports = elesfn;

      /***/
    },
    /* 31 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Heap = __webpack_require__(9);

      var elesfn = {

        dijkstra: function dijkstra(root, weightFn, directed) {
          var options;
          if (is.plainObject(root) && !is.elementOrCollection(root)) {
            options = root;
            root = options.root;
            weightFn = options.weight;
            directed = options.directed;
          }

          var cy = this._private.cy;
          weightFn = is.fn(weightFn) ? weightFn : function () {
            return 1;
          }; // if not specified, assume each edge has equal weight (1)

          var source = is.string(root) ? this.filter(root)[0] : root[0];
          var dist = {};
          var prev = {};
          var knownDist = {};

          var edges = this.edges().filter(function (ele) {
            return !ele.isLoop();
          });
          var nodes = this.nodes();

          var getDist = function getDist(node) {
            return dist[node.id()];
          };

          var setDist = function setDist(node, d) {
            dist[node.id()] = d;

            Q.updateItem(node);
          };

          var Q = new Heap(function (a, b) {
            return getDist(a) - getDist(b);
          });

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            dist[node.id()] = node.same(source) ? 0 : Infinity;
            Q.push(node);
          }

          var distBetween = function distBetween(u, v) {
            var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
            var smallestDistance = Infinity;
            var smallestEdge;

            for (var i = 0; i < uvs.length; i++) {
              var edge = uvs[i];
              var weight = weightFn(edge);

              if (weight < smallestDistance || !smallestEdge) {
                smallestDistance = weight;
                smallestEdge = edge;
              }
            }

            return {
              edge: smallestEdge,
              dist: smallestDistance
            };
          };

          while (Q.size() > 0) {
            var u = Q.pop();
            var smalletsDist = getDist(u);
            var uid = u.id();

            knownDist[uid] = smalletsDist;

            if (smalletsDist === Infinity) {
              continue;
            }

            var neighbors = u.neighborhood().intersect(nodes);
            for (var i = 0; i < neighbors.length; i++) {
              var v = neighbors[i];
              var vid = v.id();
              var vDist = distBetween(u, v);

              var alt = smalletsDist + vDist.dist;

              if (alt < getDist(v)) {
                setDist(v, alt);

                prev[vid] = {
                  node: u,
                  edge: vDist.edge
                };
              }
            } // for
          } // while

          return {
            distanceTo: function distanceTo(node) {
              var target = is.string(node) ? nodes.filter(node)[0] : node[0];

              return knownDist[target.id()];
            },

            pathTo: function pathTo(node) {
              var target = is.string(node) ? nodes.filter(node)[0] : node[0];
              var S = [];
              var u = target;

              if (target.length > 0) {
                S.unshift(target);

                while (prev[u.id()]) {
                  var p = prev[u.id()];

                  S.unshift(p.edge);
                  S.unshift(p.node);

                  u = p.node;
                }
              }

              return cy.collection(S);
            }
          };
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 32 */
    /***/function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(33);

      /***/
    },
    /* 33 */
    /***/function (module, exports, __webpack_require__) {

      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Generated by CoffeeScript 1.8.0
      (function () {
        var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

        floor = Math.floor, min = Math.min;

        /*
        Default comparison function to be used
         */

        defaultCmp = function defaultCmp(x, y) {
          if (x < y) {
            return -1;
          }
          if (x > y) {
            return 1;
          }
          return 0;
        };

        /*
        Insert item x in list a, and keep it sorted assuming a is sorted.
        
        If x is already in a, insert it to the right of the rightmost x.
        
        Optional args lo (default 0) and hi (default a.length) bound the slice
        of a to be searched.
         */

        insort = function insort(a, x, lo, hi, cmp) {
          var mid;
          if (lo == null) {
            lo = 0;
          }
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (lo < 0) {
            throw new Error('lo must be non-negative');
          }
          if (hi == null) {
            hi = a.length;
          }
          while (lo < hi) {
            mid = floor((lo + hi) / 2);
            if (cmp(x, a[mid]) < 0) {
              hi = mid;
            } else {
              lo = mid + 1;
            }
          }
          return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
        };

        /*
        Push item onto heap, maintaining the heap invariant.
         */

        heappush = function heappush(array, item, cmp) {
          if (cmp == null) {
            cmp = defaultCmp;
          }
          array.push(item);
          return _siftdown(array, 0, array.length - 1, cmp);
        };

        /*
        Pop the smallest item off the heap, maintaining the heap invariant.
         */

        heappop = function heappop(array, cmp) {
          var lastelt, returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          lastelt = array.pop();
          if (array.length) {
            returnitem = array[0];
            array[0] = lastelt;
            _siftup(array, 0, cmp);
          } else {
            returnitem = lastelt;
          }
          return returnitem;
        };

        /*
        Pop and return the current smallest value, and add the new item.
        
        This is more efficient than heappop() followed by heappush(), and can be
        more appropriate when using a fixed size heap. Note that the value
        returned may be larger than item! That constrains reasonable use of
        this routine unless written as part of a conditional replacement:
            if item > array[0]
              item = heapreplace(array, item)
         */

        heapreplace = function heapreplace(array, item, cmp) {
          var returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          returnitem = array[0];
          array[0] = item;
          _siftup(array, 0, cmp);
          return returnitem;
        };

        /*
        Fast version of a heappush followed by a heappop.
         */

        heappushpop = function heappushpop(array, item, cmp) {
          var _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (array.length && cmp(array[0], item) < 0) {
            _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
            _siftup(array, 0, cmp);
          }
          return item;
        };

        /*
        Transform list into a heap, in-place, in O(array.length) time.
         */

        heapify = function heapify(array, cmp) {
          var i, _i, _j, _len, _ref, _ref1, _results, _results1;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          _ref1 = function () {
            _results1 = [];
            for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
              _results1.push(_j);
            }
            return _results1;
          }.apply(this).reverse();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            i = _ref1[_i];
            _results.push(_siftup(array, i, cmp));
          }
          return _results;
        };

        /*
        Update the position of the given item in the heap.
        This function should be called every time the item is being modified.
         */

        updateItem = function updateItem(array, item, cmp) {
          var pos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          pos = array.indexOf(item);
          if (pos === -1) {
            return;
          }
          _siftdown(array, 0, pos, cmp);
          return _siftup(array, pos, cmp);
        };

        /*
        Find the n largest elements in a dataset.
         */

        nlargest = function nlargest(array, n, cmp) {
          var elem, result, _i, _len, _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          result = array.slice(0, n);
          if (!result.length) {
            return result;
          }
          heapify(result, cmp);
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            heappushpop(result, elem, cmp);
          }
          return result.sort(cmp).reverse();
        };

        /*
        Find the n smallest elements in a dataset.
         */

        nsmallest = function nsmallest(array, n, cmp) {
          var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (n * 10 <= array.length) {
            result = array.slice(0, n).sort(cmp);
            if (!result.length) {
              return result;
            }
            los = result[result.length - 1];
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem = _ref[_i];
              if (cmp(elem, los) < 0) {
                insort(result, elem, 0, null, cmp);
                result.pop();
                los = result[result.length - 1];
              }
            }
            return result;
          }
          heapify(array, cmp);
          _results = [];
          for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(heappop(array, cmp));
          }
          return _results;
        };

        _siftdown = function _siftdown(array, startpos, pos, cmp) {
          var newitem, parent, parentpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          newitem = array[pos];
          while (pos > startpos) {
            parentpos = pos - 1 >> 1;
            parent = array[parentpos];
            if (cmp(newitem, parent) < 0) {
              array[pos] = parent;
              pos = parentpos;
              continue;
            }
            break;
          }
          return array[pos] = newitem;
        };

        _siftup = function _siftup(array, pos, cmp) {
          var childpos, endpos, newitem, rightpos, startpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          endpos = array.length;
          startpos = pos;
          newitem = array[pos];
          childpos = 2 * pos + 1;
          while (childpos < endpos) {
            rightpos = childpos + 1;
            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
              childpos = rightpos;
            }
            array[pos] = array[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
          }
          array[pos] = newitem;
          return _siftdown(array, startpos, pos, cmp);
        };

        Heap = function () {
          Heap.push = heappush;

          Heap.pop = heappop;

          Heap.replace = heapreplace;

          Heap.pushpop = heappushpop;

          Heap.heapify = heapify;

          Heap.updateItem = updateItem;

          Heap.nlargest = nlargest;

          Heap.nsmallest = nsmallest;

          function Heap(cmp) {
            this.cmp = cmp != null ? cmp : defaultCmp;
            this.nodes = [];
          }

          Heap.prototype.push = function (x) {
            return heappush(this.nodes, x, this.cmp);
          };

          Heap.prototype.pop = function () {
            return heappop(this.nodes, this.cmp);
          };

          Heap.prototype.peek = function () {
            return this.nodes[0];
          };

          Heap.prototype.contains = function (x) {
            return this.nodes.indexOf(x) !== -1;
          };

          Heap.prototype.replace = function (x) {
            return heapreplace(this.nodes, x, this.cmp);
          };

          Heap.prototype.pushpop = function (x) {
            return heappushpop(this.nodes, x, this.cmp);
          };

          Heap.prototype.heapify = function () {
            return heapify(this.nodes, this.cmp);
          };

          Heap.prototype.updateItem = function (x) {
            return updateItem(this.nodes, x, this.cmp);
          };

          Heap.prototype.clear = function () {
            return this.nodes = [];
          };

          Heap.prototype.empty = function () {
            return this.nodes.length === 0;
          };

          Heap.prototype.size = function () {
            return this.nodes.length;
          };

          Heap.prototype.clone = function () {
            var heap;
            heap = new Heap();
            heap.nodes = this.nodes.slice(0);
            return heap;
          };

          Heap.prototype.toArray = function () {
            return this.nodes.slice(0);
          };

          Heap.prototype.insert = Heap.prototype.push;

          Heap.prototype.top = Heap.prototype.peek;

          Heap.prototype.front = Heap.prototype.peek;

          Heap.prototype.has = Heap.prototype.contains;

          Heap.prototype.copy = Heap.prototype.clone;

          return Heap;
        }();

        (function (root, factory) {
          if (true) {
            return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') {
            return module.exports = factory();
          } else {
            return root.Heap = factory();
          }
        })(this, function () {
          return Heap;
        });
      }).call(this);

      /***/
    },
    /* 34 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      // search, spanning trees, etc
      var elesfn = {

        // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
        // implemented from pseudocode from wikipedia
        kruskal: function kruskal(weightFn) {
          var cy = this.cy();

          weightFn = is.fn(weightFn) ? weightFn : function () {
            return 1;
          }; // if not specified, assume each edge has equal weight (1)

          function findSet(ele) {
            for (var i = 0; i < forest.length; i++) {
              var eles = forest[i];

              if (eles.anySame(ele)) {
                return {
                  eles: eles,
                  index: i
                };
              }
            }
          }

          var A = cy.collection(cy, []);
          var forest = [];
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            forest.push(nodes[i].collection());
          }

          var edges = this.edges();
          var S = edges.toArray().sort(function (a, b) {
            var weightA = weightFn(a);
            var weightB = weightFn(b);

            return weightA - weightB;
          });

          for (var i = 0; i < S.length; i++) {
            var edge = S[i];
            var u = edge.source()[0];
            var v = edge.target()[0];
            var setU = findSet(u);
            var setV = findSet(v);

            if (setU.index !== setV.index) {
              A = A.add(edge);

              // combine forests for u and v
              forest[setU.index] = setU.eles.add(setV.eles);
              forest.splice(setV.index, 1);
            }
          }

          return nodes.add(A);
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 35 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        // Implemented from pseudocode from wikipedia
        aStar: function aStar(options) {
          var eles = this;

          options = options || {};

          // Reconstructs the path from Start to End, acumulating the result in pathAcum
          var reconstructPath = function reconstructPath(start, end, cameFromMap, pathAcum) {
            // Base case
            if (start == end) {
              pathAcum.unshift(cy.getElementById(end));
              return pathAcum;
            }

            if (end in cameFromMap) {
              // We know which node is before the last one
              var previous = cameFromMap[end];
              var previousEdge = cameFromEdge[end];

              pathAcum.unshift(cy.getElementById(previousEdge));
              pathAcum.unshift(cy.getElementById(end));

              return reconstructPath(start, previous, cameFromMap, pathAcum);
            }

            // We should not reach here!
            return undefined;
          };

          // Returns the index of the element in openSet which has minimum fScore
          var findMin = function findMin(openSet, fScore) {
            if (openSet.length === 0) {
              // Should never be the case
              return undefined;
            }
            var minPos = 0;
            var tempScore = fScore[openSet[0]];
            for (var i = 1; i < openSet.length; i++) {
              var s = fScore[openSet[i]];
              if (s < tempScore) {
                tempScore = s;
                minPos = i;
              }
            }
            return minPos;
          };

          var cy = this._private.cy;

          // root - mandatory!
          if (options != null && options.root != null) {
            var source = is.string(options.root) ?
            // use it as a selector, e.g. "#rootID
            this.filter(options.root)[0] : options.root[0];
          } else {
            return undefined;
          }

          // goal - mandatory!
          if (options.goal != null) {
            var target = is.string(options.goal) ?
            // use it as a selector, e.g. "#goalID
            this.filter(options.goal)[0] : options.goal[0];
          } else {
            return undefined;
          }

          // Heuristic function - optional
          if (options.heuristic != null && is.fn(options.heuristic)) {
            var heuristic = options.heuristic;
          } else {
            var heuristic = function heuristic() {
              return 0;
            }; // use constant if unspecified
          }

          // Weight function - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var sid = source.id();
          var tid = target.id();

          var closedSet = [];
          var openSet = [sid];
          var cameFrom = {};
          var cameFromEdge = {};
          var gScore = {};
          var fScore = {};

          gScore[sid] = 0;
          fScore[sid] = heuristic(source);

          // Counter
          var steps = 0;

          // Main loop
          while (openSet.length > 0) {
            var minPos = findMin(openSet, fScore);
            var cMin = cy.getElementById(openSet[minPos]);
            var cMinId = cMin.id();
            steps++;

            // If we've found our goal, then we are done
            if (cMinId == tid) {
              var rPath = reconstructPath(sid, tid, cameFrom, []);

              return {
                found: true,
                distance: gScore[cMinId],
                path: eles.spawn(rPath),
                steps: steps
              };
            }

            // Add cMin to processed nodes
            closedSet.push(cMinId);
            // Remove cMin from boundary nodes
            openSet.splice(minPos, 1);

            // Update scores for neighbors of cMin
            // Take into account if graph is directed or not
            var vwEdges = cMin._private.edges;

            for (var i = 0; i < vwEdges.length; i++) {
              var e = vwEdges[i];

              // edge must be in set of calling eles
              if (!this.hasElementWithId(e.id())) {
                continue;
              }

              // cMin must be the source of edge if directed
              if (directed && e.data('source') !== cMinId) {
                continue;
              }

              var wSrc = e.source();
              var wTgt = e.target();

              var w = wSrc.id() !== cMinId ? wSrc : wTgt;
              var wid = w.id();

              // node must be in set of calling eles
              if (!this.hasElementWithId(wid)) {
                continue;
              }

              // if node is in closedSet, ignore it
              if (closedSet.indexOf(wid) != -1) {
                continue;
              }

              // New tentative score for node w
              var tempScore = gScore[cMinId] + weightFn(e);

              // Update gScore for node w if:
              //   w not present in openSet
              // OR
              //   tentative gScore is less than previous value

              // w not in openSet
              if (openSet.indexOf(wid) == -1) {
                gScore[wid] = tempScore;
                fScore[wid] = tempScore + heuristic(w);
                openSet.push(wid); // Add node to openSet
                cameFrom[wid] = cMinId;
                cameFromEdge[wid] = e.id();
                continue;
              }
              // w already in openSet, but with greater gScore
              if (tempScore < gScore[wid]) {
                gScore[wid] = tempScore;
                fScore[wid] = tempScore + heuristic(w);
                cameFrom[wid] = cMinId;
              }
            } // End of neighbors update
          } // End of main loop

          // If we've reached here, then we've not reached our goal
          return {
            found: false,
            distance: undefined,
            path: undefined,
            steps: steps
          };
        }

      }; // elesfn


      module.exports = elesfn;

      /***/
    },
    /* 36 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        // Implemented from pseudocode from wikipedia
        floydWarshall: function floydWarshall(options) {
          options = options || {};

          var cy = this.cy();

          // Weight function - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;

          // mapping: node id -> position in nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Initialize distance matrix
          var dist = [];
          for (var i = 0; i < numNodes; i++) {
            var newRow = new Array(numNodes);
            for (var j = 0; j < numNodes; j++) {
              if (i == j) {
                newRow[j] = 0;
              } else {
                newRow[j] = Infinity;
              }
            }
            dist.push(newRow);
          }

          // Initialize matrix used for path reconstruction
          // Initialize distance matrix
          var next = [];
          var edgeNext = [];

          var initMatrix = function initMatrix(next) {
            for (var i = 0; i < numNodes; i++) {
              var newRow = new Array(numNodes);
              for (var j = 0; j < numNodes; j++) {
                newRow[j] = undefined;
              }
              next.push(newRow);
            }
          };

          initMatrix(next);
          initMatrix(edgeNext);

          // Process edges
          for (var i = 0; i < edges.length; i++) {
            var sourceIndex = id2position[edges[i].source().id()];
            var targetIndex = id2position[edges[i].target().id()];
            var weight = weightFn(edges[i]);

            // Check if already process another edge between same 2 nodes
            if (dist[sourceIndex][targetIndex] > weight) {
              dist[sourceIndex][targetIndex] = weight;
              next[sourceIndex][targetIndex] = targetIndex;
              edgeNext[sourceIndex][targetIndex] = edges[i];
            }
          }

          // If undirected graph, process 'reversed' edges
          if (!directed) {
            for (var i = 0; i < edges.length; i++) {
              var sourceIndex = id2position[edges[i].target().id()];
              var targetIndex = id2position[edges[i].source().id()];
              var weight = weightFn(edges[i]);

              // Check if already process another edge between same 2 nodes
              if (dist[sourceIndex][targetIndex] > weight) {
                dist[sourceIndex][targetIndex] = weight;
                next[sourceIndex][targetIndex] = targetIndex;
                edgeNext[sourceIndex][targetIndex] = edges[i];
              }
            }
          }

          // Main loop
          for (var k = 0; k < numNodes; k++) {
            for (var i = 0; i < numNodes; i++) {
              for (var j = 0; j < numNodes; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                  dist[i][j] = dist[i][k] + dist[k][j];
                  next[i][j] = next[i][k];
                }
              }
            }
          }

          // Build result object
          var position2id = [];
          for (var i = 0; i < numNodes; i++) {
            position2id.push(nodes[i].id());
          }

          var res = {
            distance: function distance(from, to) {
              if (is.string(from)) {
                // from is a selector string
                var fromId = cy.filter(from)[0].id();
              } else {
                // from is a node
                var fromId = from.id();
              }

              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }

              return dist[id2position[fromId]][id2position[toId]];
            },

            path: function path(from, to) {
              var reconstructPathAux = function reconstructPathAux(from, to, next, position2id, edgeNext) {
                if (from === to) {
                  return cy.getElementById(position2id[from]);
                }
                if (next[from][to] === undefined) {
                  return undefined;
                }

                var path = [cy.getElementById(position2id[from])];
                var prev = from;
                while (from !== to) {
                  prev = from;
                  from = next[from][to];

                  var edge = edgeNext[prev][from];
                  path.push(edge);

                  path.push(cy.getElementById(position2id[from]));
                }
                return path;
              };

              if (is.string(from)) {
                // from is a selector string
                var fromId = cy.filter(from)[0].id();
              } else {
                // from is a node
                var fromId = from.id();
              }

              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }

              var pathArr = reconstructPathAux(id2position[fromId], id2position[toId], next, position2id, edgeNext);

              return cy.collection(pathArr);
            }
          };

          return res;
        } // floydWarshall

      }; // elesfn

      module.exports = elesfn;

      /***/
    },
    /* 37 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var elesfn = {

        // Implemented from pseudocode from wikipedia
        bellmanFord: function bellmanFord(options) {
          var eles = this;

          options = options || {};

          // Weight function - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          // root - mandatory!
          if (options.root != null) {
            if (is.string(options.root)) {
              // use it as a selector, e.g. "#rootID
              var source = this.filter(options.root)[0];
            } else {
              var source = options.root[0];
            }
          } else {
            return undefined;
          }

          var cy = this._private.cy;
          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;

          // mapping: node id -> position in nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Initializations
          var cost = [];
          var predecessor = [];
          var predEdge = [];

          for (var i = 0; i < numNodes; i++) {
            if (nodes[i].id() === source.id()) {
              cost[i] = 0;
            } else {
              cost[i] = Infinity;
            }
            predecessor[i] = undefined;
          }

          // Edges relaxation
          var flag = false;
          for (var i = 1; i < numNodes; i++) {
            flag = false;
            for (var e = 0; e < edges.length; e++) {
              var sourceIndex = id2position[edges[e].source().id()];
              var targetIndex = id2position[edges[e].target().id()];
              var weight = weightFn(edges[e]);

              var temp = cost[sourceIndex] + weight;
              if (temp < cost[targetIndex]) {
                cost[targetIndex] = temp;
                predecessor[targetIndex] = sourceIndex;
                predEdge[targetIndex] = edges[e];
                flag = true;
              }

              // If undirected graph, we need to take into account the 'reverse' edge
              if (!directed) {
                var temp = cost[targetIndex] + weight;
                if (temp < cost[sourceIndex]) {
                  cost[sourceIndex] = temp;
                  predecessor[sourceIndex] = targetIndex;
                  predEdge[sourceIndex] = edges[e];
                  flag = true;
                }
              }
            }

            if (!flag) {
              break;
            }
          }

          if (flag) {
            // Check for negative weight cycles
            for (var e = 0; e < edges.length; e++) {
              var sourceIndex = id2position[edges[e].source().id()];
              var targetIndex = id2position[edges[e].target().id()];
              var weight = weightFn(edges[e]);

              if (cost[sourceIndex] + weight < cost[targetIndex]) {
                util.error('Graph contains a negative weight cycle for Bellman-Ford');
                return { pathTo: undefined,
                  distanceTo: undefined,
                  hasNegativeWeightCycle: true };
              }
            }
          }

          // Build result object
          var position2id = [];
          for (var i = 0; i < numNodes; i++) {
            position2id.push(nodes[i].id());
          }

          var res = {
            distanceTo: function distanceTo(to) {
              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }

              return cost[id2position[toId]];
            },

            pathTo: function pathTo(to) {

              var reconstructPathAux = function reconstructPathAux(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
                for (;;) {
                  // Add toId to path
                  acumPath.push(cy.getElementById(position2id[toPos]));
                  acumPath.push(predEdge[toPos]);

                  if (fromPos === toPos) {
                    // reached starting node
                    return acumPath;
                  }

                  // If no path exists, discart acumulated path and return undefined
                  var predPos = predecessor[toPos];
                  if (typeof predPos === 'undefined') {
                    return undefined;
                  }

                  toPos = predPos;
                }
              };

              if (is.string(to)) {
                // to is a selector string
                var toId = cy.filter(to)[0].id();
              } else {
                // to is a node
                var toId = to.id();
              }
              var path = [];

              // This returns a reversed path
              var res = reconstructPathAux(predecessor, id2position[source.id()], id2position[toId], position2id, path, predEdge);

              // Get it in the correct order and return it
              if (res != null) {
                res.reverse();
              }

              return eles.spawn(res);
            },

            hasNegativeWeightCycle: false
          };

          return res;
        } // bellmanFord

      }; // elesfn

      module.exports = elesfn;

      /***/
    },
    /* 38 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var elesfn = {

        // Computes the minimum cut of an undirected graph
        // Returns the correct answer with high probability
        kargerStein: function kargerStein(options) {
          var eles = this;

          options = options || {};

          // Function which colapses 2 (meta) nodes into one
          // Updates the remaining edge lists
          // Receives as a paramater the edge which causes the collapse
          var colapse = function colapse(edgeIndex, nodeMap, remainingEdges) {
            var edgeInfo = remainingEdges[edgeIndex];
            var sourceIn = edgeInfo[1];
            var targetIn = edgeInfo[2];
            var partition1 = nodeMap[sourceIn];
            var partition2 = nodeMap[targetIn];

            // Delete all edges between partition1 and partition2
            var newEdges = remainingEdges.filter(function (edge) {
              if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
                return false;
              }
              if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
                return false;
              }
              return true;
            });

            // All edges pointing to partition2 should now point to partition1
            for (var i = 0; i < newEdges.length; i++) {
              var edge = newEdges[i];
              if (edge[1] === partition2) {
                // Check source
                newEdges[i] = edge.slice(0);
                newEdges[i][1] = partition1;
              } else if (edge[2] === partition2) {
                // Check target
                newEdges[i] = edge.slice(0);
                newEdges[i][2] = partition1;
              }
            }

            // Move all nodes from partition2 to partition1
            for (var i = 0; i < nodeMap.length; i++) {
              if (nodeMap[i] === partition2) {
                nodeMap[i] = partition1;
              }
            }

            return newEdges;
          };

          // Contracts a graph until we reach a certain number of meta nodes
          var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
            // Stop condition
            if (size <= sizeLimit) {
              return remainingEdges;
            }

            // Choose an edge randomly
            var edgeIndex = Math.floor(Math.random() * remainingEdges.length);

            // Colapse graph based on edge
            var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);

            return contractUntil(metaNodeMap, newEdges, size - 1, sizeLimit);
          };

          var cy = this._private.cy;
          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;
          var numEdges = edges.length;
          var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
          var stopSize = Math.floor(numNodes / Math.sqrt(2));

          if (numNodes < 2) {
            util.error('At least 2 nodes are required for Karger-Stein algorithm');
            return undefined;
          }

          // Create numerical identifiers for each node
          // mapping: node id -> position in nodes array
          // for reverse mapping, simply use nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Now store edge destination as indexes
          // Format for each edge (edge index, source node index, target node index)
          var edgeIndexes = [];
          for (var i = 0; i < numEdges; i++) {
            var e = edges[i];
            edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
          }

          // We will store the best cut found here
          var minCutSize = Infinity;
          var minCut;

          // Initial meta node partition
          var originalMetaNode = [];
          for (var i = 0; i < numNodes; i++) {
            originalMetaNode.push(i);
          }

          // Main loop
          for (var iter = 0; iter <= numIter; iter++) {
            // Create new meta node partition
            var metaNodeMap = originalMetaNode.slice(0);

            // Contract until stop point (stopSize nodes)
            var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);

            // Create a copy of the colapsed nodes state
            var metaNodeMap2 = metaNodeMap.slice(0);

            // Run 2 iterations starting in the stop state
            var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
            var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

            // Is any of the 2 results the best cut so far?
            if (res1.length <= res2.length && res1.length < minCutSize) {
              minCutSize = res1.length;
              minCut = [res1, metaNodeMap];
            } else if (res2.length <= res1.length && res2.length < minCutSize) {
              minCutSize = res2.length;
              minCut = [res2, metaNodeMap2];
            }
          } // end of main loop


          // Construct result
          var resEdges = minCut[0].map(function (e) {
            return edges[e[0]];
          });
          var partition1 = [];
          var partition2 = [];

          // traverse metaNodeMap for best cut
          var witnessNodePartition = minCut[1][0];
          for (var i = 0; i < minCut[1].length; i++) {
            var partitionId = minCut[1][i];
            if (partitionId === witnessNodePartition) {
              partition1.push(nodes[i]);
            } else {
              partition2.push(nodes[i]);
            }
          }

          var ret = {
            cut: eles.spawn(cy, resEdges),
            partition1: eles.spawn(partition1),
            partition2: eles.spawn(partition2)
          };

          return ret;
        }
      }; // elesfn


      module.exports = elesfn;

      /***/
    },
    /* 39 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        pageRank: function pageRank(options) {
          options = options || {};

          var normalizeVector = function normalizeVector(vector) {
            var length = vector.length;

            // First, get sum of all elements
            var total = 0;
            for (var i = 0; i < length; i++) {
              total += vector[i];
            }

            // Now, divide each by the sum of all elements
            for (var i = 0; i < length; i++) {
              vector[i] = vector[i] / total;
            }
          };

          // dampingFactor - optional
          if (options != null && options.dampingFactor != null) {
            var dampingFactor = options.dampingFactor;
          } else {
            var dampingFactor = 0.8; // Default damping factor
          }

          // desired precision - optional
          if (options != null && options.precision != null) {
            var epsilon = options.precision;
          } else {
            var epsilon = 0.000001; // Default precision
          }

          // Max number of iterations - optional
          if (options != null && options.iterations != null) {
            var numIter = options.iterations;
          } else {
            var numIter = 200; // Default number of iterations
          }

          // Weight function - optional
          if (options != null && options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          var cy = this._private.cy;
          var edges = this.edges().stdFilter(function (e) {
            return !e.isLoop();
          });
          var nodes = this.nodes();
          var numNodes = nodes.length;
          var numEdges = edges.length;

          // Create numerical identifiers for each node
          // mapping: node id -> position in nodes array
          // for reverse mapping, simply use nodes array
          var id2position = {};
          for (var i = 0; i < numNodes; i++) {
            id2position[nodes[i].id()] = i;
          }

          // Construct transposed adjacency matrix
          // First lets have a zeroed matrix of the right size
          // We'll also keep track of the sum of each column
          var matrix = [];
          var columnSum = [];
          var additionalProb = (1 - dampingFactor) / numNodes;

          // Create null matric
          for (var i = 0; i < numNodes; i++) {
            var newRow = [];
            for (var j = 0; j < numNodes; j++) {
              newRow.push(0.0);
            }
            matrix.push(newRow);
            columnSum.push(0.0);
          }

          // Now, process edges
          for (var i = 0; i < numEdges; i++) {
            var edge = edges[i];
            var s = id2position[edge.source().id()];
            var t = id2position[edge.target().id()];
            var w = weightFn(edge);

            // Update matrix
            matrix[t][s] += w;

            // Update column sum
            columnSum[s] += w;
          }

          // Add additional probability based on damping factor
          // Also, take into account columns that have sum = 0
          var p = 1.0 / numNodes + additionalProb; // Shorthand
          // Traverse matrix, column by column
          for (var j = 0; j < numNodes; j++) {
            if (columnSum[j] === 0) {
              // No 'links' out from node jth, assume equal probability for each possible node
              for (var i = 0; i < numNodes; i++) {
                matrix[i][j] = p;
              }
            } else {
              // Node jth has outgoing link, compute normalized probabilities
              for (var i = 0; i < numNodes; i++) {
                matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
              }
            }
          }

          // Compute dominant eigenvector using power method
          var eigenvector = [];
          var nullVector = [];
          var previous;

          // Start with a vector of all 1's
          // Also, initialize a null vector which will be used as shorthand
          for (var i = 0; i < numNodes; i++) {
            eigenvector.push(1.0);
            nullVector.push(0.0);
          }

          for (var iter = 0; iter < numIter; iter++) {
            // New array with all 0's
            var temp = nullVector.slice(0);

            // Multiply matrix with previous result
            for (var i = 0; i < numNodes; i++) {
              for (var j = 0; j < numNodes; j++) {
                temp[i] += matrix[i][j] * eigenvector[j];
              }
            }

            normalizeVector(temp);
            previous = eigenvector;
            eigenvector = temp;

            var diff = 0;
            // Compute difference (squared module) of both vectors
            for (var i = 0; i < numNodes; i++) {
              diff += Math.pow(previous[i] - eigenvector[i], 2);
            }

            // If difference is less than the desired threshold, stop iterating
            if (diff < epsilon) {
              break;
            }
          }

          // Construct result
          var res = {
            rank: function rank(node) {
              if (is.string(node)) {
                // is a selector string
                var nodeId = cy.filter(node)[0].id();
              } else {
                // is a node object
                var nodeId = node.id();
              }
              return eigenvector[id2position[nodeId]];
            }
          };

          return res;
        } // pageRank

      }; // elesfn

      module.exports = elesfn;

      /***/
    },
    /* 40 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var elesfn = {

        degreeCentralityNormalized: function degreeCentralityNormalized(options) {
          options = options || {};

          var cy = this.cy();

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var nodes = this.nodes();
          var numNodes = nodes.length;

          if (!directed) {
            var degrees = {};
            var maxDegree = 0;

            for (var i = 0; i < numNodes; i++) {
              var node = nodes[i];
              // add current node to the current options object and call degreeCentrality
              var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));
              if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;

              degrees[node.id()] = currDegree.degree;
            }

            return {
              degree: function degree(node) {
                if (maxDegree == 0) return 0;

                if (is.string(node)) {
                  // from is a selector string
                  var node = cy.filter(node)[0].id();
                } else {
                  // from is a node
                  var node = node.id();
                }

                return degrees[node] / maxDegree;
              }
            };
          } else {
            var indegrees = {};
            var outdegrees = {};
            var maxIndegree = 0;
            var maxOutdegree = 0;

            for (var i = 0; i < numNodes; i++) {
              var node = nodes[i];
              // add current node to the current options object and call degreeCentrality
              var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));

              if (maxIndegree < currDegree.indegree) maxIndegree = currDegree.indegree;

              if (maxOutdegree < currDegree.outdegree) maxOutdegree = currDegree.outdegree;

              indegrees[node.id()] = currDegree.indegree;
              outdegrees[node.id()] = currDegree.outdegree;
            }

            return {
              indegree: function indegree(node) {
                if (maxIndegree == 0) return 0;

                if (is.string(node)) {
                  // from is a selector string
                  var node = cy.filter(node)[0].id();
                } else {
                  // from is a node
                  var node = node.id();
                }

                return indegrees[node] / maxIndegree;
              },
              outdegree: function outdegree(node) {
                if (maxOutdegree == 0) return 0;

                if (is.string(node)) {
                  // from is a selector string
                  var node = cy.filter(node)[0].id();
                } else {
                  // from is a node
                  var node = node.id();
                }

                return outdegrees[node] / maxOutdegree;
              }

            };
          }
        }, // degreeCentralityNormalized

        // Implemented from the algorithm in Opsahl's paper
        // "Node centrality in weighted networks: Generalizing degree and shortest paths"
        // check the heading 2 "Degree"
        degreeCentrality: function degreeCentrality(options) {
          options = options || {};

          var callingEles = this;

          // root - mandatory!
          if (options != null && options.root != null) {
            var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
          } else {
            return undefined;
          }

          // weight - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weightFn = options.weight;
          } else {
            // If not specified, assume each edge has equal weight (1)
            var weightFn = function weightFn(e) {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          // alpha - optional
          if (options.alpha != null && is.number(options.alpha)) {
            var alpha = options.alpha;
          } else {
            alpha = 0;
          }

          if (!directed) {
            var connEdges = root.connectedEdges().intersection(callingEles);
            var k = connEdges.length;
            var s = 0;

            // Now, sum edge weights
            for (var i = 0; i < connEdges.length; i++) {
              var edge = connEdges[i];
              s += weightFn(edge);
            }

            return {
              degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
            };
          } else {
            var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection(callingEles);
            var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection(callingEles);
            var k_in = incoming.length;
            var k_out = outgoing.length;
            var s_in = 0;
            var s_out = 0;

            // Now, sum incoming edge weights
            for (var i = 0; i < incoming.length; i++) {
              var edge = incoming[i];
              s_in += weightFn(edge);
            }

            // Now, sum outgoing edge weights
            for (var i = 0; i < outgoing.length; i++) {
              var edge = outgoing[i];
              s_out += weightFn(edge);
            }

            return {
              indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
              outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
            };
          }
        } // degreeCentrality

      }; // elesfn

      // nice, short mathemathical alias
      elesfn.dc = elesfn.degreeCentrality;
      elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

      module.exports = elesfn;

      /***/
    },
    /* 41 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var elesfn = {

        closenessCentralityNormalized: function closenessCentralityNormalized(options) {
          options = options || {};

          var cy = this.cy();

          var harmonic = options.harmonic;
          if (harmonic === undefined) {
            harmonic = true;
          }

          var closenesses = {};
          var maxCloseness = 0;
          var nodes = this.nodes();
          var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

          // Compute closeness for every node and find the maximum closeness
          for (var i = 0; i < nodes.length; i++) {
            var currCloseness = 0;
            for (var j = 0; j < nodes.length; j++) {
              if (i != j) {
                var d = fw.distance(nodes[i], nodes[j]);

                if (harmonic) {
                  currCloseness += 1 / d;
                } else {
                  currCloseness += d;
                }
              }
            }

            if (!harmonic) {
              currCloseness = 1 / currCloseness;
            }

            if (maxCloseness < currCloseness) {
              maxCloseness = currCloseness;
            }

            closenesses[nodes[i].id()] = currCloseness;
          }

          return {
            closeness: function closeness(node) {
              if (maxCloseness == 0) {
                return 0;
              }

              if (is.string(node)) {
                // from is a selector string
                var node = cy.filter(node)[0].id();
              } else {
                // from is a node
                var node = node.id();
              }

              return closenesses[node] / maxCloseness;
            }
          };
        },

        // Implemented from pseudocode from wikipedia
        closenessCentrality: function closenessCentrality(options) {
          options = options || {};

          // root - mandatory!
          if (options.root != null) {
            if (is.string(options.root)) {
              // use it as a selector, e.g. "#rootID
              var root = this.filter(options.root)[0];
            } else {
              var root = options.root[0];
            }
          } else {
            return undefined;
          }

          // weight - optional
          if (options.weight != null && is.fn(options.weight)) {
            var weight = options.weight;
          } else {
            var weight = function weight() {
              return 1;
            };
          }

          // directed - optional
          if (options.directed != null && is.bool(options.directed)) {
            var directed = options.directed;
          } else {
            var directed = false;
          }

          var harmonic = options.harmonic;
          if (harmonic === undefined) {
            harmonic = true;
          }

          // we need distance from this node to every other node
          var dijkstra = this.dijkstra({
            root: root,
            weight: weight,
            directed: directed
          });
          var totalDistance = 0;

          var nodes = this.nodes();
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].id() != root.id()) {
              var d = dijkstra.distanceTo(nodes[i]);

              if (harmonic) {
                totalDistance += 1 / d;
              } else {
                totalDistance += d;
              }
            }
          }

          return harmonic ? totalDistance : 1 / totalDistance;
        } // closenessCentrality

      }; // elesfn

      // nice, short mathemathical alias
      elesfn.cc = elesfn.closenessCentrality;
      elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

      module.exports = elesfn;

      /***/
    },
    /* 42 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Heap = __webpack_require__(9);

      var elesfn = {

        // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
        betweennessCentrality: function betweennessCentrality(options) {
          options = options || {};

          // Weight - optional
          var weighted, weightFn;
          if (is.fn(options.weight)) {
            weightFn = options.weight;
            weighted = true;
          } else {
            weighted = false;
          }

          // Directed - default false
          var directed = options.directed != null ? options.directed : false;

          var cy = this._private.cy;

          // starting
          var V = this.nodes();
          var A = {};
          var _C = {};
          var max = 0;
          var C = {
            set: function set(key, val) {
              _C[key] = val;

              if (val > max) {
                max = val;
              }
            },

            get: function get(key) {
              return _C[key];
            }
          };

          // A contains the neighborhoods of every node
          for (var i = 0; i < V.length; i++) {
            var v = V[i];
            var vid = v.id();

            if (directed) {
              A[vid] = v.outgoers().nodes(); // get outgoers of every node
            } else {
              A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
            }

            C.set(vid, 0);
          }

          for (var s = 0; s < V.length; s++) {
            var sid = V[s].id();
            var S = []; // stack
            var P = {};
            var g = {};
            var d = {};
            var Q = new Heap(function (a, b) {
              return d[a] - d[b];
            }); // queue

            // init dictionaries
            for (var i = 0; i < V.length; i++) {
              var vid = V[i].id();

              P[vid] = [];
              g[vid] = 0;
              d[vid] = Infinity;
            }

            g[sid] = 1; // sigma
            d[sid] = 0; // distance to s

            Q.push(sid);

            while (!Q.empty()) {
              var v = Q.pop();

              S.push(v);

              if (weighted) {
                for (var j = 0; j < A[v].length; j++) {
                  var w = A[v][j];
                  var vEle = cy.getElementById(v);

                  var edge;
                  if (vEle.edgesTo(w).length > 0) {
                    edge = vEle.edgesTo(w)[0];
                  } else {
                    edge = w.edgesTo(vEle)[0];
                  }

                  var edgeWeight = weightFn(edge);

                  w = w.id();

                  if (d[w] > d[v] + edgeWeight) {
                    d[w] = d[v] + edgeWeight;

                    if (Q.nodes.indexOf(w) < 0) {
                      //if w is not in Q
                      Q.push(w);
                    } else {
                      // update position if w is in Q
                      Q.updateItem(w);
                    }

                    g[w] = 0;
                    P[w] = [];
                  }

                  if (d[w] == d[v] + edgeWeight) {
                    g[w] = g[w] + g[v];
                    P[w].push(v);
                  }
                }
              } else {
                for (var j = 0; j < A[v].length; j++) {
                  var w = A[v][j].id();

                  if (d[w] == Infinity) {
                    Q.push(w);

                    d[w] = d[v] + 1;
                  }

                  if (d[w] == d[v] + 1) {
                    g[w] = g[w] + g[v];
                    P[w].push(v);
                  }
                }
              }
            }

            var e = {};
            for (var i = 0; i < V.length; i++) {
              e[V[i].id()] = 0;
            }

            while (S.length > 0) {
              var w = S.pop();

              for (var j = 0; j < P[w].length; j++) {
                var v = P[w][j];

                e[v] = e[v] + g[v] / g[w] * (1 + e[w]);

                if (w != V[s].id()) {
                  C.set(w, C.get(w) + e[w]);
                }
              }
            }
          }

          var ret = {
            betweenness: function betweenness(node) {
              if (is.string(node)) {
                var node = cy.filter(node).id();
              } else {
                var node = node.id();
              }

              return C.get(node);
            },

            betweennessNormalized: function betweennessNormalized(node) {
              if (max == 0) return 0;

              if (is.string(node)) {
                var node = cy.filter(node).id();
              } else {
                var node = node.id();
              }

              return C.get(node) / max;
            }
          };

          // alias
          ret.betweennessNormalised = ret.betweennessNormalized;

          return ret;
        } // betweennessCentrality

      }; // elesfn

      // nice, short mathemathical alias
      elesfn.bc = elesfn.betweennessCentrality;

      module.exports = elesfn;

      /***/
    },
    /* 43 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);

      var elesfn = {
        animate: define.animate(),
        animation: define.animation(),
        animated: define.animated(),
        clearQueue: define.clearQueue(),
        delay: define.delay(),
        delayAnimation: define.delayAnimation(),
        stop: define.stop()
      };

      module.exports = elesfn;

      /***/
    },
    /* 44 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var Animation = __webpack_require__(45);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var define = {

        animated: function animated() {
          return function animatedImpl() {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return false;
            }

            var ele = all[0];

            if (ele) {
              return ele._private.animation.current.length > 0;
            }
          };
        }, // animated

        clearQueue: function clearQueue() {
          return function clearQueueImpl() {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            for (var i = 0; i < all.length; i++) {
              var ele = all[i];
              ele._private.animation.queue = [];
            }

            return this;
          };
        }, // clearQueue

        delay: function delay() {
          return function delayImpl(time, complete) {
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            return this.animate({
              delay: time,
              duration: time,
              complete: complete
            });
          };
        }, // delay

        delayAnimation: function delayAnimation() {
          return function delayAnimationImpl(time, complete) {
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            return this.animation({
              delay: time,
              duration: time,
              complete: complete
            });
          };
        }, // delay

        animation: function animation() {
          return function animationImpl(properties, params) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;
            var isCore = !selfIsArrayLike;
            var isEles = !isCore;

            if (!cy.styleEnabled()) {
              return this;
            }

            var style = cy.style();

            properties = util.assign({}, properties, params);

            var propertiesEmpty = Object.keys(properties).length === 0;

            if (propertiesEmpty) {
              return new Animation(all[0], properties); // nothing to animate
            }

            if (properties.duration === undefined) {
              properties.duration = 400;
            }

            switch (properties.duration) {
              case 'slow':
                properties.duration = 600;
                break;
              case 'fast':
                properties.duration = 200;
                break;
            }

            if (isEles) {
              properties.style = style.getPropsList(properties.style || properties.css);

              properties.css = undefined;
            }

            if (isEles && properties.renderedPosition != null) {
              var rpos = properties.renderedPosition;
              var pan = cy.pan();
              var zoom = cy.zoom();

              properties.position = math.renderedToModelPosition(rpos, zoom, pan);
            }

            // override pan w/ panBy if set
            if (isCore && properties.panBy != null) {
              var panBy = properties.panBy;
              var cyPan = cy.pan();

              properties.pan = {
                x: cyPan.x + panBy.x,
                y: cyPan.y + panBy.y
              };
            }

            // override pan w/ center if set
            var center = properties.center || properties.centre;
            if (isCore && center != null) {
              var centerPan = cy.getCenterPan(center.eles, properties.zoom);

              if (centerPan != null) {
                properties.pan = centerPan;
              }
            }

            // override pan & zoom w/ fit if set
            if (isCore && properties.fit != null) {
              var fit = properties.fit;
              var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

              if (fitVp != null) {
                properties.pan = fitVp.pan;
                properties.zoom = fitVp.zoom;
              }
            }

            // override zoom (& potentially pan) w/ zoom obj if set
            if (isCore && is.plainObject(properties.zoom)) {
              var vp = cy.getZoomedViewport(properties.zoom);

              if (vp != null) {
                if (vp.zoomed) {
                  properties.zoom = vp.zoom;
                }

                if (vp.panned) {
                  properties.pan = vp.pan;
                }
              }
            }

            return new Animation(all[0], properties);
          };
        }, // animate

        animate: function animate() {
          return function animateImpl(properties, params) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            if (params) {
              properties = util.extend({}, properties, params);
            }

            // manually hook and run the animation
            for (var i = 0; i < all.length; i++) {
              var ele = all[i];
              var queue = ele.animated() && (properties.queue === undefined || properties.queue);

              var ani = ele.animation(properties, queue ? { queue: true } : undefined);

              ani.play();
            }

            return this; // chaining
          };
        }, // animate

        stop: function stop() {
          return function stopImpl(clearQueue, jumpToEnd) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            for (var i = 0; i < all.length; i++) {
              var ele = all[i];
              var _p = ele._private;
              var anis = _p.animation.current;

              for (var j = 0; j < anis.length; j++) {
                var ani = anis[j];
                var ani_p = ani._private;

                if (jumpToEnd) {
                  // next iteration of the animation loop, the animation
                  // will go straight to the end and be removed
                  ani_p.duration = 0;
                }
              }

              // clear the queue of future animations
              if (clearQueue) {
                _p.animation.queue = [];
              }

              if (!jumpToEnd) {
                _p.animation.current = [];
              }
            }

            // we have to notify (the animation loop doesn't do it for us on `stop`)
            cy.notify({
              eles: this,
              type: 'draw'
            });

            return this;
          };
        } // stop

      }; // define

      module.exports = define;

      /***/
    },
    /* 45 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);

      var Animation = function Animation(target, opts, opts2) {
        var _p = this._private = util.extend({
          duration: 1000
        }, opts, opts2);

        _p.target = target;
        _p.style = _p.style || _p.css;
        _p.started = false;
        _p.playing = false;
        _p.hooked = false;
        _p.applying = false;
        _p.progress = 0;
        _p.completes = [];
        _p.frames = [];

        if (_p.complete && is.fn(_p.complete)) {
          _p.completes.push(_p.complete);
        }

        // for future timeline/animations impl
        this.length = 1;
        this[0] = this;
      };

      var anifn = Animation.prototype;

      util.extend(anifn, {

        instanceString: function instanceString() {
          return 'animation';
        },

        hook: function hook() {
          var _p = this._private;

          if (!_p.hooked) {
            // add to target's animation queue
            var q = void 0;
            var tAni = _p.target._private.animation;
            if (_p.queue) {
              q = tAni.queue;
            } else {
              q = tAni.current;
            }
            q.push(this);

            // add to the animation loop pool
            if (is.elementOrCollection(_p.target)) {
              _p.target.cy().addToAnimationPool(_p.target);
            }

            _p.hooked = true;
          }

          return this;
        },

        play: function play() {
          var _p = this._private;

          // autorewind
          if (_p.progress === 1) {
            _p.progress = 0;
          }

          _p.playing = true;
          _p.started = false; // needs to be started by animation loop
          _p.stopped = false;

          this.hook();

          // the animation loop will start the animation...

          return this;
        },

        playing: function playing() {
          return this._private.playing;
        },

        apply: function apply() {
          var _p = this._private;

          _p.applying = true;
          _p.started = false; // needs to be started by animation loop
          _p.stopped = false;

          this.hook();

          // the animation loop will apply the animation at this progress

          return this;
        },

        applying: function applying() {
          return this._private.applying;
        },

        pause: function pause() {
          var _p = this._private;

          _p.playing = false;
          _p.started = false;

          return this;
        },

        stop: function stop() {
          var _p = this._private;

          _p.playing = false;
          _p.started = false;
          _p.stopped = true; // to be removed from animation queues

          return this;
        },

        rewind: function rewind() {
          return this.progress(0);
        },

        fastforward: function fastforward() {
          return this.progress(1);
        },

        time: function time(t) {
          var _p = this._private;

          if (t === undefined) {
            return _p.progress * _p.duration;
          } else {
            return this.progress(t / _p.duration);
          }
        },

        progress: function progress(p) {
          var _p = this._private;
          var wasPlaying = _p.playing;

          if (p === undefined) {
            return _p.progress;
          } else {
            if (wasPlaying) {
              this.pause();
            }

            _p.progress = p;
            _p.started = false;

            if (wasPlaying) {
              this.play();
            }
          }

          return this;
        },

        completed: function completed() {
          return this._private.progress === 1;
        },

        reverse: function reverse() {
          var _p = this._private;
          var wasPlaying = _p.playing;

          if (wasPlaying) {
            this.pause();
          }

          _p.progress = 1 - _p.progress;
          _p.started = false;

          var swap = function swap(a, b) {
            var _pa = _p[a];

            if (_pa == null) {
              return;
            }

            _p[a] = _p[b];
            _p[b] = _pa;
          };

          swap('zoom', 'startZoom');
          swap('pan', 'startPan');
          swap('position', 'startPosition');

          // swap styles
          if (_p.style) {
            for (var i = 0; i < _p.style.length; i++) {
              var prop = _p.style[i];
              var name = prop.name;
              var startStyleProp = _p.startStyle[name];

              _p.startStyle[name] = prop;
              _p.style[i] = startStyleProp;
            }
          }

          if (wasPlaying) {
            this.play();
          }

          return this;
        },

        promise: function promise(type) {
          var _p = this._private;

          var arr = void 0;

          switch (type) {
            case 'frame':
              arr = _p.frames;
              break;
            default:
            case 'complete':
            case 'completed':
              arr = _p.completes;
          }

          return new Promise(function (resolve, reject) {
            arr.push(function () {
              resolve();
            });
          });
        }

      });

      anifn.complete = anifn.completed;

      module.exports = Animation;

      /***/
    },
    /* 46 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }return obj;
      }

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var define = {

        // access data field
        data: function data(params) {
          var defaults = {
            field: 'data',
            bindingEvent: 'data',
            allowBinding: false,
            allowSetting: false,
            allowGetting: false,
            settingEvent: 'data',
            settingTriggersEvent: false,
            triggerFnName: 'trigger',
            immutableKeys: {}, // key => true if immutable
            updateStyle: false,
            beforeGet: function beforeGet(self) {},
            beforeSet: function beforeSet(self, obj) {},
            onSet: function onSet(self) {},
            canSet: function canSet(self) {
              return true;
            }
          };
          params = util.extend({}, defaults, params);

          return function dataImpl(name, value) {
            var p = params;
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
            var single = selfIsArrayLike ? self[0] : self;

            // .data('foo', ...)
            if (is.string(name)) {
              // set or get property

              // .data('foo')
              if (p.allowGetting && value === undefined) {
                // get

                var ret = void 0;
                if (single) {
                  p.beforeGet(single);

                  ret = single._private[p.field][name];
                }
                return ret;

                // .data('foo', 'bar')
              } else if (p.allowSetting && value !== undefined) {
                // set
                var valid = !p.immutableKeys[name];
                if (valid) {
                  var change = _defineProperty({}, name, value);

                  p.beforeSet(self, change);

                  for (var i = 0, l = all.length; i < l; i++) {
                    var ele = all[i];

                    if (p.canSet(ele)) {
                      ele._private[p.field][name] = value;
                    }
                  }

                  // update mappers if asked
                  if (p.updateStyle) {
                    self.updateStyle();
                  }

                  // call onSet callback
                  p.onSet(self);

                  if (p.settingTriggersEvent) {
                    self[p.triggerFnName](p.settingEvent);
                  }
                }
              }

              // .data({ 'foo': 'bar' })
            } else if (p.allowSetting && is.plainObject(name)) {
              // extend
              var obj = name;
              var k = void 0,
                  v = void 0;
              var keys = Object.keys(obj);

              p.beforeSet(self, obj);

              for (var _i = 0; _i < keys.length; _i++) {
                k = keys[_i];
                v = obj[k];

                var _valid = !p.immutableKeys[k];
                if (_valid) {
                  for (var j = 0; j < all.length; j++) {
                    var _ele = all[j];

                    if (p.canSet(_ele)) {
                      _ele._private[p.field][k] = v;
                    }
                  }
                }
              }

              // update mappers if asked
              if (p.updateStyle) {
                self.updateStyle();
              }

              // call onSet callback
              p.onSet(self);

              if (p.settingTriggersEvent) {
                self[p.triggerFnName](p.settingEvent);
              }

              // .data(function(){ ... })
            } else if (p.allowBinding && is.fn(name)) {
              // bind to event
              var fn = name;
              self.on(p.bindingEvent, fn);

              // .data()
            } else if (p.allowGetting && name === undefined) {
              // get whole object
              var _ret = void 0;
              if (single) {
                p.beforeGet(single);

                _ret = single._private[p.field];
              }
              return _ret;
            }

            return self; // maintain chainability
          }; // function
        }, // data

        // remove data field
        removeData: function removeData(params) {
          var defaults = {
            field: 'data',
            event: 'data',
            triggerFnName: 'trigger',
            triggerEvent: false,
            immutableKeys: {} // key => true if immutable
          };
          params = util.extend({}, defaults, params);

          return function removeDataImpl(names) {
            var p = params;
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            // .removeData('foo bar')
            if (is.string(names)) {
              // then get the list of keys, and delete them
              var keys = names.split(/\s+/);
              var l = keys.length;

              for (var i = 0; i < l; i++) {
                // delete each non-empty key
                var key = keys[i];
                if (is.emptyString(key)) {
                  continue;
                }

                var valid = !p.immutableKeys[key]; // not valid if immutable
                if (valid) {
                  for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
                    all[i_a]._private[p.field][key] = undefined;
                  }
                }
              }

              if (p.triggerEvent) {
                self[p.triggerFnName](p.event);
              }

              // .removeData()
            } else if (names === undefined) {
              // then delete all keys

              for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
                var _privateFields = all[_i_a]._private[p.field];
                var _keys = Object.keys(_privateFields);

                for (var _i2 = 0; _i2 < _keys.length; _i2++) {
                  var _key = _keys[_i2];
                  var validKeyToDelete = !p.immutableKeys[_key];

                  if (validKeyToDelete) {
                    _privateFields[_key] = undefined;
                  }
                }
              }

              if (p.triggerEvent) {
                self[p.triggerFnName](p.event);
              }
            }

            return self; // maintain chaining
          }; // function
        } // removeData
      }; // define

      module.exports = define;

      /***/
    },
    /* 47 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Promise = __webpack_require__(5);

      var define = {

        eventAliasesOn: function eventAliasesOn(proto) {
          var p = proto;

          p.addListener = p.listen = p.bind = p.on;
          p.unlisten = p.unbind = p.off = p.removeListener;
          p.trigger = p.emit;

          // this is just a wrapper alias of .on()
          p.pon = p.promiseOn = function (events, selector) {
            var self = this;
            var args = Array.prototype.slice.call(arguments, 0);

            return new Promise(function (resolve, reject) {
              var callback = function callback(e) {
                self.off.apply(self, offArgs);

                resolve(e);
              };

              var onArgs = args.concat([callback]);
              var offArgs = onArgs.concat([]);

              self.on.apply(self, onArgs);
            });
          };
        }

      }; // define

      module.exports = define;

      /***/
    },
    /* 48 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Set = __webpack_require__(8);

      var elesfn = {
        classes: function classes(_classes) {
          _classes = (_classes || '').match(/\S+/g) || [];
          var self = this;
          var changed = [];
          var classesMap = new Set(_classes);

          // check and update each ele

          var _loop = function _loop(j) {
            var ele = self[j];
            var _p = ele._private;
            var eleClasses = _p.classes;
            var changedEle = false;

            // check if ele has all of the passed classes
            classesMap.forEach(function (cls) {
              var eleHasClass = eleClasses.has(cls);

              if (!eleHasClass) {
                changedEle = true;
              }
            });

            // check if ele has classes outside of those passed
            if (!changedEle) {
              eleClasses.forEach(function (eleCls) {
                var specdClass = classesMap.has(eleCls);

                if (!specdClass) {
                  changedEle = true;
                }
              });
            }

            if (changedEle) {
              _p.classes = new Set(classesMap);

              changed.push(ele);
            }
          };

          for (var j = 0; j < self.length; j++) {
            _loop(j);
          }

          // trigger update style on those eles that had class changes
          if (changed.length > 0) {
            this.spawn(changed).updateStyle().emit('class');
          }

          return self;
        },

        addClass: function addClass(classes) {
          return this.toggleClass(classes, true);
        },

        hasClass: function hasClass(className) {
          var ele = this[0];
          return ele != null && ele._private.classes.has(className);
        },

        toggleClass: function toggleClass(classesStr, toggle) {
          var classes = classesStr.match(/\S+/g) || [];
          var self = this;
          var changed = []; // eles who had classes changed

          for (var i = 0, il = self.length; i < il; i++) {
            var _ele = self[i];
            var _changedEle = false;

            for (var j = 0; j < classes.length; j++) {
              var cls = classes[j];
              var _eleClasses = _ele._private.classes;
              var hasClass = _eleClasses.has(cls);
              var shouldAdd = toggle || toggle === undefined && !hasClass;

              if (shouldAdd) {
                _eleClasses.add(cls);

                if (!hasClass && !_changedEle) {
                  changed.push(_ele);
                  _changedEle = true;
                }
              } else {
                // then remove
                _eleClasses.delete(cls);

                if (hasClass && !_changedEle) {
                  changed.push(_ele);
                  _changedEle = true;
                }
              }
            } // for j classes
          } // for i eles

          // trigger update style on those eles that had class changes
          if (changed.length > 0) {
            this.spawn(changed).updateStyle().emit('class');
          }

          return self;
        },

        removeClass: function removeClass(classes) {
          return this.toggleClass(classes, false);
        },

        flashClass: function flashClass(classes, duration) {
          var self = this;

          if (duration == null) {
            duration = 250;
          } else if (duration === 0) {
            return self; // nothing to do really
          }

          self.addClass(classes);
          setTimeout(function () {
            self.removeClass(classes);
          }, duration);

          return self;
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 49 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Selector = __webpack_require__(6);

      var elesfn = {
        allAre: function allAre(selector) {
          var selObj = new Selector(selector);

          return this.every(function (ele) {
            return selObj.matches(ele);
          });
        },

        is: function is(selector) {
          var selObj = new Selector(selector);

          return this.some(function (ele) {
            return selObj.matches(ele);
          });
        },

        some: function some(fn, thisArg) {
          for (var i = 0; i < this.length; i++) {
            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

            if (ret) {
              return true;
            }
          }

          return false;
        },

        every: function every(fn, thisArg) {
          for (var i = 0; i < this.length; i++) {
            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

            if (!ret) {
              return false;
            }
          }

          return true;
        },

        same: function same(collection) {
          collection = this.cy().collection(collection);

          // cheap extra check
          if (this.length !== collection.length) {
            return false;
          }

          return this.every(function (ele) {
            return collection.hasElementWithId(ele.id());
          });
        },

        anySame: function anySame(collection) {
          collection = this.cy().collection(collection);

          return this.some(function (ele) {
            return collection.hasElementWithId(ele.id());
          });
        },

        allAreNeighbors: function allAreNeighbors(collection) {
          collection = this.cy().collection(collection);

          var nhood = this.neighborhood();

          return collection.every(function (ele) {
            return nhood.hasElementWithId(ele.id());
          });
        },

        contains: function contains(collection) {
          collection = this.cy().collection(collection);

          var self = this;

          return collection.every(function (ele) {
            return self.hasElementWithId(ele.id());
          });
        }
      };

      elesfn.allAreNeighbours = elesfn.allAreNeighbors;
      elesfn.has = elesfn.contains;

      module.exports = elesfn;

      /***/
    },
    /* 50 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var exprs = __webpack_require__(51);
      var newQuery = __webpack_require__(10);

      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function consumeExpr(remaining) {
        var expr = void 0;
        var match = void 0;
        var name = void 0;

        for (var j = 0; j < exprs.length; j++) {
          var e = exprs[j];
          var n = e.name;

          var m = remaining.match(e.regexObj);

          if (m != null) {
            match = m;
            expr = e;
            name = n;

            var consumed = m[0];
            remaining = remaining.substring(consumed.length);

            break; // we've consumed one expr, so we can return now
          }
        }

        return {
          expr: expr,
          match: match,
          name: name,
          remaining: remaining
        };
      };

      // consume all leading whitespace
      var consumeWhitespace = function consumeWhitespace(remaining) {
        var match = remaining.match(/^\s+/);

        if (match) {
          var consumed = match[0];
          remaining = remaining.substring(consumed.length);
        }

        return remaining;
      };

      var parse = function parse(selector) {
        var self = this;

        var remaining = self._private.selectorText = selector;

        var currentQuery = self[0] = newQuery();
        self.length = 1;

        remaining = consumeWhitespace(remaining); // get rid of leading whitespace

        for (;;) {
          var check = consumeExpr(remaining);

          if (check.expr == null) {
            util.error('The selector `' + selector + '`is invalid');
            return false;
          } else {
            var args = check.match.slice(1);

            // let the token populate the selector object in currentQuery
            var ret = check.expr.populate(self, currentQuery, args);

            if (ret === false) {
              return false; // exit if population failed
            } else if (ret != null) {
              currentQuery = ret; // change the current query to be filled if the expr specifies
            }
          }

          remaining = check.remaining;

          // we're done when there's nothing left to parse
          if (remaining.match(/^\s*$/)) {
            break;
          }
        }

        // adjust references for subject
        for (var j = 0; j < self.length; j++) {
          var query = self[j];

          if (query.subject != null) {
            // go up the tree until we reach the subject
            for (;;) {
              if (query.subject === query) {
                break;
              } // done if subject is self

              if (query.parent != null) {
                // swap parent/child reference
                var parent = query.parent;
                var child = query;

                child.parent = null;
                parent.child = child;

                query = parent; // go up the tree
              } else if (query.ancestor != null) {
                // swap ancestor/descendant
                var ancestor = query.ancestor;
                var descendant = query;

                descendant.ancestor = null;
                ancestor.descendant = descendant;

                query = ancestor; // go up the tree
              } else if (query.source || query.target || query.connectedNodes) {
                util.error('The selector `' + self.text() + '` can not contain a subject selector that applies to the source or target of an edge selector');
                return false;
              } else {
                util.error('When adjusting references for the selector `' + self.text() + '`, neither parent nor ancestor was found');
                return false;
              }
            } // for

            self[j] = query.subject; // subject should be the root query
          } // if
        } // for

        return true; // success
      };

      module.exports = { parse: parse };

      /***/
    },
    /* 51 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _require = __webpack_require__(15),
          stateSelectorRegex = _require.stateSelectorRegex;

      var tokens = __webpack_require__(52);
      var util = __webpack_require__(1);
      var newQuery = __webpack_require__(10);

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function cleanMetaChars(str) {
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
          return $1;
        });
      };

      var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
        if (examiningQuery === selector[selector.length - 1]) {
          selector[selector.length - 1] = replacementQuery;
        }
      };

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in selector[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = [{
        name: 'group',
        query: true,
        regex: '(' + tokens.group + ')',
        populate: function populate(selector, query, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              group = _ref2[0];

          query.group = group === '*' ? group : group + 's';
        }
      }, {
        name: 'state',
        query: true,
        regex: stateSelectorRegex,
        populate: function populate(selector, query, _ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              state = _ref4[0];

          query.colonSelectors.push(state);
        }
      }, {
        name: 'id',
        query: true,
        regex: '\\#(' + tokens.id + ')',
        populate: function populate(selector, query, _ref5) {
          var _ref6 = _slicedToArray(_ref5, 1),
              id = _ref6[0];

          query.ids.push(cleanMetaChars(id));
        }
      }, {
        name: 'className',
        query: true,
        regex: '\\.(' + tokens.className + ')',
        populate: function populate(selector, query, _ref7) {
          var _ref8 = _slicedToArray(_ref7, 1),
              className = _ref8[0];

          query.classes.push(cleanMetaChars(className));
        }
      }, {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function populate(selector, query, _ref9) {
          var _ref10 = _slicedToArray(_ref9, 1),
              variable = _ref10[0];

          query.data.push({
            field: cleanMetaChars(variable)
          });
        }
      }, {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
        populate: function populate(selector, query, _ref11) {
          var _ref12 = _slicedToArray(_ref11, 3),
              variable = _ref12[0],
              comparatorOp = _ref12[1],
              value = _ref12[2];

          var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

          if (valueIsString) {
            value = value.substring(1, value.length - 1);
          } else {
            value = parseFloat(value);
          }

          query.data.push({
            field: cleanMetaChars(variable),
            operator: comparatorOp,
            value: value
          });
        }
      }, {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function populate(selector, query, _ref13) {
          var _ref14 = _slicedToArray(_ref13, 2),
              boolOp = _ref14[0],
              variable = _ref14[1];

          query.data.push({
            field: cleanMetaChars(variable),
            operator: boolOp
          });
        }
      }, {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
        populate: function populate(selector, query, _ref15) {
          var _ref16 = _slicedToArray(_ref15, 3),
              meta = _ref16[0],
              comparatorOp = _ref16[1],
              number = _ref16[2];

          query.meta.push({
            field: cleanMetaChars(meta),
            operator: comparatorOp,
            value: parseFloat(number)
          });
        }
      }, {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function populate(selector) {
          // go on to next query
          var nextQuery = selector[selector.length++] = newQuery();
          selector.currentSubject = null;

          return nextQuery;
        }
      }, {
        name: 'directedEdge',
        separator: true,
        regex: tokens.directedEdge,
        populate: function populate(selector, query) {
          var edgeQuery = newQuery();
          var source = query;
          var target = newQuery();

          edgeQuery.group = 'edges';
          edgeQuery.target = target;
          edgeQuery.source = source;
          edgeQuery.subject = selector.currentSubject;

          // the query in the selector should be the edge rather than the source
          replaceLastQuery(selector, query, edgeQuery);

          // we're now populating the target query with expressions that follow
          return target;
        }
      }, {
        name: 'undirectedEdge',
        separator: true,
        regex: tokens.undirectedEdge,
        populate: function populate(selector, query) {
          var edgeQuery = newQuery();
          var source = query;
          var target = newQuery();

          edgeQuery.group = 'edges';
          edgeQuery.connectedNodes = [source, target];
          edgeQuery.subject = selector.currentSubject;

          // the query in the selector should be the edge rather than the source
          replaceLastQuery(selector, query, edgeQuery);

          // we're now populating the target query with expressions that follow
          return target;
        }
      }, {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function populate(selector, query) {
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = query;
          childQuery.subject = selector.currentSubject;

          // it's cheaper to compare children first and go up so replace the parent
          replaceLastQuery(selector, query, childQuery);

          // we're now populating the child query with expressions that follow
          return childQuery;
        }
      }, {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function populate(selector, query) {
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = query;
          descendantQuery.subject = selector.currentSubject;

          // it's cheaper to compare descendants first and go up so replace the ancestor
          replaceLastQuery(selector, query, descendantQuery);

          // we're now populating the descendant query with expressions that follow
          return descendantQuery;
        }
      }, {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function populate(selector, query) {
          if (selector.currentSubject != null && query.subject != query) {
            util.error('Redefinition of subject in selector `' + selector.toString() + '`');
            return false;
          }

          selector.currentSubject = query;
          query.subject = query;
          selector[selector.length - 1].subject = query;
        }
      }];

      exprs.forEach(function (e) {
        return e.regexObj = new RegExp('^' + e.regex);
      });

      module.exports = exprs;

      /***/
    },
    /* 52 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in let names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$',
        group: 'node|edge|\\*',
        directedEdge: '\\s+->\\s+',
        undirectedEdge: '\\s+<->\\s+'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      (function () {
        var ops = void 0,
            op = void 0,
            i = void 0;

        // add @ variants to comparatorOp
        ops = tokens.comparatorOp.split('|');
        for (i = 0; i < ops.length; i++) {
          op = ops[i];
          tokens.comparatorOp += '|@' + op;
        }

        // add ! variants to comparatorOp
        ops = tokens.comparatorOp.split('|');
        for (i = 0; i < ops.length; i++) {
          op = ops[i];

          if (op.indexOf('!') >= 0) {
            continue;
          } // skip ops that explicitly contain !
          if (op === '=') {
            continue;
          } // skip = b/c != is explicitly defined

          tokens.comparatorOp += '|\\!' + op;
        }
      })();

      module.exports = tokens;

      /***/
    },
    /* 53 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var _require = __webpack_require__(15),
          stateSelectorMatches = _require.stateSelectorMatches;

      var is = __webpack_require__(0);

      // generic checking for data/metadata
      var operandsMatch = function operandsMatch(query, params) {
        var allDataMatches = true;
        for (var k = 0; k < query[params.name].length; k++) {
          var data = query[params.name][k];
          var operator = data.operator;
          var value = data.value;
          var field = data.field;
          var _matches = void 0;
          var fieldVal = params.fieldValue(field);

          if (operator != null && value != null) {
            var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
            var valStr = '' + value;

            var caseInsensitive = false;
            if (operator.indexOf('@') >= 0) {
              fieldStr = fieldStr.toLowerCase();
              valStr = valStr.toLowerCase();

              operator = operator.replace('@', '');
              caseInsensitive = true;
            }

            var notExpr = false;
            if (operator.indexOf('!') >= 0) {
              operator = operator.replace('!', '');
              notExpr = true;
            }

            // if we're doing a case insensitive comparison, then we're using a STRING comparison
            // even if we're comparing numbers
            if (caseInsensitive) {
              value = valStr.toLowerCase();
              fieldVal = fieldStr.toLowerCase();
            }

            var isIneqCmp = false;

            switch (operator) {
              case '*=':
                _matches = fieldStr.indexOf(valStr) >= 0;
                break;
              case '$=':
                _matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
                break;
              case '^=':
                _matches = fieldStr.indexOf(valStr) === 0;
                break;
              case '=':
                _matches = fieldVal === value;
                break;
              case '>':
                isIneqCmp = true;
                _matches = fieldVal > value;
                break;
              case '>=':
                isIneqCmp = true;
                _matches = fieldVal >= value;
                break;
              case '<':
                isIneqCmp = true;
                _matches = fieldVal < value;
                break;
              case '<=':
                isIneqCmp = true;
                _matches = fieldVal <= value;
                break;
              default:
                _matches = false;
                break;
            }

            // apply the not op, but null vals for inequalities should always stay non-matching
            if (notExpr && (fieldVal != null || !isIneqCmp)) {
              _matches = !_matches;
            }
          } else if (operator != null) {
            switch (operator) {
              case '?':
                _matches = fieldVal ? true : false;
                break;
              case '!':
                _matches = fieldVal ? false : true;
                break;
              case '^':
                _matches = fieldVal === undefined;
                break;
            }
          } else {
            _matches = fieldVal !== undefined;
          }

          if (!_matches) {
            allDataMatches = false;
            break;
          }
        } // for

        return allDataMatches;
      }; // operandsMatch

      // check parent/child relations
      var confirmRelations = function confirmRelations(query, isNecessary, eles) {
        if (query != null) {
          var _matches2 = false;

          if (!isNecessary) {
            return false;
          }

          eles = eles(); // save cycles if query == null

          // query must match for at least one element (may be recursive)
          for (var i = 0; i < eles.length; i++) {
            if (queryMatches(query, eles[i])) {
              _matches2 = true;
              break;
            }
          }

          return _matches2;
        } else {
          return true;
        }
      };

      var queryMatches = function queryMatches(query, ele) {
        // make single group-only selectors really cheap to check since they're the most common ones
        if (query.groupOnly) {
          return query.group === '*' || query.group === ele.group();
        }

        // check group
        if (query.group != null && query.group != '*' && query.group != ele.group()) {
          return false;
        }

        var cy = ele.cy();
        var k = void 0;

        // check colon selectors
        var allColonSelectorsMatch = true;
        for (k = 0; k < query.colonSelectors.length; k++) {
          var sel = query.colonSelectors[k];

          allColonSelectorsMatch = stateSelectorMatches(sel, ele);

          if (!allColonSelectorsMatch) break;
        }
        if (!allColonSelectorsMatch) return false;

        // check id
        var allIdsMatch = true;
        for (k = 0; k < query.ids.length; k++) {
          var id = query.ids[k];
          var actualId = ele.id();

          allIdsMatch = allIdsMatch && id == actualId;

          if (!allIdsMatch) break;
        }
        if (!allIdsMatch) return false;

        // check classes
        var allClassesMatch = true;
        for (k = 0; k < query.classes.length; k++) {
          var cls = query.classes[k];

          allClassesMatch = allClassesMatch && ele.hasClass(cls);

          if (!allClassesMatch) break;
        }
        if (!allClassesMatch) return false;

        // check data matches
        var allDataMatches = operandsMatch(query, {
          name: 'data',
          fieldValue: function fieldValue(field) {
            return ele.data(field);
          }
        });

        if (!allDataMatches) {
          return false;
        }

        // check metadata matches
        var allMetaMatches = operandsMatch(query, {
          name: 'meta',
          fieldValue: function fieldValue(field) {
            return ele[field]();
          }
        });

        if (!allMetaMatches) {
          return false;
        }

        // check collection
        if (query.collection != null) {
          var matchesAny = query.collection.hasElementWithId(ele.id());

          if (!matchesAny) {
            return false;
          }
        }

        // check filter function
        if (query.filter != null && ele.collection().some(query.filter)) {
          return false;
        }

        var isCompound = cy.hasCompoundNodes();
        var getSource = function getSource() {
          return ele.source();
        };
        var getTarget = function getTarget() {
          return ele.target();
        };

        if (!confirmRelations(query.parent, isCompound, function () {
          return ele.parent();
        })) {
          return false;
        }

        if (!confirmRelations(query.ancestor, isCompound, function () {
          return ele.parents();
        })) {
          return false;
        }

        if (!confirmRelations(query.child, isCompound, function () {
          return ele.children();
        })) {
          return false;
        }

        if (!confirmRelations(query.descendant, isCompound, function () {
          return ele.descendants();
        })) {
          return false;
        }

        if (!confirmRelations(query.source, true, getSource)) {
          return false;
        }

        if (!confirmRelations(query.target, true, getTarget)) {
          return false;
        }

        if (query.connectedNodes) {
          var q0 = query.connectedNodes[0];
          var q1 = query.connectedNodes[1];

          if (confirmRelations(q0, true, getSource) && confirmRelations(q1, true, getTarget)) {
            // match
          } else if (confirmRelations(q0, true, getTarget) && confirmRelations(q1, true, getSource)) {
            // match
          } else {
            return false;
          }
        }

        // we've reached the end, so we've matched everything for this query
        return true;
      }; // queryMatches

      // filter an existing collection
      var filter = function filter(collection) {
        var self = this;
        var cy = collection.cy();

        // don't bother trying if it's invalid
        if (self.invalid()) {
          return cy.collection();
        }

        // for 1 id #foo queries, just get the element
        if (self.length === 1 && self[0].length === 1 && self[0].ids.length === 1) {
          return collection.getElementById(self[0].ids[0]).collection();
        }

        var selectorFunction = function selectorFunction(element) {
          for (var j = 0; j < self.length; j++) {
            var query = self[j];

            if (queryMatches(query, element)) {
              return true;
            }
          }

          return false;
        };

        if (self.text() == null) {
          selectorFunction = function selectorFunction() {
            return true;
          };
        }

        var filteredCollection = collection.filter(selectorFunction);

        return filteredCollection;
      }; // filter

      // does selector match a single element?
      var matches = function matches(ele) {
        var self = this;

        // don't bother trying if it's invalid
        if (self.invalid()) {
          return false;
        }

        for (var j = 0; j < self.length; j++) {
          var query = self[j];

          if (queryMatches(query, ele)) {
            return true;
          }
        }

        return false;
      }; // filter

      module.exports = { matches: matches, filter: filter };

      /***/
    },
    /* 54 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Set = __webpack_require__(8);

      var elesfn = {
        parent: function parent(selector) {
          var parents = [];

          // optimisation for single ele call
          if (this.length === 1) {
            var parent = this[0]._private.parent;

            if (parent) {
              return parent;
            }
          }

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var _parent = ele._private.parent;

            if (_parent) {
              parents.push(_parent);
            }
          }

          return this.spawn(parents, { unique: true }).filter(selector);
        },

        parents: function parents(selector) {
          var parents = [];

          var eles = this.parent();
          while (eles.nonempty()) {
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              parents.push(ele);
            }

            eles = eles.parent();
          }

          return this.spawn(parents, { unique: true }).filter(selector);
        },

        commonAncestors: function commonAncestors(selector) {
          var ancestors = void 0;

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var parents = ele.parents();

            ancestors = ancestors || parents;

            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
          }

          return ancestors.filter(selector);
        },

        orphans: function orphans(selector) {
          return this.stdFilter(function (ele) {
            return ele.isOrphan();
          }).filter(selector);
        },

        nonorphans: function nonorphans(selector) {
          return this.stdFilter(function (ele) {
            return ele.isChild();
          }).filter(selector);
        },

        children: function children(selector) {
          var children = [];

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            children = children.concat(ele._private.children);
          }

          return this.spawn(children, { unique: true }).filter(selector);
        },

        siblings: function siblings(selector) {
          return this.parent().children().not(this).filter(selector);
        },

        isParent: function isParent() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.children.length !== 0;
          }
        },

        isChildless: function isChildless() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.children.length === 0;
          }
        },

        isChild: function isChild() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.parent != null;
          }
        },

        isOrphan: function isOrphan() {
          var ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.parent == null;
          }
        },

        descendants: function descendants(selector) {
          var elements = [];

          function add(eles) {
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];

              elements.push(ele);

              if (ele.children().nonempty()) {
                add(ele.children());
              }
            }
          }

          add(this.children());

          return this.spawn(elements, { unique: true }).filter(selector);
        }
      };

      function forEachCompound(eles, fn, includeSelf, recursiveStep) {
        var q = [];
        var did = new Set();
        var cy = eles.cy();
        var hasCompounds = cy.hasCompoundNodes();

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (includeSelf) {
            q.push(ele);
          } else if (hasCompounds) {
            recursiveStep(q, did, ele);
          }
        }

        while (q.length > 0) {
          var _ele = q.shift();

          fn(_ele);

          did.add(_ele.id());

          if (hasCompounds) {
            recursiveStep(q, did, _ele);
          }
        }

        return eles;
      }

      function addChildren(q, did, ele) {
        if (ele.isParent()) {
          var children = ele._private.children;

          for (var i = 0; i < children.length; i++) {
            var child = children[i];

            if (!did.has(child.id())) {
              q.push(child);
            }
          }
        }
      }

      // very efficient version of eles.add( eles.descendants() ).forEach()
      // for internal use
      elesfn.forEachDown = function (fn) {
        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return forEachCompound(this, fn, includeSelf, addChildren);
      };

      function addParent(q, did, ele) {
        if (ele.isChild()) {
          var parent = ele._private.parent;

          if (!did.has(parent.id())) {
            q.push(parent);
          }
        }
      }

      elesfn.forEachUp = function (fn) {
        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return forEachCompound(this, fn, includeSelf, addParent);
      };

      function addParentAndChildren(q, did, ele) {
        addParent(q, did, ele);
        addChildren(q, did, ele);
      }

      elesfn.forEachUpAndDown = function (fn) {
        var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return forEachCompound(this, fn, includeSelf, addParentAndChildren);
      };

      // aliases
      elesfn.ancestors = elesfn.parents;

      module.exports = elesfn;

      /***/
    },
    /* 55 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);
      var fn = void 0,
          elesfn = void 0;

      fn = elesfn = {

        data: define.data({
          field: 'data',
          bindingEvent: 'data',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'data',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          immutableKeys: {
            'id': true,
            'source': true,
            'target': true,
            'parent': true
          },
          updateStyle: true
        }),

        removeData: define.removeData({
          field: 'data',
          event: 'data',
          triggerFnName: 'trigger',
          triggerEvent: true,
          immutableKeys: {
            'id': true,
            'source': true,
            'target': true,
            'parent': true
          },
          updateStyle: true
        }),

        scratch: define.data({
          field: 'scratch',
          bindingEvent: 'scratch',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'scratch',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          updateStyle: true
        }),

        removeScratch: define.removeData({
          field: 'scratch',
          event: 'scratch',
          triggerFnName: 'trigger',
          triggerEvent: true,
          updateStyle: true
        }),

        rscratch: define.data({
          field: 'rscratch',
          allowBinding: false,
          allowSetting: true,
          settingTriggersEvent: false,
          allowGetting: true
        }),

        removeRscratch: define.removeData({
          field: 'rscratch',
          triggerEvent: false
        }),

        id: function id() {
          var ele = this[0];

          if (ele) {
            return ele._private.data.id;
          }
        }

      };

      // aliases
      fn.attr = fn.data;
      fn.removeAttr = fn.removeData;

      module.exports = elesfn;

      /***/
    },
    /* 56 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var elesfn = {};

      function defineDegreeFunction(callback) {
        return function (includeLoops) {
          var self = this;

          if (includeLoops === undefined) {
            includeLoops = true;
          }

          if (self.length === 0) {
            return;
          }

          if (self.isNode() && !self.removed()) {
            var degree = 0;
            var node = self[0];
            var connectedEdges = node._private.edges;

            for (var i = 0; i < connectedEdges.length; i++) {
              var edge = connectedEdges[i];

              if (!includeLoops && edge.isLoop()) {
                continue;
              }

              degree += callback(node, edge);
            }

            return degree;
          } else {
            return;
          }
        };
      }

      util.extend(elesfn, {
        degree: defineDegreeFunction(function (node, edge) {
          if (edge.source().same(edge.target())) {
            return 2;
          } else {
            return 1;
          }
        }),

        indegree: defineDegreeFunction(function (node, edge) {
          if (edge.target().same(node)) {
            return 1;
          } else {
            return 0;
          }
        }),

        outdegree: defineDegreeFunction(function (node, edge) {
          if (edge.source().same(node)) {
            return 1;
          } else {
            return 0;
          }
        })
      });

      function defineDegreeBoundsFunction(degreeFn, callback) {
        return function (includeLoops) {
          var ret = void 0;
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            var ele = nodes[i];
            var degree = ele[degreeFn](includeLoops);
            if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
              ret = degree;
            }
          }

          return ret;
        };
      }

      util.extend(elesfn, {
        minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
          return degree < min;
        }),

        maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
          return degree > max;
        }),

        minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
          return degree < min;
        }),

        maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
          return degree > max;
        }),

        minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
          return degree < min;
        }),

        maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
          return degree > max;
        })
      });

      util.extend(elesfn, {
        totalDegree: function totalDegree(includeLoops) {
          var total = 0;
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            total += nodes[i].degree(includeLoops);
          }

          return total;
        }
      });

      module.exports = elesfn;

      /***/
    },
    /* 57 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var position = __webpack_require__(58);
      var bounds = __webpack_require__(59);
      var widthHeight = __webpack_require__(60);
      var edgePoints = __webpack_require__(61);

      module.exports = util.assign({}, position, bounds, widthHeight, edgePoints);

      /***/
    },
    /* 58 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);
      var is = __webpack_require__(0);
      var math = __webpack_require__(2);
      var fn = void 0,
          elesfn = void 0;

      var beforePositionSet = function beforePositionSet(eles, newPos) {
        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (ele.isParent() && !ele.locked()) {
            var oldPos = ele._private.position;
            var delta = {
              x: newPos.x - oldPos.x,
              y: newPos.y - oldPos.y
            };

            eles.children().shift(delta);
          }
        }
      };

      fn = elesfn = {

        position: define.data({
          field: 'position',
          bindingEvent: 'position',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'position',
          settingTriggersEvent: true,
          triggerFnName: 'emitAndNotify',
          allowGetting: true,
          validKeys: ['x', 'y'],
          beforeGet: function beforeGet(ele) {
            ele.updateCompoundBounds();
          },
          beforeSet: beforePositionSet,
          onSet: function onSet(eles) {
            eles.dirtyCompoundBoundsCache();
          },
          canSet: function canSet(ele) {
            return !ele.locked();
          }
        }),

        // position but no notification to renderer
        silentPosition: define.data({
          field: 'position',
          bindingEvent: 'position',
          allowBinding: false,
          allowSetting: true,
          settingEvent: 'position',
          settingTriggersEvent: false,
          triggerFnName: 'trigger',
          allowGetting: false,
          validKeys: ['x', 'y'],
          beforeSet: beforePositionSet,
          onSet: function onSet(eles) {
            eles.dirtyCompoundBoundsCache();
          },
          canSet: function canSet(ele) {
            return !ele.locked();
          }
        }),

        positions: function positions(pos, silent) {
          if (is.plainObject(pos)) {
            if (silent) {
              this.silentPosition(pos);
            } else {
              this.position(pos);
            }
          } else if (is.fn(pos)) {
            var _fn = pos;
            var cy = this.cy();

            cy.startBatch();

            for (var i = 0; i < this.length; i++) {
              var ele = this[i];
              var _pos = void 0;

              if (_pos = _fn(ele, i)) {
                if (silent) {
                  ele.silentPosition(_pos);
                } else {
                  ele.position(_pos);
                }
              }
            }

            cy.endBatch();
          }

          return this; // chaining
        },

        silentPositions: function silentPositions(pos) {
          return this.positions(pos, true);
        },

        shift: function shift(dim, val) {
          var delta = void 0;

          if (is.plainObject(dim)) {
            delta = dim;
          } else if (is.string(dim) && is.number(val)) {
            delta = { x: 0, y: 0 };

            delta[dim] = val;
          }

          if (delta != null) {
            for (var i = 0; i < this.length; i++) {
              var ele = this[i];
              var pos = ele.position();

              ele.position({
                x: pos.x + delta.x,
                y: pos.y + delta.y
              });
            }
          }

          return this;
        },

        // get/set the rendered (i.e. on screen) positon of the element
        renderedPosition: function renderedPosition(dim, val) {
          var ele = this[0];
          var cy = this.cy();
          var zoom = cy.zoom();
          var pan = cy.pan();
          var rpos = is.plainObject(dim) ? dim : undefined;
          var setting = rpos !== undefined || val !== undefined && is.string(dim);

          if (ele && ele.isNode()) {
            // must have an element and must be a node to return position
            if (setting) {
              for (var i = 0; i < this.length; i++) {
                var _ele = this[i];

                if (val !== undefined) {
                  // set one dimension
                  _ele.position(dim, (val - pan[dim]) / zoom);
                } else if (rpos !== undefined) {
                  // set whole position
                  _ele.position(math.renderedToModelPosition(rpos, zoom, pan));
                }
              }
            } else {
              // getting
              var pos = ele.position();
              rpos = math.modelToRenderedPosition(pos, zoom, pan);

              if (dim === undefined) {
                // then return the whole rendered position
                return rpos;
              } else {
                // then return the specified dimension
                return rpos[dim];
              }
            }
          } else if (!setting) {
            return undefined; // for empty collection case
          }

          return this; // chaining
        },

        // get/set the position relative to the parent
        relativePosition: function relativePosition(dim, val) {
          var ele = this[0];
          var cy = this.cy();
          var ppos = is.plainObject(dim) ? dim : undefined;
          var setting = ppos !== undefined || val !== undefined && is.string(dim);
          var hasCompoundNodes = cy.hasCompoundNodes();

          if (ele && ele.isNode()) {
            // must have an element and must be a node to return position
            if (setting) {
              for (var i = 0; i < this.length; i++) {
                var _ele2 = this[i];
                var parent = hasCompoundNodes ? _ele2.parent() : null;
                var hasParent = parent && parent.length > 0;
                var relativeToParent = hasParent;

                if (hasParent) {
                  parent = parent[0];
                }

                var origin = relativeToParent ? parent.position() : { x: 0, y: 0 };

                if (val !== undefined) {
                  // set one dimension
                  _ele2.position(dim, val + origin[dim]);
                } else if (ppos !== undefined) {
                  // set whole position
                  _ele2.position({
                    x: ppos.x + origin.x,
                    y: ppos.y + origin.y
                  });
                }
              }
            } else {
              // getting
              var pos = ele.position();
              var _parent = hasCompoundNodes ? ele.parent() : null;
              var _hasParent = _parent && _parent.length > 0;
              var _relativeToParent = _hasParent;

              if (_hasParent) {
                _parent = _parent[0];
              }

              var _origin = _relativeToParent ? _parent.position() : { x: 0, y: 0 };

              ppos = {
                x: pos.x - _origin.x,
                y: pos.y - _origin.y
              };

              if (dim === undefined) {
                // then return the whole rendered position
                return ppos;
              } else {
                // then return the specified dimension
                return ppos[dim];
              }
            }
          } else if (!setting) {
            return undefined; // for empty collection case
          }

          return this; // chaining
        }
      };

      // aliases
      fn.modelPosition = fn.point = fn.position;
      fn.modelPositions = fn.points = fn.positions;
      fn.renderedPoint = fn.renderedPosition;
      fn.relativePoint = fn.relativePosition;

      module.exports = elesfn;

      /***/
    },
    /* 59 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var fn = void 0,
          elesfn = void 0;

      fn = elesfn = {};

      elesfn.renderedBoundingBox = function (options) {
        var bb = this.boundingBox(options);
        var cy = this.cy();
        var zoom = cy.zoom();
        var pan = cy.pan();

        var x1 = bb.x1 * zoom + pan.x;
        var x2 = bb.x2 * zoom + pan.x;
        var y1 = bb.y1 * zoom + pan.y;
        var y2 = bb.y2 * zoom + pan.y;

        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          w: x2 - x1,
          h: y2 - y1
        };
      };

      elesfn.dirtyCompoundBoundsCache = function () {
        var cy = this.cy();

        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
          return this;
        }

        this.forEachUp(function (ele) {
          ele._private.compoundBoundsClean = false;

          if (ele.isParent()) {
            ele.emit('bounds');
          }
        });

        return this;
      };

      elesfn.updateCompoundBounds = function () {
        var cy = this.cy();

        // save cycles for non compound graphs or when style disabled
        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
          return this;
        }

        // save cycles when batching -- but bounds will be stale (or not exist yet)
        if (cy.batching()) {
          return this;
        }

        var updated = [];

        function update(parent) {
          if (!parent.isParent()) {
            return;
          }

          var _p = parent._private;
          var children = parent.children();
          var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';

          var min = {
            width: {
              val: parent.pstyle('min-width').pfValue,
              left: parent.pstyle('min-width-bias-left'),
              right: parent.pstyle('min-width-bias-right')
            },
            height: {
              val: parent.pstyle('min-height').pfValue,
              top: parent.pstyle('min-height-bias-top'),
              bottom: parent.pstyle('min-height-bias-bottom')
            }
          };

          var bb = children.boundingBox({
            includeLabels: includeLabels,
            includeOverlays: false,

            // updating the compound bounds happens outside of the regular
            // cache cycle (i.e. before fired events)
            useCache: false
          });
          var pos = _p.position;

          // if children take up zero area then keep position and fall back on stylesheet w/h
          if (bb.w === 0 || bb.h === 0) {
            bb = {
              w: parent.pstyle('width').pfValue,
              h: parent.pstyle('height').pfValue
            };

            bb.x1 = pos.x - bb.w / 2;
            bb.x2 = pos.x + bb.w / 2;
            bb.y1 = pos.y - bb.h / 2;
            bb.y2 = pos.y + bb.h / 2;
          }

          function computeBiasValues(propDiff, propBias, propBiasComplement) {
            var biasDiff = 0;
            var biasComplementDiff = 0;
            var biasTotal = propBias + propBiasComplement;

            if (propDiff > 0 && biasTotal > 0) {
              biasDiff = propBias / biasTotal * propDiff;
              biasComplementDiff = propBiasComplement / biasTotal * propDiff;
            }
            return {
              biasDiff: biasDiff,
              biasComplementDiff: biasComplementDiff
            };
          }

          function computePaddingValues(width, height, paddingObject, relativeTo) {
            // Assuming percentage is number from 0 to 1
            if (paddingObject.units === '%') {
              switch (relativeTo) {
                case 'width':
                  return width > 0 ? paddingObject.pfValue * width : 0;
                case 'height':
                  return height > 0 ? paddingObject.pfValue * height : 0;
                case 'average':
                  return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;
                case 'min':
                  return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;
                case 'max':
                  return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;
                default:
                  return 0;
              }
            } else if (paddingObject.units === 'px') {
              return paddingObject.pfValue;
            } else {
              return 0;
            }
          }

          var leftVal = min.width.left.value;
          if (min.width.left.units === 'px' && min.width.val > 0) {
            leftVal = leftVal * 100 / min.width.val;
          }
          var rightVal = min.width.right.value;
          if (min.width.right.units === 'px' && min.width.val > 0) {
            rightVal = rightVal * 100 / min.width.val;
          }

          var topVal = min.height.top.value;
          if (min.height.top.units === 'px' && min.height.val > 0) {
            topVal = topVal * 100 / min.height.val;
          }

          var bottomVal = min.height.bottom.value;
          if (min.height.bottom.units === 'px' && min.height.val > 0) {
            bottomVal = bottomVal * 100 / min.height.val;
          }

          var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
          var diffLeft = widthBiasDiffs.biasDiff;
          var diffRight = widthBiasDiffs.biasComplementDiff;

          var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
          var diffTop = heightBiasDiffs.biasDiff;
          var diffBottom = heightBiasDiffs.biasComplementDiff;

          _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);

          _p.autoWidth = Math.max(bb.w, min.width.val);
          pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

          _p.autoHeight = Math.max(bb.h, min.height.val);
          pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;

          updated.push(parent);
        }

        for (var i = 0; i < this.length; i++) {
          var ele = this[i];
          var _p = ele._private;

          if (!_p.compoundBoundsClean) {
            update(ele);

            if (!cy._private.batchingStyle) {
              _p.compoundBoundsClean = true;
            }
          }
        }

        return this;
      };

      var noninf = function noninf(x) {
        if (x === Infinity || x === -Infinity) {
          return 0;
        }

        return x;
      };

      var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
        // don't update with zero area boxes
        if (x2 - x1 === 0 || y2 - y1 === 0) {
          return;
        }

        // don't update with null dim
        if (x1 == null || y1 == null || x2 == null || y2 == null) {
          return;
        }

        b.x1 = x1 < b.x1 ? x1 : b.x1;
        b.x2 = x2 > b.x2 ? x2 : b.x2;
        b.y1 = y1 < b.y1 ? y1 : b.y1;
        b.y2 = y2 > b.y2 ? y2 : b.y2;
      };

      var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
        return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
      };

      var prefixedProperty = function prefixedProperty(obj, field, prefix) {
        return util.getPrefixedProperty(obj, field, prefix);
      };

      var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
        if (ele.cy().headless()) {
          return;
        }

        var _p = ele._private;
        var rstyle = _p.rstyle;
        var halfArW = rstyle.arrowWidth / 2;
        var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
        var x = void 0;
        var y = void 0;

        if (arrowType !== 'none') {
          if (prefix === 'source') {
            x = rstyle.srcX;
            y = rstyle.srcY;
          } else if (prefix === 'target') {
            x = rstyle.tgtX;
            y = rstyle.tgtY;
          } else {
            x = rstyle.midX;
            y = rstyle.midY;
          }

          updateBounds(bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW);
        }
      };

      var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
        if (ele.cy().headless()) {
          return;
        }

        var prefixDash = void 0;

        if (prefix) {
          prefixDash = prefix + '-';
        } else {
          prefixDash = '';
        }

        var _p = ele._private;
        var rstyle = _p.rstyle;
        var label = ele.pstyle(prefixDash + 'label').strValue;

        if (label) {
          var halign = ele.pstyle('text-halign');
          var valign = ele.pstyle('text-valign');
          var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
          var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
          var labelX = prefixedProperty(rstyle, 'labelX', prefix);
          var labelY = prefixedProperty(rstyle, 'labelY', prefix);
          var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
          var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
          var isEdge = ele.isEdge();
          var rotation = ele.pstyle(prefixDash + 'text-rotation');
          var outlineWidth = ele.pstyle('text-outline-width').pfValue;
          var borderWidth = ele.pstyle('text-border-width').pfValue;
          var halfBorderWidth = borderWidth / 2;
          var padding = ele.pstyle('text-background-padding').pfValue;

          var lh = labelHeight + 2 * padding;
          var lw = labelWidth + 2 * padding;
          var lw_2 = lw / 2;
          var lh_2 = lh / 2;
          var lx1 = void 0,
              lx2 = void 0,
              ly1 = void 0,
              ly2 = void 0;

          if (isEdge) {
            lx1 = labelX - lw_2;
            lx2 = labelX + lw_2;
            ly1 = labelY - lh_2;
            ly2 = labelY + lh_2;
          } else {
            switch (halign.value) {
              case 'left':
                lx1 = labelX - lw;
                lx2 = labelX;
                break;

              case 'center':
                lx1 = labelX - lw_2;
                lx2 = labelX + lw_2;
                break;

              case 'right':
                lx1 = labelX;
                lx2 = labelX + lw;
                break;
            }

            switch (valign.value) {
              case 'top':
                ly1 = labelY - lh;
                ly2 = labelY;
                break;

              case 'center':
                ly1 = labelY - lh_2;
                ly2 = labelY + lh_2;
                break;

              case 'bottom':
                ly1 = labelY;
                ly2 = labelY + lh;
                break;
            }
          }

          var isAutorotate = isEdge && rotation.strValue === 'autorotate';
          var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

          if (isAutorotate || isPfValue) {
            var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);

            var rotate = function rotate(x, y) {
              x = x - labelX;
              y = y - labelY;

              return {
                x: x * cos - y * sin + labelX,
                y: x * sin + y * cos + labelY
              };
            };

            var px1y1 = rotate(lx1, ly1);
            var px1y2 = rotate(lx1, ly2);
            var px2y1 = rotate(lx2, ly1);
            var px2y2 = rotate(lx2, ly2);

            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
          }

          lx1 += marginX - Math.max(outlineWidth, halfBorderWidth);
          lx2 += marginX + Math.max(outlineWidth, halfBorderWidth);
          ly1 += marginY - Math.max(outlineWidth, halfBorderWidth);
          ly2 += marginY + Math.max(outlineWidth, halfBorderWidth);

          updateBounds(bounds, lx1, ly1, lx2, ly2);
        }

        return bounds;
      };

      // get the bounding box of the elements (in raw model position)
      var boundingBoxImpl = function boundingBoxImpl(ele, options) {
        var cy = ele._private.cy;
        var styleEnabled = cy.styleEnabled();
        var headless = cy.headless();

        var bounds = {
          x1: Infinity,
          y1: Infinity,
          x2: -Infinity,
          y2: -Infinity
        };

        var _p = ele._private;
        var display = styleEnabled ? ele.pstyle('display').value : 'element';
        var isNode = ele.isNode();
        var isEdge = ele.isEdge();
        var ex1 = void 0,
            ex2 = void 0,
            ey1 = void 0,
            ey2 = void 0; // extrema of body / lines
        var x = void 0,
            y = void 0; // node pos
        var displayed = display !== 'none';

        if (displayed) {
          var overlayOpacity = 0;
          var overlayPadding = 0;

          if (styleEnabled && options.includeOverlays) {
            overlayOpacity = ele.pstyle('overlay-opacity').value;

            if (overlayOpacity !== 0) {
              overlayPadding = ele.pstyle('overlay-padding').value;
            }
          }

          var w = 0;
          var wHalf = 0;

          if (styleEnabled) {
            w = ele.pstyle('width').pfValue;
            wHalf = w / 2;
          }

          if (isNode && options.includeNodes) {
            var pos = ele.position();
            x = pos.x;
            y = pos.y;
            var _w = ele.outerWidth();
            var halfW = _w / 2;
            var h = ele.outerHeight();
            var halfH = h / 2;

            // handle node dimensions
            /////////////////////////

            ex1 = x - halfW - overlayPadding;
            ex2 = x + halfW + overlayPadding;
            ey1 = y - halfH - overlayPadding;
            ey2 = y + halfH + overlayPadding;

            updateBounds(bounds, ex1, ey1, ex2, ey2);
          } else if (isEdge && options.includeEdges) {
            var rstyle = _p.rstyle || {};

            // handle edge dimensions (rough box estimate)
            //////////////////////////////////////////////
            if (styleEnabled && !headless) {
              ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
              ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
              ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
              ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);

              // take into account edge width
              ex1 -= wHalf;
              ex2 += wHalf;
              ey1 -= wHalf;
              ey2 += wHalf;

              updateBounds(bounds, ex1, ey1, ex2, ey2);
            }

            // precise haystacks
            ////////////////////
            if (styleEnabled && !headless && ele.pstyle('curve-style').strValue === 'haystack') {
              var hpts = rstyle.haystackPts || [];

              ex1 = hpts[0].x;
              ey1 = hpts[0].y;
              ex2 = hpts[1].x;
              ey2 = hpts[1].y;

              if (ex1 > ex2) {
                var temp = ex1;
                ex1 = ex2;
                ex2 = temp;
              }

              if (ey1 > ey2) {
                var _temp = ey1;
                ey1 = ey2;
                ey2 = _temp;
              }

              updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);

              // handle points along edge
              ///////////////////////////
            } else {
              var pts = rstyle.bezierPts || rstyle.linePts || [];

              for (var j = 0; j < pts.length; j++) {
                var pt = pts[j];

                ex1 = pt.x - wHalf;
                ex2 = pt.x + wHalf;
                ey1 = pt.y - wHalf;
                ey2 = pt.y + wHalf;

                updateBounds(bounds, ex1, ey1, ex2, ey2);
              }

              // fallback on source and target positions
              //////////////////////////////////////////
              if (pts.length === 0) {
                var n1 = ele.source();
                var n1pos = n1.position();

                var n2 = ele.target();
                var n2pos = n2.position();

                ex1 = n1pos.x;
                ex2 = n2pos.x;
                ey1 = n1pos.y;
                ey2 = n2pos.y;

                if (ex1 > ex2) {
                  var _temp2 = ex1;
                  ex1 = ex2;
                  ex2 = _temp2;
                }

                if (ey1 > ey2) {
                  var _temp3 = ey1;
                  ey1 = ey2;
                  ey2 = _temp3;
                }

                // take into account edge width
                ex1 -= wHalf;
                ex2 += wHalf;
                ey1 -= wHalf;
                ey2 += wHalf;

                updateBounds(bounds, ex1, ey1, ex2, ey2);
              }
            }
          } // edges


          // handle edge arrow size
          /////////////////////////

          if (styleEnabled && options.includeEdges && isEdge) {
            updateBoundsFromArrow(bounds, ele, 'mid-source', options);
            updateBoundsFromArrow(bounds, ele, 'mid-target', options);
            updateBoundsFromArrow(bounds, ele, 'source', options);
            updateBoundsFromArrow(bounds, ele, 'target', options);
          }

          // ghost
          ////////

          if (styleEnabled) {
            var ghost = ele.pstyle('ghost').value === 'yes';

            if (ghost) {
              var gx = ele.pstyle('ghost-offset-x').pfValue;
              var gy = ele.pstyle('ghost-offset-y').pfValue;

              updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
            }
          }

          // overlay
          //////////

          if (styleEnabled) {

            ex1 = bounds.x1;
            ex2 = bounds.x2;
            ey1 = bounds.y1;
            ey2 = bounds.y2;

            updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
          }

          // handle label dimensions
          //////////////////////////

          if (styleEnabled && options.includeLabels) {
            updateBoundsFromLabel(bounds, ele, null, options);

            if (isEdge) {
              updateBoundsFromLabel(bounds, ele, 'source', options);
              updateBoundsFromLabel(bounds, ele, 'target', options);
            }
          } // style enabled for labels
        } // if displayed

        bounds.x1 = noninf(bounds.x1);
        bounds.y1 = noninf(bounds.y1);
        bounds.x2 = noninf(bounds.x2);
        bounds.y2 = noninf(bounds.y2);
        bounds.w = noninf(bounds.x2 - bounds.x1);
        bounds.h = noninf(bounds.y2 - bounds.y1);

        // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
        if (bounds.w > 0 && bounds.h > 0 && displayed) {
          math.expandBoundingBox(bounds, 1);
        }

        return bounds;
      };

      var tf = function tf(val) {
        if (val) {
          return 't';
        } else {
          return 'f';
        }
      };

      var getKey = function getKey(opts) {
        var key = '';

        key += tf(opts.incudeNodes);
        key += tf(opts.includeEdges);
        key += tf(opts.includeLabels);
        key += tf(opts.includeOverlays);

        return key;
      };

      var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
        var _p = ele._private;
        var bb = void 0;
        var headless = ele.cy().headless();
        var key = opts === defBbOpts ? defBbOptsKey : getKey(opts);

        if (!opts.useCache || headless || !_p.bbCache || !_p.bbCache[key]) {
          bb = boundingBoxImpl(ele, opts);

          if (!headless) {
            _p.bbCache = _p.bbCache || {};
            _p.bbCache[key] = bb;
          }
        } else {
          bb = _p.bbCache[key];
        }

        return bb;
      };

      var defBbOpts = {
        includeNodes: true,
        includeEdges: true,
        includeLabels: true,
        includeOverlays: true,
        useCache: true
      };

      var defBbOptsKey = getKey(defBbOpts);

      function filledBbOpts(options) {
        return {
          includeNodes: util.default(options.includeNodes, defBbOpts.includeNodes),
          includeEdges: util.default(options.includeEdges, defBbOpts.includeEdges),
          includeLabels: util.default(options.includeLabels, defBbOpts.includeLabels),
          includeOverlays: util.default(options.includeOverlays, defBbOpts.includeOverlays),
          useCache: util.default(options.useCache, defBbOpts.useCache)
        };
      }

      elesfn.boundingBox = function (options) {
        // the main usecase is ele.boundingBox() for a single element with no/def options
        // specified s.t. the cache is used, so check for this case to make it faster by
        // avoiding the overhead of the rest of the function
        if (this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true)) {
          if (options === undefined) {
            options = defBbOpts;
          } else {
            options = filledBbOpts(options);
          }

          return cachedBoundingBoxImpl(this[0], options);
        }

        var bounds = {
          x1: Infinity,
          y1: Infinity,
          x2: -Infinity,
          y2: -Infinity
        };

        options = options || util.staticEmptyObject();

        var opts = filledBbOpts(options);

        var eles = this;
        var cy = eles.cy();
        var styleEnabled = cy.styleEnabled();

        if (styleEnabled) {
          this.recalculateRenderedStyle(opts.useCache);
        }

        this.updateCompoundBounds();

        var updatedEdge = {}; // use to avoid duplicated edge updates

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ele.id()]) {
            var edges = ele.parallelEdges();

            for (var j = 0; j < edges.length; j++) {
              // make all as updated
              updatedEdge[edges[j].id()] = true;
            }

            edges.recalculateRenderedStyle(opts.useCache); // n.b. ele.parallelEdges() single is cached
          }

          updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));
        }

        bounds.x1 = noninf(bounds.x1);
        bounds.y1 = noninf(bounds.y1);
        bounds.x2 = noninf(bounds.x2);
        bounds.y2 = noninf(bounds.y2);
        bounds.w = noninf(bounds.x2 - bounds.x1);
        bounds.h = noninf(bounds.y2 - bounds.y1);

        return bounds;
      };

      // private helper to get bounding box for custom node positions
      // - good for perf in certain cases but currently requires dirtying the rendered style
      // - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
      // - try to use for only things like discrete layouts where the node position would change anyway
      elesfn.boundingBoxAt = function (fn) {
        var nodes = this.nodes();

        if (is.plainObject(fn)) {
          var obj = fn;

          fn = function fn() {
            return obj;
          };
        }

        // save the current position and set the new one, per node
        for (var i = 0; i < nodes.length; i++) {
          var n = nodes[i];
          var _p = n._private;
          var pos = _p.position;
          var newPos = fn.call(n, n, i);

          _p.bbAtOldPos = { x: pos.x, y: pos.y };

          if (newPos) {
            pos.x = newPos.x;
            pos.y = newPos.y;
          }
        }

        this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

        nodes.dirtyCompoundBoundsCache().updateCompoundBounds();

        var bb = this.boundingBox({ useCache: false });

        // restore the original position, per node
        for (var _i = 0; _i < nodes.length; _i++) {
          var _n = nodes[_i];
          var _p2 = _n._private;
          var _pos = _n._private.position;
          var old = _p2.bbAtOldPos;

          _pos.x = old.x;
          _pos.y = old.y;
        }

        nodes.dirtyCompoundBoundsCache();

        this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

        return bb;
      };

      fn.boundingbox = fn.boundingBox;
      fn.renderedBoundingbox = fn.renderedBoundingBox;

      module.exports = elesfn;

      /***/
    },
    /* 60 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var fn = void 0,
          elesfn = void 0;

      fn = elesfn = {};

      var defineDimFns = function defineDimFns(opts) {
        opts.uppercaseName = util.capitalize(opts.name);
        opts.autoName = 'auto' + opts.uppercaseName;
        opts.labelName = 'label' + opts.uppercaseName;
        opts.outerName = 'outer' + opts.uppercaseName;
        opts.uppercaseOuterName = util.capitalize(opts.outerName);

        fn[opts.name] = function dimImpl() {
          var ele = this[0];
          var _p = ele._private;
          var cy = _p.cy;
          var styleEnabled = cy._private.styleEnabled;

          if (ele) {
            if (styleEnabled) {
              if (ele.isParent()) {
                ele.updateCompoundBounds();

                return _p[opts.autoName] || 0;
              }

              var d = ele.pstyle(opts.name);

              switch (d.strValue) {
                case 'label':
                  ele.recalculateRenderedStyle();

                  return _p.rstyle[opts.labelName] || 0;

                default:
                  return d.pfValue;
              }
            } else {
              return 1;
            }
          }
        };

        fn['outer' + opts.uppercaseName] = function outerDimImpl() {
          var ele = this[0];
          var _p = ele._private;
          var cy = _p.cy;
          var styleEnabled = cy._private.styleEnabled;

          if (ele) {
            if (styleEnabled) {
              var dim = ele[opts.name]();
              var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side
              var padding = 2 * ele.padding();

              return dim + border + padding;
            } else {
              return 1;
            }
          }
        };

        fn['rendered' + opts.uppercaseName] = function renderedDimImpl() {
          var ele = this[0];

          if (ele) {
            var d = ele[opts.name]();
            return d * this.cy().zoom();
          }
        };

        fn['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
          var ele = this[0];

          if (ele) {
            var od = ele[opts.outerName]();
            return od * this.cy().zoom();
          }
        };
      };

      defineDimFns({
        name: 'width'
      });

      defineDimFns({
        name: 'height'
      });

      elesfn.padding = function () {
        var ele = this[0];
        var _p = ele._private;
        if (ele.isParent()) {
          ele.updateCompoundBounds();

          if (_p.autoPadding !== undefined) {
            return _p.autoPadding;
          } else {
            return ele.pstyle('padding').pfValue;
          }
        } else {
          return ele.pstyle('padding').pfValue;
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 61 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var ifEdge = function ifEdge(self, then) {
        if (self.isEdge()) {
          return then(self.renderer());
        }
      };

      module.exports = {
        controlPoints: function controlPoints() {
          var _this = this;

          return ifEdge(this, function (renderer) {
            return renderer.getControlPoints(_this);
          });
        },
        segmentPoints: function segmentPoints() {
          var _this2 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getSegmentPoints(_this2);
          });
        },
        sourceEndpoint: function sourceEndpoint() {
          var _this3 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getSourceEndpoint(_this3);
          });
        },
        targetEndpoint: function targetEndpoint() {
          var _this4 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getTargetEndpoint(_this4);
          });
        },
        midpoint: function midpoint() {
          var _this5 = this;

          return ifEdge(this, function (renderer) {
            return renderer.getEdgeMidpoint(_this5);
          });
        }
      };

      /***/
    },
    /* 62 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Emitter = __webpack_require__(11);
      var define = __webpack_require__(4);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var emitterOptions = {
        qualifierCompare: function qualifierCompare(selector1, selector2) {
          if (selector1 == null || selector2 == null) {
            return selector1 == null && selector2 == null;
          } else {
            return selector1.sameText(selector2);
          }
        },
        eventMatches: function eventMatches(ele, listener, eventObj) {
          var selector = listener.qualifier;

          if (selector != null) {
            return ele !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
          }

          return true;
        },
        eventFields: function eventFields(ele) {
          return {
            cy: ele.cy(),
            target: ele
          };
        },
        callbackContext: function callbackContext(ele, listener, eventObj) {
          return listener.qualifier != null ? eventObj.target : ele;
        },
        beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {
          if (listener.conf && listener.conf.once) {
            listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
          }
        },
        bubble: function bubble() {
          return true;
        },
        parent: function parent(ele) {
          return ele.isChild() ? ele.parent() : ele.cy();
        }
      };

      var argSelector = function argSelector(arg) {
        if (is.string(arg)) {
          return new Selector(arg);
        } else {
          return arg;
        }
      };

      var elesfn = {
        createEmitter: function createEmitter() {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var _p = ele._private;

            if (!_p.emitter) {
              _p.emitter = new Emitter(util.assign({
                context: ele
              }, emitterOptions));
            }
          }

          return this;
        },

        emitter: function emitter() {
          return this._private.emitter;
        },

        on: function on(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().on(events, argSelector(selector), callback);
          }

          return this;
        },

        removeListener: function removeListener(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().removeListener(events, argSelector(selector), callback);
          }

          return this;
        },

        one: function one(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().one(events, argSelector(selector), callback);
          }

          return this;
        },

        once: function once(events, selector, callback) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().on(events, argSelector(selector), callback, {
              once: true,
              onceCollection: this
            });
          }
        },

        emit: function emit(events, extraParams) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];

            ele.emitter().emit(events, extraParams);
          }

          return this;
        },

        emitAndNotify: function emitAndNotify(event, extraParams) {
          // for internal use only
          if (this.length === 0) {
            return;
          } // empty collections don't need to notify anything

          // notify renderer
          this.cy().notify({
            type: event,
            eles: this
          });

          this.emit(event, extraParams);

          return this;
        }
      };

      define.eventAliasesOn(elesfn);

      module.exports = elesfn;

      /***/
    },
    /* 63 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Selector = __webpack_require__(6);

      var elesfn = {
        nodes: function nodes(selector) {
          return this.filter(function (ele) {
            return ele.isNode();
          }).filter(selector);
        },

        edges: function edges(selector) {
          return this.filter(function (ele) {
            return ele.isEdge();
          }).filter(selector);
        },

        filter: function filter(_filter, thisArg) {
          if (_filter === undefined) {
            // check this first b/c it's the most common/performant case
            return this;
          } else if (is.string(_filter) || is.elementOrCollection(_filter)) {
            return new Selector(_filter).filter(this);
          } else if (is.fn(_filter)) {
            var filterEles = this.spawn();
            var eles = this;

            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];
              var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

              if (include) {
                filterEles.merge(ele);
              }
            }

            return filterEles;
          }

          return this.spawn(); // if not handled by above, give 'em an empty collection
        },

        not: function not(toRemove) {
          if (!toRemove) {
            return this;
          } else {

            if (is.string(toRemove)) {
              toRemove = this.filter(toRemove);
            }

            var elements = [];
            var rMap = toRemove._private.map;

            for (var i = 0; i < this.length; i++) {
              var element = this[i];

              var remove = rMap.has(element.id());
              if (!remove) {
                elements.push(element);
              }
            }

            return this.spawn(elements);
          }
        },

        absoluteComplement: function absoluteComplement() {
          var cy = this.cy();

          return cy.mutableElements().not(this);
        },

        intersect: function intersect(other) {
          // if a selector is specified, then filter by it instead
          if (is.string(other)) {
            var selector = other;
            return this.filter(selector);
          }

          var elements = [];
          var col1 = this;
          var col2 = other;
          var col1Smaller = this.length < other.length;
          var map2 = col1Smaller ? col2._private.map : col1._private.map;
          var col = col1Smaller ? col1 : col2;

          for (var i = 0; i < col.length; i++) {
            var id = col[i]._private.data.id;
            var entry = map2.get(id);

            if (entry) {
              elements.push(entry.ele);
            }
          }

          return this.spawn(elements);
        },

        xor: function xor(other) {
          var cy = this._private.cy;

          if (is.string(other)) {
            other = cy.$(other);
          }

          var elements = [];
          var col1 = this;
          var col2 = other;

          var add = function add(col, other) {
            for (var i = 0; i < col.length; i++) {
              var ele = col[i];
              var id = ele._private.data.id;
              var inOther = other.hasElementWithId(id);

              if (!inOther) {
                elements.push(ele);
              }
            }
          };

          add(col1, col2);
          add(col2, col1);

          return this.spawn(elements);
        },

        diff: function diff(other) {
          var cy = this._private.cy;

          if (is.string(other)) {
            other = cy.$(other);
          }

          var left = [];
          var right = [];
          var both = [];
          var col1 = this;
          var col2 = other;

          var add = function add(col, other, retEles) {

            for (var i = 0; i < col.length; i++) {
              var ele = col[i];
              var id = ele._private.data.id;
              var inOther = other.hasElementWithId(id);

              if (inOther) {
                both.push(ele);
              } else {
                retEles.push(ele);
              }
            }
          };

          add(col1, col2, left);
          add(col2, col1, right);

          return {
            left: this.spawn(left, { unique: true }),
            right: this.spawn(right, { unique: true }),
            both: this.spawn(both, { unique: true })
          };
        },

        add: function add(toAdd) {
          var cy = this._private.cy;

          if (!toAdd) {
            return this;
          }

          if (is.string(toAdd)) {
            var selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
          }

          var elements = [];

          for (var i = 0; i < this.length; i++) {
            elements.push(this[i]);
          }

          var map = this._private.map;

          for (var _i = 0; _i < toAdd.length; _i++) {

            var add = !map.has(toAdd[_i].id());
            if (add) {
              elements.push(toAdd[_i]);
            }
          }

          return this.spawn(elements);
        },

        // in place merge on calling collection
        merge: function merge(toAdd) {
          var _p = this._private;
          var cy = _p.cy;

          if (!toAdd) {
            return this;
          }

          if (toAdd && is.string(toAdd)) {
            var selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
          }

          var map = _p.map;

          for (var i = 0; i < toAdd.length; i++) {
            var toAddEle = toAdd[i];
            var id = toAddEle._private.data.id;
            var add = !map.has(id);

            if (add) {
              var index = this.length++;

              this[index] = toAddEle;

              map.set(id, { ele: toAddEle, index: index });
            } else {
              // replace
              var _index = map.get(id).index;

              this[_index] = toAddEle;
              map.set(id, { ele: toAddEle, index: _index });
            }
          }

          return this; // chaining
        },

        // remove single ele in place in calling collection
        unmergeOne: function unmergeOne(ele) {
          ele = ele[0];

          var _p = this._private;
          var id = ele._private.data.id;
          var map = _p.map;
          var entry = map.get(id);

          if (!entry) {
            return this; // no need to remove
          }

          var i = entry.index;

          // remove ele
          this[i] = undefined;
          map.delete(id);

          var unmergedLastEle = i === this.length - 1;

          // replace empty spot with last ele in collection
          if (this.length > 1 && !unmergedLastEle) {
            var lastEleI = this.length - 1;
            var lastEle = this[lastEleI];
            var lastEleId = lastEle._private.data.id;

            this[lastEleI] = undefined;
            this[i] = lastEle;
            map.set(lastEleId, { ele: lastEle, index: i });
          }

          // the collection is now 1 ele smaller
          this.length--;

          return this;
        },

        // remove eles in place on calling collection
        unmerge: function unmerge(toRemove) {
          var cy = this._private.cy;

          if (!toRemove) {
            return this;
          }

          if (toRemove && is.string(toRemove)) {
            var selector = toRemove;
            toRemove = cy.mutableElements().filter(selector);
          }

          for (var i = 0; i < toRemove.length; i++) {
            this.unmergeOne(toRemove[i]);
          }

          return this; // chaining
        },

        map: function map(mapFn, thisArg) {
          var arr = [];
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);

            arr.push(ret);
          }

          return arr;
        },

        reduce: function reduce(fn, initialValue) {
          var val = initialValue;
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            val = fn(val, eles[i], i, eles);
          }

          return val;
        },

        max: function max(valFn, thisArg) {
          var max = -Infinity;
          var maxEle = void 0;
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

            if (val > max) {
              max = val;
              maxEle = ele;
            }
          }

          return {
            value: max,
            ele: maxEle
          };
        },

        min: function min(valFn, thisArg) {
          var min = Infinity;
          var minEle = void 0;
          var eles = this;

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

            if (val < min) {
              min = val;
              minEle = ele;
            }
          }

          return {
            value: min,
            ele: minEle
          };
        }
      };

      // aliases
      var fn = elesfn;
      fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
      fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
      fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
      fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
      fn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;
      fn.complement = fn.abscomp = fn.absoluteComplement;

      module.exports = elesfn;

      /***/
    },
    /* 64 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var elesfn = {
        isNode: function isNode() {
          return this.group() === 'nodes';
        },

        isEdge: function isEdge() {
          return this.group() === 'edges';
        },

        isLoop: function isLoop() {
          return this.isEdge() && this.source().id() === this.target().id();
        },

        isSimple: function isSimple() {
          return this.isEdge() && this.source().id() !== this.target().id();
        },

        group: function group() {
          var ele = this[0];

          if (ele) {
            return ele._private.group;
          }
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 65 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var zIndexSort = __webpack_require__(17);
      var util = __webpack_require__(1);

      var elesfn = {
        forEach: function forEach(fn, thisArg) {
          if (is.fn(fn)) {

            for (var i = 0; i < this.length; i++) {
              var ele = this[i];
              var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);

              if (ret === false) {
                break;
              } // exit each early on return false
            }
          }

          return this;
        },

        toArray: function toArray() {
          var array = [];

          for (var i = 0; i < this.length; i++) {
            array.push(this[i]);
          }

          return array;
        },

        slice: function slice(start, end) {
          var array = [];
          var thisSize = this.length;

          if (end == null) {
            end = thisSize;
          }

          if (start == null) {
            start = 0;
          }

          if (start < 0) {
            start = thisSize + start;
          }

          if (end < 0) {
            end = thisSize + end;
          }

          for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
            array.push(this[i]);
          }

          return this.spawn(array);
        },

        size: function size() {
          return this.length;
        },

        eq: function eq(i) {
          return this[i] || this.spawn();
        },

        first: function first() {
          return this[0] || this.spawn();
        },

        last: function last() {
          return this[this.length - 1] || this.spawn();
        },

        empty: function empty() {
          return this.length === 0;
        },

        nonempty: function nonempty() {
          return !this.empty();
        },

        sort: function sort(sortFn) {
          if (!is.fn(sortFn)) {
            return this;
          }

          var sorted = this.toArray().sort(sortFn);

          return this.spawn(sorted);
        },

        sortByZIndex: function sortByZIndex() {
          return this.sort(zIndexSort);
        },

        zDepth: function zDepth() {
          var ele = this[0];
          if (!ele) {
            return undefined;
          }

          // let cy = ele.cy();
          var _p = ele._private;
          var group = _p.group;

          if (group === 'nodes') {
            var depth = _p.data.parent ? ele.parents().size() : 0;

            if (!ele.isParent()) {
              return util.MAX_INT - 1; // childless nodes always on top
            }

            return depth;
          } else {
            var src = _p.source;
            var tgt = _p.target;
            var srcDepth = src.zDepth();
            var tgtDepth = tgt.zDepth();

            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
          }
        }
      };

      elesfn.each = elesfn.forEach;

      module.exports = elesfn;

      /***/
    },
    /* 66 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Promise = __webpack_require__(5);
      var math = __webpack_require__(2);

      var elesfn = {
        // Calculates and returns node dimensions { x, y } based on options given
        layoutDimensions: function layoutDimensions(options) {
          options = util.assign({
            nodeDimensionsIncludeLabels: true
          }, options);

          if (options.nodeDimensionsIncludeLabels) {
            var bbDim = this.boundingBox();
            return {
              w: bbDim.w,
              h: bbDim.h
            };
          } else {
            return {
              w: this.outerWidth(),
              h: this.outerHeight()
            };
          }
        },

        // using standard layout options, apply position function (w/ or w/o animation)
        layoutPositions: function layoutPositions(layout, options, fn) {
          var nodes = this.nodes();
          var cy = this.cy();
          var layoutEles = options.eles; // nodes & edges
          var getMemoizeKey = function getMemoizeKey(node, i) {
            return node.id() + '$' + i;
          };
          var fnMem = util.memoize(fn, getMemoizeKey); // memoized version of position function

          layout.emit({ type: 'layoutstart', layout: layout });

          layout.animations = [];

          var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
            var center = {
              x: nodesBb.x1 + nodesBb.w / 2,
              y: nodesBb.y1 + nodesBb.h / 2
            };

            var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
              x: (pos.x - center.x) * spacing,
              y: (pos.y - center.y) * spacing
            };

            return {
              x: center.x + spacingVector.x,
              y: center.y + spacingVector.y
            };
          };

          var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

          var spacingBb = function spacingBb() {
            if (!useSpacingFactor) {
              return null;
            }

            var bb = math.makeBoundingBox();

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var pos = fnMem(node, i);

              math.expandBoundingBoxByPoint(bb, pos.x, pos.y);
            }

            return bb;
          };

          var bb = spacingBb();

          var getFinalPos = util.memoize(function (node, i) {
            var newPos = fnMem(node, i);
            var pos = node.position();

            if (!is.number(pos.x) || !is.number(pos.y)) {
              node.silentPosition({ x: 0, y: 0 });
            }

            if (useSpacingFactor) {
              var spacing = Math.abs(options.spacingFactor);

              newPos = calculateSpacing(spacing, bb, newPos);
            }

            if (options.transform != null) {
              newPos = options.transform(node, newPos);
            }

            return newPos;
          }, getMemoizeKey);

          if (options.animate) {
            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var newPos = getFinalPos(node, i);
              var animateNode = options.animateFilter == null || options.animateFilter(node, i);

              if (animateNode) {
                var ani = node.animation({
                  position: newPos,
                  duration: options.animationDuration,
                  easing: options.animationEasing
                });

                layout.animations.push(ani);

                ani.play();
              } else {
                node.position(newPos);
              }
            }

            if (options.fit) {
              var fitAni = cy.animation({
                fit: {
                  boundingBox: layoutEles.boundingBoxAt(getFinalPos),
                  padding: options.padding
                },
                duration: options.animationDuration,
                easing: options.animationEasing
              });

              layout.animations.push(fitAni);

              fitAni.play();
            } else if (options.zoom !== undefined && options.pan !== undefined) {
              var zoomPanAni = cy.animation({
                zoom: options.zoom,
                pan: options.pan,
                duration: options.animationDuration,
                easing: options.animationEasing
              });

              layout.animations.push(zoomPanAni);

              zoomPanAni.play();
            }

            layout.one('layoutready', options.ready);
            layout.emit({ type: 'layoutready', layout: layout });

            Promise.all(layout.animations.map(function (ani) {
              return ani.promise();
            })).then(function () {
              layout.one('layoutstop', options.stop);
              layout.emit({ type: 'layoutstop', layout: layout });
            });
          } else {

            nodes.positions(getFinalPos);

            if (options.fit) {
              cy.fit(options.eles, options.padding);
            }

            if (options.zoom != null) {
              cy.zoom(options.zoom);
            }

            if (options.pan) {
              cy.pan(options.pan);
            }

            layout.one('layoutready', options.ready);
            layout.emit({ type: 'layoutready', layout: layout });

            layout.one('layoutstop', options.stop);
            layout.emit({ type: 'layoutstop', layout: layout });
          }

          return this; // chaining
        },

        layout: function layout(options) {
          var cy = this.cy();

          return cy.makeLayout(util.extend({}, options, {
            eles: this
          }));
        }

      };

      // aliases:
      elesfn.createLayout = elesfn.makeLayout = elesfn.layout;

      module.exports = elesfn;

      /***/
    },
    /* 67 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      function styleCache(key, fn, ele) {
        var _p = ele._private;
        var cache = _p.styleCache = _p.styleCache || {};
        var val;

        if ((val = cache[key]) != null) {
          return val;
        } else {
          val = cache[key] = fn(ele);

          return val;
        }
      }

      function cacheStyleFunction(key, fn) {
        return function cachedStyleFunction(ele) {
          return styleCache(key, fn, ele);
        };
      }

      function cachePrototypeStyleFunction(key, fn) {
        var selfFn = function selfFn(ele) {
          return fn.call(ele);
        };

        return function cachedPrototypeStyleFunction() {
          var ele = this[0];

          if (ele) {
            return styleCache(key, selfFn, ele);
          }
        };
      }

      var elesfn = {

        recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
          var cy = this.cy();
          var renderer = cy.renderer();
          var styleEnabled = cy.styleEnabled();

          if (renderer && styleEnabled) {
            renderer.recalculateRenderedStyle(this, useCache);
          }

          return this;
        },

        dirtyStyleCache: function dirtyStyleCache() {
          var cy = this.cy();
          var dirty = function dirty(ele) {
            return ele._private.styleCache = {};
          };

          if (cy.hasCompoundNodes()) {
            var eles = void 0;

            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());

            eles.merge(eles.connectedEdges());

            eles.forEach(dirty);
          } else {
            this.forEach(function (ele) {
              dirty(ele);

              ele.connectedEdges().forEach(dirty);
            });
          }

          return this;
        },

        // fully updates (recalculates) the style for the elements
        updateStyle: function updateStyle(notifyRenderer) {
          var cy = this._private.cy;

          if (!cy.styleEnabled()) {
            return this;
          }

          if (cy._private.batchingStyle) {
            var bEles = cy._private.batchStyleEles;

            bEles.merge(this);

            return this; // chaining and exit early when batching
          }

          var hasCompounds = cy.hasCompoundNodes();
          var style = cy.style();
          var updatedEles = this;

          notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

          if (hasCompounds) {
            // then add everything up and down for compound selector checks
            updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
          }

          var changedEles = style.apply(updatedEles);

          changedEles.dirtyStyleCache();
          changedEles.dirtyCompoundBoundsCache();

          if (notifyRenderer) {
            changedEles.emitAndNotify('style'); // let renderer know we changed style
          } else {
            changedEles.emit('style'); // just fire the event
          }

          return this; // chaining
        },

        // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
        updateMappers: function updateMappers(notifyRenderer) {
          var cy = this._private.cy;
          var style = cy.style();
          notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

          if (!cy.styleEnabled()) {
            return this;
          }

          var changedEles = style.updateMappers(this);

          changedEles.dirtyStyleCache();
          changedEles.dirtyCompoundBoundsCache();

          if (notifyRenderer) {
            changedEles.emitAndNotify('style'); // let renderer know we changed style
          } else {
            changedEles.emit('style'); // just fire the event
          }
          return this; // chaining
        },

        // get the internal parsed style object for the specified property
        parsedStyle: function parsedStyle(property) {
          var ele = this[0];
          var cy = ele.cy();

          if (!cy.styleEnabled()) {
            return;
          }

          if (ele) {
            return ele._private.style[property] || cy.style().getDefaultProperty(property);
          }
        },

        numericStyle: function numericStyle(property) {
          var ele = this[0];

          if (!ele.cy().styleEnabled()) {
            return;
          }

          if (ele) {
            var pstyle = ele.pstyle(property);

            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
          }
        },

        numericStyleUnits: function numericStyleUnits(property) {
          var ele = this[0];

          if (!ele.cy().styleEnabled()) {
            return;
          }

          if (ele) {
            return ele.pstyle(property).units;
          }
        },

        // get the specified css property as a rendered value (i.e. on-screen value)
        // or get the whole rendered style if no property specified (NB doesn't allow setting)
        renderedStyle: function renderedStyle(property) {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return this;
          }

          var ele = this[0];

          if (ele) {
            return cy.style().getRenderedStyle(ele, property);
          }
        },

        // read the calculated css style of the element or override the style (via a bypass)
        style: function style(name, value) {
          var cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          var updateTransitions = false;
          var style = cy.style();

          if (is.plainObject(name)) {
            // then extend the bypass
            var props = name;
            style.applyBypass(this, props, updateTransitions);

            this.dirtyStyleCache();
            this.dirtyCompoundBoundsCache();

            this.emitAndNotify('style'); // let the renderer know we've updated style
          } else if (is.string(name)) {

            if (value === undefined) {
              // then get the property from the style
              var ele = this[0];

              if (ele) {
                return style.getStylePropertyValue(ele, name);
              } else {
                // empty collection => can't get any value
                return;
              }
            } else {
              // then set the bypass with the property value
              style.applyBypass(this, name, value, updateTransitions);

              this.dirtyStyleCache();
              this.dirtyCompoundBoundsCache();

              this.emitAndNotify('style'); // let the renderer know we've updated style
            }
          } else if (name === undefined) {
            var _ele = this[0];

            if (_ele) {
              return style.getRawStyle(_ele);
            } else {
              // empty collection => can't get any value
              return;
            }
          }

          return this; // chaining
        },

        removeStyle: function removeStyle(names) {
          var cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          var updateTransitions = false;
          var style = cy.style();
          var eles = this;

          if (names === undefined) {
            for (var i = 0; i < eles.length; i++) {
              var ele = eles[i];

              style.removeAllBypasses(ele, updateTransitions);
            }
          } else {
            names = names.split(/\s+/);

            for (var _i = 0; _i < eles.length; _i++) {
              var _ele2 = eles[_i];

              style.removeBypasses(_ele2, names, updateTransitions);
            }
          }

          this.dirtyStyleCache();
          this.dirtyCompoundBoundsCache();

          this.emitAndNotify('style'); // let the renderer know we've updated style

          return this; // chaining
        },

        show: function show() {
          this.css('display', 'element');
          return this; // chaining
        },

        hide: function hide() {
          this.css('display', 'none');
          return this; // chaining
        },

        effectiveOpacity: function effectiveOpacity() {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return 1;
          }

          var hasCompoundNodes = cy.hasCompoundNodes();
          var ele = this[0];

          if (ele) {
            var _p = ele._private;
            var parentOpacity = ele.pstyle('opacity').value;

            if (!hasCompoundNodes) {
              return parentOpacity;
            }

            var parents = !_p.data.parent ? null : ele.parents();

            if (parents) {
              for (var i = 0; i < parents.length; i++) {
                var parent = parents[i];
                var opacity = parent.pstyle('opacity').value;

                parentOpacity = opacity * parentOpacity;
              }
            }

            return parentOpacity;
          }
        },

        transparent: function transparent() {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return false;
          }

          var ele = this[0];
          var hasCompoundNodes = ele.cy().hasCompoundNodes();

          if (ele) {
            if (!hasCompoundNodes) {
              return ele.pstyle('opacity').value === 0;
            } else {
              return ele.effectiveOpacity() === 0;
            }
          }
        },

        backgrounding: function backgrounding() {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return false;
          }

          var ele = this[0];

          return ele._private.backgrounding ? true : false;
        }

      };

      function checkCompound(ele, parentOk) {
        var _p = ele._private;
        var parents = _p.data.parent ? ele.parents() : null;

        if (parents) {
          for (var i = 0; i < parents.length; i++) {
            var parent = parents[i];

            if (!parentOk(parent)) {
              return false;
            }
          }
        }

        return true;
      }

      function defineDerivedStateFunction(specs) {
        var ok = specs.ok;
        var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
        var parentOk = specs.parentOk || specs.ok;

        return function () {
          var cy = this.cy();
          if (!cy.styleEnabled()) {
            return true;
          }

          var ele = this[0];
          var hasCompoundNodes = cy.hasCompoundNodes();

          if (ele) {
            var _p = ele._private;

            if (!ok(ele)) {
              return false;
            }

            if (ele.isNode()) {
              return !hasCompoundNodes || checkCompound(ele, parentOk);
            } else {
              var src = _p.source;
              var tgt = _p.target;

              return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
            }
          }
        };
      }

      var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
        return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
      });

      elesfn.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
        ok: eleTakesUpSpace
      }));

      var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
        return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
      });

      var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
        return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
      });

      elesfn.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
        ok: eleInteractive,
        parentOk: parentInteractive,
        edgeOkViaNode: eleTakesUpSpace
      }));

      elesfn.noninteractive = function () {
        var ele = this[0];

        if (ele) {
          return !ele.interactive();
        }
      };

      var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
        return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
      });

      var edgeVisibleViaNode = eleTakesUpSpace;

      elesfn.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
        ok: eleVisible,
        edgeOkViaNode: edgeVisibleViaNode
      }));

      elesfn.hidden = function () {
        var ele = this[0];

        if (ele) {
          return !ele.visible();
        }
      };

      elesfn.bypass = elesfn.css = elesfn.style;
      elesfn.renderedCss = elesfn.renderedStyle;
      elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
      elesfn.pstyle = elesfn.parsedStyle;

      module.exports = elesfn;

      /***/
    },
    /* 68 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var elesfn = {};

      function defineSwitchFunction(params) {
        return function () {
          var args = arguments;
          var changedEles = [];

          // e.g. cy.nodes().select( data, handler )
          if (args.length === 2) {
            var data = args[0];
            var handler = args[1];
            this.on(params.event, data, handler);
          }

          // e.g. cy.nodes().select( handler )
          else if (args.length === 1) {
              var _handler = args[0];
              this.on(params.event, _handler);
            }

            // e.g. cy.nodes().select()
            else if (args.length === 0) {
                for (var i = 0; i < this.length; i++) {
                  var ele = this[i];
                  var able = !params.ableField || ele._private[params.ableField];
                  var changed = ele._private[params.field] != params.value;

                  if (params.overrideAble) {
                    var overrideAble = params.overrideAble(ele);

                    if (overrideAble !== undefined) {
                      able = overrideAble;

                      if (!overrideAble) {
                        return this;
                      } // to save cycles assume not able for all on override
                    }
                  }

                  if (able) {
                    ele._private[params.field] = params.value;

                    if (changed) {
                      changedEles.push(ele);
                    }
                  }
                }

                var changedColl = this.spawn(changedEles);
                changedColl.updateStyle(); // change of state => possible change of style
                changedColl.emit(params.event);
              }

          return this;
        };
      }

      function defineSwitchSet(params) {
        elesfn[params.field] = function () {
          var ele = this[0];

          if (ele) {
            if (params.overrideField) {
              var val = params.overrideField(ele);

              if (val !== undefined) {
                return val;
              }
            }

            return ele._private[params.field];
          }
        };

        elesfn[params.on] = defineSwitchFunction({
          event: params.on,
          field: params.field,
          ableField: params.ableField,
          overrideAble: params.overrideAble,
          value: true
        });

        elesfn[params.off] = defineSwitchFunction({
          event: params.off,
          field: params.field,
          ableField: params.ableField,
          overrideAble: params.overrideAble,
          value: false
        });
      }

      defineSwitchSet({
        field: 'locked',
        overrideField: function overrideField(ele) {
          return ele.cy().autolock() ? true : undefined;
        },
        on: 'lock',
        off: 'unlock'
      });

      defineSwitchSet({
        field: 'grabbable',
        overrideField: function overrideField(ele) {
          return ele.cy().autoungrabify() ? false : undefined;
        },
        on: 'grabify',
        off: 'ungrabify'
      });

      defineSwitchSet({
        field: 'selected',
        ableField: 'selectable',
        overrideAble: function overrideAble(ele) {
          return ele.cy().autounselectify() ? false : undefined;
        },
        on: 'select',
        off: 'unselect'
      });

      defineSwitchSet({
        field: 'selectable',
        overrideField: function overrideField(ele) {
          return ele.cy().autounselectify() ? false : undefined;
        },
        on: 'selectify',
        off: 'unselectify'
      });

      elesfn.deselect = elesfn.unselect;

      elesfn.grabbed = function () {
        var ele = this[0];
        if (ele) {
          return ele._private.grabbed;
        }
      };

      defineSwitchSet({
        field: 'active',
        on: 'activate',
        off: 'unactivate'
      });

      elesfn.inactive = function () {
        var ele = this[0];
        if (ele) {
          return !ele._private.active;
        }
      };

      module.exports = elesfn;

      /***/
    },
    /* 69 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var elesfn = {};

      var cache = function cache(fn, name) {
        return function traversalCache(arg1, arg2, arg3, arg4) {
          var selectorOrEles = arg1;
          var eles = this;
          var key = void 0;

          if (selectorOrEles == null) {
            key = 'null';
          } else if (is.elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
            key = '#' + selectorOrEles.id();
          }

          if (eles.length === 1 && key) {
            var _p = eles[0]._private;
            var tch = _p.traversalCache = _p.traversalCache || {};
            var ch = tch[name] = tch[name] || {};
            var cacheHit = ch[key];

            if (cacheHit) {
              return cacheHit;
            } else {
              return ch[key] = fn.call(eles, arg1, arg2, arg3, arg4);
            }
          } else {
            return fn.call(eles, arg1, arg2, arg3, arg4);
          }
        };
      };

      // DAG functions
      ////////////////

      var defineDagExtremity = function defineDagExtremity(params) {
        return function dagExtremityImpl(selector) {
          var eles = this;
          var ret = [];

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            if (!ele.isNode()) {
              continue;
            }

            var disqualified = false;
            var edges = ele.connectedEdges();

            for (var j = 0; j < edges.length; j++) {
              var edge = edges[j];
              var src = edge.source();
              var tgt = edge.target();

              if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
                disqualified = true;
                break;
              }
            }

            if (!disqualified) {
              ret.push(ele);
            }
          }

          return this.spawn(ret, { unique: true }).filter(selector);
        };
      };

      var defineDagOneHop = function defineDagOneHop(params) {
        return function (selector) {
          var eles = this;
          var oEles = [];

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];

            if (!ele.isNode()) {
              continue;
            }

            var edges = ele.connectedEdges();
            for (var j = 0; j < edges.length; j++) {
              var edge = edges[j];
              var src = edge.source();
              var tgt = edge.target();

              if (params.outgoing && src === ele) {
                oEles.push(edge);
                oEles.push(tgt);
              } else if (params.incoming && tgt === ele) {
                oEles.push(edge);
                oEles.push(src);
              }
            }
          }

          return this.spawn(oEles, { unique: true }).filter(selector);
        };
      };

      var defineDagAllHops = function defineDagAllHops(params) {
        return function (selector) {
          var eles = this;
          var sEles = [];
          var sElesIds = {};

          for (;;) {
            var next = params.outgoing ? eles.outgoers() : eles.incomers();

            if (next.length === 0) {
              break;
            } // done if none left

            var newNext = false;
            for (var i = 0; i < next.length; i++) {
              var n = next[i];
              var nid = n.id();

              if (!sElesIds[nid]) {
                sElesIds[nid] = true;
                sEles.push(n);
                newNext = true;
              }
            }

            if (!newNext) {
              break;
            } // done if touched all outgoers already

            eles = next;
          }

          return this.spawn(sEles, { unique: true }).filter(selector);
        };
      };

      elesfn.clearTraversalCache = function () {
        for (var i = 0; i < this.length; i++) {
          this[i]._private.traversalCache = null;
        }
      };

      util.extend(elesfn, {
        // get the root nodes in the DAG
        roots: defineDagExtremity({ noIncomingEdges: true }),

        // get the leaf nodes in the DAG
        leaves: defineDagExtremity({ noOutgoingEdges: true }),

        // normally called children in graph theory
        // these nodes =edges=> outgoing nodes
        outgoers: cache(defineDagOneHop({ outgoing: true }), 'outgoers'),

        // aka DAG descendants
        successors: defineDagAllHops({ outgoing: true }),

        // normally called parents in graph theory
        // these nodes <=edges= incoming nodes
        incomers: cache(defineDagOneHop({ incoming: true }), 'incomers'),

        // aka DAG ancestors
        predecessors: defineDagAllHops({ incoming: true })
      });

      // Neighbourhood functions
      //////////////////////////

      util.extend(elesfn, {
        neighborhood: cache(function (selector) {
          var elements = [];
          var nodes = this.nodes();

          for (var i = 0; i < nodes.length; i++) {
            // for all nodes
            var node = nodes[i];
            var connectedEdges = node.connectedEdges();

            // for each connected edge, add the edge and the other node
            for (var j = 0; j < connectedEdges.length; j++) {
              var edge = connectedEdges[j];
              var src = edge.source();
              var tgt = edge.target();
              var otherNode = node === src ? tgt : src;

              // need check in case of loop
              if (otherNode.length > 0) {
                elements.push(otherNode[0]); // add node 1 hop away
              }

              // add connected edge
              elements.push(edge[0]);
            }
          }

          return this.spawn(elements, { unique: true }).filter(selector);
        }, 'neighborhood'),

        closedNeighborhood: function closedNeighborhood(selector) {
          return this.neighborhood().add(this).filter(selector);
        },

        openNeighborhood: function openNeighborhood(selector) {
          return this.neighborhood(selector);
        }
      });

      // aliases
      elesfn.neighbourhood = elesfn.neighborhood;
      elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
      elesfn.openNeighbourhood = elesfn.openNeighborhood;

      // Edge functions
      /////////////////

      util.extend(elesfn, {
        source: cache(function sourceImpl(selector) {
          var ele = this[0];
          var src = void 0;

          if (ele) {
            src = ele._private.source || ele.cy().collection();
          }

          return src && selector ? src.filter(selector) : src;
        }, 'source'),

        target: cache(function targetImpl(selector) {
          var ele = this[0];
          var tgt = void 0;

          if (ele) {
            tgt = ele._private.target || ele.cy().collection();
          }

          return tgt && selector ? tgt.filter(selector) : tgt;
        }, 'target'),

        sources: defineSourceFunction({
          attr: 'source'
        }),

        targets: defineSourceFunction({
          attr: 'target'
        })
      });

      function defineSourceFunction(params) {
        return function sourceImpl(selector) {
          var sources = [];

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var src = ele._private[params.attr];

            if (src) {
              sources.push(src);
            }
          }

          return this.spawn(sources, { unique: true }).filter(selector);
        };
      }

      util.extend(elesfn, {
        edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),

        edgesTo: cache(defineEdgesWithFunction({
          thisIsSrc: true
        }), 'edgesTo')
      });

      function defineEdgesWithFunction(params) {

        return function edgesWithImpl(otherNodes) {
          var elements = [];
          var cy = this._private.cy;
          var p = params || {};

          // get elements if a selector is specified
          if (is.string(otherNodes)) {
            otherNodes = cy.$(otherNodes);
          }

          for (var h = 0; h < otherNodes.length; h++) {
            var edges = otherNodes[h]._private.edges;

            for (var i = 0; i < edges.length; i++) {
              var edge = edges[i];
              var edgeData = edge._private.data;
              var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
              var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
              var edgeConnectsThisAndOther = thisToOther || otherToThis;

              if (!edgeConnectsThisAndOther) {
                continue;
              }

              if (p.thisIsSrc || p.thisIsTgt) {
                if (p.thisIsSrc && !thisToOther) {
                  continue;
                }

                if (p.thisIsTgt && !otherToThis) {
                  continue;
                }
              }

              elements.push(edge);
            }
          }

          return this.spawn(elements, { unique: true });
        };
      }

      util.extend(elesfn, {
        connectedEdges: cache(function (selector) {
          var retEles = [];

          var eles = this;
          for (var i = 0; i < eles.length; i++) {
            var node = eles[i];
            if (!node.isNode()) {
              continue;
            }

            var edges = node._private.edges;

            for (var j = 0; j < edges.length; j++) {
              var edge = edges[j];
              retEles.push(edge);
            }
          }

          return this.spawn(retEles, { unique: true }).filter(selector);
        }, 'connectedEdges'),

        connectedNodes: cache(function (selector) {
          var retEles = [];

          var eles = this;
          for (var i = 0; i < eles.length; i++) {
            var edge = eles[i];
            if (!edge.isEdge()) {
              continue;
            }

            retEles.push(edge.source()[0]);
            retEles.push(edge.target()[0]);
          }

          return this.spawn(retEles, { unique: true }).filter(selector);
        }, 'connectedNodes'),

        parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),

        codirectedEdges: cache(defineParallelEdgesFunction({
          codirected: true
        }), 'codirectedEdges')
      });

      function defineParallelEdgesFunction(params) {
        var defaults = {
          codirected: false
        };
        params = util.extend({}, defaults, params);

        return function parallelEdgesImpl(selector) {
          // micro-optimised for renderer
          var elements = [];
          var edges = this.edges();
          var p = params;

          // look at all the edges in the collection
          for (var i = 0; i < edges.length; i++) {
            var edge1 = edges[i];
            var edge1_p = edge1._private;
            var src1 = edge1_p.source;
            var srcid1 = src1._private.data.id;
            var tgtid1 = edge1_p.data.target;
            var srcEdges1 = src1._private.edges;

            // look at edges connected to the src node of this edge
            for (var j = 0; j < srcEdges1.length; j++) {
              var edge2 = srcEdges1[j];
              var edge2data = edge2._private.data;
              var tgtid2 = edge2data.target;
              var srcid2 = edge2data.source;

              var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
              var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

              if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
                elements.push(edge2);
              }
            }
          }

          return this.spawn(elements, { unique: true }).filter(selector);
        };
      }

      // Misc functions
      /////////////////

      util.extend(elesfn, {
        components: function components() {
          var self = this;
          var cy = self.cy();
          var visited = self.spawn();
          var unvisited = self.nodes().spawnSelf();
          var components = [];

          var visitInComponent = function visitInComponent(node, component) {
            visited.merge(node);
            unvisited.unmerge(node);
            component.merge(node);
          };

          if (unvisited.empty()) {
            return self.spawn();
          }

          var _loop = function _loop() {
            var component = cy.collection();
            components.push(component);

            var root = unvisited[0];
            visitInComponent(root, component);

            self.bfs({
              directed: false,
              roots: root,
              visit: function visit(v, e, u, i, depth) {
                visitInComponent(v, component);
              }
            });
          };

          do {
            _loop();
          } while (unvisited.length > 0);

          return components.map(function (component) {
            var connectedEdges = component.connectedEdges().stdFilter(function (edge) {
              return component.anySame(edge.source()) && component.anySame(edge.target());
            });

            return component.union(connectedEdges);
          });
        }
      });

      module.exports = elesfn;

      /***/
    },
    /* 70 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Collection = __webpack_require__(7);
      var Element = __webpack_require__(14);

      var corefn = {
        add: function add(opts) {

          var elements = void 0;
          var cy = this;

          // add the elements
          if (is.elementOrCollection(opts)) {
            var eles = opts;

            if (eles._private.cy === cy) {
              // same instance => just restore
              elements = eles.restore();
            } else {
              // otherwise, copy from json
              var jsons = [];

              for (var i = 0; i < eles.length; i++) {
                var ele = eles[i];
                jsons.push(ele.json());
              }

              elements = new Collection(cy, jsons);
            }
          }

          // specify an array of options
          else if (is.array(opts)) {
              var _jsons = opts;

              elements = new Collection(cy, _jsons);
            }

            // specify via opts.nodes and opts.edges
            else if (is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges))) {
                var elesByGroup = opts;
                var _jsons2 = [];

                var grs = ['nodes', 'edges'];
                for (var _i = 0, il = grs.length; _i < il; _i++) {
                  var group = grs[_i];
                  var elesArray = elesByGroup[group];

                  if (is.array(elesArray)) {

                    for (var j = 0, jl = elesArray.length; j < jl; j++) {
                      var json = util.extend({ group: group }, elesArray[j]);

                      _jsons2.push(json);
                    }
                  }
                }

                elements = new Collection(cy, _jsons2);
              }

              // specify options for one element
              else {
                  var _json = opts;
                  elements = new Element(cy, _json).collection();
                }

          return elements;
        },

        remove: function remove(collection) {
          if (is.elementOrCollection(collection)) {
            // already have right ref
          } else if (is.string(collection)) {
            var selector = collection;
            collection = this.$(selector);
          }

          return collection.remove();
        }
      };

      module.exports = corefn;

      /***/
    },
    /* 71 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var define = __webpack_require__(4);
      var util = __webpack_require__(1);
      var stepAll = __webpack_require__(72);

      var corefn = {

        // pull in animation functions
        animate: define.animate(),
        animation: define.animation(),
        animated: define.animated(),
        clearQueue: define.clearQueue(),
        delay: define.delay(),
        delayAnimation: define.delayAnimation(),
        stop: define.stop(),

        addToAnimationPool: function addToAnimationPool(eles) {
          var cy = this;

          if (!cy.styleEnabled()) {
            return;
          } // save cycles when no style used

          cy._private.aniEles.merge(eles);
        },

        stopAnimationLoop: function stopAnimationLoop() {
          this._private.animationsRunning = false;
        },

        startAnimationLoop: function startAnimationLoop() {
          var cy = this;

          cy._private.animationsRunning = true;

          if (!cy.styleEnabled()) {
            return;
          } // save cycles when no style used

          // NB the animation loop will exec in headless environments if style enabled
          // and explicit cy.destroy() is necessary to stop the loop

          function headlessStep() {
            if (!cy._private.animationsRunning) {
              return;
            }

            util.requestAnimationFrame(function animationStep(now) {
              stepAll(now, cy);
              headlessStep();
            });
          }

          var renderer = cy.renderer();

          if (renderer && renderer.beforeRender) {
            // let the renderer schedule animations
            renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
              stepAll(now, cy);
            }, renderer.beforeRenderPriorities.animations);
          } else {
            // manage the animation loop ourselves
            headlessStep(); // first call
          }
        }

      };

      module.exports = corefn;

      /***/
    },
    /* 72 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var step = __webpack_require__(73);
      var startAnimation = __webpack_require__(78);

      function stepAll(now, cy) {
        var eles = cy._private.aniEles;
        var doneEles = [];

        function stepOne(ele, isCore) {
          var _p = ele._private;
          var current = _p.animation.current;
          var queue = _p.animation.queue;
          var ranAnis = false;

          // cancel all animations on display:none ele
          if (!isCore && ele.pstyle('display').value === 'none') {
            // put all current and queue animations in this tick's current list
            // and empty the lists for the element
            current = current.splice(0, current.length).concat(queue.splice(0, queue.length));

            // stop all animations
            for (var i = 0; i < current.length; i++) {
              current[i].stop();
            }
          }

          // if nothing currently animating, get something from the queue
          if (current.length === 0) {
            var next = queue.shift();

            if (next) {
              current.push(next);
            }
          }

          var callbacks = function callbacks(_callbacks) {
            for (var j = _callbacks.length - 1; j >= 0; j--) {
              var cb = _callbacks[j];

              cb();
            }

            _callbacks.splice(0, _callbacks.length);
          };

          // step and remove if done
          for (var _i = current.length - 1; _i >= 0; _i--) {
            var ani = current[_i];
            var ani_p = ani._private;

            if (ani_p.stopped) {
              current.splice(_i, 1);

              ani_p.hooked = false;
              ani_p.playing = false;
              ani_p.started = false;

              callbacks(ani_p.frames);

              continue;
            }

            if (!ani_p.playing && !ani_p.applying) {
              continue;
            }

            // an apply() while playing shouldn't do anything
            if (ani_p.playing && ani_p.applying) {
              ani_p.applying = false;
            }

            if (!ani_p.started) {
              startAnimation(ele, ani, now, isCore);
            }

            step(ele, ani, now, isCore);

            if (ani_p.applying) {
              ani_p.applying = false;
            }

            callbacks(ani_p.frames);

            if (ani.completed()) {
              current.splice(_i, 1);

              ani_p.hooked = false;
              ani_p.playing = false;
              ani_p.started = false;

              callbacks(ani_p.completes);
            }

            ranAnis = true;
          }

          if (!isCore && current.length === 0 && queue.length === 0) {
            doneEles.push(ele);
          }

          return ranAnis;
        } // stepElement

        // handle all eles
        var ranEleAni = false;
        for (var e = 0; e < eles.length; e++) {
          var ele = eles[e];
          var handledThisEle = stepOne(ele);

          ranEleAni = ranEleAni || handledThisEle;
        } // each element

        var ranCoreAni = stepOne(cy, true);

        // notify renderer
        if (ranEleAni || ranCoreAni) {
          if (eles.length > 0) {
            eles.dirtyCompoundBoundsCache();

            cy.notify({
              type: 'draw',
              eles: eles
            });
          } else {
            cy.notify({
              type: 'draw'
            });
          }
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge(doneEles);

        cy.emit('step');
      } // stepAll

      module.exports = stepAll;

      /***/
    },
    /* 73 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var easings = __webpack_require__(74);
      var ease = __webpack_require__(77);
      var is = __webpack_require__(0);

      function step(self, ani, now, isCore) {
        var isEles = !isCore;
        var _p = self._private;
        var ani_p = ani._private;
        var pEasing = ani_p.easing;
        var startTime = ani_p.startTime;
        var cy = isCore ? self : self.cy();
        var style = cy.style();

        if (!ani_p.easingImpl) {

          if (pEasing == null) {
            // use default
            ani_p.easingImpl = easings['linear'];
          } else {
            // then define w/ name
            var easingVals = void 0;

            if (is.string(pEasing)) {
              var easingProp = style.parse('transition-timing-function', pEasing);

              easingVals = easingProp.value;
            } else {
              // then assume preparsed array
              easingVals = pEasing;
            }

            var name = void 0,
                args = void 0;

            if (is.string(easingVals)) {
              name = easingVals;
              args = [];
            } else {
              name = easingVals[1];
              args = easingVals.slice(2).map(function (n) {
                return +n;
              });
            }

            if (args.length > 0) {
              // create with args
              if (name === 'spring') {
                args.push(ani_p.duration); // need duration to generate spring
              }

              ani_p.easingImpl = easings[name].apply(null, args);
            } else {
              // static impl by name
              ani_p.easingImpl = easings[name];
            }
          }
        }

        var easing = ani_p.easingImpl;
        var percent = void 0;

        if (ani_p.duration === 0) {
          percent = 1;
        } else {
          percent = (now - startTime) / ani_p.duration;
        }

        if (ani_p.applying) {
          percent = ani_p.progress;
        }

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (ani_p.delay == null) {
          // then update

          var startPos = ani_p.startPosition;
          var endPos = ani_p.position;

          if (endPos && isEles && !self.locked()) {
            var pos = self.position();

            if (valid(startPos.x, endPos.x)) {
              pos.x = ease(startPos.x, endPos.x, percent, easing);
            }

            if (valid(startPos.y, endPos.y)) {
              pos.y = ease(startPos.y, endPos.y, percent, easing);
            }

            self.emit('position');
          }

          var startPan = ani_p.startPan;
          var endPan = ani_p.pan;
          var pan = _p.pan;
          var animatingPan = endPan != null && isCore;
          if (animatingPan) {
            if (valid(startPan.x, endPan.x)) {
              pan.x = ease(startPan.x, endPan.x, percent, easing);
            }

            if (valid(startPan.y, endPan.y)) {
              pan.y = ease(startPan.y, endPan.y, percent, easing);
            }

            self.emit('pan');
          }

          var startZoom = ani_p.startZoom;
          var endZoom = ani_p.zoom;
          var animatingZoom = endZoom != null && isCore;
          if (animatingZoom) {
            if (valid(startZoom, endZoom)) {
              _p.zoom = ease(startZoom, endZoom, percent, easing);
            }

            self.emit('zoom');
          }

          if (animatingPan || animatingZoom) {
            self.emit('viewport');
          }

          var props = ani_p.style;
          if (props && props.length > 0 && isEles) {
            for (var i = 0; i < props.length; i++) {
              var prop = props[i];
              var _name = prop.name;
              var end = prop;
              var start = ani_p.startStyle[_name];
              var propSpec = style.properties[start.name];
              var easedVal = ease(start, end, percent, easing, propSpec);

              style.overrideBypass(self, _name, easedVal);
            } // for props

            self.emit('style');
          } // if
        }

        ani_p.progress = percent;

        return percent;
      }

      function valid(start, end) {
        if (start == null || end == null) {
          return false;
        }

        if (is.number(start) && is.number(end)) {
          return true;
        } else if (start && end) {
          return true;
        }

        return false;
      }

      module.exports = step;

      /***/
    },
    /* 74 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var generateCubicBezier = __webpack_require__(75);
      var generateSpringRK4 = __webpack_require__(76);

      var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
        var bezier = generateCubicBezier(t1, p1, t2, p2);

        return function (start, end, percent) {
          return start + (end - start) * bezier(percent);
        };
      };

      var easings = {
        'linear': function linear(start, end, percent) {
          return start + (end - start) * percent;
        },

        // default easings
        'ease': cubicBezier(0.25, 0.1, 0.25, 1),
        'ease-in': cubicBezier(0.42, 0, 1, 1),
        'ease-out': cubicBezier(0, 0, 0.58, 1),
        'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),

        // sine
        'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
        'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
        'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),

        // quad
        'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
        'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
        'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),

        // cubic
        'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
        'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
        'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),

        // quart
        'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
        'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
        'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),

        // quint
        'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
        'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
        'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),

        // expo
        'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
        'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
        'ease-in-out-expo': cubicBezier(1, 0, 0, 1),

        // circ
        'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
        'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
        'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),

        // user param easings...

        'spring': function spring(tension, friction, duration) {
          if (duration === 0) {
            // can't get a spring w/ duration 0
            return easings.linear; // duration 0 => jump to end so impl doesn't matter
          }

          var spring = generateSpringRK4(tension, friction, duration);

          return function (start, end, percent) {
            return start + (end - start) * spring(percent);
          };
        },

        'cubic-bezier': cubicBezier
      };

      module.exports = easings;

      /***/
    },
    /* 75 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /* global Float32Array */

      /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */

      function generateCubicBezier(mX1, mY1, mX2, mY2) {
        var NEWTON_ITERATIONS = 4,
            NEWTON_MIN_SLOPE = 0.001,
            SUBDIVISION_PRECISION = 0.0000001,
            SUBDIVISION_MAX_ITERATIONS = 10,
            kSplineTableSize = 11,
            kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
            float32ArraySupported = typeof Float32Array !== 'undefined';

        /* Must contain four arguments. */
        if (arguments.length !== 4) {
          return false;
        }

        /* Arguments must be numbers. */
        for (var i = 0; i < 4; ++i) {
          if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
            return false;
          }
        }

        /* X values must be in the [0, 1] range. */
        mX1 = Math.min(mX1, 1);
        mX2 = Math.min(mX2, 1);
        mX1 = Math.max(mX1, 0);
        mX2 = Math.max(mX2, 0);

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function A(aA1, aA2) {
          return 1.0 - 3.0 * aA2 + 3.0 * aA1;
        }

        function B(aA1, aA2) {
          return 3.0 * aA2 - 6.0 * aA1;
        }

        function C(aA1) {
          return 3.0 * aA1;
        }

        function calcBezier(aT, aA1, aA2) {
          return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        }

        function getSlope(aT, aA1, aA2) {
          return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }

        function newtonRaphsonIterate(aX, aGuessT) {
          for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);

            if (currentSlope === 0.0) {
              return aGuessT;
            }

            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }

          return aGuessT;
        }

        function calcSampleValues() {
          for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
            mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
          }
        }

        function binarySubdivide(aX, aA, aB) {
          var currentX = void 0,
              currentT = void 0,
              i = 0;

          do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

          return currentT;
        }

        function getTForX(aX) {
          var intervalStart = 0.0,
              currentSample = 1,
              lastSample = kSplineTableSize - 1;

          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }

          --currentSample;

          var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
              guessForT = intervalStart + dist * kSampleStepSize,
              initialSlope = getSlope(guessForT, mX1, mX2);

          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT);
          } else if (initialSlope === 0.0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
          }
        }

        var _precomputed = false;

        function precompute() {
          _precomputed = true;
          if (mX1 !== mY1 || mX2 !== mY2) {
            calcSampleValues();
          }
        }

        var f = function f(aX) {
          if (!_precomputed) {
            precompute();
          }
          if (mX1 === mY1 && mX2 === mY2) {
            return aX;
          }
          if (aX === 0) {
            return 0;
          }
          if (aX === 1) {
            return 1;
          }

          return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function () {
          return [{
            x: mX1,
            y: mY1
          }, {
            x: mX2,
            y: mY2
          }];
        };

        var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
        f.toString = function () {
          return str;
        };

        return f;
      }

      module.exports = generateCubicBezier;

      /***/
    },
    /* 76 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
      /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
         then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */

      var generateSpringRK4 = function () {
        function springAccelerationForState(state) {
          return -state.tension * state.x - state.friction * state.v;
        }

        function springEvaluateStateWithDerivative(initialState, dt, derivative) {
          var state = {
            x: initialState.x + derivative.dx * dt,
            v: initialState.v + derivative.dv * dt,
            tension: initialState.tension,
            friction: initialState.friction
          };

          return { dx: state.v, dv: springAccelerationForState(state) };
        }

        function springIntegrateState(state, dt) {
          var a = {
            dx: state.v,
            dv: springAccelerationForState(state)
          },
              b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
              c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
              d = springEvaluateStateWithDerivative(state, dt, c),
              dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
              dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

          state.x = state.x + dxdt * dt;
          state.v = state.v + dvdt * dt;

          return state;
        }

        return function springRK4Factory(tension, friction, duration) {

          var initState = {
            x: -1,
            v: 0,
            tension: null,
            friction: null
          },
              path = [0],
              time_lapsed = 0,
              tolerance = 1 / 10000,
              DT = 16 / 1000,
              have_duration = void 0,
              dt = void 0,
              last_state = void 0;

          tension = parseFloat(tension) || 500;
          friction = parseFloat(friction) || 20;
          duration = duration || null;

          initState.tension = tension;
          initState.friction = friction;

          have_duration = duration !== null;

          /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
          if (have_duration) {
            /* Run the simulation without a duration. */
            time_lapsed = springRK4Factory(tension, friction);
            /* Compute the adjusted time delta. */
            dt = time_lapsed / duration * DT;
          } else {
            dt = DT;
          }

          for (;;) {
            /* Next/step function .*/
            last_state = springIntegrateState(last_state || initState, dt);
            /* Store the position. */
            path.push(1 + last_state.x);
            time_lapsed += 16;
            /* If the change threshold is reached, break. */
            if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
              break;
            }
          }

          /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
             computed path and returns a snapshot of the position according to a given percentComplete. */
          return !have_duration ? time_lapsed : function (percentComplete) {
            return path[percentComplete * (path.length - 1) | 0];
          };
        };
      }();

      module.exports = generateSpringRK4;

      /***/
    },
    /* 77 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      function getEasedValue(type, start, end, percent, easingFn) {
        if (percent === 1) {
          return end;
        }

        var val = easingFn(start, end, percent);

        if (type == null) {
          return val;
        }

        if (type.roundValue || type.color) {
          val = Math.round(val);
        }

        if (type.min !== undefined) {
          val = Math.max(val, type.min);
        }

        if (type.max !== undefined) {
          val = Math.min(val, type.max);
        }

        return val;
      }

      function getValue(prop, spec) {
        if (prop.pfValue != null || prop.value != null) {
          if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
            return prop.pfValue;
          } else {
            return prop.value;
          }
        } else {
          return prop;
        }
      }

      function ease(startProp, endProp, percent, easingFn, propSpec) {
        var type = propSpec != null ? propSpec.type : null;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        var start = getValue(startProp, propSpec);
        var end = getValue(endProp, propSpec);

        if (is.number(start) && is.number(end)) {
          return getEasedValue(type, start, end, percent, easingFn);
        } else if (is.array(start) && is.array(end)) {
          var easedArr = [];

          for (var i = 0; i < end.length; i++) {
            var si = start[i];
            var ei = end[i];

            if (si != null && ei != null) {
              var val = getEasedValue(type, si, ei, percent, easingFn);

              easedArr.push(val);
            } else {
              easedArr.push(ei);
            }
          }

          return easedArr;
        }

        return undefined;
      }

      module.exports = ease;

      /***/
    },
    /* 78 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function startAnimation(self, ani, now, isCore) {
        var isEles = !isCore;
        var ele = self;
        var ani_p = ani._private;
        var cy = isCore ? self : self.cy();
        var style = cy.style();

        if (isEles) {
          var pos = ele.position();

          ani_p.startPosition = ani_p.startPosition || {
            x: pos.x,
            y: pos.y
          };

          ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle(ele, ani_p.style);
        }

        if (isCore) {
          var pan = cy._private.pan;

          ani_p.startPan = ani_p.startPan || {
            x: pan.x,
            y: pan.y
          };

          ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
        }

        ani_p.started = true;
        ani_p.startTime = now - ani_p.progress * ani_p.duration;
      }

      module.exports = startAnimation;

      /***/
    },
    /* 79 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Emitter = __webpack_require__(11);
      var define = __webpack_require__(4);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var emitterOptions = {
        qualifierCompare: function qualifierCompare(selector1, selector2) {
          if (selector1 == null || selector2 == null) {
            return selector1 == null && selector2 == null;
          } else {
            return selector1.sameText(selector2);
          }
        },
        eventMatches: function eventMatches(cy, listener, eventObj) {
          var selector = listener.qualifier;

          if (selector != null) {
            return cy !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
          }

          return true;
        },
        eventFields: function eventFields(cy) {
          return {
            cy: cy,
            target: cy
          };
        },
        callbackContext: function callbackContext(cy, listener, eventObj) {
          return listener.qualifier != null ? eventObj.target : cy;
        }
      };

      var argSelector = function argSelector(arg) {
        if (is.string(arg)) {
          return new Selector(arg);
        } else {
          return arg;
        }
      };

      var elesfn = {
        createEmitter: function createEmitter() {
          var _p = this._private;

          if (!_p.emitter) {
            _p.emitter = new Emitter(util.assign({
              context: this
            }, emitterOptions));
          }

          return this;
        },

        emitter: function emitter() {
          return this._private.emitter;
        },

        on: function on(events, selector, callback) {
          this.emitter().on(events, argSelector(selector), callback);

          return this;
        },

        removeListener: function removeListener(events, selector, callback) {
          this.emitter().removeListener(events, argSelector(selector), callback);

          return this;
        },

        one: function one(events, selector, callback) {
          this.emitter().one(events, argSelector(selector), callback);

          return this;
        },

        once: function once(events, selector, callback) {
          this.emitter().one(events, argSelector(selector), callback);

          return this;
        },

        emit: function emit(events, extraParams) {
          this.emitter().emit(events, extraParams);

          return this;
        }
      };

      define.eventAliasesOn(elesfn);

      module.exports = elesfn;

      /***/
    },
    /* 80 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var corefn = {

        png: function png(options) {
          var renderer = this._private.renderer;
          options = options || {};

          return renderer.png(options);
        },

        jpg: function jpg(options) {
          var renderer = this._private.renderer;
          options = options || {};

          options.bg = options.bg || '#fff';

          return renderer.jpg(options);
        }

      };

      corefn.jpeg = corefn.jpg;

      module.exports = corefn;

      /***/
    },
    /* 81 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var corefn = {

        layout: function layout(options) {
          var cy = this;

          if (options == null) {
            util.error('Layout options must be specified to make a layout');
            return;
          }

          if (options.name == null) {
            util.error('A `name` must be specified to make a layout');
            return;
          }

          var name = options.name;
          var Layout = cy.extension('layout', name);

          if (Layout == null) {
            util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
            return;
          }

          var eles = void 0;
          if (is.string(options.eles)) {
            eles = cy.$(options.eles);
          } else {
            eles = options.eles != null ? options.eles : cy.$();
          }

          var layout = new Layout(util.extend({}, options, {
            cy: cy,
            eles: eles
          }));

          return layout;
        }

      };

      corefn.createLayout = corefn.makeLayout = corefn.layout;

      module.exports = corefn;

      /***/
    },
    /* 82 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var corefn = {
        notify: function notify(params) {
          var _p = this._private;

          if (_p.batchingNotify) {
            var bEles = _p.batchNotifyEles;
            var bTypes = _p.batchNotifyTypes;

            if (params.eles) {
              bEles.merge(params.eles);
            }

            if (!bTypes.ids[params.type]) {
              bTypes.push(params.type);
              bTypes.ids[params.type] = true;
            }

            return; // notifications are disabled during batching
          }

          if (!_p.notificationsEnabled) {
            return;
          } // exit on disabled

          var renderer = this.renderer();

          // exit if destroy() called on core or renderer in between frames #1499 #1528
          if (this.isDestroyed() || !renderer) {
            return;
          }

          renderer.notify(params);
        },

        notifications: function notifications(bool) {
          var p = this._private;

          if (bool === undefined) {
            return p.notificationsEnabled;
          } else {
            p.notificationsEnabled = bool ? true : false;
          }
        },

        noNotifications: function noNotifications(callback) {
          this.notifications(false);
          callback();
          this.notifications(true);
        },

        batching: function batching() {
          return this._private.batchCount > 0;
        },

        startBatch: function startBatch() {
          var _p = this._private;

          if (_p.batchCount == null) {
            _p.batchCount = 0;
          }

          if (_p.batchCount === 0) {
            _p.batchingStyle = _p.batchingNotify = true;
            _p.batchStyleEles = this.collection();
            _p.batchNotifyEles = this.collection();
            _p.batchNotifyTypes = [];
            _p.batchNotifyTypes.ids = {};
          }

          _p.batchCount++;

          return this;
        },

        endBatch: function endBatch() {
          var _p = this._private;

          _p.batchCount--;

          if (_p.batchCount === 0) {
            // update style for dirty eles
            _p.batchingStyle = false;
            _p.batchStyleEles.updateStyle();

            // notify the renderer of queued eles and event types
            _p.batchingNotify = false;
            this.notify({
              type: _p.batchNotifyTypes,
              eles: _p.batchNotifyEles
            });
          }

          return this;
        },

        batch: function batch(callback) {
          this.startBatch();
          callback();
          this.endBatch();

          return this;
        },

        // for backwards compatibility
        batchData: function batchData(map) {
          var cy = this;

          return this.batch(function () {
            var ids = Object.keys(map);

            for (var i = 0; i < ids.length; i++) {
              var id = ids[i];
              var data = map[id];
              var ele = cy.getElementById(id);

              ele.data(data);
            }
          });
        }
      };

      module.exports = corefn;

      /***/
    },
    /* 83 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var corefn = {

        renderTo: function renderTo(context, zoom, pan, pxRatio) {
          var r = this._private.renderer;

          r.renderTo(context, zoom, pan, pxRatio);
          return this;
        },

        renderer: function renderer() {
          return this._private.renderer;
        },

        forceRender: function forceRender() {
          this.notify({
            type: 'draw'
          });

          return this;
        },

        resize: function resize() {
          this.invalidateSize();

          this.notify({
            type: 'resize'
          });

          this.emit('resize');

          return this;
        },

        initRenderer: function initRenderer(options) {
          var cy = this;

          var RendererProto = cy.extension('renderer', options.name);
          if (RendererProto == null) {
            util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
            return;
          }

          cy._private.renderer = new RendererProto(util.extend({}, options, { cy: cy }));

          this.notify({ type: 'init' });
        },

        destroyRenderer: function destroyRenderer() {
          var cy = this;

          cy.notify({ type: 'destroy' }); // destroy the renderer

          var domEle = cy.container();
          if (domEle) {
            domEle._cyreg = null;

            while (domEle.childNodes.length > 0) {
              domEle.removeChild(domEle.childNodes[0]);
            }
          }

          cy._private.renderer = null; // to be extra safe, remove the ref
        },

        onRender: function onRender(fn) {
          return this.on('render', fn);
        },

        offRender: function offRender(fn) {
          return this.off('render', fn);
        }

      };

      corefn.invalidateDimensions = corefn.resize;

      module.exports = corefn;

      /***/
    },
    /* 84 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Collection = __webpack_require__(7);

      var corefn = {

        // get a collection
        // - empty collection on no args
        // - collection of elements in the graph on selector arg
        // - guarantee a returned collection when elements or collection specified
        collection: function collection(eles, opts) {

          if (is.string(eles)) {
            return this.$(eles);
          } else if (is.elementOrCollection(eles)) {
            return eles.collection();
          } else if (is.array(eles)) {
            return new Collection(this, eles, opts);
          }

          return new Collection(this);
        },

        nodes: function nodes(selector) {
          var nodes = this.$(function (ele) {
            return ele.isNode();
          });

          if (selector) {
            return nodes.filter(selector);
          }

          return nodes;
        },

        edges: function edges(selector) {
          var edges = this.$(function (ele) {
            return ele.isEdge();
          });

          if (selector) {
            return edges.filter(selector);
          }

          return edges;
        },

        // search the graph like jQuery
        $: function $(selector) {
          var eles = this._private.elements;

          if (selector) {
            return eles.filter(selector);
          } else {
            return eles.spawnSelf();
          }
        },

        mutableElements: function mutableElements() {
          return this._private.elements;
        }

      };

      // aliases
      corefn.elements = corefn.filter = corefn.$;

      module.exports = corefn;

      /***/
    },
    /* 85 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var Style = __webpack_require__(18);

      var corefn = {

        style: function style(newStyle) {
          if (newStyle) {
            var s = this.setStyle(newStyle);

            s.update();
          }

          return this._private.style;
        },

        setStyle: function setStyle(style) {
          var _p = this._private;

          if (is.stylesheet(style)) {
            _p.style = style.generateStyle(this);
          } else if (is.array(style)) {
            _p.style = Style.fromJson(this, style);
          } else if (is.string(style)) {
            _p.style = Style.fromString(this, style);
          } else {
            _p.style = Style(this);
          }

          return _p.style;
        }
      };

      module.exports = corefn;

      /***/
    },
    /* 86 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);

      var styfn = {};

      // (potentially expensive calculation)
      // apply the style to the element based on
      // - its bypass
      // - what selectors match it
      styfn.apply = function (eles) {
        var self = this;
        var _p = self._private;
        var cy = _p.cy;
        var updatedEles = cy.collection();

        if (_p.newStyle) {
          // clear style caches
          _p.contextStyles = {};
          _p.propDiffs = {};

          self.cleanElements(eles, true);
        }

        for (var ie = 0; ie < eles.length; ie++) {
          var ele = eles[ie];

          var cxtMeta = self.getContextMeta(ele);

          if (cxtMeta.empty) {
            continue;
          } else {
            updatedEles.merge(ele);
          }

          var cxtStyle = self.getContextStyle(cxtMeta);
          var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

          if (!_p.newStyle) {
            self.updateTransitions(ele, app.diffProps);
          }

          self.updateStyleHints(ele);
        } // for elements

        _p.newStyle = false;

        return updatedEles;
      };

      styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
        var self = this;
        var cache = self._private.propDiffs = self._private.propDiffs || {};
        var dualCxtKey = oldCxtKey + '-' + newCxtKey;
        var cachedVal = cache[dualCxtKey];

        if (cachedVal) {
          return cachedVal;
        }

        var diffProps = [];
        var addedProp = {};

        for (var i = 0; i < self.length; i++) {
          var cxt = self[i];
          var oldHasCxt = oldCxtKey[i] === 't';
          var newHasCxt = newCxtKey[i] === 't';
          var cxtHasDiffed = oldHasCxt !== newHasCxt;
          var cxtHasMappedProps = cxt.mappedProperties.length > 0;

          if (cxtHasDiffed || cxtHasMappedProps) {
            var props = void 0;

            if (cxtHasDiffed && cxtHasMappedProps) {
              props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
            } else if (cxtHasDiffed) {
              props = cxt.properties; // need to check them all
            } else if (cxtHasMappedProps) {
              props = cxt.mappedProperties; // only need to check mapped
            }

            for (var j = 0; j < props.length; j++) {
              var prop = props[j];
              var name = prop.name;

              // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
              // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
              // is cached)
              var laterCxtOverrides = false;
              for (var k = i + 1; k < self.length; k++) {
                var laterCxt = self[k];
                var hasLaterCxt = newCxtKey[k] === 't';

                if (!hasLaterCxt) {
                  continue;
                } // can't override unless the context is active

                laterCxtOverrides = laterCxt.properties[prop.name] != null;

                if (laterCxtOverrides) {
                  break;
                } // exit early as long as one later context overrides
              }

              if (!addedProp[name] && !laterCxtOverrides) {
                addedProp[name] = true;
                diffProps.push(name);
              }
            } // for props
          } // if
        } // for contexts

        cache[dualCxtKey] = diffProps;
        return diffProps;
      };

      styfn.getContextMeta = function (ele) {
        var self = this;
        var cxtKey = '';
        var diffProps = void 0;
        var prevKey = ele._private.styleCxtKey || '';

        if (self._private.newStyle) {
          prevKey = ''; // since we need to apply all style if a fresh stylesheet
        }

        // get the cxt key
        for (var i = 0; i < self.length; i++) {
          var context = self[i];
          var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

          if (contextSelectorMatches) {
            cxtKey += 't';
          } else {
            cxtKey += 'f';
          }
        } // for context

        diffProps = self.getPropertiesDiff(prevKey, cxtKey);

        ele._private.styleCxtKey = cxtKey;

        return {
          key: cxtKey,
          diffPropNames: diffProps,
          empty: diffProps.length === 0
        };
      };

      // gets a computed ele style object based on matched contexts
      styfn.getContextStyle = function (cxtMeta) {
        var cxtKey = cxtMeta.key;
        var self = this;
        var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

        // if already computed style, returned cached copy
        if (cxtStyles[cxtKey]) {
          return cxtStyles[cxtKey];
        }

        var style = {
          _private: {
            key: cxtKey
          }
        };

        for (var i = 0; i < self.length; i++) {
          var cxt = self[i];
          var hasCxt = cxtKey[i] === 't';

          if (!hasCxt) {
            continue;
          }

          for (var j = 0; j < cxt.properties.length; j++) {
            var prop = cxt.properties[j];

            style[prop.name] = prop;
          }
        }

        cxtStyles[cxtKey] = style;
        return style;
      };

      styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
        var self = this;
        var diffProps = cxtMeta.diffPropNames;
        var retDiffProps = {};

        for (var i = 0; i < diffProps.length; i++) {
          var diffPropName = diffProps[i];
          var cxtProp = cxtStyle[diffPropName];
          var eleProp = ele.pstyle(diffPropName);

          if (!cxtProp) {
            // no context prop means delete
            if (!eleProp) {
              continue; // no existing prop means nothing needs to be removed
              // nb affects initial application on mapped values like control-point-distances
            } else if (eleProp.bypass) {
              cxtProp = { name: diffPropName, deleteBypassed: true };
            } else {
              cxtProp = { name: diffPropName, delete: true };
            }
          }

          // save cycles when the context prop doesn't need to be applied
          if (eleProp === cxtProp) {
            continue;
          }

          var retDiffProp = retDiffProps[diffPropName] = {
            prev: eleProp
          };

          self.applyParsedProperty(ele, cxtProp);

          retDiffProp.next = ele.pstyle(diffPropName);

          if (retDiffProp.next && retDiffProp.next.bypass) {
            retDiffProp.next = retDiffProp.next.bypassed;
          }
        }

        return {
          diffProps: retDiffProps
        };
      };

      styfn.updateStyleHints = function (ele) {
        var _p = ele._private;
        var self = this;

        if (ele.removed()) {
          return;
        }

        // set whether has pie or not; for greater efficiency
        var hasPie = false;
        if (_p.group === 'nodes') {
          for (var i = 1; i <= self.pieBackgroundN; i++) {
            // 1..N
            var _size = ele.pstyle('pie-' + i + '-background-size').value;

            if (_size > 0) {
              hasPie = true;
              break;
            }
          }
        }

        _p.hasPie = hasPie;

        var transform = ele.pstyle('text-transform').strValue;
        var content = ele.pstyle('label').strValue;
        var srcContent = ele.pstyle('source-label').strValue;
        var tgtContent = ele.pstyle('target-label').strValue;
        var fStyle = ele.pstyle('font-style').strValue;
        var size = ele.pstyle('font-size').pfValue + 'px';
        var family = ele.pstyle('font-family').strValue;
        // let letiant = style['font-letiant'].strValue;
        var weight = ele.pstyle('font-weight').strValue;
        var valign = ele.pstyle('text-valign').strValue;
        var halign = ele.pstyle('text-valign').strValue;
        var oWidth = ele.pstyle('text-outline-width').pfValue;
        var wrap = ele.pstyle('text-wrap').strValue;
        var wrapW = ele.pstyle('text-max-width').pfValue;
        var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
        _p.labelStyleKey = labelStyleKey;
        _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
        _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
        _p.labelKey = labelStyleKey + '$' + content;
        _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

        _p.styleKey = Date.now();
      };

      // apply a property to the style (for internal use)
      // returns whether application was successful
      //
      // now, this function flattens the property, and here's how:
      //
      // for parsedProp:{ bypass: true, deleteBypass: true }
      // no property is generated, instead the bypass property in the
      // element's style is replaced by what's pointed to by the `bypassed`
      // field in the bypass property (i.e. restoring the property the
      // bypass was overriding)
      //
      // for parsedProp:{ mapped: truthy }
      // the generated flattenedProp:{ mapping: prop }
      //
      // for parsedProp:{ bypass: true }
      // the generated flattenedProp:{ bypassed: parsedProp }
      styfn.applyParsedProperty = function (ele, parsedProp) {
        var self = this;
        var prop = parsedProp;
        var style = ele._private.style;
        var fieldVal = void 0,
            flatProp = void 0;
        var types = self.types;
        var type = self.properties[prop.name].type;
        var propIsBypass = prop.bypass;
        var origProp = style[prop.name];
        var origPropIsBypass = origProp && origProp.bypass;
        var _p = ele._private;
        var flatPropMapping = 'mapping';

        var checkZOrder = function checkZOrder() {
          self.checkZOrderTrigger(ele, prop.name, origProp ? origProp.value : null, prop.value);
        };

        // edges connected to compound nodes can not be haystacks
        if (parsedProp.name === 'curve-style' && parsedProp.value === 'haystack' && ele.isEdge() && (ele.isLoop() || ele.source().isParent() || ele.target().isParent())) {
          prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
        }

        if (prop.delete) {
          // delete the property and use the default value on falsey value
          style[prop.name] = undefined;

          checkZOrder();

          return true;
        }

        if (prop.deleteBypassed) {
          // delete the property that the
          if (!origProp) {
            checkZOrder();

            return true; // can't delete if no prop
          } else if (origProp.bypass) {
            // delete bypassed
            origProp.bypassed = undefined;

            checkZOrder();

            return true;
          } else {
            return false; // we're unsuccessful deleting the bypassed
          }
        }

        // check if we need to delete the current bypass
        if (prop.deleteBypass) {
          // then this property is just here to indicate we need to delete
          if (!origProp) {
            checkZOrder();

            return true; // property is already not defined
          } else if (origProp.bypass) {
            // then replace the bypass property with the original
            // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
            style[prop.name] = origProp.bypassed;

            checkZOrder();

            return true;
          } else {
            return false; // we're unsuccessful deleting the bypass
          }
        }

        var printMappingErr = function printMappingErr() {
          util.error('Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
        };

        // put the property in the style objects
        switch (prop.mapped) {// flatten the property if mapped
          case types.mapData:
            {
              // flatten the field (e.g. data.foo.bar)
              var fields = prop.field.split('.');
              var _fieldVal = _p.data;

              for (var i = 0; i < fields.length && _fieldVal; i++) {
                var field = fields[i];
                _fieldVal = _fieldVal[field];
              }

              var percent = void 0;
              if (!is.number(_fieldVal)) {
                // then keep the mapping but assume 0% for now
                percent = 0;
              } else {
                percent = (_fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
              }

              // make sure to bound percent value
              if (percent < 0) {
                percent = 0;
              } else if (percent > 1) {
                percent = 1;
              }

              if (type.color) {
                var r1 = prop.valueMin[0];
                var r2 = prop.valueMax[0];
                var g1 = prop.valueMin[1];
                var g2 = prop.valueMax[1];
                var b1 = prop.valueMin[2];
                var b2 = prop.valueMax[2];
                var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
                var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

                var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];

                flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
                  bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
                  name: prop.name,
                  value: clr,
                  strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
                };
              } else if (type.number) {
                var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
                flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
              } else {
                return false; // can only map to colours and numbers
              }

              if (!flatProp) {
                // if we can't flatten the property, then use the origProp so we still keep the mapping itself
                flatProp = this.parse(prop.name, origProp.strValue, prop.bypass, flatPropMapping);
              }

              if (!flatProp) {
                printMappingErr();
              }
              flatProp.mapping = prop; // keep a reference to the mapping
              prop = flatProp; // the flattened (mapped) property is the one we want

              break;
            }

          // direct mapping
          case types.data:
            {
              // flatten the field (e.g. data.foo.bar)
              var _fields = prop.field.split('.');
              var _fieldVal2 = _p.data;

              if (_fieldVal2) {
                for (var _i = 0; _i < _fields.length; _i++) {
                  var _field = _fields[_i];
                  _fieldVal2 = _fieldVal2[_field];
                }
              }

              flatProp = this.parse(prop.name, _fieldVal2, prop.bypass, flatPropMapping);

              if (!flatProp) {
                // if we can't flatten the property, then use the origProp so we still keep the mapping itself
                var flatPropVal = origProp ? origProp.strValue : '';

                flatProp = this.parse(prop.name, flatPropVal, prop.bypass, flatPropMapping);
              }

              if (!flatProp) {
                printMappingErr();
              }
              flatProp.mapping = prop; // keep a reference to the mapping
              prop = flatProp; // the flattened (mapped) property is the one we want

              break;
            }

          case types.fn:
            {
              var fn = prop.value;
              var fnRetVal = fn(ele);

              flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);
              flatProp.mapping = prop; // keep a reference to the mapping
              prop = flatProp; // the flattened (mapped) property is the one we want

              break;
            }

          case undefined:
            break; // just set the property

          default:
            return false; // not a valid mapping
        }

        // if the property is a bypass property, then link the resultant property to the original one
        if (propIsBypass) {
          if (origPropIsBypass) {
            // then this bypass overrides the existing one
            prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
          } else {
            // then link the orig prop to the new bypass
            prop.bypassed = origProp;
          }

          style[prop.name] = prop; // and set
        } else {
          // prop is not bypass
          if (origPropIsBypass) {
            // then keep the orig prop (since it's a bypass) and link to the new prop
            origProp.bypassed = prop;
          } else {
            // then just replace the old prop with the new one
            style[prop.name] = prop;
          }
        }

        checkZOrder();

        return true;
      };

      styfn.cleanElements = function (eles, keepBypasses) {
        var self = this;
        var props = self.properties;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (!keepBypasses) {
            ele._private.style = {};
          } else {
            var style = ele._private.style;

            for (var j = 0; j < props.length; j++) {
              var prop = props[j];
              var eleProp = style[prop.name];

              if (eleProp) {
                if (eleProp.bypass) {
                  eleProp.bypassed = null;
                } else {
                  style[prop.name] = null;
                }
              }
            }
          }
        }
      };

      // updates the visual style for all elements (useful for manual style modification after init)
      styfn.update = function () {
        var cy = this._private.cy;
        var eles = cy.mutableElements();

        eles.updateStyle();
      };

      // just update the functional properties (i.e. mappings) in the elements'
      // styles (less expensive than recalculation)
      styfn.updateMappers = function (eles) {
        var self = this;
        var cy = this._private.cy;
        var updatedEles = cy.collection();

        for (var i = 0; i < eles.length; i++) {
          // for each ele
          var ele = eles[i];
          var style = ele._private.style;
          var updatedEle = false;

          for (var j = 0; j < self.properties.length; j++) {
            // for each prop
            var prop = self.properties[j];
            var propInStyle = style[prop.name];

            if (propInStyle && propInStyle.mapping) {
              var mapping = propInStyle.mapping;

              this.applyParsedProperty(ele, mapping); // reapply the mapping property

              updatedEle = true;
            }
          }

          if (updatedEle) {
            this.updateStyleHints(ele);

            updatedEles.merge(ele);
          }
        }

        return updatedEles;
      };

      // diffProps : { name => { prev, next } }
      styfn.updateTransitions = function (ele, diffProps, isBypass) {
        var self = this;
        var _p = ele._private;
        var props = ele.pstyle('transition-property').value;
        var duration = ele.pstyle('transition-duration').pfValue;
        var delay = ele.pstyle('transition-delay').pfValue;

        if (props.length > 0 && duration > 0) {

          var style = {};

          // build up the style to animate towards
          var anyPrev = false;
          for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            var styProp = ele.pstyle(prop);
            var diffProp = diffProps[prop];

            if (!diffProp) {
              continue;
            }

            var prevProp = diffProp.prev;
            var fromProp = prevProp;
            var toProp = diffProp.next != null ? diffProp.next : styProp;
            var diff = false;
            var initVal = void 0;
            var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

            if (!fromProp) {
              continue;
            }

            // consider px values
            if (is.number(fromProp.pfValue) && is.number(toProp.pfValue)) {
              diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
              initVal = fromProp.pfValue + initDt * diff;

              // consider numerical values
            } else if (is.number(fromProp.value) && is.number(toProp.value)) {
              diff = toProp.value - fromProp.value; // nonzero is truthy
              initVal = fromProp.value + initDt * diff;

              // consider colour values
            } else if (is.array(fromProp.value) && is.array(toProp.value)) {
              diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];

              initVal = fromProp.strValue;
            }

            // the previous value is good for an animation only if it's different
            if (diff) {
              style[prop] = toProp.strValue; // to val
              this.applyBypass(ele, prop, initVal); // from val
              anyPrev = true;
            }
          } // end if props allow ani

          // can't transition if there's nothing previous to transition from
          if (!anyPrev) {
            return;
          }

          _p.transitioning = true;

          new Promise(function (resolve) {
            if (delay > 0) {
              ele.delayAnimation(delay).play().promise().then(resolve);
            } else {
              resolve();
            }
          }).then(function () {
            return ele.animation({
              style: style,
              duration: duration,
              easing: ele.pstyle('transition-timing-function').value,
              queue: false
            }).play().promise();
          }).then(function () {
            // if( !isBypass ){
            self.removeBypasses(ele, props);
            ele.emitAndNotify('style');
            // }

            _p.transitioning = false;
          });
        } else if (_p.transitioning) {
          this.removeBypasses(ele, props);
          ele.emitAndNotify('style');

          _p.transitioning = false;
        }
      };

      styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
        var prop = this.properties[name];

        if (prop.triggersZOrder != null && (fromValue == null || prop.triggersZOrder(fromValue, toValue))) {
          this._private.cy.notify({
            type: 'zorder',
            eles: ele
          });
        }
      };

      module.exports = styfn;

      /***/
    },
    /* 87 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var styfn = {};

      // bypasses are applied to an existing style on an element, and just tacked on temporarily
      // returns true iff application was successful for at least 1 specified property
      styfn.applyBypass = function (eles, name, value, updateTransitions) {
        var self = this;
        var props = [];
        var isBypass = true;

        // put all the properties (can specify one or many) in an array after parsing them
        if (name === '*' || name === '**') {
          // apply to all property names

          if (value !== undefined) {
            for (var i = 0; i < self.properties.length; i++) {
              var prop = self.properties[i];
              var _name = prop.name;

              var parsedProp = this.parse(_name, value, true);

              if (parsedProp) {
                props.push(parsedProp);
              }
            }
          }
        } else if (is.string(name)) {
          // then parse the single property
          var _parsedProp = this.parse(name, value, true);

          if (_parsedProp) {
            props.push(_parsedProp);
          }
        } else if (is.plainObject(name)) {
          // then parse each property
          var specifiedProps = name;
          updateTransitions = value;

          var names = Object.keys(specifiedProps);

          for (var _i = 0; _i < names.length; _i++) {
            var _name2 = names[_i];
            var _prop = self.properties[_name2];
            var _value = specifiedProps[_name2];

            if (_value === undefined) {
              // try camel case name too
              _value = specifiedProps[util.dash2camel(_name2)];
            }

            if (_value !== undefined) {
              var _parsedProp2 = this.parse(_name2, _value, true);

              if (_parsedProp2) {
                props.push(_parsedProp2);
              }
            }
          }
        } else {
          // can't do anything without well defined properties
          return false;
        }

        // we've failed if there are no valid properties
        if (props.length === 0) {
          return false;
        }

        // now, apply the bypass properties on the elements
        var ret = false; // return true if at least one succesful bypass applied
        for (var _i2 = 0; _i2 < eles.length; _i2++) {
          // for each ele
          var ele = eles[_i2];
          var diffProps = {};
          var diffProp = void 0;

          for (var j = 0; j < props.length; j++) {
            // for each prop
            var _prop2 = props[j];

            if (updateTransitions) {
              var prevProp = ele.pstyle(_prop2.name);
              diffProp = diffProps[_prop2.name] = { prev: prevProp };
            }

            ret = this.applyParsedProperty(ele, _prop2) || ret;

            if (updateTransitions) {
              diffProp.next = ele.pstyle(_prop2.name);
            }
          } // for props

          if (ret) {
            this.updateStyleHints(ele);
          }

          if (updateTransitions) {
            this.updateTransitions(ele, diffProps, isBypass);
          }
        } // for eles

        return ret;
      };

      // only useful in specific cases like animation
      styfn.overrideBypass = function (eles, name, value) {
        name = util.camel2dash(name);

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var prop = ele._private.style[name];
          var type = this.properties[name].type;
          var isColor = type.color;
          var isMulti = type.mutiple;

          if (!prop || !prop.bypass) {
            // need a bypass if one doesn't exist
            this.applyBypass(ele, name, value);
            continue;
          }

          var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

          prop.value = value;

          if (prop.pfValue != null) {
            prop.pfValue = value;
          }

          if (isColor) {
            prop.strValue = 'rgb(' + value.join(',') + ')';
          } else if (isMulti) {
            prop.strValue = value.join(' ');
          } else {
            prop.strValue = '' + value;
          }

          this.checkZOrderTrigger(ele, name, oldValue, value);
        }
      };

      styfn.removeAllBypasses = function (eles, updateTransitions) {
        return this.removeBypasses(eles, this.propertyNames, updateTransitions);
      };

      styfn.removeBypasses = function (eles, props, updateTransitions) {
        var isBypass = true;

        for (var j = 0; j < eles.length; j++) {
          var ele = eles[j];
          var diffProps = {};

          for (var i = 0; i < props.length; i++) {
            var name = props[i];
            var prop = this.properties[name];
            var prevProp = ele.pstyle(prop.name);

            if (!prevProp || !prevProp.bypass) {
              // if a bypass doesn't exist for the prop, nothing needs to be removed
              continue;
            }

            var value = ''; // empty => remove bypass
            var parsedProp = this.parse(name, value, true);
            var diffProp = diffProps[prop.name] = { prev: prevProp };

            this.applyParsedProperty(ele, parsedProp);

            diffProp.next = ele.pstyle(prop.name);
          } // for props

          this.updateStyleHints(ele);

          if (updateTransitions) {
            this.updateTransitions(ele, diffProps, isBypass);
          }
        } // for eles
      };

      module.exports = styfn;

      /***/
    },
    /* 88 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);

      var styfn = {};

      // gets what an em size corresponds to in pixels relative to a dom element
      styfn.getEmSizeInPixels = function () {
        var px = this.containerCss('font-size');

        if (px != null) {
          return parseFloat(px);
        } else {
          return 1; // for headless
        }
      };

      // gets css property from the core container
      styfn.containerCss = function (propName) {
        var cy = this._private.cy;
        var domElement = cy.container();

        if (window && domElement && window.getComputedStyle) {
          return window.getComputedStyle(domElement).getPropertyValue(propName);
        }
      };

      module.exports = styfn;

      /***/
    },
    /* 89 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var styfn = {};

      // gets the rendered style for an element
      styfn.getRenderedStyle = function (ele, prop) {
        if (prop) {
          return this.getStylePropertyValue(ele, prop, true);
        } else {
          return this.getRawStyle(ele, true);
        }
      };

      // gets the raw style for an element
      styfn.getRawStyle = function (ele, isRenderedVal) {
        var self = this;

        ele = ele[0]; // insure it's an element

        if (ele) {
          var rstyle = {};

          for (var i = 0; i < self.properties.length; i++) {
            var prop = self.properties[i];
            var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

            if (val != null) {
              rstyle[prop.name] = val;
              rstyle[util.dash2camel(prop.name)] = val;
            }
          }

          return rstyle;
        }
      };

      styfn.getIndexedStyle = function (ele, property, subproperty, index) {
        var pstyle = ele.pstyle(property)[subproperty][index];
        return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
      };

      styfn.getStylePropertyValue = function (ele, propName, isRenderedVal) {
        var self = this;

        ele = ele[0]; // insure it's an element

        if (ele) {
          var prop = self.properties[propName];

          if (prop.alias) {
            prop = prop.pointsTo;
          }

          var type = prop.type;
          var styleProp = ele.pstyle(prop.name);
          var zoom = ele.cy().zoom();

          if (styleProp) {
            var units = styleProp.units ? type.implicitUnits || 'px' : null;
            var val = units ? [].concat(styleProp.pfValue).map(function (pfValue) {
              return pfValue * (isRenderedVal ? zoom : 1) + units;
            }).join(' ') : styleProp.strValue;

            return val;
          }
        }
      };

      styfn.getAnimationStartStyle = function (ele, aniProps) {
        var rstyle = {};

        for (var i = 0; i < aniProps.length; i++) {
          var aniProp = aniProps[i];
          var name = aniProp.name;

          var styleProp = ele.pstyle(name);

          if (styleProp !== undefined) {
            // then make a prop of it
            if (is.plainObject(styleProp)) {
              styleProp = this.parse(name, styleProp.strValue);
            } else {
              styleProp = this.parse(name, styleProp);
            }
          }

          if (styleProp) {
            rstyle[name] = styleProp;
          }
        }

        return rstyle;
      };

      styfn.getPropsList = function (propsObj) {
        var self = this;
        var rstyle = [];
        var style = propsObj;
        var props = self.properties;

        if (style) {
          var names = Object.keys(style);

          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            var val = style[name];
            var prop = props[name] || props[util.camel2dash(name)];
            var styleProp = this.parse(prop.name, val);

            if (styleProp) {
              rstyle.push(styleProp);
            }
          }
        }

        return rstyle;
      };

      module.exports = styfn;

      /***/
    },
    /* 90 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var styfn = {};

      styfn.appendFromJson = function (json) {
        var style = this;

        for (var i = 0; i < json.length; i++) {
          var context = json[i];
          var selector = context.selector;
          var props = context.style || context.css;
          var names = Object.keys(props);

          style.selector(selector); // apply selector

          for (var j = 0; j < names.length; j++) {
            var name = names[j];
            var value = props[name];

            style.css(name, value); // apply property
          }
        }

        return style;
      };

      // accessible cy.style() function
      styfn.fromJson = function (json) {
        var style = this;

        style.resetToDefault();
        style.appendFromJson(json);

        return style;
      };

      // get json from cy.style() api
      styfn.json = function () {
        var json = [];

        for (var i = this.defaultLength; i < this.length; i++) {
          var cxt = this[i];
          var selector = cxt.selector;
          var props = cxt.properties;
          var css = {};

          for (var j = 0; j < props.length; j++) {
            var prop = props[j];
            css[prop.name] = prop.strValue;
          }

          json.push({
            selector: !selector ? 'core' : selector.toString(),
            style: css
          });
        }

        return json;
      };

      module.exports = styfn;

      /***/
    },
    /* 91 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var Selector = __webpack_require__(6);

      var styfn = {};

      styfn.appendFromString = function (string) {
        var self = this;
        var style = this;
        var remaining = '' + string;
        var selAndBlockStr = void 0;
        var blockRem = void 0;
        var propAndValStr = void 0;

        // remove comments from the style string
        remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

        function removeSelAndBlockFromRemaining() {
          // remove the parsed selector and block from the remaining text to parse
          if (remaining.length > selAndBlockStr.length) {
            remaining = remaining.substr(selAndBlockStr.length);
          } else {
            remaining = '';
          }
        }

        function removePropAndValFromRem() {
          // remove the parsed property and value from the remaining block text to parse
          if (blockRem.length > propAndValStr.length) {
            blockRem = blockRem.substr(propAndValStr.length);
          } else {
            blockRem = '';
          }
        }

        while (true) {
          var nothingLeftToParse = remaining.match(/^\s*$/);
          if (nothingLeftToParse) {
            break;
          }

          var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

          if (!selAndBlock) {
            util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
            break;
          }

          selAndBlockStr = selAndBlock[0];

          // parse the selector
          var selectorStr = selAndBlock[1];
          if (selectorStr !== 'core') {
            var selector = new Selector(selectorStr);
            if (selector._private.invalid) {
              util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

              // skip this selector and block
              removeSelAndBlockFromRemaining();
              continue;
            }
          }

          // parse the block of properties and values
          var blockStr = selAndBlock[2];
          var invalidBlock = false;
          blockRem = blockStr;
          var props = [];

          while (true) {
            var _nothingLeftToParse = blockRem.match(/^\s*$/);
            if (_nothingLeftToParse) {
              break;
            }

            var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

            if (!propAndVal) {
              util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
              invalidBlock = true;
              break;
            }

            propAndValStr = propAndVal[0];
            var propStr = propAndVal[1];
            var valStr = propAndVal[2];

            var prop = self.properties[propStr];
            if (!prop) {
              util.error('Skipping property: Invalid property name in: ' + propAndValStr);

              // skip this property in the block
              removePropAndValFromRem();
              continue;
            }

            var parsedProp = style.parse(propStr, valStr);

            if (!parsedProp) {
              util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

              // skip this property in the block
              removePropAndValFromRem();
              continue;
            }

            props.push({
              name: propStr,
              val: valStr
            });
            removePropAndValFromRem();
          }

          if (invalidBlock) {
            removeSelAndBlockFromRemaining();
            break;
          }

          // put the parsed block in the style
          style.selector(selectorStr);
          for (var i = 0; i < props.length; i++) {
            var _prop = props[i];
            style.css(_prop.name, _prop.val);
          }

          removeSelAndBlockFromRemaining();
        }

        return style;
      };

      styfn.fromString = function (string) {
        var style = this;

        style.resetToDefault();
        style.appendFromString(string);

        return style;
      };

      module.exports = styfn;

      /***/
    },
    /* 92 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var styfn = {};

      (function () {
        var number = util.regex.number;
        var rgba = util.regex.rgbaNoBackRefs;
        var hsla = util.regex.hslaNoBackRefs;
        var hex3 = util.regex.hex3;
        var hex6 = util.regex.hex6;
        var data = function data(prefix) {
          return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
        };
        var mapData = function mapData(prefix) {
          var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
          return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
        };
        var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$'];

        // each visual style property has a type and needs to be validated according to it
        styfn.types = {
          time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
          percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
          zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
          zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },
          nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
          nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
          position: { enums: ['parent', 'origin'] },
          nodeSize: { number: true, min: 0, enums: ['label'] },
          number: { number: true, unitless: true },
          numbers: { number: true, unitless: true, multiple: true },
          positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
          size: { number: true, min: 0 },
          bidirectionalSize: { number: true }, // allows negative
          bidirectionalSizes: { number: true, multiple: true }, // allows negative
          sizeMaybePercent: { number: true, min: 0, allowPercent: true },
          paddingRelativeTo: { enums: ['width', 'height', 'average', 'min', 'max'] },
          bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'], multiple: true },
          bgPos: { number: true, allowPercent: true, multiple: true },
          bgRelativeTo: { enums: ['inner', 'include-padding'], multiple: true },
          bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'], multiple: true },
          bgFit: { enums: ['none', 'contain', 'cover'], multiple: true },
          bgCrossOrigin: { enums: ['anonymous', 'use-credentials'], multiple: true },
          bgClip: { enums: ['none', 'node'] },
          color: { color: true },
          bool: { enums: ['yes', 'no'] },
          lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
          borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
          curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
          fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
          fontletiant: { enums: ['small-caps', 'normal'] },
          fontStyle: { enums: ['italic', 'normal', 'oblique'] },
          fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
          textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
          textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
          textWrap: { enums: ['none', 'wrap', 'ellipsis'] },
          textBackgroundShape: { enums: ['rectangle', 'roundrectangle'] },
          nodeShape: { enums: ['rectangle', 'roundrectangle', 'cutrectangle', 'bottomroundrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'concavehexagon', 'heptagon', 'octagon', 'tag', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
          compoundIncludeLabels: { enums: ['include', 'exclude'] },
          arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
          arrowFill: { enums: ['filled', 'hollow'] },
          display: { enums: ['element', 'none'] },
          visibility: { enums: ['hidden', 'visible'] },
          zCompoundDepth: { enums: ['bottom', 'orphan', 'auto', 'top'] },
          zIndexCompare: { enums: ['auto', 'manual'] },
          valign: { enums: ['top', 'center', 'bottom'] },
          halign: { enums: ['left', 'center', 'right'] },
          text: { string: true },
          data: { mapping: true, regex: data('data') },
          layoutData: { mapping: true, regex: data('layoutData') },
          scratch: { mapping: true, regex: data('scratch') },
          mapData: { mapping: true, regex: mapData('mapData') },
          mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
          mapScratch: { mapping: true, regex: mapData('mapScratch') },
          fn: { mapping: true, fn: true },
          url: { regexes: urlRegexes, singleRegexMatchValue: true },
          urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },
          propList: { propList: true },
          angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
          textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: ['none', 'autorotate'] },
          polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
          edgeDistances: { enums: ['intersection', 'node-position'] },
          edgeEndpoint: {
            number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
            enums: ['inside-to-node', 'outside-to-node', 'outside-to-line'], singleEnum: true,
            validate: function validate(valArr, unitsArr) {
              switch (valArr.length) {
                case 2:
                  // can be % or px only
                  return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
                case 1:
                  // can be enum, deg, or rad only
                  return is.string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
                default:
                  return false;
              }
            }
          },
          easing: {
            regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
            enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
          }
        };

        var zOrderDiff = {
          zeroNonZero: function zeroNonZero(val1, val2) {
            if (val1 === 0 && val2 !== 0) {
              return true;
            } else if (val1 !== 0 && val2 === 0) {
              return true;
            } else {
              return false;
            }
          },
          anyDiff: function anyDiff(val1, val2) {
            return val1 !== val2;
          }
        };

        var zd = zOrderDiff;

        // define visual style properties
        var t = styfn.types;
        var props = styfn.properties = [
        // main label
        { name: 'label', type: t.text }, { name: 'text-rotation', type: t.textRotation }, { name: 'text-margin-x', type: t.bidirectionalSize }, { name: 'text-margin-y', type: t.bidirectionalSize },

        // source label
        { name: 'source-label', type: t.text }, { name: 'source-text-rotation', type: t.textRotation }, { name: 'source-text-margin-x', type: t.bidirectionalSize }, { name: 'source-text-margin-y', type: t.bidirectionalSize }, { name: 'source-text-offset', type: t.size },

        // target label
        { name: 'target-label', type: t.text }, { name: 'target-text-rotation', type: t.textRotation }, { name: 'target-text-margin-x', type: t.bidirectionalSize }, { name: 'target-text-margin-y', type: t.bidirectionalSize }, { name: 'target-text-offset', type: t.size },

        // common label style
        { name: 'text-valign', type: t.valign }, { name: 'text-halign', type: t.halign }, { name: 'color', type: t.color }, { name: 'text-outline-color', type: t.color }, { name: 'text-outline-width', type: t.size }, { name: 'text-outline-opacity', type: t.zeroOneNumber }, { name: 'text-opacity', type: t.zeroOneNumber }, { name: 'text-background-color', type: t.color }, { name: 'text-background-opacity', type: t.zeroOneNumber }, { name: 'text-background-padding', type: t.size }, { name: 'text-border-opacity', type: t.zeroOneNumber }, { name: 'text-border-color', type: t.color }, { name: 'text-border-width', type: t.size }, { name: 'text-border-style', type: t.borderStyle }, { name: 'text-background-shape', type: t.textBackgroundShape },
        // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
        { name: 'text-transform', type: t.textTransform }, { name: 'text-wrap', type: t.textWrap }, { name: 'text-max-width', type: t.size }, { name: 'text-events', type: t.bool }, { name: 'font-family', type: t.fontFamily }, { name: 'font-style', type: t.fontStyle },
        // { name: 'font-letiant', type: t.fontletiant }, // not useful
        { name: 'font-weight', type: t.fontWeight }, { name: 'font-size', type: t.size }, { name: 'min-zoomed-font-size', type: t.size },

        // behaviour
        { name: 'events', type: t.bool },

        // visibility
        { name: 'display', type: t.display, triggersZOrder: zd.anyDiff }, { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff }, { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero }, { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff }, { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff }, { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

        // overlays
        { name: 'overlay-padding', type: t.size }, { name: 'overlay-color', type: t.color }, { name: 'overlay-opacity', type: t.zeroOneNumber },

        // transition anis
        { name: 'transition-property', type: t.propList }, { name: 'transition-duration', type: t.time }, { name: 'transition-delay', type: t.time }, { name: 'transition-timing-function', type: t.easing },

        // node body
        { name: 'height', type: t.nodeSize }, { name: 'width', type: t.nodeSize }, { name: 'shape', type: t.nodeShape }, { name: 'shape-polygon-points', type: t.polygonPointList }, { name: 'background-color', type: t.color }, { name: 'background-opacity', type: t.zeroOneNumber }, { name: 'background-blacken', type: t.nOneOneNumber }, { name: 'padding', type: t.sizeMaybePercent }, { name: 'padding-relative-to', type: t.paddingRelativeTo },

        // node border
        { name: 'border-color', type: t.color }, { name: 'border-opacity', type: t.zeroOneNumber }, { name: 'border-width', type: t.size }, { name: 'border-style', type: t.borderStyle },

        // node background images
        { name: 'background-image', type: t.urls }, { name: 'background-image-crossorigin', type: t.bgCrossOrigin }, { name: 'background-image-opacity', type: t.zeroOneNumbers }, { name: 'background-position-x', type: t.bgPos }, { name: 'background-position-y', type: t.bgPos }, { name: 'background-width-relative-to', type: t.bgRelativeTo }, { name: 'background-height-relative-to', type: t.bgRelativeTo }, { name: 'background-repeat', type: t.bgRepeat }, { name: 'background-fit', type: t.bgFit }, { name: 'background-clip', type: t.bgClip }, { name: 'background-width', type: t.bgWH }, { name: 'background-height', type: t.bgWH },

        // compound props
        { name: 'position', type: t.position }, { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels }, { name: 'min-width', type: t.size }, { name: 'min-width-bias-left', type: t.sizeMaybePercent }, { name: 'min-width-bias-right', type: t.sizeMaybePercent }, { name: 'min-height', type: t.size }, { name: 'min-height-bias-top', type: t.sizeMaybePercent }, { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

        // edge line
        { name: 'line-style', type: t.lineStyle }, { name: 'line-color', type: t.color }, { name: 'curve-style', type: t.curveStyle }, { name: 'haystack-radius', type: t.zeroOneNumber }, { name: 'source-endpoint', type: t.edgeEndpoint }, { name: 'target-endpoint', type: t.edgeEndpoint }, { name: 'control-point-step-size', type: t.size }, { name: 'control-point-distances', type: t.bidirectionalSizes }, { name: 'control-point-weights', type: t.numbers }, { name: 'segment-distances', type: t.bidirectionalSizes }, { name: 'segment-weights', type: t.numbers }, { name: 'edge-distances', type: t.edgeDistances }, { name: 'arrow-scale', type: t.positiveNumber }, { name: 'loop-direction', type: t.angle }, { name: 'loop-sweep', type: t.angle }, { name: 'source-distance-from-node', type: t.size }, { name: 'target-distance-from-node', type: t.size },

        // ghost properties
        { name: 'ghost', type: t.bool }, { name: 'ghost-offset-x', type: t.bidirectionalSize }, { name: 'ghost-offset-y', type: t.bidirectionalSize }, { name: 'ghost-opacity', type: t.zeroOneNumber },

        // these are just for the core
        { name: 'selection-box-color', type: t.color }, { name: 'selection-box-opacity', type: t.zeroOneNumber }, { name: 'selection-box-border-color', type: t.color }, { name: 'selection-box-border-width', type: t.size }, { name: 'active-bg-color', type: t.color }, { name: 'active-bg-opacity', type: t.zeroOneNumber }, { name: 'active-bg-size', type: t.size }, { name: 'outside-texture-bg-color', type: t.color }, { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }];

        // define aliases
        var aliases = styfn.aliases = [{ name: 'content', pointsTo: 'label' }, { name: 'control-point-distance', pointsTo: 'control-point-distances' }, { name: 'control-point-weight', pointsTo: 'control-point-weights' }, { name: 'edge-text-rotation', pointsTo: 'text-rotation' }, { name: 'padding-left', pointsTo: 'padding' }, { name: 'padding-right', pointsTo: 'padding' }, { name: 'padding-top', pointsTo: 'padding' }, { name: 'padding-bottom', pointsTo: 'padding' }];

        // pie backgrounds for nodes
        styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
        props.push({ name: 'pie-size', type: t.sizeMaybePercent });
        for (var i = 1; i <= styfn.pieBackgroundN; i++) {
          props.push({ name: 'pie-' + i + '-background-color', type: t.color });
          props.push({ name: 'pie-' + i + '-background-size', type: t.percent });
          props.push({ name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber });
        }

        // edge arrows
        var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
        [{ name: 'arrow-shape', type: t.arrowShape }, { name: 'arrow-color', type: t.color }, { name: 'arrow-fill', type: t.arrowFill }].forEach(function (prop) {
          arrowPrefixes.forEach(function (prefix) {
            var name = prefix + '-' + prop.name;
            var type = prop.type;

            props.push({ name: name, type: type });
          });
        }, {});

        // list of property names
        styfn.propertyNames = props.map(function (p) {
          return p.name;
        });

        // allow access of properties by name ( e.g. style.properties.height )
        for (var _i = 0; _i < props.length; _i++) {
          var prop = props[_i];

          props[prop.name] = prop; // allow lookup by name
        }

        // map aliases
        for (var _i2 = 0; _i2 < aliases.length; _i2++) {
          var alias = aliases[_i2];
          var pointsToProp = props[alias.pointsTo];
          var aliasProp = {
            name: alias.name,
            alias: true,
            pointsTo: pointsToProp
          };

          // add alias prop for parsing
          props.push(aliasProp);

          props[alias.name] = aliasProp; // allow lookup by name
        }
      })();

      styfn.getDefaultProperty = function (name) {
        return this.getDefaultProperties()[name];
      };

      styfn.getDefaultProperties = util.memoize(function () {
        var rawProps = util.extend({
          // common node/edge props
          'events': 'yes',
          'text-events': 'no',
          'text-valign': 'top',
          'text-halign': 'center',
          'color': '#000',
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': 'none',
          'text-wrap': 'none',
          'text-max-width': 9999,
          'text-background-color': '#000',
          'text-background-opacity': 0,
          'text-background-shape': 'rectangle',
          'text-background-padding': 0,
          'text-border-opacity': 0,
          'text-border-width': 0,
          'text-border-style': 'solid',
          'text-border-color': '#000',
          'font-family': 'Helvetica Neue, Helvetica, sans-serif',
          'font-style': 'normal',
          // 'font-letiant': fontletiant,
          'font-weight': 'normal',
          'font-size': 16,
          'min-zoomed-font-size': 0,
          'text-rotation': 'none',
          'source-text-rotation': 'none',
          'target-text-rotation': 'none',
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-compound-depth': 'auto',
          'z-index-compare': 'auto',
          'z-index': 0,
          'label': '',
          'text-margin-x': 0,
          'text-margin-y': 0,
          'source-label': '',
          'source-text-offset': 0,
          'source-text-margin-x': 0,
          'source-text-margin-y': 0,
          'target-label': '',
          'target-text-offset': 0,
          'target-text-margin-x': 0,
          'target-text-margin-y': 0,
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,
          'transition-timing-function': 'linear',

          // node props
          'background-blacken': 0,
          'background-color': '#999',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-crossorigin': 'anonymous',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-width-relative-to': 'include-padding',
          'background-height-relative-to': 'include-padding',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'background-width': 'auto',
          'background-height': 'auto',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',
          'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

          // ghost props
          'ghost': 'no',
          'ghost-offset-y': 0,
          'ghost-offset-x': 0,
          'ghost-opacity': 0,

          // compound props
          'padding': 0,
          'padding-relative-to': 'width',
          'position': 'origin',
          'compound-sizing-wrt-labels': 'include',
          'min-width': 0,
          'min-width-bias-left': 0,
          'min-width-bias-right': 0,
          'min-height': 0,
          'min-height-bias-top': 0,
          'min-height-bias-bottom': 0
        }, {
          // node pie bg
          'pie-size': '100%'
        }, [{ name: 'pie-{{i}}-background-color', value: 'black' }, { name: 'pie-{{i}}-background-size', value: '0%' }, { name: 'pie-{{i}}-background-opacity', value: 1 }].reduce(function (css, prop) {
          for (var i = 1; i <= styfn.pieBackgroundN; i++) {
            var name = prop.name.replace('{{i}}', i);
            var val = prop.value;

            css[name] = val;
          }

          return css;
        }, {}), {
          // edge props
          'line-style': 'solid',
          'line-color': '#999',
          'control-point-step-size': 40,
          'control-point-weights': 0.5,
          'segment-weights': 0.5,
          'segment-distances': 20,
          'edge-distances': 'intersection',
          'curve-style': 'bezier',
          'haystack-radius': 0,
          'arrow-scale': 1,
          'loop-direction': '-45deg',
          'loop-sweep': '-90deg',
          'source-distance-from-node': 0,
          'target-distance-from-node': 0,
          'source-endpoint': 'outside-to-node',
          'target-endpoint': 'outside-to-node'
        }, [{ name: 'arrow-shape', value: 'none' }, { name: 'arrow-color', value: '#999' }, { name: 'arrow-fill', value: 'filled' }].reduce(function (css, prop) {
          styfn.arrowPrefixes.forEach(function (prefix) {
            var name = prefix + '-' + prop.name;
            var val = prop.value;

            css[name] = val;
          });

          return css;
        }, {}));

        var parsedProps = {};

        for (var i = 0; i < this.properties.length; i++) {
          var prop = this.properties[i];

          if (prop.pointsTo) {
            continue;
          }

          var name = prop.name;
          var val = rawProps[name];
          var parsedProp = this.parse(name, val);

          parsedProps[name] = parsedProp;
        }

        return parsedProps;
      });

      styfn.addDefaultStylesheet = function () {
        this.selector('$node > node') // compound (parent) node properties
        .css({
          'shape': 'rectangle',
          'padding': 10,
          'background-color': '#eee',
          'border-color': '#ccc',
          'border-width': 1
        }).selector('edge') // just edge properties
        .css({
          'width': 3,
          'curve-style': 'haystack'
        }).selector(':parent <-> node').css({
          'curve-style': 'bezier',
          'source-endpoint': 'outside-to-line',
          'target-endpoint': 'outside-to-line'
        }).selector(':selected').css({
          'background-color': '#0169D9',
          'line-color': '#0169D9',
          'source-arrow-color': '#0169D9',
          'target-arrow-color': '#0169D9',
          'mid-source-arrow-color': '#0169D9',
          'mid-target-arrow-color': '#0169D9'
        }).selector('node:parent:selected').css({
          'background-color': '#CCE1F9',
          'border-color': '#aec8e5'
        }).selector(':active').css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        }).selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': 30,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        });

        this.defaultLength = this.length;
      };

      module.exports = styfn;

      /***/
    },
    /* 93 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var math = __webpack_require__(2);

      var styfn = {};

      // a caching layer for property parsing
      styfn.parse = function (name, value, propIsBypass, propIsFlat) {
        var self = this;

        // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
        if (is.fn(value)) {
          return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
        }

        var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
        var argHash = [name, value, propIsBypass, flatKey].join('$');
        var propCache = self.propCache = self.propCache || {};
        var ret = void 0;

        if (!(ret = propCache[argHash])) {
          ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
        }

        // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
        // - mappings can't be shared b/c mappings are per-element
        if (propIsBypass || propIsFlat === 'mapping') {
          // need a copy since props are mutated later in their lifecycles
          ret = util.copy(ret);

          if (ret) {
            ret.value = util.copy(ret.value); // because it could be an array, e.g. colour
          }
        }

        return ret;
      };

      styfn.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
        var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

        if (!prop && value != null) {
          util.error('The style property `%s: %s` is invalid', name, value);
        }

        return prop;
      };

      // parse a property; return null on invalid; return parsed property otherwise
      // fields :
      // - name : the name of the property
      // - value : the parsed, native-typed value of the property
      // - strValue : a string value that represents the property value in valid css
      // - bypass : true iff the property is a bypass property
      styfn.parseImpl = function (name, value, propIsBypass, propIsFlat) {
        var self = this;

        name = util.camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

        var property = self.properties[name];
        var passedValue = value;
        var types = self.types;

        if (!property) {
          return null;
        } // return null on property of unknown name
        if (value === undefined) {
          return null;
        } // can't assign undefined

        // the property may be an alias
        if (property.alias) {
          property = property.pointsTo;
          name = property.name;
        }

        var valueIsString = is.string(value);
        if (valueIsString) {
          // trim the value to make parsing easier
          value = value.trim();
        }

        var type = property.type;
        if (!type) {
          return null;
        } // no type, no luck

        // check if bypass is null or empty string (i.e. indication to delete bypass property)
        if (propIsBypass && (value === '' || value === null)) {
          return {
            name: name,
            value: value,
            bypass: true,
            deleteBypass: true
          };
        }

        // check if value is a function used as a mapper
        if (is.fn(value)) {
          return {
            name: name,
            value: value,
            strValue: 'fn',
            mapped: types.fn,
            bypass: propIsBypass
          };
        }

        // check if value is mapped
        var data = void 0,
            mapData = void 0;
        if (!valueIsString || propIsFlat) {
          // then don't bother to do the expensive regex checks

        } else if (data = new RegExp(types.data.regex).exec(value)) {
          if (propIsBypass) {
            return false;
          } // mappers not allowed in bypass

          var mapped = types.data;

          return {
            name: name,
            value: data,
            strValue: '' + value,
            mapped: mapped,
            field: data[1],
            bypass: propIsBypass
          };
        } else if (mapData = new RegExp(types.mapData.regex).exec(value)) {
          if (propIsBypass) {
            return false;
          } // mappers not allowed in bypass
          if (type.multiple) {
            return false;
          } // impossible to map to num

          var _mapped = types.mapData;

          // we can map only if the type is a colour or a number
          if (!(type.color || type.number)) {
            return false;
          }

          var valueMin = this.parse(name, mapData[4]); // parse to validate
          if (!valueMin || valueMin.mapped) {
            return false;
          } // can't be invalid or mapped

          var valueMax = this.parse(name, mapData[5]); // parse to validate
          if (!valueMax || valueMax.mapped) {
            return false;
          } // can't be invalid or mapped

          // check if valueMin and valueMax are the same
          if (valueMin.value === valueMax.value) {
            return false; // can't make much of a mapper without a range
          } else if (type.color) {
            var c1 = valueMin.value;
            var c2 = valueMax.value;

            var same = c1[0] === c2[0] // red
            && c1[1] === c2[1] // green
            && c1[2] === c2[2] // blue
            && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
            c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            );

            if (same) {
              return false;
            } // can't make a mapper without a range
          }

          return {
            name: name,
            value: mapData,
            strValue: '' + value,
            mapped: _mapped,
            field: mapData[1],
            fieldMin: parseFloat(mapData[2]), // min & max are numeric
            fieldMax: parseFloat(mapData[3]),
            valueMin: valueMin.value,
            valueMax: valueMax.value,
            bypass: propIsBypass
          };
        }

        if (type.multiple && propIsFlat !== 'multiple') {
          var vals = void 0;

          if (valueIsString) {
            vals = value.split(/\s+/);
          } else if (is.array(value)) {
            vals = value;
          } else {
            vals = [value];
          }

          if (type.evenMultiple && vals.length % 2 !== 0) {
            return null;
          }

          var valArr = [];
          var unitsArr = [];
          var pfValArr = [];
          var hasEnum = false;

          for (var i = 0; i < vals.length; i++) {
            var p = self.parse(name, vals[i], propIsBypass, 'multiple');

            hasEnum = hasEnum || is.string(p.value);

            valArr.push(p.value);
            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
            unitsArr.push(p.units);
          }

          if (type.validate && !type.validate(valArr, unitsArr)) {
            return null;
          }

          if (type.singleEnum && hasEnum) {
            if (valArr.length === 1 && is.string(valArr[0])) {
              return {
                name: name,
                value: valArr[0],
                strValue: valArr[0],
                bypass: propIsBypass
              };
            } else {
              return null;
            }
          }

          return {
            name: name,
            value: valArr,
            pfValue: pfValArr,
            strValue: valArr.map(function (val, i) {
              return val + (unitsArr[i] || '');
            }).join(' '),
            bypass: propIsBypass,
            units: unitsArr
          };
        }

        // several types also allow enums
        var checkEnums = function checkEnums() {
          for (var _i = 0; _i < type.enums.length; _i++) {
            var en = type.enums[_i];

            if (en === value) {
              return {
                name: name,
                value: value,
                strValue: '' + value,
                bypass: propIsBypass
              };
            }
          }

          return null;
        };

        // check the type and return the appropriate object
        if (type.number) {
          var units = void 0;
          var implicitUnits = 'px'; // not set => px

          if (type.units) {
            // use specified units if set
            units = type.units;
          }

          if (type.implicitUnits) {
            implicitUnits = type.implicitUnits;
          }

          if (!type.unitless) {
            if (valueIsString) {
              var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
              if (units) {
                unitsRegex = units;
              } // only allow explicit units if so set
              var match = value.match('^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$');

              if (match) {
                value = match[1];
                units = match[2] || implicitUnits;
              }
            } else if (!units || type.implicitUnits) {
              units = implicitUnits; // implicitly px if unspecified
            }
          }

          value = parseFloat(value);

          // if not a number and enums not allowed, then the value is invalid
          if (isNaN(value) && type.enums === undefined) {
            return null;
          }

          // check if this number type also accepts special keywords in place of numbers
          // (i.e. `left`, `auto`, etc)
          if (isNaN(value) && type.enums !== undefined) {
            value = passedValue;

            return checkEnums();
          }

          // check if value must be an integer
          if (type.integer && !is.integer(value)) {
            return null;
          }

          // check value is within range
          if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
            return null;
          }

          var ret = {
            name: name,
            value: value,
            strValue: '' + value + (units ? units : ''),
            units: units,
            bypass: propIsBypass
          };

          // normalise value in pixels
          if (type.unitless || units !== 'px' && units !== 'em') {
            ret.pfValue = value;
          } else {
            ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
          }

          // normalise value in ms
          if (units === 'ms' || units === 's') {
            ret.pfValue = units === 'ms' ? value : 1000 * value;
          }

          // normalise value in rad
          if (units === 'deg' || units === 'rad') {
            ret.pfValue = units === 'rad' ? value : math.deg2rad(value);
          }

          // normalize value in %
          if (units === '%') {
            ret.pfValue = value / 100;
          }

          return ret;
        } else if (type.propList) {

          var props = [];
          var propsStr = '' + value;

          if (propsStr === 'none') {
            // leave empty

          } else {
            // go over each prop

            var propsSplit = propsStr.split(',');
            for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
              var propName = propsSplit[_i2].trim();

              if (self.properties[propName]) {
                props.push(propName);
              }
            }

            if (props.length === 0) {
              return null;
            }
          }

          return {
            name: name,
            value: props,
            strValue: props.length === 0 ? 'none' : props.join(', '),
            bypass: propIsBypass
          };
        } else if (type.color) {
          var tuple = util.color2tuple(value);

          if (!tuple) {
            return null;
          }

          return {
            name: name,
            value: tuple,
            pfValue: tuple,
            strValue: '' + value,
            bypass: propIsBypass
          };
        } else if (type.regex || type.regexes) {

          // first check enums
          if (type.enums) {
            var enumProp = checkEnums();

            if (enumProp) {
              return enumProp;
            }
          }

          var regexes = type.regexes ? type.regexes : [type.regex];

          for (var _i3 = 0; _i3 < regexes.length; _i3++) {
            var regex = new RegExp(regexes[_i3]); // make a regex from the type string
            var m = regex.exec(value);

            if (m) {
              // regex matches
              return {
                name: name,
                value: type.singleRegexMatchValue ? m[1] : m,
                strValue: '' + value,
                bypass: propIsBypass
              };
            }
          }

          return null; // didn't match any
        } else if (type.string) {
          // just return
          return {
            name: name,
            value: '' + value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        } else if (type.enums) {
          // check enums last because it's a combo type in others
          return checkEnums();
        } else {
          return null; // not a type we can handle
        }
      };

      module.exports = styfn;

      /***/
    },
    /* 94 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var window = __webpack_require__(3);
      var math = __webpack_require__(2);

      var corefn = {

        autolock: function autolock(bool) {
          if (bool !== undefined) {
            this._private.autolock = bool ? true : false;
          } else {
            return this._private.autolock;
          }

          return this; // chaining
        },

        autoungrabify: function autoungrabify(bool) {
          if (bool !== undefined) {
            this._private.autoungrabify = bool ? true : false;
          } else {
            return this._private.autoungrabify;
          }

          return this; // chaining
        },

        autounselectify: function autounselectify(bool) {
          if (bool !== undefined) {
            this._private.autounselectify = bool ? true : false;
          } else {
            return this._private.autounselectify;
          }

          return this; // chaining
        },

        panningEnabled: function panningEnabled(bool) {
          if (bool !== undefined) {
            this._private.panningEnabled = bool ? true : false;
          } else {
            return this._private.panningEnabled;
          }

          return this; // chaining
        },

        userPanningEnabled: function userPanningEnabled(bool) {
          if (bool !== undefined) {
            this._private.userPanningEnabled = bool ? true : false;
          } else {
            return this._private.userPanningEnabled;
          }

          return this; // chaining
        },

        zoomingEnabled: function zoomingEnabled(bool) {
          if (bool !== undefined) {
            this._private.zoomingEnabled = bool ? true : false;
          } else {
            return this._private.zoomingEnabled;
          }

          return this; // chaining
        },

        userZoomingEnabled: function userZoomingEnabled(bool) {
          if (bool !== undefined) {
            this._private.userZoomingEnabled = bool ? true : false;
          } else {
            return this._private.userZoomingEnabled;
          }

          return this; // chaining
        },

        boxSelectionEnabled: function boxSelectionEnabled(bool) {
          if (bool !== undefined) {
            this._private.boxSelectionEnabled = bool ? true : false;
          } else {
            return this._private.boxSelectionEnabled;
          }

          return this; // chaining
        },

        pan: function pan() {
          var args = arguments;
          var pan = this._private.pan;
          var dim = void 0,
              val = void 0,
              dims = void 0,
              x = void 0,
              y = void 0;

          switch (args.length) {
            case 0:
              // .pan()
              return pan;

            case 1:

              if (is.string(args[0])) {
                // .pan('x')
                dim = args[0];
                return pan[dim];
              } else if (is.plainObject(args[0])) {
                // .pan({ x: 0, y: 100 })
                if (!this._private.panningEnabled) {
                  return this;
                }

                dims = args[0];
                x = dims.x;
                y = dims.y;

                if (is.number(x)) {
                  pan.x = x;
                }

                if (is.number(y)) {
                  pan.y = y;
                }

                this.emit('pan viewport');
              }
              break;

            case 2:
              // .pan('x', 100)
              if (!this._private.panningEnabled) {
                return this;
              }

              dim = args[0];
              val = args[1];

              if ((dim === 'x' || dim === 'y') && is.number(val)) {
                pan[dim] = val;
              }

              this.emit('pan viewport');
              break;

            default:
              break; // invalid
          }

          this.notify({ // notify the renderer that the viewport changed
            type: 'viewport'
          });

          return this; // chaining
        },

        panBy: function panBy(arg0, arg1) {
          var args = arguments;
          var pan = this._private.pan;
          var dim = void 0,
              val = void 0,
              dims = void 0,
              x = void 0,
              y = void 0;

          if (!this._private.panningEnabled) {
            return this;
          }

          switch (args.length) {
            case 1:

              if (is.plainObject(arg0)) {
                // .panBy({ x: 0, y: 100 })
                dims = args[0];
                x = dims.x;
                y = dims.y;

                if (is.number(x)) {
                  pan.x += x;
                }

                if (is.number(y)) {
                  pan.y += y;
                }

                this.emit('pan viewport');
              }
              break;

            case 2:
              // .panBy('x', 100)
              dim = arg0;
              val = arg1;

              if ((dim === 'x' || dim === 'y') && is.number(val)) {
                pan[dim] += val;
              }

              this.emit('pan viewport');
              break;

            default:
              break; // invalid
          }

          this.notify({ // notify the renderer that the viewport changed
            type: 'viewport'
          });

          return this; // chaining
        },

        fit: function fit(elements, padding) {
          var viewportState = this.getFitViewport(elements, padding);

          if (viewportState) {
            var _p = this._private;
            _p.zoom = viewportState.zoom;
            _p.pan = viewportState.pan;

            this.emit('pan zoom viewport');

            this.notify({ // notify the renderer that the viewport changed
              type: 'viewport'
            });
          }

          return this; // chaining
        },

        getFitViewport: function getFitViewport(elements, padding) {
          if (is.number(elements) && padding === undefined) {
            // elements is optional
            padding = elements;
            elements = undefined;
          }

          if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
            return;
          }

          var bb = void 0;

          if (is.string(elements)) {
            var sel = elements;
            elements = this.$(sel);
          } else if (is.boundingBox(elements)) {
            // assume bb
            var bbe = elements;
            bb = {
              x1: bbe.x1,
              y1: bbe.y1,
              x2: bbe.x2,
              y2: bbe.y2
            };

            bb.w = bb.x2 - bb.x1;
            bb.h = bb.y2 - bb.y1;
          } else if (!is.elementOrCollection(elements)) {
            elements = this.mutableElements();
          }

          if (is.elementOrCollection(elements) && elements.empty()) {
            return;
          } // can't fit to nothing

          bb = bb || elements.boundingBox();

          var w = this.width();
          var h = this.height();
          var zoom = void 0;
          padding = is.number(padding) ? padding : 0;

          if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);

            // crop zoom
            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

            var pan = { // now pan to middle
              x: (w - zoom * (bb.x1 + bb.x2)) / 2,
              y: (h - zoom * (bb.y1 + bb.y2)) / 2
            };

            return {
              zoom: zoom,
              pan: pan
            };
          }

          return;
        },

        minZoom: function minZoom(zoom) {
          if (zoom === undefined) {
            return this._private.minZoom;
          } else if (is.number(zoom)) {
            this._private.minZoom = zoom;
          }

          return this;
        },

        maxZoom: function maxZoom(zoom) {
          if (zoom === undefined) {
            return this._private.maxZoom;
          } else if (is.number(zoom)) {
            this._private.maxZoom = zoom;
          }

          return this;
        },

        getZoomedViewport: function getZoomedViewport(params) {
          var _p = this._private;
          var currentPan = _p.pan;
          var currentZoom = _p.zoom;
          var pos = void 0; // in rendered px
          var zoom = void 0;
          var bail = false;

          if (!_p.zoomingEnabled) {
            // zooming disabled
            bail = true;
          }

          if (is.number(params)) {
            // then set the zoom
            zoom = params;
          } else if (is.plainObject(params)) {
            // then zoom about a point
            zoom = params.level;

            if (params.position != null) {
              pos = math.modelToRenderedPosition(params.position, currentZoom, currentPan);
            } else if (params.renderedPosition != null) {
              pos = params.renderedPosition;
            }

            if (pos != null && !_p.panningEnabled) {
              // panning disabled
              bail = true;
            }
          }

          // crop zoom
          zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
          zoom = zoom < _p.minZoom ? _p.minZoom : zoom;

          // can't zoom with invalid params
          if (bail || !is.number(zoom) || zoom === currentZoom || pos != null && (!is.number(pos.x) || !is.number(pos.y))) {
            return null;
          }

          if (pos != null) {
            // set zoom about position
            var pan1 = currentPan;
            var zoom1 = currentZoom;
            var zoom2 = zoom;

            var pan2 = {
              x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
              y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
            };

            return {
              zoomed: true,
              panned: true,
              zoom: zoom2,
              pan: pan2
            };
          } else {
            // just set the zoom
            return {
              zoomed: true,
              panned: false,
              zoom: zoom,
              pan: currentPan
            };
          }
        },

        zoom: function zoom(params) {
          if (params === undefined) {
            // get
            return this._private.zoom;
          } else {
            // set
            var vp = this.getZoomedViewport(params);
            var _p = this._private;

            if (vp == null || !vp.zoomed) {
              return this;
            }

            _p.zoom = vp.zoom;

            if (vp.panned) {
              _p.pan.x = vp.pan.x;
              _p.pan.y = vp.pan.y;
            }

            this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');

            this.notify({ // notify the renderer that the viewport changed
              type: 'viewport'
            });

            return this; // chaining
          }
        },

        viewport: function viewport(opts) {
          var _p = this._private;
          var zoomDefd = true;
          var panDefd = true;
          var events = []; // to trigger
          var zoomFailed = false;
          var panFailed = false;

          if (!opts) {
            return this;
          }
          if (!is.number(opts.zoom)) {
            zoomDefd = false;
          }
          if (!is.plainObject(opts.pan)) {
            panDefd = false;
          }
          if (!zoomDefd && !panDefd) {
            return this;
          }

          if (zoomDefd) {
            var z = opts.zoom;

            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
              zoomFailed = true;
            } else {
              _p.zoom = z;

              events.push('zoom');
            }
          }

          if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
            var p = opts.pan;

            if (is.number(p.x)) {
              _p.pan.x = p.x;
              panFailed = false;
            }

            if (is.number(p.y)) {
              _p.pan.y = p.y;
              panFailed = false;
            }

            if (!panFailed) {
              events.push('pan');
            }
          }

          if (events.length > 0) {
            events.push('viewport');
            this.emit(events.join(' '));

            this.notify({
              type: 'viewport'
            });
          }

          return this; // chaining
        },

        center: function center(elements) {
          var pan = this.getCenterPan(elements);

          if (pan) {
            this._private.pan = pan;

            this.emit('pan viewport');

            this.notify({ // notify the renderer that the viewport changed
              type: 'viewport'
            });
          }

          return this; // chaining
        },

        getCenterPan: function getCenterPan(elements, zoom) {
          if (!this._private.panningEnabled) {
            return;
          }

          if (is.string(elements)) {
            var selector = elements;
            elements = this.mutableElements().filter(selector);
          } else if (!is.elementOrCollection(elements)) {
            elements = this.mutableElements();
          }

          if (elements.length === 0) {
            return;
          } // can't centre pan to nothing

          var bb = elements.boundingBox();
          var w = this.width();
          var h = this.height();
          zoom = zoom === undefined ? this._private.zoom : zoom;

          var pan = { // middle
            x: (w - zoom * (bb.x1 + bb.x2)) / 2,
            y: (h - zoom * (bb.y1 + bb.y2)) / 2
          };

          return pan;
        },

        reset: function reset() {
          if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
            return this;
          }

          this.viewport({
            pan: { x: 0, y: 0 },
            zoom: 1
          });

          return this; // chaining
        },

        invalidateSize: function invalidateSize() {
          this._private.sizeCache = null;
        },

        size: function size() {
          var _p = this._private;
          var container = _p.container;

          return _p.sizeCache = _p.sizeCache || (container ? function () {
            var style = window.getComputedStyle(container);
            var val = function val(name) {
              return parseFloat(style.getPropertyValue(name));
            };

            return {
              width: container.clientWidth - val('padding-left') - val('padding-right'),
              height: container.clientHeight - val('padding-top') - val('padding-bottom')
            };
          }() : { // fallback if no container (not 0 b/c can be used for dividing etc)
            width: 1,
            height: 1
          });
        },

        width: function width() {
          return this.size().width;
        },

        height: function height() {
          return this.size().height;
        },

        extent: function extent() {
          var pan = this._private.pan;
          var zoom = this._private.zoom;
          var rb = this.renderedExtent();

          var b = {
            x1: (rb.x1 - pan.x) / zoom,
            x2: (rb.x2 - pan.x) / zoom,
            y1: (rb.y1 - pan.y) / zoom,
            y2: (rb.y2 - pan.y) / zoom
          };

          b.w = b.x2 - b.x1;
          b.h = b.y2 - b.y1;

          return b;
        },

        renderedExtent: function renderedExtent() {
          var width = this.width();
          var height = this.height();

          return {
            x1: 0,
            y1: 0,
            x2: width,
            y2: height,
            w: width,
            h: height
          };
        }
      };

      // aliases
      corefn.centre = corefn.center;

      // backwards compatibility
      corefn.autolockNodes = corefn.autolock;
      corefn.autoungrabifyNodes = corefn.autoungrabify;

      module.exports = corefn;

      /***/
    },
    /* 95 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var define = __webpack_require__(4);
      var Collection = __webpack_require__(7);
      var Core = __webpack_require__(12);
      var incExts = __webpack_require__(96);
      var is = __webpack_require__(0);
      var Emitter = __webpack_require__(11);

      // registered extensions to cytoscape, indexed by name
      var extensions = {};

      // registered modules for extensions, indexed by name
      var modules = {};

      function setExtension(type, name, registrant) {

        var ext = registrant;

        var overrideErr = function overrideErr(field) {
          util.error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
        };

        if (type === 'core') {
          if (Core.prototype[name]) {
            return overrideErr(name);
          } else {
            Core.prototype[name] = registrant;
          }
        } else if (type === 'collection') {
          if (Collection.prototype[name]) {
            return overrideErr(name);
          } else {
            Collection.prototype[name] = registrant;
          }
        } else if (type === 'layout') {
          // fill in missing layout functions in the prototype

          var Layout = function Layout(options) {
            this.options = options;

            registrant.call(this, options);

            // make sure layout has _private for use w/ std apis like .on()
            if (!is.plainObject(this._private)) {
              this._private = {};
            }

            this._private.cy = options.cy;
            this._private.listeners = [];

            this.createEmitter();
          };

          var layoutProto = Layout.prototype = Object.create(registrant.prototype);

          var optLayoutFns = [];

          for (var i = 0; i < optLayoutFns.length; i++) {
            var fnName = optLayoutFns[i];

            layoutProto[fnName] = layoutProto[fnName] || function () {
              return this;
            };
          }

          // either .start() or .run() is defined, so autogen the other
          if (layoutProto.start && !layoutProto.run) {
            layoutProto.run = function () {
              this.start();return this;
            };
          } else if (!layoutProto.start && layoutProto.run) {
            layoutProto.start = function () {
              this.run();return this;
            };
          }

          var regStop = registrant.prototype.stop;
          layoutProto.stop = function () {
            var opts = this.options;

            if (opts && opts.animate) {
              var anis = this.animations;

              if (anis) {
                for (var _i = 0; _i < anis.length; _i++) {
                  anis[_i].stop();
                }
              }
            }

            if (regStop) {
              regStop.call(this);
            } else {
              this.emit('layoutstop');
            }

            return this;
          };

          if (!layoutProto.destroy) {
            layoutProto.destroy = function () {
              return this;
            };
          }

          layoutProto.cy = function () {
            return this._private.cy;
          };

          var getCy = function getCy(layout) {
            return layout._private.cy;
          };

          util.assign(layoutProto, {
            createEmitter: function createEmitter() {
              this._private.emitter = new Emitter({
                eventFields: function eventFields(layout) {
                  return {
                    layout: layout,
                    cy: getCy(layout),
                    target: layout
                  };
                },
                bubble: function bubble() {
                  return true;
                },
                parent: function parent(layout) {
                  return getCy(layout);
                },
                context: this
              });

              return this;
            },
            emitter: function emitter() {
              return this._private.emitter;
            },
            on: function on(evt, cb) {
              this.emitter().on(evt, cb);return this;
            },
            one: function one(evt, cb) {
              this.emitter().one(evt, cb);return this;
            },
            once: function once(evt, cb) {
              this.emitter().one(evt, cb);return this;
            },
            removeListener: function removeListener(evt, cb) {
              this.emitter().removeListener(evt, cb);return this;
            },
            emit: function emit(evt, params) {
              this.emitter().emit(evt, params);return this;
            }
          });

          define.eventAliasesOn(layoutProto);

          ext = Layout; // replace with our wrapped layout
        } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
          // user registered renderers inherit from base

          var BaseRenderer = getExtension('renderer', 'base');
          var bProto = BaseRenderer.prototype;
          var RegistrantRenderer = registrant;
          var rProto = registrant.prototype;

          var Renderer = function Renderer() {
            BaseRenderer.apply(this, arguments);
            RegistrantRenderer.apply(this, arguments);
          };

          var proto = Renderer.prototype;

          for (var pName in bProto) {
            var pVal = bProto[pName];
            var existsInR = rProto[pName] != null;

            if (existsInR) {
              return overrideErr(pName);
            }

            proto[pName] = pVal; // take impl from base
          }

          for (var _pName in rProto) {
            proto[_pName] = rProto[_pName]; // take impl from registrant
          }

          bProto.clientFunctions.forEach(function (name) {
            proto[name] = proto[name] || function () {
              util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
            };
          });

          ext = Renderer;
        }

        return util.setMap({
          map: extensions,
          keys: [type, name],
          value: ext
        });
      }

      function getExtension(type, name) {
        return util.getMap({
          map: extensions,
          keys: [type, name]
        });
      }

      function setModule(type, name, moduleType, moduleName, registrant) {
        return util.setMap({
          map: modules,
          keys: [type, name, moduleType, moduleName],
          value: registrant
        });
      }

      function getModule(type, name, moduleType, moduleName) {
        return util.getMap({
          map: modules,
          keys: [type, name, moduleType, moduleName]
        });
      }

      var extension = function extension() {
        // e.g. extension('renderer', 'svg')
        if (arguments.length === 2) {
          return getExtension.apply(null, arguments);
        }

        // e.g. extension('renderer', 'svg', { ... })
        else if (arguments.length === 3) {
            return setExtension.apply(null, arguments);
          }

          // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
          else if (arguments.length === 4) {
              return getModule.apply(null, arguments);
            }

            // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
            else if (arguments.length === 5) {
                return setModule.apply(null, arguments);
              } else {
                util.error('Invalid extension access syntax');
              }
      };

      // allows a core instance to access extensions internally
      Core.prototype.extension = extension;

      // included extensions
      incExts.forEach(function (group) {
        group.extensions.forEach(function (ext) {
          setExtension(group.type, ext.name, ext.impl);
        });
      });

      module.exports = extension;

      /***/
    },
    /* 96 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = [{
        type: 'layout',
        extensions: __webpack_require__(97)
      }, {
        type: 'renderer',
        extensions: __webpack_require__(107)
      }];

      /***/
    },
    /* 97 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = [{ name: 'breadthfirst', impl: __webpack_require__(98) }, { name: 'circle', impl: __webpack_require__(99) }, { name: 'concentric', impl: __webpack_require__(100) }, { name: 'cose', impl: __webpack_require__(101) }, { name: 'grid', impl: __webpack_require__(102) }, { name: 'null', impl: __webpack_require__(103) }, { name: 'preset', impl: __webpack_require__(104) }, { name: 'random', impl: __webpack_require__(105) }, { name: 'tree', impl: __webpack_require__(106) }];

      /***/
    },
    /* 98 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
        padding: 30, // padding on fit
        circle: false, // put depths in concentric circles if true, put depths top down if false
        spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        roots: undefined, // the roots of the trees
        maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled,
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts
      };

      function BreadthFirstLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      BreadthFirstLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');
        var graph = eles;

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var roots = void 0;
        if (is.elementOrCollection(options.roots)) {
          roots = options.roots;
        } else if (is.array(options.roots)) {
          var rootsArray = [];

          for (var i = 0; i < options.roots.length; i++) {
            var id = options.roots[i];
            var ele = cy.getElementById(id);
            rootsArray.push(ele);
          }

          roots = cy.collection(rootsArray);
        } else if (is.string(options.roots)) {
          roots = cy.$(options.roots);
        } else {
          if (options.directed) {
            roots = nodes.roots();
          } else {
            var components = [];
            var unhandledNodes = nodes;

            var _loop = function _loop() {
              var currComp = cy.collection();

              eles.bfs({
                roots: unhandledNodes[0],
                visit: function visit(node, edge, pNode, i, depth) {
                  currComp = currComp.add(node);
                },
                directed: false
              });

              unhandledNodes = unhandledNodes.not(currComp);
              components.push(currComp);
            };

            while (unhandledNodes.length > 0) {
              _loop();
            }

            roots = cy.collection();

            var _loop2 = function _loop2(_i) {
              var comp = components[_i];
              var maxDegree = comp.maxDegree(false);
              var compRoots = comp.filter(function (ele) {
                return ele.degree(false) === maxDegree;
              });

              roots = roots.add(compRoots);
            };

            for (var _i = 0; _i < components.length; _i++) {
              _loop2(_i);
            }
          }
        }

        var depths = [];
        var foundByBfs = {};
        var id2depth = {};
        var prevNode = {};
        var prevEdge = {};
        var successors = {};

        // find the depths of the nodes
        graph.bfs({
          roots: roots,
          directed: options.directed,
          visit: function visit(node, edge, pNode, i, depth) {
            var ele = node[0];
            var id = ele.id();

            if (!depths[depth]) {
              depths[depth] = [];
            }

            depths[depth].push(ele);
            foundByBfs[id] = true;
            id2depth[id] = depth;
            prevNode[id] = pNode;
            prevEdge[id] = edge;

            if (pNode) {
              var prevId = pNode.id();
              var succ = successors[prevId] = successors[prevId] || [];

              succ.push(node);
            }
          }
        });

        // check for nodes not found by bfs
        var orphanNodes = [];
        for (var _i2 = 0; _i2 < nodes.length; _i2++) {
          var _ele = nodes[_i2];

          if (foundByBfs[_ele.id()]) {
            continue;
          } else {
            orphanNodes.push(_ele);
          }
        }

        // assign orphan nodes a depth from their neighborhood
        var maxChecks = orphanNodes.length * 3;
        var checks = 0;
        while (orphanNodes.length !== 0 && checks < maxChecks) {
          var node = orphanNodes.shift();
          var neighbors = node.neighborhood().nodes();
          var assignedDepth = false;

          for (var _i3 = 0; _i3 < neighbors.length; _i3++) {
            var depth = id2depth[neighbors[_i3].id()];

            if (depth !== undefined) {
              depths[depth].push(node);
              assignedDepth = true;
              break;
            }
          }

          if (!assignedDepth) {
            orphanNodes.push(node);
          }

          checks++;
        }

        // assign orphan nodes that are still left to the depth of their subgraph
        while (orphanNodes.length !== 0) {
          var _node = orphanNodes.shift();
          //let subgraph = graph.bfs( node ).path;
          var _assignedDepth = false;

          // for( let i = 0; i < subgraph.length; i++ ){
          //   let depth = id2depth[ subgraph[i].id() ];

          //   if( depth !== undefined ){
          //     depths[depth].push( node );
          //     assignedDepth = true;
          //     break;
          //   }
          // }

          if (!_assignedDepth) {
            // worst case if the graph really isn't tree friendly, then just dump it in 0
            if (depths.length === 0) {
              depths.push([]);
            }

            depths[0].push(_node);
          }
        }

        // assign the nodes a depth and index
        var assignDepthsToEles = function assignDepthsToEles() {
          for (var _i4 = 0; _i4 < depths.length; _i4++) {
            var _eles = depths[_i4];

            for (var j = 0; j < _eles.length; j++) {
              var _ele2 = _eles[j];

              if (_ele2 == null) {
                _eles.splice(j, 1);
                j--;
                continue;
              }

              _ele2._private.scratch.breadthfirst = {
                depth: _i4,
                index: j
              };
            }
          }
        };
        assignDepthsToEles();

        var intersectsDepth = function intersectsDepth(node) {
          // returns true if has edges pointing in from a higher depth
          var edges = node.connectedEdges(function (ele) {
            return ele.data('target') === node.id();
          });
          var thisInfo = node._private.scratch.breadthfirst;
          var highestDepthOfOther = 0;
          var highestOther = void 0;
          for (var _i5 = 0; _i5 < edges.length; _i5++) {
            var edge = edges[_i5];
            var otherNode = edge.source()[0];
            var otherInfo = otherNode._private.scratch.breadthfirst;

            if (thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth) {
              highestDepthOfOther = otherInfo.depth;
              highestOther = otherNode;
            }
          }

          return highestOther;
        };

        // make maximal if so set by adjusting depths
        for (var adj = 0; adj < options.maximalAdjustments; adj++) {

          var nDepths = depths.length;
          var elesToMove = [];
          for (var _i6 = 0; _i6 < nDepths; _i6++) {
            var _depth = depths[_i6];

            var nDepth = _depth.length;
            for (var j = 0; j < nDepth; j++) {
              var _ele3 = _depth[j];
              var info = _ele3._private.scratch.breadthfirst;
              var intEle = intersectsDepth(_ele3);

              if (intEle) {
                info.intEle = intEle;
                elesToMove.push(_ele3);
              }
            }
          }

          for (var _i7 = 0; _i7 < elesToMove.length; _i7++) {
            var _ele4 = elesToMove[_i7];
            var _info = _ele4._private.scratch.breadthfirst;
            var _intEle = _info.intEle;
            var intInfo = _intEle._private.scratch.breadthfirst;

            depths[_info.depth][_info.index] = null; // remove from old depth & index (create hole to be cleaned)

            // add to end of new depth
            var newDepth = intInfo.depth + 1;
            while (newDepth > depths.length - 1) {
              depths.push([]);
            }
            depths[newDepth].push(_ele4);

            _info.depth = newDepth;
            _info.index = depths[newDepth].length - 1;
          }

          assignDepthsToEles();
        }

        // find min distance we need to leave between nodes
        var minDistance = 0;
        if (options.avoidOverlap) {
          for (var _i8 = 0; _i8 < nodes.length; _i8++) {
            var n = nodes[_i8];
            var nbb = n.layoutDimensions(options);
            var w = nbb.w;
            var h = nbb.h;

            minDistance = Math.max(minDistance, w, h);
          }
        }

        // get the weighted percent for an element based on its connectivity to other levels
        var cachedWeightedPercent = {};
        var getWeightedPercent = function getWeightedPercent(ele) {
          if (cachedWeightedPercent[ele.id()]) {
            return cachedWeightedPercent[ele.id()];
          }

          var eleDepth = ele._private.scratch.breadthfirst.depth;
          var neighbors = ele.neighborhood().nodes().not(':parent').intersection(nodes);
          var percent = 0;
          var samples = 0;

          for (var _i9 = 0; _i9 < neighbors.length; _i9++) {
            var neighbor = neighbors[_i9];
            var bf = neighbor._private.scratch.breadthfirst;
            var index = bf.index;
            var _depth2 = bf.depth;
            var _nDepth = depths[_depth2].length;

            if (eleDepth > _depth2 || eleDepth === 0) {
              // only get influenced by elements above
              percent += index / _nDepth;
              samples++;
            }
          }

          samples = Math.max(1, samples);
          percent = percent / samples;

          if (samples === 0) {
            // so lone nodes have a "don't care" state in sorting
            percent = undefined;
          }

          cachedWeightedPercent[ele.id()] = percent;
          return percent;
        };

        // rearrange the indices in each depth level based on connectivity

        var sortFn = function sortFn(a, b) {
          var apct = getWeightedPercent(a);
          var bpct = getWeightedPercent(b);

          return apct - bpct;
        };

        for (var times = 0; times < 3; times++) {
          // do it a few times b/c the depths are dynamic and we want a more stable result

          for (var _i10 = 0; _i10 < depths.length; _i10++) {
            depths[_i10] = depths[_i10].sort(sortFn);
          }
          assignDepthsToEles(); // and update
        }

        var biggestDepthSize = 0;
        for (var _i11 = 0; _i11 < depths.length; _i11++) {
          biggestDepthSize = Math.max(depths[_i11].length, biggestDepthSize);
        }

        var center = {
          x: bb.x1 + bb.w / 2,
          y: bb.x1 + bb.h / 2
        };

        var getPosition = function getPosition(ele, isBottomDepth) {
          var info = ele._private.scratch.breadthfirst;
          var depth = info.depth;
          var index = info.index;
          var depthSize = depths[depth].length;

          var distanceX = Math.max(bb.w / (depthSize + 1), minDistance);
          var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
          var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
          radiusStepSize = Math.max(radiusStepSize, minDistance);

          if (!options.circle) {

            var epos = {
              x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
              y: (depth + 1) * distanceY
            };

            if (isBottomDepth) {
              return epos;
            }

            // let succs = successors[ ele.id() ];
            // if( succs ){
            //   epos.x = 0;
            //
            //   for( let i = 0 ; i < succs.length; i++ ){
            //     let spos = pos[ succs[i].id() ];
            //
            //     epos.x += spos.x;
            //   }
            //
            //   epos.x /= succs.length;
            // } else {
            //   //debugger;
            // }

            return epos;
          } else {
            if (options.circle) {
              var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
              var theta = 2 * Math.PI / depths[depth].length * index;

              if (depth === 0 && depths[0].length === 1) {
                radius = 1;
              }

              return {
                x: center.x + radius * Math.cos(theta),
                y: center.y + radius * Math.sin(theta)
              };
            } else {
              return {
                x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
                y: (depth + 1) * distanceY
              };
            }
          }
        };

        // get positions in reverse depth order
        var pos = {};
        for (var _i12 = depths.length - 1; _i12 >= 0; _i12--) {
          var _depth3 = depths[_i12];

          for (var _j = 0; _j < _depth3.length; _j++) {
            var _node2 = _depth3[_j];

            pos[_node2.id()] = getPosition(_node2, _i12 === depths.length - 1);
          }
        }

        nodes.layoutPositions(this, options, function (node) {
          return pos[node.id()];
        });

        return this; // chaining
      };

      module.exports = BreadthFirstLayout;

      /***/
    },
    /* 99 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // the padding on fit
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        radius: undefined, // the radius of the circle
        startAngle: 3 / 2 * Math.PI, // where nodes start in radians
        sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
        clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
        sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 

      };

      function CircleLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      CircleLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;

        var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

        var nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var center = {
          x: bb.x1 + bb.w / 2,
          y: bb.y1 + bb.h / 2
        };

        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
        var dTheta = sweep / Math.max(1, nodes.length - 1);
        var r = void 0;

        var minDistance = 0;
        for (var i = 0; i < nodes.length; i++) {
          var n = nodes[i];
          var nbb = n.layoutDimensions(options);
          var w = nbb.w;
          var h = nbb.h;

          minDistance = Math.max(minDistance, w, h);
        }

        if (is.number(options.radius)) {
          r = options.radius;
        } else if (nodes.length <= 1) {
          r = 0;
        } else {
          r = Math.min(bb.h, bb.w) / 2 - minDistance;
        }

        // calculate the radius
        if (nodes.length > 1 && options.avoidOverlap) {
          // but only if more than one node (can't overlap)
          minDistance *= 1.75; // just to have some nice spacing

          var dcos = Math.cos(dTheta) - Math.cos(0);
          var dsin = Math.sin(dTheta) - Math.sin(0);
          var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
          r = Math.max(rMin, r);
        }

        var getPos = function getPos(ele, i) {
          var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);

          var rx = r * Math.cos(theta);
          var ry = r * Math.sin(theta);
          var pos = {
            x: center.x + rx,
            y: center.y + ry
          };

          return pos;
        };

        nodes.layoutPositions(this, options, getPos);

        return this; // chaining
      };

      module.exports = CircleLayout;

      /***/
    },
    /* 100 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // the padding on fit
        startAngle: 3 / 2 * Math.PI, // where nodes start in radians
        sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
        clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
        equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
        minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        height: undefined, // height of layout area (overrides container height)
        width: undefined, // width of layout area (overrides container width)
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        concentric: function concentric(node) {
          // returns numeric value for each node, placing higher nodes in levels towards the centre
          return node.degree();
        },
        levelWidth: function levelWidth(nodes) {
          // the letiation of concentric values in each level
          return nodes.maxDegree() / 4;
        },
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function ConcentricLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      ConcentricLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

        var cy = params.cy;

        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var center = {
          x: bb.x1 + bb.w / 2,
          y: bb.y1 + bb.h / 2
        };

        var nodeValues = []; // { node, value }
        var theta = options.startAngle;
        var maxNodeSize = 0;

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var value = void 0;

          // calculate the node value
          value = options.concentric(node);
          nodeValues.push({
            value: value,
            node: node
          });

          // for style mapping
          node._private.scratch.concentric = value;
        }

        // in case we used the `concentric` in style
        nodes.updateStyle();

        // calculate max size now based on potentially updated mappers
        for (var _i = 0; _i < nodes.length; _i++) {
          var _node = nodes[_i];
          var nbb = _node.layoutDimensions(options);

          maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
        }

        // sort node values in descreasing order
        nodeValues.sort(function (a, b) {
          return b.value - a.value;
        });

        var levelWidth = options.levelWidth(nodes);

        // put the values into levels
        var levels = [[]];
        var currentLevel = levels[0];
        for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
          var val = nodeValues[_i2];

          if (currentLevel.length > 0) {
            var diff = Math.abs(currentLevel[0].value - val.value);

            if (diff >= levelWidth) {
              currentLevel = [];
              levels.push(currentLevel);
            }
          }

          currentLevel.push(val);
        }

        // create positions from levels

        var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

        if (!options.avoidOverlap) {
          // then strictly constrain to bb
          var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
          var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
          var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);

          minDist = Math.min(minDist, rStep);
        }

        // find the metrics for each level
        var r = 0;
        for (var _i3 = 0; _i3 < levels.length; _i3++) {
          var level = levels[_i3];
          var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
          var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);

          // calculate the radius
          if (level.length > 1 && options.avoidOverlap) {
            // but only if more than one node (can't overlap)
            var dcos = Math.cos(dTheta) - Math.cos(0);
            var dsin = Math.sin(dTheta) - Math.sin(0);
            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

            r = Math.max(rMin, r);
          }

          level.r = r;

          r += minDist;
        }

        if (options.equidistant) {
          var rDeltaMax = 0;
          var _r = 0;

          for (var _i4 = 0; _i4 < levels.length; _i4++) {
            var _level = levels[_i4];
            var rDelta = _level.r - _r;

            rDeltaMax = Math.max(rDeltaMax, rDelta);
          }

          _r = 0;
          for (var _i5 = 0; _i5 < levels.length; _i5++) {
            var _level2 = levels[_i5];

            if (_i5 === 0) {
              _r = _level2.r;
            }

            _level2.r = _r;

            _r += rDeltaMax;
          }
        }

        // calculate the node positions
        var pos = {}; // id => position
        for (var _i6 = 0; _i6 < levels.length; _i6++) {
          var _level3 = levels[_i6];
          var _dTheta = _level3.dTheta;
          var _r2 = _level3.r;

          for (var j = 0; j < _level3.length; j++) {
            var _val = _level3[j];
            var _theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;

            var p = {
              x: center.x + _r2 * Math.cos(_theta),
              y: center.y + _r2 * Math.sin(_theta)
            };

            pos[_val.node.id()] = p;
          }
        }

        // position the nodes
        nodes.layoutPositions(this, options, function (ele) {
          var id = ele.id();

          return pos[id];
        });

        return this; // chaining
      };

      module.exports = ConcentricLayout;

      /***/
    },
    /* 101 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*
      The CoSE layout was written by Gerardo Huck.
      https://www.linkedin.com/in/gerardohuck/
      
      Based on the following article:
      http://dl.acm.org/citation.cfm?id=1498047
      
      Modifications tracked on Github.
      */

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var is = __webpack_require__(0);
      var Promise = __webpack_require__(5);

      var DEBUG;

      /**
       * @brief :  default layout options
       */
      var defaults = {
        // Called on `layoutready`
        ready: function ready() {},

        // Called on `layoutstop`
        stop: function stop() {},

        // Whether to animate while running the layout
        // true : Animate continuously as the layout is running
        // false : Just show the end result
        // 'end' : Animate with the end result, from the initial positions to the end positions
        animate: true,

        // Easing of the animation for animate:'end'
        animationEasing: undefined,

        // The duration of the animation for animate:'end'
        animationDuration: undefined,

        // A function that determines whether the node should be animated
        // All nodes animated by default on animate enabled
        // Non-animated nodes are positioned immediately when the layout starts
        animateFilter: function animateFilter(node, i) {
          return true;
        },

        // The layout animates only after this many milliseconds for animate:true
        // (prevents flashing on fast runs)
        animationThreshold: 250,

        // Number of iterations between consecutive screen positions update
        // (0 -> only updated on the end)
        refresh: 20,

        // Whether to fit the network view after when done
        fit: true,

        // Padding on fit
        padding: 30,

        // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        boundingBox: undefined,

        // Excludes the label when calculating node bounding boxes for the layout algorithm
        nodeDimensionsIncludeLabels: false,

        // Randomize the initial positions of the nodes (true) or use existing positions (false)
        randomize: false,

        // Extra spacing between components in non-compound graphs
        componentSpacing: 40,

        // Node repulsion (non overlapping) multiplier
        nodeRepulsion: function nodeRepulsion(node) {
          return 2048;
        },

        // Node repulsion (overlapping) multiplier
        nodeOverlap: 4,

        // Ideal edge (non nested) length
        idealEdgeLength: function idealEdgeLength(edge) {
          return 32;
        },

        // Divisor to compute edge forces
        edgeElasticity: function edgeElasticity(edge) {
          return 32;
        },

        // Nesting factor (multiplier) to compute ideal edge length for nested edges
        nestingFactor: 1.2,

        // Gravity force (constant)
        gravity: 1,

        // Maximum number of iterations to perform
        numIter: 1000,

        // Initial temperature (maximum node displacement)
        initialTemp: 1000,

        // Cooling factor (how the temperature is reduced between consecutive iterations
        coolingFactor: 0.99,

        // Lower temperature threshold (below this point the layout will end)
        minTemp: 1.0,

        // Pass a reference to weaver to use threads for calculations
        weaver: false
      };

      /**
       * @brief       : constructor
       * @arg options : object containing layout options
       */
      function CoseLayout(options) {
        this.options = util.extend({}, defaults, options);

        this.options.layout = this;
      }

      /**
       * @brief : runs the layout
       */
      CoseLayout.prototype.run = function () {
        var options = this.options;
        var cy = options.cy;
        var layout = this;
        var thread = this.thread;
        var Thread = options.weaver ? options.weaver.Thread : null;

        var falseThread = { // use false thread as polyfill
          listeners: [],
          on: function on(e, cb) {
            this.listeners.push({ event: e, callback: cb });

            return this;
          },
          trigger: function trigger(e) {
            if (is.string(e)) {
              e = { type: e };
            }

            var matchesEvent = function matchesEvent(l) {
              return l.event === e.type;
            };
            var trigger = function trigger(l) {
              l.callback(e);
            };

            this.listeners.filter(matchesEvent).forEach(trigger);

            return this;
          },
          pass: function pass(data) {
            this.pass = data;

            return this;
          },
          run: function run(cb) {
            var pass = this.pass;

            return new Promise(function (resolve) {
              resolve(cb(pass));
            });
          },
          stop: function stop() {
            return this;
          },
          stopped: function stopped() {
            return true;
          }
        };

        function broadcast(message) {
          // for false thread
          var e = { type: 'message', message: message };

          falseThread.trigger(e);
        }

        if (!thread || thread.stopped()) {
          thread = this.thread = Thread ? new Thread() : falseThread;
        }

        layout.stopped = false;

        if (options.animate === true || options.animate === false) {
          layout.emit({ type: 'layoutstart', layout: layout });
        }

        // Set DEBUG - Global variable
        if (true === options.debug) {
          DEBUG = true;
        } else {
          DEBUG = false;
        }

        // Initialize layout info
        var layoutInfo = createLayoutInfo(cy, layout, options);

        // Show LayoutInfo contents if debugging
        if (DEBUG) {
          printLayoutInfo(layoutInfo);
        }

        // If required, randomize node positions
        if (options.randomize) {
          randomizePositions(layoutInfo, cy);
        }

        var startTime = Date.now();
        var refreshRequested = false;
        var refresh = function refresh(rOpts) {
          rOpts = rOpts || {};

          if (refreshRequested && !rOpts.next) {
            return;
          }

          if (!rOpts.force && Date.now() - startTime < options.animationThreshold) {
            return;
          }

          refreshRequested = true;

          util.requestAnimationFrame(function () {
            refreshPositions(layoutInfo, cy, options);

            // Fit the graph if necessary
            if (true === options.fit) {
              cy.fit(options.padding);
            }

            refreshRequested = false;

            if (rOpts.next) {
              rOpts.next();
            }
          });
        };

        thread.on('message', function (e) {
          var layoutNodes = e.message;

          layoutInfo.layoutNodes = layoutNodes;
          refresh();
        });

        thread.pass({
          layoutInfo: layoutInfo,
          options: {
            animate: options.animate,
            refresh: options.refresh,
            componentSpacing: options.componentSpacing,
            nodeOverlap: options.nodeOverlap,
            nestingFactor: options.nestingFactor,
            gravity: options.gravity,
            numIter: options.numIter,
            initialTemp: options.initialTemp,
            coolingFactor: options.coolingFactor,
            minTemp: options.minTemp
          }
        }).run(function (pass) {
          var layoutInfo = pass.layoutInfo;
          var options = pass.options;
          var stopped = false;

          /**
           * @brief          : Performs one iteration of the physical simulation
           * @arg layoutInfo : LayoutInfo object already initialized
           * @arg cy         : Cytoscape object
           * @arg options    : Layout options
           */
          var step = function step(layoutInfo, options, _step) {
            // var s = "\n\n###############################";
            // s += "\nSTEP: " + step;
            // s += "\n###############################\n";
            // logDebug(s);

            // Calculate node repulsions
            calculateNodeForces(layoutInfo, options);
            // Calculate edge forces
            calculateEdgeForces(layoutInfo, options);
            // Calculate gravity forces
            calculateGravityForces(layoutInfo, options);
            // Propagate forces from parent to child
            propagateForces(layoutInfo, options);
            // Update positions based on calculated forces
            updatePositions(layoutInfo, options);
          };

          /**
           * @brief : Computes the node repulsion forces
           */
          var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
            // Go through each of the graphs in graphSet
            // Nodes only repel each other if they belong to the same graph
            // var s = 'calculateNodeForces';
            // logDebug(s);
            for (var i = 0; i < layoutInfo.graphSet.length; i++) {
              var graph = layoutInfo.graphSet[i];
              var numNodes = graph.length;

              // s = "Set: " + graph.toString();
              // logDebug(s);

              // Now get all the pairs of nodes
              // Only get each pair once, (A, B) = (B, A)
              for (var j = 0; j < numNodes; j++) {
                var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

                for (var k = j + 1; k < numNodes; k++) {
                  var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];

                  nodeRepulsion(node1, node2, layoutInfo, options);
                }
              }
            }
          };

          var randomDistance = function randomDistance(max) {
            return -max + 2 * max * Math.random();
          };

          /**
           * @brief : Compute the node repulsion forces between a pair of nodes
           */
          var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
            // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

            var cmptId1 = node1.cmptId;
            var cmptId2 = node2.cmptId;

            if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
              return;
            }

            // Get direction of line connecting both node centers
            var directionX = node2.positionX - node1.positionX;
            var directionY = node2.positionY - node1.positionY;
            var maxRandDist = 1;
            // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

            // If both centers are the same, apply a random force
            if (0 === directionX && 0 === directionY) {
              directionX = randomDistance(maxRandDist);
              directionY = randomDistance(maxRandDist);
            }

            var overlap = nodesOverlap(node1, node2, directionX, directionY);

            if (overlap > 0) {
              // s += "\nNodes DO overlap.";
              // s += "\nOverlap: " + overlap;
              // If nodes overlap, repulsion force is proportional
              // to the overlap
              var force = options.nodeOverlap * overlap;

              // Compute the module and components of the force vector
              var distance = Math.sqrt(directionX * directionX + directionY * directionY);
              // s += "\nDistance: " + distance;
              var forceX = force * directionX / distance;
              var forceY = force * directionY / distance;
            } else {
              // s += "\nNodes do NOT overlap.";
              // If there's no overlap, force is inversely proportional
              // to squared distance

              // Get clipping points for both nodes
              var point1 = findClippingPoint(node1, directionX, directionY);
              var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

              // Use clipping points to compute distance
              var distanceX = point2.x - point1.x;
              var distanceY = point2.y - point1.y;
              var distanceSqr = distanceX * distanceX + distanceY * distanceY;
              var distance = Math.sqrt(distanceSqr);
              // s += "\nDistance: " + distance;

              // Compute the module and components of the force vector
              var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
              var forceX = force * distanceX / distance;
              var forceY = force * distanceY / distance;
            }

            // Apply force
            if (!node1.isLocked) {
              node1.offsetX -= forceX;
              node1.offsetY -= forceY;
            }

            if (!node2.isLocked) {
              node2.offsetX += forceX;
              node2.offsetY += forceY;
            }

            // s += "\nForceX: " + forceX + " ForceY: " + forceY;
            // logDebug(s);

            return;
          };

          /**
           * @brief  : Determines whether two nodes overlap or not
           * @return : Amount of overlapping (0 => no overlap)
           */
          var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {

            if (dX > 0) {
              var overlapX = node1.maxX - node2.minX;
            } else {
              var overlapX = node2.maxX - node1.minX;
            }

            if (dY > 0) {
              var overlapY = node1.maxY - node2.minY;
            } else {
              var overlapY = node2.maxY - node1.minY;
            }

            if (overlapX >= 0 && overlapY >= 0) {
              return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
            } else {
              return 0;
            }
          };

          /**
           * @brief : Finds the point in which an edge (direction dX, dY) intersects
           *          the rectangular bounding box of it's source/target node
           */
          var findClippingPoint = function findClippingPoint(node, dX, dY) {

            // Shorcuts
            var X = node.positionX;
            var Y = node.positionY;
            var H = node.height || 1;
            var W = node.width || 1;
            var dirSlope = dY / dX;
            var nodeSlope = H / W;

            // var s = 'Computing clipping point of node ' + node.id +
            //   " . Height:  " + H + ", Width: " + W +
            //   "\nDirection " + dX + ", " + dY;
            //
            // Compute intersection
            var res = {};

            // Case: Vertical direction (up)
            if (0 === dX && 0 < dY) {
              res.x = X;
              // s += "\nUp direction";
              res.y = Y + H / 2;

              return res;
            }

            // Case: Vertical direction (down)
            if (0 === dX && 0 > dY) {
              res.x = X;
              res.y = Y + H / 2;
              // s += "\nDown direction";

              return res;
            }

            // Case: Intersects the right border
            if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
              res.x = X + W / 2;
              res.y = Y + W * dY / 2 / dX;
              // s += "\nRightborder";

              return res;
            }

            // Case: Intersects the left border
            if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
              res.x = X - W / 2;
              res.y = Y - W * dY / 2 / dX;
              // s += "\nLeftborder";

              return res;
            }

            // Case: Intersects the top border
            if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
              res.x = X + H * dX / 2 / dY;
              res.y = Y + H / 2;
              // s += "\nTop border";

              return res;
            }

            // Case: Intersects the bottom border
            if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
              res.x = X - H * dX / 2 / dY;
              res.y = Y - H / 2;
              // s += "\nBottom border";

              return res;
            }

            // s += "\nClipping point found at " + res.x + ", " + res.y;
            // logDebug(s);
            return res;
          };

          /**
           * @brief : Calculates all edge forces
           */
          var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
            // Iterate over all edges
            for (var i = 0; i < layoutInfo.edgeSize; i++) {
              // Get edge, source & target nodes
              var edge = layoutInfo.layoutEdges[i];
              var sourceIx = layoutInfo.idToIndex[edge.sourceId];
              var source = layoutInfo.layoutNodes[sourceIx];
              var targetIx = layoutInfo.idToIndex[edge.targetId];
              var target = layoutInfo.layoutNodes[targetIx];

              // Get direction of line connecting both node centers
              var directionX = target.positionX - source.positionX;
              var directionY = target.positionY - source.positionY;

              // If both centers are the same, do nothing.
              // A random force has already been applied as node repulsion
              if (0 === directionX && 0 === directionY) {
                continue;
              }

              // Get clipping points for both nodes
              var point1 = findClippingPoint(source, directionX, directionY);
              var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);

              var lx = point2.x - point1.x;
              var ly = point2.y - point1.y;
              var l = Math.sqrt(lx * lx + ly * ly);

              var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

              if (0 !== l) {
                var forceX = force * lx / l;
                var forceY = force * ly / l;
              } else {
                var forceX = 0;
                var forceY = 0;
              }

              // Add this force to target and source nodes
              if (!source.isLocked) {
                source.offsetX += forceX;
                source.offsetY += forceY;
              }

              if (!target.isLocked) {
                target.offsetX -= forceX;
                target.offsetY -= forceY;
              }

              // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
              // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
              // logDebug(s);
            }
          };

          /**
           * @brief : Computes gravity forces for all nodes
           */
          var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
            var distThreshold = 1;

            // var s = 'calculateGravityForces';
            // logDebug(s);
            for (var i = 0; i < layoutInfo.graphSet.length; i++) {
              var graph = layoutInfo.graphSet[i];
              var numNodes = graph.length;

              // s = "Set: " + graph.toString();
              // logDebug(s);

              // Compute graph center
              if (0 === i) {
                var centerX = layoutInfo.clientHeight / 2;
                var centerY = layoutInfo.clientWidth / 2;
              } else {
                // Get Parent node for this graph, and use its position as center
                var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
                var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
                var centerX = parent.positionX;
                var centerY = parent.positionY;
              }
              // s = "Center found at: " + centerX + ", " + centerY;
              // logDebug(s);

              // Apply force to all nodes in graph
              for (var j = 0; j < numNodes; j++) {
                var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
                // s = "Node: " + node.id;

                if (node.isLocked) {
                  continue;
                }

                var dx = centerX - node.positionX;
                var dy = centerY - node.positionY;
                var d = Math.sqrt(dx * dx + dy * dy);
                if (d > distThreshold) {
                  var fx = options.gravity * dx / d;
                  var fy = options.gravity * dy / d;
                  node.offsetX += fx;
                  node.offsetY += fy;
                  // s += ": Applied force: " + fx + ", " + fy;
                } else {}
                // s += ": skypped since it's too close to center";

                // logDebug(s);
              }
            }
          };

          /**
           * @brief          : This function propagates the existing offsets from
           *                   parent nodes to its descendents.
           * @arg layoutInfo : layoutInfo Object
           * @arg cy         : cytoscape Object
           * @arg options    : Layout options
           */
          var propagateForces = function propagateForces(layoutInfo, options) {
            // Inline implementation of a queue, used for traversing the graph in BFS order
            var queue = [];
            var start = 0; // Points to the start the queue
            var end = -1; // Points to the end of the queue

            // logDebug('propagateForces');

            // Start by visiting the nodes in the root graph
            queue.push.apply(queue, layoutInfo.graphSet[0]);
            end += layoutInfo.graphSet[0].length;

            // Traverse the graph, level by level,
            while (start <= end) {
              // Get the node to visit and remove it from queue
              var nodeId = queue[start++];
              var nodeIndex = layoutInfo.idToIndex[nodeId];
              var node = layoutInfo.layoutNodes[nodeIndex];
              var children = node.children;

              // We only need to process the node if it's compound
              if (0 < children.length && !node.isLocked) {
                var offX = node.offsetX;
                var offY = node.offsetY;

                // var s = "Propagating offset from parent node : " + node.id +
                //   ". OffsetX: " + offX + ". OffsetY: " + offY;
                // s += "\n Children: " + children.toString();
                // logDebug(s);

                for (var i = 0; i < children.length; i++) {
                  var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
                  // Propagate offset
                  childNode.offsetX += offX;
                  childNode.offsetY += offY;
                  // Add children to queue to be visited
                  queue[++end] = children[i];
                }

                // Reset parent offsets
                node.offsetX = 0;
                node.offsetY = 0;
              }
            }
          };

          /**
           * @brief : Updates the layout model positions, based on
           *          the accumulated forces
           */
          var updatePositions = function updatePositions(layoutInfo, options) {
            // var s = 'Updating positions';
            // logDebug(s);

            // Reset boundaries for compound nodes
            for (var i = 0; i < layoutInfo.nodeSize; i++) {
              var n = layoutInfo.layoutNodes[i];
              if (0 < n.children.length) {
                // logDebug("Resetting boundaries of compound node: " + n.id);
                n.maxX = undefined;
                n.minX = undefined;
                n.maxY = undefined;
                n.minY = undefined;
              }
            }

            for (var i = 0; i < layoutInfo.nodeSize; i++) {
              var n = layoutInfo.layoutNodes[i];
              if (0 < n.children.length || n.isLocked) {
                // No need to set compound or locked node position
                // logDebug("Skipping position update of node: " + n.id);
                continue;
              }
              // s = "Node: " + n.id + " Previous position: (" +
              // n.positionX + ", " + n.positionY + ").";

              // Limit displacement in order to improve stability
              var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
              n.positionX += tempForce.x;
              n.positionY += tempForce.y;
              n.offsetX = 0;
              n.offsetY = 0;
              n.minX = n.positionX - n.width;
              n.maxX = n.positionX + n.width;
              n.minY = n.positionY - n.height;
              n.maxY = n.positionY + n.height;
              // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
              // logDebug(s);

              // Update ancestry boudaries
              updateAncestryBoundaries(n, layoutInfo);
            }

            // Update size, position of compund nodes
            for (var i = 0; i < layoutInfo.nodeSize; i++) {
              var n = layoutInfo.layoutNodes[i];
              if (0 < n.children.length && !n.isLocked) {
                n.positionX = (n.maxX + n.minX) / 2;
                n.positionY = (n.maxY + n.minY) / 2;
                n.width = n.maxX - n.minX;
                n.height = n.maxY - n.minY;
                // s = "Updating position, size of compound node " + n.id;
                // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
                // s += "\nWidth: " + n.width + ", Height: " + n.height;
                // logDebug(s);
              }
            }
          };

          /**
           * @brief : Limits a force (forceX, forceY) to be not
           *          greater (in modulo) than max.
           8          Preserves force direction.
           */
          var limitForce = function limitForce(forceX, forceY, max) {
            // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
            var force = Math.sqrt(forceX * forceX + forceY * forceY);

            if (force > max) {
              var res = {
                x: max * forceX / force,
                y: max * forceY / force
              };
            } else {
              var res = {
                x: forceX,
                y: forceY
              };
            }

            // s += ".\nResult: (" + res.x + ", " + res.y + ")";
            // logDebug(s);

            return res;
          };

          /**
           * @brief : Function used for keeping track of compound node
           *          sizes, since they should bound all their subnodes.
           */
          var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
            // var s = "Propagating new position/size of node " + node.id;
            var parentId = node.parentId;
            if (null == parentId) {
              // If there's no parent, we are done
              // s += ". No parent node.";
              // logDebug(s);
              return;
            }

            // Get Parent Node
            var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
            var flag = false;

            // MaxX
            if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
              p.maxX = node.maxX + p.padRight;
              flag = true;
              // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
            }

            // MinX
            if (null == p.minX || node.minX - p.padLeft < p.minX) {
              p.minX = node.minX - p.padLeft;
              flag = true;
              // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
            }

            // MaxY
            if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
              p.maxY = node.maxY + p.padBottom;
              flag = true;
              // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
            }

            // MinY
            if (null == p.minY || node.minY - p.padTop < p.minY) {
              p.minY = node.minY - p.padTop;
              flag = true;
              // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
            }

            // If updated boundaries, propagate changes upward
            if (flag) {
              // logDebug(s);
              return updateAncestryBoundaries(p, layoutInfo);
            }

            // s += ". No changes in boundaries/position of parent node " + p.id;
            // logDebug(s);
            return;
          };

          var separateComponents = function separateComponents(layutInfo, options) {
            var nodes = layoutInfo.layoutNodes;
            var components = [];

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var cid = node.cmptId;
              var component = components[cid] = components[cid] || [];

              component.push(node);
            }

            var totalA = 0;

            for (var i = 0; i < components.length; i++) {
              var c = components[i];

              if (!c) {
                continue;
              }

              c.x1 = Infinity;
              c.x2 = -Infinity;
              c.y1 = Infinity;
              c.y2 = -Infinity;

              for (var j = 0; j < c.length; j++) {
                var n = c[j];

                c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
                c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
                c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
                c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
              }

              c.w = c.x2 - c.x1;
              c.h = c.y2 - c.y1;

              totalA += c.w * c.h;
            }

            components.sort(function (c1, c2) {
              return c2.w * c2.h - c1.w * c1.h;
            });

            var x = 0;
            var y = 0;
            var usedW = 0;
            var rowH = 0;
            var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

            for (var i = 0; i < components.length; i++) {
              var c = components[i];

              if (!c) {
                continue;
              }

              for (var j = 0; j < c.length; j++) {
                var n = c[j];

                if (!n.isLocked) {
                  n.positionX += x;
                  n.positionY += y;
                }
              }

              x += c.w + options.componentSpacing;
              usedW += c.w + options.componentSpacing;
              rowH = Math.max(rowH, c.h);

              if (usedW > maxRowW) {
                y += rowH + options.componentSpacing;
                x = 0;
                usedW = 0;
                rowH = 0;
              }
            }
          };

          var mainLoop = function mainLoop(i) {
            if (stopped) {
              // logDebug("Layout manually stopped. Stopping computation in step " + i);
              return false;
            }

            // Do one step in the phisical simulation
            step(layoutInfo, options, i);

            // Update temperature
            layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
            // logDebug("New temperature: " + layoutInfo.temperature);

            if (layoutInfo.temperature < options.minTemp) {
              // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
              return false;
            }

            return true;
          };

          var i = 0;
          var loopRet;

          do {
            var f = 0;

            while (f < options.refresh && i < options.numIter) {
              var loopRet = mainLoop(i);
              if (!loopRet) {
                break;
              }

              f++;
              i++;
            }

            if (options.animate === true) {
              broadcast(layoutInfo.layoutNodes); // eslint-disable-line no-undef
            }
          } while (loopRet && i + 1 < options.numIter);

          separateComponents(layoutInfo, options);

          return layoutInfo;
        }).then(function (layoutInfoUpdated) {
          layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

          thread.stop();
          done();
        });

        var done = function done() {
          if (options.animate === true || options.animate === false) {
            refresh({
              force: true,
              next: function next() {
                // Layout has finished
                layout.one('layoutstop', options.stop);
                layout.emit({ type: 'layoutstop', layout: layout });
              }
            });
          } else {
            options.eles.nodes().layoutPositions(layout, options, function (node) {
              var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

              return { x: lnode.positionX, y: lnode.positionY };
            });
          }
        };

        return this; // chaining
      };

      /**
       * @brief : called on continuous layouts to stop them before they finish
       */
      CoseLayout.prototype.stop = function () {
        this.stopped = true;

        if (this.thread) {
          this.thread.stop();
        }

        this.emit('layoutstop');

        return this; // chaining
      };

      CoseLayout.prototype.destroy = function () {
        if (this.thread) {
          this.thread.stop();
        }

        return this; // chaining
      };

      /**
       * @brief     : Creates an object which is contains all the data
       *              used in the layout process
       * @arg cy    : cytoscape.js object
       * @return    : layoutInfo object initialized
       */
      var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
        // Shortcut
        var edges = options.eles.edges();
        var nodes = options.eles.nodes();

        var layoutInfo = {
          isCompound: cy.hasCompoundNodes(),
          layoutNodes: [],
          idToIndex: {},
          nodeSize: nodes.size(),
          graphSet: [],
          indexToGraph: [],
          layoutEdges: [],
          edgeSize: edges.size(),
          temperature: options.initialTemp,
          clientWidth: cy.width(),
          clientHeight: cy.width(),
          boundingBox: math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
            x1: 0, y1: 0, w: cy.width(), h: cy.height()
          })
        };

        var components = options.eles.components();
        var id2cmptId = {};

        for (var i = 0; i < components.length; i++) {
          var component = components[i];

          for (var j = 0; j < component.length; j++) {
            var node = component[j];

            id2cmptId[node.id()] = i;
          }
        }

        // Iterate over all nodes, creating layout nodes
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = nodes[i];
          var nbb = n.layoutDimensions(options);

          var tempNode = {};
          tempNode.isLocked = n.locked();
          tempNode.id = n.data('id');
          tempNode.parentId = n.data('parent');
          tempNode.cmptId = id2cmptId[n.id()];
          tempNode.children = [];
          tempNode.positionX = n.position('x');
          tempNode.positionY = n.position('y');
          tempNode.offsetX = 0;
          tempNode.offsetY = 0;
          tempNode.height = nbb.w;
          tempNode.width = nbb.h;
          tempNode.maxX = tempNode.positionX + tempNode.width / 2;
          tempNode.minX = tempNode.positionX - tempNode.width / 2;
          tempNode.maxY = tempNode.positionY + tempNode.height / 2;
          tempNode.minY = tempNode.positionY - tempNode.height / 2;
          tempNode.padLeft = parseFloat(n.style('padding'));
          tempNode.padRight = parseFloat(n.style('padding'));
          tempNode.padTop = parseFloat(n.style('padding'));
          tempNode.padBottom = parseFloat(n.style('padding'));

          // forces
          tempNode.nodeRepulsion = is.fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;

          // Add new node
          layoutInfo.layoutNodes.push(tempNode);
          // Add entry to id-index map
          layoutInfo.idToIndex[tempNode.id] = i;
        }

        // Inline implementation of a queue, used for traversing the graph in BFS order
        var queue = [];
        var start = 0; // Points to the start the queue
        var end = -1; // Points to the end of the queue

        var tempGraph = [];

        // Second pass to add child information and
        // initialize queue for hierarchical traversal
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];
          var p_id = n.parentId;
          // Check if node n has a parent node
          if (null != p_id) {
            // Add node Id to parent's list of children
            layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
          } else {
            // If a node doesn't have a parent, then it's in the root graph
            queue[++end] = n.id;
            tempGraph.push(n.id);
          }
        }

        // Add root graph to graphSet
        layoutInfo.graphSet.push(tempGraph);

        // Traverse the graph, level by level,
        while (start <= end) {
          // Get the node to visit and remove it from queue
          var node_id = queue[start++];
          var node_ix = layoutInfo.idToIndex[node_id];
          var node = layoutInfo.layoutNodes[node_ix];
          var children = node.children;
          if (children.length > 0) {
            // Add children nodes as a new graph to graph set
            layoutInfo.graphSet.push(children);
            // Add children to que queue to be visited
            for (var i = 0; i < children.length; i++) {
              queue[++end] = children[i];
            }
          }
        }

        // Create indexToGraph map
        for (var i = 0; i < layoutInfo.graphSet.length; i++) {
          var graph = layoutInfo.graphSet[i];
          for (var j = 0; j < graph.length; j++) {
            var index = layoutInfo.idToIndex[graph[j]];
            layoutInfo.indexToGraph[index] = i;
          }
        }

        // Iterate over all edges, creating Layout Edges
        for (var i = 0; i < layoutInfo.edgeSize; i++) {
          var e = edges[i];
          var tempEdge = {};
          tempEdge.id = e.data('id');
          tempEdge.sourceId = e.data('source');
          tempEdge.targetId = e.data('target');

          // Compute ideal length
          var idealLength = is.fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
          var elasticity = is.fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;

          // Check if it's an inter graph edge
          var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
          var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
          var sourceGraph = layoutInfo.indexToGraph[sourceIx];
          var targetGraph = layoutInfo.indexToGraph[targetIx];

          if (sourceGraph != targetGraph) {
            // Find lowest common graph ancestor
            var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

            // Compute sum of node depths, relative to lca graph
            var lcaGraph = layoutInfo.graphSet[lca];
            var depth = 0;

            // Source depth
            var tempNode = layoutInfo.layoutNodes[sourceIx];
            while (-1 === lcaGraph.indexOf(tempNode.id)) {
              tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
              depth++;
            }

            // Target depth
            tempNode = layoutInfo.layoutNodes[targetIx];
            while (-1 === lcaGraph.indexOf(tempNode.id)) {
              tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
              depth++;
            }

            // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
            //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
            //  ". Depth: " + depth);

            // Update idealLength
            idealLength *= depth * options.nestingFactor;
          }

          tempEdge.idealLength = idealLength;
          tempEdge.elasticity = elasticity;

          layoutInfo.layoutEdges.push(tempEdge);
        }

        // Finally, return layoutInfo object
        return layoutInfo;
      };

      /**
       * @brief : This function finds the index of the lowest common
       *          graph ancestor between 2 nodes in the subtree
       *          (from the graph hierarchy induced tree) whose
       *          root is graphIx
       *
       * @arg node1: node1's ID
       * @arg node2: node2's ID
       * @arg layoutInfo: layoutInfo object
       *
       */
      var findLCA = function findLCA(node1, node2, layoutInfo) {
        // Find their common ancester, starting from the root graph
        var res = findLCA_aux(node1, node2, 0, layoutInfo);
        if (2 > res.count) {
          // If aux function couldn't find the common ancester,
          // then it is the root graph
          return 0;
        } else {
          return res.graph;
        }
      };

      /**
       * @brief          : Auxiliary function used for LCA computation
       *
       * @arg node1      : node1's ID
       * @arg node2      : node2's ID
       * @arg graphIx    : subgraph index
       * @arg layoutInfo : layoutInfo object
       *
       * @return         : object of the form {count: X, graph: Y}, where:
       *                   X is the number of ancesters (max: 2) found in
       *                   graphIx (and it's subgraphs),
       *                   Y is the graph index of the lowest graph containing
       *                   all X nodes
       */
      var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
        var graph = layoutInfo.graphSet[graphIx];
        // If both nodes belongs to graphIx
        if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
          return { count: 2, graph: graphIx };
        }

        // Make recursive calls for all subgraphs
        var c = 0;
        for (var i = 0; i < graph.length; i++) {
          var nodeId = graph[i];
          var nodeIx = layoutInfo.idToIndex[nodeId];
          var children = layoutInfo.layoutNodes[nodeIx].children;

          // If the node has no child, skip it
          if (0 === children.length) {
            continue;
          }

          var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
          var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
          if (0 === result.count) {
            // Neither node1 nor node2 are present in this subgraph
            continue;
          } else if (1 === result.count) {
            // One of (node1, node2) is present in this subgraph
            c++;
            if (2 === c) {
              // We've already found both nodes, no need to keep searching
              break;
            }
          } else {
            // Both nodes are present in this subgraph
            return result;
          }
        }

        return { count: c, graph: graphIx };
      };

      /**
       * @brief: printsLayoutInfo into js console
       *         Only used for debbuging
       */
      var printLayoutInfo = function printLayoutInfo(layoutInfo) {
        /* eslint-disable */

        if (!DEBUG) {
          return;
        }
        console.debug('layoutNodes:');
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];
          var s = '\nindex: ' + i + '\nId: ' + n.id + '\nChildren: ' + n.children.toString() + '\nparentId: ' + n.parentId + '\npositionX: ' + n.positionX + '\npositionY: ' + n.positionY + '\nOffsetX: ' + n.offsetX + '\nOffsetY: ' + n.offsetY + '\npadLeft: ' + n.padLeft + '\npadRight: ' + n.padRight + '\npadTop: ' + n.padTop + '\npadBottom: ' + n.padBottom;

          console.debug(s);
        }

        console.debug('idToIndex');
        for (var i in layoutInfo.idToIndex) {
          console.debug('Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[i]);
        }

        console.debug('Graph Set');
        var set = layoutInfo.graphSet;
        for (var i = 0; i < set.length; i++) {
          console.debug('Set : ' + i + ': ' + set[i].toString());
        }

        var s = 'IndexToGraph';
        for (var i = 0; i < layoutInfo.indexToGraph.length; i++) {
          s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[i];
        }
        console.debug(s);

        s = 'Layout Edges';
        for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
          var e = layoutInfo.layoutEdges[i];
          s += '\nEdge Index: ' + i + ' ID: ' + e.id + ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId + ' Ideal Length: ' + e.idealLength;
        }
        console.debug(s);

        s = 'nodeSize: ' + layoutInfo.nodeSize;
        s += '\nedgeSize: ' + layoutInfo.edgeSize;
        s += '\ntemperature: ' + layoutInfo.temperature;
        console.debug(s);

        return;
        /* eslint-enable */
      };

      /**
       * @brief : Randomizes the position of all nodes
       */
      var randomizePositions = function randomizePositions(layoutInfo, cy) {
        var width = layoutInfo.clientWidth;
        var height = layoutInfo.clientHeight;

        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];

          // No need to randomize compound nodes or locked nodes
          if (0 === n.children.length && !n.isLocked) {
            n.positionX = Math.random() * width;
            n.positionY = Math.random() * height;
          }
        }
      };

      /**
       * @brief          : Updates the positions of nodes in the network
       * @arg layoutInfo : LayoutInfo object
       * @arg cy         : Cytoscape object
       * @arg options    : Layout options
       */
      var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
        // var s = 'Refreshing positions';
        // logDebug(s);

        var layout = options.layout;
        var nodes = options.eles.nodes();
        var bb = layoutInfo.boundingBox;
        var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

        if (options.boundingBox) {
          nodes.forEach(function (node) {
            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);

            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
          });

          coseBB.w = coseBB.x2 - coseBB.x1;
          coseBB.h = coseBB.y2 - coseBB.y1;
        }

        nodes.positions(function (ele, i) {
          var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
          // s = "Node: " + lnode.id + ". Refreshed position: (" +
          // lnode.positionX + ", " + lnode.positionY + ").";
          // logDebug(s);

          if (options.boundingBox) {
            // then add extra bounding box constraint
            var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
            var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

            return {
              x: bb.x1 + pctX * bb.w,
              y: bb.y1 + pctY * bb.h
            };
          } else {
            return {
              x: lnode.positionX,
              y: lnode.positionY
            };
          }
        });

        // Trigger layoutReady only on first call
        if (true !== layoutInfo.ready) {
          // s = 'Triggering layoutready';
          // logDebug(s);
          layoutInfo.ready = true;
          layout.one('layoutready', options.ready);
          layout.emit({ type: 'layoutready', layout: this });
        }
      };

      /**
       * @brief : Logs a debug message in JS console, if DEBUG is ON
       */
      // var logDebug = function(text) {
      //   if (DEBUG) {
      //     console.debug(text);
      //   }
      // };

      module.exports = CoseLayout;

      /***/
    },
    /* 102 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // padding used on fit
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        condense: false, // uses all available space on false, uses minimal space on true
        rows: undefined, // force num of rows in the grid
        cols: undefined, // force num of columns in the grid
        position: function position(node) {}, // returns { row, col } for element
        sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function GridLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      GridLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        if (bb.h === 0 || bb.w === 0) {
          nodes.layoutPositions(this, options, function (ele) {
            return { x: bb.x1, y: bb.y1 };
          });
        } else {

          // width/height * splits^2 = cells where splits is number of times to split width
          var cells = nodes.size();
          var splits = Math.sqrt(cells * bb.h / bb.w);
          var rows = Math.round(splits);
          var cols = Math.round(bb.w / bb.h * splits);

          var small = function small(val) {
            if (val == null) {
              return Math.min(rows, cols);
            } else {
              var min = Math.min(rows, cols);
              if (min == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var large = function large(val) {
            if (val == null) {
              return Math.max(rows, cols);
            } else {
              var max = Math.max(rows, cols);
              if (max == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var oRows = options.rows;
          var oCols = options.cols != null ? options.cols : options.columns;

          // if rows or columns were set in options, use those values
          if (oRows != null && oCols != null) {
            rows = oRows;
            cols = oCols;
          } else if (oRows != null && oCols == null) {
            rows = oRows;
            cols = Math.ceil(cells / rows);
          } else if (oRows == null && oCols != null) {
            cols = oCols;
            rows = Math.ceil(cells / cols);
          }

          // otherwise use the automatic values and adjust accordingly

          // if rounding was up, see if we can reduce rows or columns
          else if (cols * rows > cells) {
              var sm = small();
              var lg = large();

              // reducing the small side takes away the most cells, so try it first
              if ((sm - 1) * lg >= cells) {
                small(sm - 1);
              } else if ((lg - 1) * sm >= cells) {
                large(lg - 1);
              }
            } else {

              // if rounding was too low, add rows or columns
              while (cols * rows < cells) {
                var _sm = small();
                var _lg = large();

                // try to add to larger side first (adds less in multiplication)
                if ((_lg + 1) * _sm >= cells) {
                  large(_lg + 1);
                } else {
                  small(_sm + 1);
                }
              }
            }

          var cellWidth = bb.w / cols;
          var cellHeight = bb.h / rows;

          if (options.condense) {
            cellWidth = 0;
            cellHeight = 0;
          }

          if (options.avoidOverlap) {
            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var pos = node._private.position;

              if (pos.x == null || pos.y == null) {
                // for bb
                pos.x = 0;
                pos.y = 0;
              }

              var nbb = node.layoutDimensions(options);
              var p = options.avoidOverlapPadding;

              var w = nbb.w + p;
              var h = nbb.h + p;

              cellWidth = Math.max(cellWidth, w);
              cellHeight = Math.max(cellHeight, h);
            }
          }

          var cellUsed = {}; // e.g. 'c-0-2' => true

          var used = function used(row, col) {
            return cellUsed['c-' + row + '-' + col] ? true : false;
          };

          var use = function use(row, col) {
            cellUsed['c-' + row + '-' + col] = true;
          };

          // to keep track of current cell position
          var row = 0;
          var col = 0;
          var moveToNextCell = function moveToNextCell() {
            col++;
            if (col >= cols) {
              col = 0;
              row++;
            }
          };

          // get a cache of all the manual positions
          var id2manPos = {};
          for (var _i = 0; _i < nodes.length; _i++) {
            var _node = nodes[_i];
            var rcPos = options.position(_node);

            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
              // must have at least row or col def'd
              var _pos = {
                row: rcPos.row,
                col: rcPos.col
              };

              if (_pos.col === undefined) {
                // find unused col
                _pos.col = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.col++;
                }
              } else if (_pos.row === undefined) {
                // find unused row
                _pos.row = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.row++;
                }
              }

              id2manPos[_node.id()] = _pos;
              use(_pos.row, _pos.col);
            }
          }

          var getPos = function getPos(element, i) {
            var x = void 0,
                y = void 0;

            if (element.locked() || element.isParent()) {
              return false;
            }

            // see if we have a manual position set
            var rcPos = id2manPos[element.id()];
            if (rcPos) {
              x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
              y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
            } else {
              // otherwise set automatically

              while (used(row, col)) {
                moveToNextCell();
              }

              x = col * cellWidth + cellWidth / 2 + bb.x1;
              y = row * cellHeight + cellHeight / 2 + bb.y1;
              use(row, col);

              moveToNextCell();
            }

            return { x: x, y: y };
          };

          nodes.layoutPositions(this, options, getPos);
        }

        return this; // chaining
      };

      module.exports = GridLayout;

      /***/
    },
    /* 103 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      // default layout options
      var defaults = {
        ready: function ready() {}, // on layoutready
        stop: function stop() {} // on layoutstop
      };

      // constructor
      // options : object containing layout options
      function NullLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      // runs the layout
      NullLayout.prototype.run = function () {
        var options = this.options;
        var eles = options.eles; // elements to consider in the layout
        var layout = this;

        // cy is automatically populated for us in the constructor
        var cy = options.cy; // jshint ignore:line

        layout.emit('layoutstart');

        // puts all nodes at (0, 0)
        eles.nodes().positions(function () {
          return {
            x: 0,
            y: 0
          };
        });

        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.emit('layoutready');

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.emit('layoutstop');

        return this; // chaining
      };

      // called on continuous layouts to stop them before they finish
      NullLayout.prototype.stop = function () {
        return this; // chaining
      };

      module.exports = NullLayout;

      /***/
    },
    /* 104 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);

      var defaults = {
        positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
        zoom: undefined, // the zoom level to set (prob want fit = false if set)
        pan: undefined, // the pan level to set (prob want fit = false if set)
        fit: true, // whether to fit to viewport
        padding: 30, // padding on fit
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function PresetLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      PresetLayout.prototype.run = function () {
        var options = this.options;
        var eles = options.eles;

        var nodes = eles.nodes();
        var posIsFn = is.fn(options.positions);

        function getPosition(node) {
          if (options.positions == null) {
            return null;
          }

          if (posIsFn) {
            return options.positions(node);
          }

          var pos = options.positions[node._private.data.id];

          if (pos == null) {
            return null;
          }

          return pos;
        }

        nodes.layoutPositions(this, options, function (node, i) {
          var position = getPosition(node);

          if (node.locked() || position == null) {
            return false;
          }

          return position;
        });

        return this; // chaining
      };

      module.exports = PresetLayout;

      /***/
    },
    /* 105 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit to viewport
        padding: 30, // fit padding
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 
      };

      function RandomLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      RandomLayout.prototype.run = function () {
        var options = this.options;
        var cy = options.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        var getPos = function getPos(node, i) {
          return {
            x: bb.x1 + Math.round(Math.random() * bb.w),
            y: bb.y1 + Math.round(Math.random() * bb.h)
          };
        };

        nodes.layoutPositions(this, options, getPos);

        return this; // chaining
      };

      module.exports = RandomLayout;

      /***/
    },
    /* 106 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var defaults = {
        fit: true, // whether to fit the viewport to the graph
        padding: 30, // padding used on fit
        boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
        avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
        nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        condense: true, // uses all available space on false, uses minimal space on true
        rows: undefined, // force num of rows in the grid
        cols: undefined, // force num of columns in the grid
        position: function position(node) {}, // returns { row, col } for element
        sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false, // whether to transition the node positions
        animationDuration: 500, // duration of animation in ms if enabled
        animationEasing: undefined, // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined, // callback on layoutready
        stop: undefined, // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts
      };

      function TreeLayout(options) {
        this.options = util.extend({}, defaults, options);
      }

      TreeLayout.prototype.run = function () {
        var params = this.options;
        var options = params;

        var cy = params.cy;
        var eles = options.eles;
        var nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0, y1: 0, w: cy.width(), h: cy.height()
        });

        if (bb.h === 0 || bb.w === 0) {
          nodes.layoutPositions(this, options, function (ele) {
            return { x: bb.x1, y: bb.y1 };
          });
        } else {

          // width/height * splits^2 = cells where splits is number of times to split width
          var cells = nodes.size();
          var splits = Math.sqrt(cells * bb.h / bb.w);
          var rows = Math.round(splits);
          var cols = Math.round(bb.w / bb.h * splits);

          var small = function small(val) {
            if (val == null) {
              return Math.min(rows, cols);
            } else {
              var min = Math.min(rows, cols);
              if (min == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var large = function large(val) {
            if (val == null) {
              return Math.max(rows, cols);
            } else {
              var max = Math.max(rows, cols);
              if (max == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          var oRows = options.rows;
          var oCols = options.cols != null ? options.cols : options.columns;

          // if rows or columns were set in options, use those values
          if (oRows != null && oCols != null) {
            rows = oRows;
            cols = oCols;
          } else if (oRows != null && oCols == null) {
            rows = oRows;
            cols = Math.ceil(cells / rows);
          } else if (oRows == null && oCols != null) {
            cols = oCols;
            rows = Math.ceil(cells / cols);
          }

          // otherwise use the automatic values and adjust accordingly

          // if rounding was up, see if we can reduce rows or columns
          else if (cols * rows > cells) {
              var sm = small();
              var lg = large();

              // reducing the small side takes away the most cells, so try it first
              if ((sm - 1) * lg >= cells) {
                small(sm - 1);
              } else if ((lg - 1) * sm >= cells) {
                large(lg - 1);
              }
            } else {

              // if rounding was too low, add rows or columns
              while (cols * rows < cells) {
                var _sm = small();
                var _lg = large();

                // try to add to larger side first (adds less in multiplication)
                if ((_lg + 1) * _sm >= cells) {
                  large(_lg + 1);
                } else {
                  small(_sm + 1);
                }
              }
            }

          var cellWidth = bb.w / cols;
          var cellHeight = bb.h / rows;

          if (options.condense) {
            cellWidth = 0;
            cellHeight = 0;
          }

          var widthCoefs = [];
          var widths = [];
          for (var i = 0; i < nodes.length; i++) {
            widthCoefs.push(1.0);
          }

          var posWordMax = {};
          if (options.avoidOverlap) {
            // iterate through all the nodes and set the cellWidth and cellHeight
            // to the maximum width/height seen in the graph plus a padding value
            for (var _i = 0; _i < nodes.length; _i++) {
              var clumpId = parseInt(nodes[_i]._private.data.clump);
              posWordMax[clumpId] = 0;
            }
            for (var _i2 = 0; _i2 < nodes.length; _i2++) {
              // the current node
              var node = nodes[_i2];
              var pos = node._private.position;

              if (pos.x == null || pos.y == null) {
                // for bb
                pos.x = 0;
                pos.y = 0;
              }

              var nbb = node.layoutDimensions(options);
              var p = options.avoidOverlapPadding;

              var w = nbb.w + p;
              var h = nbb.h + p;

              widths[_i2] = w;

              //console.log('tree.js: [' + i + '] ' + node._private.data.label);
              //console.log('tree.js: [' + i + '] ' + node._private.data.id);
              var _clumpId = parseInt(node._private.data.clump);
              //console.log('tree.js: [' + i + '] ' + clumpId);
              posWordMax[_clumpId] = Math.max(posWordMax[_clumpId], nbb.w + p);
              //console.log('tree.js: [' + i + '] ' + posWordMax[clumpId]);
              //console.log('tree.js: [' + i + '] nbb.w|nbb.h|cellWidth|cellHeight = ' + nbb.w +'|'+ nbb.h +'|'+ cellWidth +'|'+ cellHeight);
              cellWidth = Math.max(cellWidth, w);
              cellHeight = Math.max(cellHeight, h);
            }
            //console.log('tree.js: ** ' + Object.entries(posWordMax));
            for (var _i3 = 0; _i3 < nodes.length; _i3++) {
              widthCoefs[_i3] = widths[_i3] / cellWidth;
              //console.log('tree.js: posWordMax  ' + posWordMax[i]);
              if (widthCoefs[_i3] < 0.7) {
                widthCoefs[_i3] = 0.7;
              }
            }
            //console.log('tree.js ' + widthCoefs);
          }

          var cellUsed = {}; // e.g. 'c-0-2' => true

          var used = function used(row, col) {
            return cellUsed['c-' + row + '-' + col] ? true : false;
          };

          var use = function use(row, col) {
            cellUsed['c-' + row + '-' + col] = true;
          };

          // to keep track of current cell position
          var row = 0;
          var col = 0;
          var moveToNextCell = function moveToNextCell() {
            col++;
            if (col >= cols) {
              col = 0;
              row++;
            }
          };

          // get a cache of all the manual positions
          var id2manPos = {};
          for (var _i4 = 0; _i4 < nodes.length; _i4++) {
            var _node = nodes[_i4];
            var rcPos = options.position(_node);

            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
              // must have at least row or col def'd
              var _pos = {
                row: rcPos.row,
                col: rcPos.col
              };

              if (_pos.col === undefined) {
                // find unused col
                _pos.col = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.col++;
                }
              } else if (_pos.row === undefined) {
                // find unused row
                _pos.row = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.row++;
                }
              }

              id2manPos[_node.id()] = _pos;
              use(_pos.row, _pos.col);
            }
          }

          var getPos = function getPos(element, i) {
            var x = void 0,
                y = void 0;

            if (element.locked() || element.isParent()) {
              return false;
            }

            // see if we have a manual position set
            var rcPos = id2manPos[element.id()];
            if (rcPos) {
              x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
              y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
            } else {
              // otherwise set automatically
              while (used(row, col)) {
                moveToNextCell();
              }

              var prevNodes = 0;
              for (var ii = 0; ii < col; ii++) {
                prevNodes += posWordMax[ii];
              }
              var pad = 2;
              // this is where we set the final position
              //x = (0.1*cellWidth) + newX + (cellWidth * widthCoefs[col]) / 2 + bb.x1;
              x = prevNodes + pad * 2 * col + posWordMax[col] / 2;
              //x = col * cellWidth + cellWidth / 2 + bb.x1;
              y = row * cellHeight + cellHeight / 2 + bb.y1;

              log.debug('tree.js [' + row + '][' + col + '] x,y = ' + x + ',' + y);

              use(row, col);

              moveToNextCell();
            }

            return { x: x, y: y };
          };

          nodes.layoutPositions(this, options, getPos);
        }

        return this; // chaining
      };

      module.exports = TreeLayout;

      /***/
    },
    /* 107 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = [{ name: 'null', impl: __webpack_require__(108) }, { name: 'base', impl: __webpack_require__(109) }, { name: 'canvas', impl: __webpack_require__(125) }];

      /***/
    },
    /* 108 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      function NullRenderer(options) {
        this.options = options;
        this.notifications = 0; // for testing
      }

      var noop = function noop() {};

      NullRenderer.prototype = {
        recalculateRenderedStyle: noop,
        notify: function notify() {
          this.notifications++;
        },
        init: noop
      };

      module.exports = NullRenderer;

      /***/
    },
    /* 109 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var window = __webpack_require__(3);

      var BaseRenderer = function BaseRenderer(options) {
        this.init(options);
      };
      var BR = BaseRenderer;
      var BRp = BR.prototype;

      BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

      BRp.init = function (options) {
        var r = this;

        r.options = options;

        r.cy = options.cy;

        var ctr = r.container = options.cy.container();

        // prepend a stylesheet in the head such that
        if (window) {
          var document = window.document;
          var head = document.head;
          var stylesheetId = '__________cytoscape_stylesheet';
          var className = '__________cytoscape_container';
          var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

          if (ctr.className.indexOf(className) < 0) {
            ctr.className = (ctr.className || '') + ' ' + className;
          }

          if (!stylesheetAlreadyExists) {
            var stylesheet = document.createElement('style');

            stylesheet.id = stylesheetId;
            stylesheet.innerHTML = '.' + className + ' { position: relative; }';

            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
          }

          var computedStyle = window.getComputedStyle(ctr);
          var position = computedStyle.getPropertyValue('position');

          if (position === 'static') {
            util.error('A Cytoscape container has style position:static and so can not use UI extensions properly');
          }
        }

        r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

        r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];

        //--Pointer-related data
        r.hoverData = { down: null, last: null,
          downTime: null, triggerMode: null,
          dragging: false,
          initialPan: [null, null], capture: false };

        r.dragData = { possibleDragElements: [] };

        r.touchData = {
          start: null, capture: false,

          // These 3 fields related to tap, taphold events
          startPosition: [null, null, null, null, null, null],
          singleTouchStartTime: null,
          singleTouchMoved: true,

          now: [null, null, null, null, null, null],
          earlier: [null, null, null, null, null, null]
        };

        r.redraws = 0;
        r.showFps = options.showFps;
        r.debug = options.debug;

        r.hideEdgesOnViewport = options.hideEdgesOnViewport;
        r.hideLabelsOnViewport = options.hideLabelsOnViewport;
        r.textureOnViewport = options.textureOnViewport;
        r.wheelSensitivity = options.wheelSensitivity;
        r.motionBlurEnabled = options.motionBlur; // on by default
        r.forcedPixelRatio = options.pixelRatio;
        r.motionBlur = options.motionBlur; // for initial kick off
        r.motionBlurOpacity = options.motionBlurOpacity;
        r.motionBlurTransparency = 1 - r.motionBlurOpacity;
        r.motionBlurPxRatio = 1;
        r.mbPxRBlurry = 1; //0.8;
        r.minMbLowQualFrames = 4;
        r.fullQualityMb = false;
        r.clearedForMotionBlur = [];
        r.desktopTapThreshold = options.desktopTapThreshold;
        r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
        r.touchTapThreshold = options.touchTapThreshold;
        r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
        r.tapholdDuration = 500;

        r.bindings = [];
        r.beforeRenderCallbacks = [];
        r.beforeRenderPriorities = { // higher priority execs before lower one
          animations: 400,
          eleCalcs: 300,
          eleTxrDeq: 200,
          lyrTxrDeq: 100
        };

        r.registerNodeShapes();
        r.registerArrowShapes();
        r.registerCalculationListeners();
      };

      BRp.notify = function (params) {
        var types;
        var r = this;

        // the renderer can't be notified after it's destroyed
        if (this.destroyed) {
          return;
        }

        if (is.array(params.type)) {
          types = params.type;
        } else {
          types = [params.type];
        }

        var has = {};
        for (var i = 0; i < types.length; i++) {
          var type = types[i];

          has[type] = true;
        } // for

        if (has['init']) {
          r.load();
          return;
        }

        if (has['destroy']) {
          r.destroy();
          return;
        }

        if (has['add'] || has['remove'] || has['load'] || has['zorder']) {
          r.invalidateCachedZSortedEles();
        }

        if (has['viewport']) {
          r.redrawHint('select', true);
        }

        if (has['load'] || has['resize']) {
          r.invalidateContainerClientCoordsCache();
          r.matchCanvasSize(r.container);
        }

        r.redrawHint('eles', true);
        r.redrawHint('drag', true);

        this.startRenderLoop();

        this.redraw();
      };

      BRp.destroy = function () {
        var r = this;

        r.destroyed = true;

        r.cy.stopAnimationLoop();

        for (var i = 0; i < r.bindings.length; i++) {
          var binding = r.bindings[i];
          var b = binding;
          var tgt = b.target;

          (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
        }

        r.bindings = [];
        r.beforeRenderCallbacks = [];
        r.onUpdateEleCalcsFns = [];

        if (r.removeObserver) {
          r.removeObserver.disconnect();
        }

        if (r.styleObserver) {
          r.styleObserver.disconnect();
        }

        if (r.labelCalcDiv) {
          try {
            document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
          } catch (e) {
            // ie10 issue #1014
          }
        }
      };

      [__webpack_require__(110), __webpack_require__(111), __webpack_require__(121), __webpack_require__(122), __webpack_require__(123), __webpack_require__(124)].forEach(function (props) {
        util.extend(BRp, props);
      });

      module.exports = BR;

      /***/
    },
    /* 110 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var BRp = {};

      BRp.arrowShapeWidth = 0.3;

      BRp.registerArrowShapes = function () {
        var arrowShapes = this.arrowShapes = {};
        var renderer = this;

        // Contract for arrow shapes:
        // 0, 0 is arrow tip
        // (0, 1) is direction towards node
        // (1, 0) is right
        //
        // functional api:
        // collide: check x, y in shape
        // roughCollide: called before collide, no false negatives
        // draw: draw
        // spacing: dist(arrowTip, nodeBoundary)
        // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

        var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
          var x1 = translation.x - size / 2 - padding;
          var x2 = translation.x + size / 2 + padding;
          var y1 = translation.y - size / 2 - padding;
          var y2 = translation.y + size / 2 + padding;

          var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;

          return inside;
        };

        var transform = function transform(x, y, size, angle, translation) {
          var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
          var yRotated = x * Math.sin(angle) + y * Math.cos(angle);

          var xScaled = xRotated * size;
          var yScaled = yRotated * size;

          var xTranslated = xScaled + translation.x;
          var yTranslated = yScaled + translation.y;

          return {
            x: xTranslated,
            y: yTranslated
          };
        };

        var transformPoints = function transformPoints(pts, size, angle, translation) {
          var retPts = [];

          for (var i = 0; i < pts.length; i += 2) {
            var x = pts[i];
            var y = pts[i + 1];

            retPts.push(transform(x, y, size, angle, translation));
          }

          return retPts;
        };

        var pointsToArr = function pointsToArr(pts) {
          var ret = [];

          for (var i = 0; i < pts.length; i++) {
            var p = pts[i];

            ret.push(p.x, p.y);
          }

          return ret;
        };

        var standardGap = function standardGap(edge) {
          return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
        };

        var defineArrowShape = function defineArrowShape(name, defn) {
          if (is.string(defn)) {
            defn = arrowShapes[defn];
          }

          arrowShapes[name] = util.extend({
            name: name,

            points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],

            collide: function collide(x, y, size, angle, translation, padding) {
              var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
              var inside = math.pointInsidePolygonPoints(x, y, points);

              return inside;
            },

            roughCollide: bbCollide,

            draw: function draw(context, size, angle, translation) {
              var points = transformPoints(this.points, size, angle, translation);

              renderer.arrowShapeImpl('polygon')(context, points);
            },

            spacing: function spacing(edge) {
              return 0;
            },

            gap: standardGap
          }, defn);
        };

        defineArrowShape('none', {
          collide: util.falsify,

          roughCollide: util.falsify,

          draw: util.noop,

          spacing: util.zeroify,

          gap: util.zeroify
        });

        defineArrowShape('triangle', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
        });

        defineArrowShape('arrow', 'triangle');

        defineArrowShape('triangle-backcurve', {
          points: arrowShapes['triangle'].points,

          controlPoint: [0, -0.15],

          roughCollide: bbCollide,

          draw: function draw(context, size, angle, translation, edgeWidth) {
            var ptsTrans = transformPoints(this.points, size, angle, translation);
            var ctrlPt = this.controlPoint;
            var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);

            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
          },

          gap: function gap(edge) {
            return standardGap(edge) * 0.8;
          }
        });

        defineArrowShape('triangle-tee', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

          pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],

          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));

            var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

            return inside;
          },

          draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.points, size, angle, translation);
            var teePts = transformPoints(this.pointsTee, size, angle, translation);

            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
          }
        });

        defineArrowShape('triangle-cross', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

          baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
          -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
          0.15, -0.4],

          crossLinePts: function crossLinePts(size, edgeWidth) {
            // shift points so that the distance between the cross points matches edge width
            var p = this.baseCrossLinePts.slice();
            var shiftFactor = edgeWidth / size;
            var y0 = 3;
            var y1 = 5;

            p[y0] = p[y0] - shiftFactor;
            p[y1] = p[y1] - shiftFactor;

            return p;
          },

          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
            var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

            return inside;
          },

          draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.points, size, angle, translation);
            var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);

            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
          }
        });

        defineArrowShape('vee', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],

          gap: function gap(edge) {
            return standardGap(edge) * 0.525;
          }
        });

        defineArrowShape('circle', {
          radius: 0.15,

          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var t = translation;
            var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);

            return inside;
          },

          draw: function draw(context, size, angle, translation, edgeWidth) {
            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
          },

          spacing: function spacing(edge) {
            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
          }
        });

        defineArrowShape('tee', {
          points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],

          spacing: function spacing(edge) {
            return 1;
          },

          gap: function gap(edge) {
            return 1;
          }
        });

        defineArrowShape('square', {
          points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
        });

        defineArrowShape('diamond', {
          points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],

          gap: function gap(edge) {
            return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
          }
        });
      };

      module.exports = BRp;

      /***/
    },
    /* 111 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var BRp = {};

      [__webpack_require__(112), __webpack_require__(113), __webpack_require__(114), __webpack_require__(115), __webpack_require__(116), __webpack_require__(117), __webpack_require__(118), __webpack_require__(119), __webpack_require__(120)].forEach(function (props) {
        util.extend(BRp, props);
      });

      module.exports = BRp;

      /***/
    },
    /* 112 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var window = __webpack_require__(3);
      var math = __webpack_require__(2);
      var util = __webpack_require__(1);
      var window = __webpack_require__(3);

      var BRp = {};

      // Project mouse
      BRp.projectIntoViewport = function (clientX, clientY) {
        var cy = this.cy;
        var offsets = this.findContainerClientCoords();
        var offsetLeft = offsets[0];
        var offsetTop = offsets[1];
        var scale = offsets[4];
        var pan = cy.pan();
        var zoom = cy.zoom();

        var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
        var y = ((clientY - offsetTop) / scale - pan.y) / zoom;

        return [x, y];
      };

      BRp.findContainerClientCoords = function () {
        if (this.containerBB) {
          return this.containerBB;
        }

        var container = this.container;
        var rect = container.getBoundingClientRect();
        var style = window.getComputedStyle(container);
        var styleValue = function styleValue(name) {
          return parseFloat(style.getPropertyValue(name));
        };

        var padding = {
          left: styleValue('padding-left'),
          right: styleValue('padding-right'),
          top: styleValue('padding-top'),
          bottom: styleValue('padding-bottom')
        };

        var border = {
          left: styleValue('border-left-width'),
          right: styleValue('border-right-width'),
          top: styleValue('border-top-width'),
          bottom: styleValue('border-bottom-width')
        };

        var clientWidth = container.clientWidth;
        var clientHeight = container.clientHeight;

        var paddingHor = padding.left + padding.right;
        var paddingVer = padding.top + padding.bottom;

        var borderHor = border.left + border.right;
        var borderVer = border.top + border.bottom;

        var scale = rect.width / (clientWidth + borderHor);

        var unscaledW = clientWidth - paddingHor;
        var unscaledH = clientHeight - paddingVer;

        var scaledW = rect.width - (paddingHor + borderHor) * scale;
        var scaledH = rect.height - (paddingVer + borderVer) * scale;

        var left = rect.left + padding.left + border.left;
        var top = rect.top + padding.top + border.top;

        return this.containerBB = [left, top, unscaledW, unscaledH, scale];
      };

      BRp.invalidateContainerClientCoordsCache = function () {
        this.containerBB = null;
      };

      BRp.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
        return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
      };

      BRp.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
        var self = this;
        var r = this;
        var eles = r.getCachedZSortedEles();
        var near = []; // 1 node max, 1 edge max
        var zoom = r.cy.zoom();
        var hasCompounds = r.cy.hasCompoundNodes();
        var edgeThreshold = (isTouch ? 24 : 8) / zoom;
        var nodeThreshold = (isTouch ? 8 : 2) / zoom;
        var labelThreshold = (isTouch ? 8 : 2) / zoom;
        var minSqDist = Infinity;
        var nearEdge;
        var nearNode;

        if (interactiveElementsOnly) {
          eles = eles.interactive;
        }

        function addEle(ele, sqDist) {
          if (ele.isNode()) {
            if (nearNode) {
              return; // can't replace node
            } else {
              nearNode = ele;
              near.push(ele);
            }
          }

          if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
            if (nearEdge) {
              // then replace existing edge
              // can replace only if same z-index
              if (nearEdge.pstyle('z-index').value === ele.pstyle('z-index').value) {
                for (var i = 0; i < near.length; i++) {
                  if (near[i].isEdge()) {
                    near[i] = ele;
                    nearEdge = ele;
                    minSqDist = sqDist != null ? sqDist : minSqDist;
                    break;
                  }
                }
              }
            } else {
              near.push(ele);
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
            }
          }
        }

        function checkNode(node) {
          var width = node.outerWidth() + 2 * nodeThreshold;
          var height = node.outerHeight() + 2 * nodeThreshold;
          var hw = width / 2;
          var hh = height / 2;
          var pos = node.position();

          if (pos.x - hw <= x && x <= pos.x + hw // bb check x
          && pos.y - hh <= y && y <= pos.y + hh // bb check y
          ) {
              var shape = r.nodeShapes[self.getNodeShape(node)];

              if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
                addEle(node, 0);
                return true;
              }
            }
        }

        function checkEdge(edge) {
          var _p = edge._private;

          var rs = _p.rscratch;
          var styleWidth = edge.pstyle('width').pfValue;
          var scale = edge.pstyle('arrow-scale').value;
          var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
          var widthSq = width * width;
          var width2 = width * 2;
          var src = _p.source;
          var tgt = _p.target;
          var inEdgeBB = false;
          var sqDist;

          if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
            var pts = rs.allpts;

            for (var i = 0; i + 3 < pts.length; i += 2) {
              if ((inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2)) && widthSq > (sqDist = math.sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
                addEle(edge, sqDist);
                return true;
              }
            }
          } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
            var pts = rs.allpts;
            for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
              if ((inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2)) && widthSq > (sqDist = math.sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
                addEle(edge, sqDist);
                return true;
              }
            }
          }

          // if we're close to the edge but didn't hit it, maybe we hit its arrows

          var src = src || _p.source;
          var tgt = tgt || _p.target;

          var arSize = self.getArrowWidth(styleWidth, scale);

          var arrows = [{ name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle }, { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle }, { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle }, { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }];

          for (var i = 0; i < arrows.length; i++) {
            var ar = arrows[i];
            var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
            var edgeWidth = edge.pstyle('width').pfValue;
            if (shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold)) {
              addEle(edge);
              return true;
            }
          }

          // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
          if (hasCompounds && near.length > 0) {
            checkNode(src);
            checkNode(tgt);
          }
        }

        function preprop(obj, name, pre) {
          return util.getPrefixedProperty(obj, name, pre);
        }

        function checkLabel(ele, prefix) {
          var _p = ele._private;
          var th = labelThreshold;

          var prefixDash;
          if (prefix) {
            prefixDash = prefix + '-';
          } else {
            prefixDash = '';
          }

          var text = ele.pstyle(prefixDash + 'label').value;
          var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

          if (!eventsEnabled || !text) {
            return;
          }

          var rstyle = _p.rstyle;
          var bw = ele.pstyle('text-border-width').pfValue;
          var pw = ele.pstyle('text-background-padding').pfValue;
          var lw = preprop(rstyle, 'labelWidth', prefix) + bw + 2 * th + 2 * pw;
          var lh = preprop(rstyle, 'labelHeight', prefix) + bw + 2 * th + 2 * pw;
          var lx = preprop(rstyle, 'labelX', prefix);
          var ly = preprop(rstyle, 'labelY', prefix);

          var theta = preprop(_p.rscratch, 'labelAngle', prefix);

          var lx1 = lx - lw / 2;
          var lx2 = lx + lw / 2;
          var ly1 = ly - lh / 2;
          var ly2 = ly + lh / 2;

          if (theta) {
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);

            var rotate = function rotate(x, y) {
              x = x - lx;
              y = y - ly;

              return {
                x: x * cos - y * sin + lx,
                y: x * sin + y * cos + ly
              };
            };

            var px1y1 = rotate(lx1, ly1);
            var px1y2 = rotate(lx1, ly2);
            var px2y1 = rotate(lx2, ly1);
            var px2y2 = rotate(lx2, ly2);

            var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

            if (math.pointInsidePolygonPoints(x, y, points)) {
              addEle(ele);
              return true;
            }
          } else {
            // do a cheaper bb check
            var bb = {
              w: lw,
              h: lh,
              x1: lx1,
              x2: lx2,
              y1: ly1,
              y2: ly2
            };

            if (math.inBoundingBox(bb, x, y)) {
              addEle(ele);
              return true;
            }
          }
        }

        for (var i = eles.length - 1; i >= 0; i--) {
          // reverse order for precedence
          var ele = eles[i];

          if (ele.isNode()) {
            checkNode(ele) || checkLabel(ele);
          } else {
            // then edge
            checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
          }
        }

        return near;
      };

      // 'Give me everything from this box'
      BRp.getAllInBox = function (x1, y1, x2, y2) {
        var eles = this.getCachedZSortedEles().interactive;
        var box = [];

        var x1c = Math.min(x1, x2);
        var x2c = Math.max(x1, x2);
        var y1c = Math.min(y1, y2);
        var y2c = Math.max(y1, y2);

        x1 = x1c;
        x2 = x2c;
        y1 = y1c;
        y2 = y2c;

        var boxBb = math.makeBoundingBox({
          x1: x1, y1: y1,
          x2: x2, y2: y2
        });

        for (var e = 0; e < eles.length; e++) {
          var ele = eles[e];

          if (ele.isNode()) {
            var node = ele;
            var nodeBb = node.boundingBox({
              includeNodes: true,
              includeEdges: false,
              includeLabels: false
            });

            if (math.boundingBoxesIntersect(boxBb, nodeBb) && !math.boundingBoxInBoundingBox(nodeBb, boxBb)) {
              box.push(node);
            }
          } else {
            var edge = ele;
            var _p = edge._private;
            var rs = _p.rscratch;

            if (rs.startX != null && rs.startY != null && !math.inBoundingBox(boxBb, rs.startX, rs.startY)) {
              continue;
            }
            if (rs.endX != null && rs.endY != null && !math.inBoundingBox(boxBb, rs.endX, rs.endY)) {
              continue;
            }

            if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {

              var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
              var allInside = true;

              for (var i = 0; i < pts.length; i++) {
                if (!math.pointInBoundingBox(boxBb, pts[i])) {
                  allInside = false;
                  break;
                }
              }

              if (allInside) {
                box.push(edge);
              }
            } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
              box.push(edge);
            }
          }
        }

        return box;
      };

      module.exports = BRp;

      /***/
    },
    /* 113 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var BRp = {};

      BRp.calculateArrowAngles = function (edge) {
        var rs = edge._private.rscratch;
        var isHaystack = rs.edgeType === 'haystack';
        var isBezier = rs.edgeType === 'bezier';
        var isMultibezier = rs.edgeType === 'multibezier';
        var isSegments = rs.edgeType === 'segments';
        var isCompound = rs.edgeType === 'compound';
        var isSelf = rs.edgeType === 'self';

        // Displacement gives direction for arrowhead orientation
        var dispX, dispY;
        var startX, startY, endX, endY, midX, midY;

        if (isHaystack) {
          startX = rs.haystackPts[0];
          startY = rs.haystackPts[1];
          endX = rs.haystackPts[2];
          endY = rs.haystackPts[3];
        } else {
          startX = rs.arrowStartX;
          startY = rs.arrowStartY;
          endX = rs.arrowEndX;
          endY = rs.arrowEndY;
        }

        midX = rs.midX;
        midY = rs.midY;

        // source
        //

        if (isSegments) {
          dispX = startX - rs.segpts[0];
          dispY = startY - rs.segpts[1];
        } else if (isMultibezier || isCompound || isSelf || isBezier) {
          var pts = rs.allpts;
          var bX = math.qbezierAt(pts[0], pts[2], pts[4], 0.1);
          var bY = math.qbezierAt(pts[1], pts[3], pts[5], 0.1);

          dispX = startX - bX;
          dispY = startY - bY;
        } else {
          dispX = startX - midX;
          dispY = startY - midY;
        }

        rs.srcArrowAngle = math.getAngleFromDisp(dispX, dispY);

        // mid target
        //

        var midX = rs.midX;
        var midY = rs.midY;

        if (isHaystack) {
          midX = (startX + endX) / 2;
          midY = (startY + endY) / 2;
        }

        dispX = endX - startX;
        dispY = endY - startY;

        if (isSegments) {
          var pts = rs.allpts;

          if (pts.length / 2 % 2 === 0) {
            var i2 = pts.length / 2;
            var i1 = i2 - 2;

            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
          } else {
            var i2 = pts.length / 2 - 1;
            var i1 = i2 - 2;
            var i3 = i2 + 2;

            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
          }
        } else if (isMultibezier || isCompound || isSelf) {
          var pts = rs.allpts;
          var cpts = rs.ctrlpts;
          var bp0x, bp0y;
          var bp1x, bp1y;

          if (cpts.length / 2 % 2 === 0) {
            var p0 = pts.length / 2 - 1; // startpt
            var ic = p0 + 2;
            var p1 = ic + 2;

            bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
            bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);

            bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
            bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
          } else {
            var ic = pts.length / 2 - 1; // ctrpt
            var p0 = ic - 2; // startpt
            var p1 = ic + 2; // endpt

            bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
            bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);

            bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
            bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
          }

          dispX = bp1x - bp0x;
          dispY = bp1y - bp0y;
        }

        rs.midtgtArrowAngle = math.getAngleFromDisp(dispX, dispY);

        rs.midDispX = dispX;
        rs.midDispY = dispY;

        // mid source
        //

        dispX *= -1;
        dispY *= -1;

        if (isSegments) {
          var pts = rs.allpts;

          if (pts.length / 2 % 2 === 0) {
            // already ok
          } else {
            var i2 = pts.length / 2 - 1;
            var i3 = i2 + 2;

            dispX = -(pts[i3] - pts[i2]);
            dispY = -(pts[i3 + 1] - pts[i2 + 1]);
          }
        }

        rs.midsrcArrowAngle = math.getAngleFromDisp(dispX, dispY);

        // target
        //

        if (isSegments) {
          dispX = endX - rs.segpts[rs.segpts.length - 2];
          dispY = endY - rs.segpts[rs.segpts.length - 1];
        } else if (isMultibezier || isCompound || isSelf || isBezier) {
          var pts = rs.allpts;
          var l = pts.length;
          var bX = math.qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
          var bY = math.qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);

          dispX = endX - bX;
          dispY = endY - bY;
        } else {
          dispX = endX - midX;
          dispY = endY - midY;
        }

        rs.tgtArrowAngle = math.getAngleFromDisp(dispX, dispY);
      };

      BRp.getArrowWidth = BRp.getArrowHeight = function (edgeWidth, scale) {
        var cache = this.arrowWidthCache = this.arrowWidthCache || {};

        var cachedVal = cache[edgeWidth + ', ' + scale];
        if (cachedVal) {
          return cachedVal;
        }

        cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
        cache[edgeWidth + ', ' + scale] = cachedVal;

        return cachedVal;
      };

      module.exports = BRp;

      /***/
    },
    /* 114 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var BRp = {};

      BRp.findEdgeControlPoints = function (edges) {
        if (!edges || edges.length === 0) {
          return;
        }

        var r = this;
        var cy = r.cy;
        var hasCompounds = cy.hasCompoundNodes();
        var hashTable = {};
        var pairIds = [];
        var haystackEdges = [];

        // create a table of edge (src, tgt) => list of edges between them
        var pairId;
        for (var i = 0; i < edges.length; i++) {
          var edge = edges[i];
          var _p = edge._private;
          var data = _p.data;
          var curveStyle = edge.pstyle('curve-style').value;
          var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';
          var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';

          // ignore edges who are not to be displayed
          // they shouldn't take up space
          if (edge.pstyle('display').value === 'none') {
            continue;
          }

          if (curveStyle === 'haystack') {
            haystackEdges.push(edge);
            continue;
          }

          var srcId = data.source;
          var tgtId = data.target;

          pairId = srcId > tgtId ? tgtId + '$-$' + srcId : srcId + '$-$' + tgtId;

          if (edgeIsUnbundled) {
            pairId = 'unbundled' + '$-$' + data.id;
          }

          var tableEntry = hashTable[pairId];

          if (tableEntry == null) {
            tableEntry = hashTable[pairId] = [];
            pairIds.push(pairId);
          }

          tableEntry.push(edge);

          if (edgeIsUnbundled) {
            tableEntry.hasUnbundled = true;
          }

          if (edgeIsBezier) {
            tableEntry.hasBezier = true;
          }
        }

        var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
        var vectorNormInverse;
        var badBezier;

        // for each pair (src, tgt), create the ctrl pts
        // Nested for loop is OK; total number of iterations for both loops = edgeCount
        for (var p = 0; p < pairIds.length; p++) {
          pairId = pairIds[p];
          var pairEdges = hashTable[pairId];

          // for each pair id, the edges should be sorted by index
          pairEdges.sort(function (edge1, edge2) {
            return edge1.poolIndex() - edge2.poolIndex();
          });

          src = pairEdges[0]._private.source;
          tgt = pairEdges[0]._private.target;

          // make sure src/tgt distinction is consistent for bundled edges
          if (!pairEdges.hasUnbundled && src.id() > tgt.id()) {
            var temp = src;
            src = tgt;
            tgt = temp;
          }

          srcPos = src.position();
          tgtPos = tgt.position();

          srcW = src.outerWidth();
          srcH = src.outerHeight();

          tgtW = tgt.outerWidth();
          tgtH = tgt.outerHeight();

          srcShape = r.nodeShapes[this.getNodeShape(src)];
          tgtShape = r.nodeShapes[this.getNodeShape(tgt)];

          badBezier = false;

          var edge;
          var edge_p;
          var rs;

          var dirCounts = {
            'north': 0,
            'west': 0,
            'south': 0,
            'east': 0,
            'northwest': 0,
            'southwest': 0,
            'northeast': 0,
            'southeast': 0
          };

          var srcX2 = srcPos.x;
          var srcY2 = srcPos.y;
          var srcW2 = srcW;
          var srcH2 = srcH;

          var tgtX2 = tgtPos.x;
          var tgtY2 = tgtPos.y;
          var tgtW2 = tgtW;
          var tgtH2 = tgtH;

          var numEdges2 = pairEdges.length;

          for (var i = 0; i < pairEdges.length; i++) {
            edge = pairEdges[i];
            edge_p = edge._private;
            rs = edge_p.rscratch;

            var edgeIndex1 = rs.lastEdgeIndex;
            var edgeIndex2 = i;

            var numEdges1 = rs.lastNumEdges;

            var curveStyle = edge.pstyle('curve-style').value;

            var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

            // whether the normalised pair order is the reverse of the edge's src-tgt order
            var edgeIsSwapped = src.id() !== edge.source().id();

            var ctrlptDists = edge.pstyle('control-point-distances');
            var loopDir = edge.pstyle('loop-direction').pfValue;
            var loopSwp = edge.pstyle('loop-sweep').pfValue;
            var ctrlptWs = edge.pstyle('control-point-weights');
            var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
            var stepSize = edge.pstyle('control-point-step-size').pfValue;
            var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
            var ctrlptWeight = ctrlptWs.value[0];
            var edgeDistances = edge.pstyle('edge-distances').value;
            var segmentWs = edge.pstyle('segment-weights');
            var segmentDs = edge.pstyle('segment-distances');
            var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
            var srcEndpt = edge.pstyle('source-endpoint').value;
            var tgtEndpt = edge.pstyle('target-endpoint').value;
            var srcArrShape = edge.pstyle('source-arrow-shape').value;
            var tgtArrShape = edge.pstyle('target-arrow-shape').value;
            var arrowScale = edge.pstyle('arrow-scale').value;
            var lineWidth = edge.pstyle('width').pfValue;

            var srcX1 = rs.lastSrcCtlPtX;
            var srcY1 = rs.lastSrcCtlPtY;
            var srcW1 = rs.lastSrcCtlPtW;
            var srcH1 = rs.lastSrcCtlPtH;

            var tgtX1 = rs.lastTgtCtlPtX;
            var tgtY1 = rs.lastTgtCtlPtY;
            var tgtW1 = rs.lastTgtCtlPtW;
            var tgtH1 = rs.lastTgtCtlPtH;

            var curveStyle1 = rs.lastCurveStyle;
            var curveStyle2 = curveStyle;

            var ctrlptDists1 = rs.lastCtrlptDists;
            var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;

            var ctrlptWs1 = rs.lastCtrlptWs;
            var ctrlptWs2 = ctrlptWs.strValue;

            var segmentWs1 = rs.lastSegmentWs;
            var segmentWs2 = segmentWs.strValue;

            var segmentDs1 = rs.lastSegmentDs;
            var segmentDs2 = segmentDs.strValue;

            var stepSize1 = rs.lastStepSize;
            var stepSize2 = stepSize;

            var loopDir1 = rs.lastLoopDir;
            var loopDir2 = loopDir;

            var loopSwp1 = rs.lastLoopSwp;
            var loopSwp2 = loopSwp;

            var edgeDistances1 = rs.lastEdgeDistances;
            var edgeDistances2 = edgeDistances;

            var srcEndpt1 = rs.lastSrcEndpt;
            var srcEndpt2 = srcEndpt;

            var tgtEndpt1 = rs.lastTgtEndpt;
            var tgtEndpt2 = tgtEndpt;

            var srcArr1 = rs.lastSrcArr;
            var srcArr2 = srcArrShape;

            var tgtArr1 = rs.lastTgtArr;
            var tgtArr2 = tgtArrShape;

            var lineW1 = rs.lastLineW;
            var lineW2 = lineWidth;

            var arrScl1 = rs.lastArrScl;
            var arrScl2 = arrowScale;

            if (badBezier) {
              rs.badBezier = true;
            } else {
              rs.badBezier = false;
            }

            var ptCacheHit;

            if (srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2 && tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2 && curveStyle1 === curveStyle2 && ctrlptDists1 === ctrlptDists2 && ctrlptWs1 === ctrlptWs2 && segmentWs1 === segmentWs2 && segmentDs1 === segmentDs2 && stepSize1 === stepSize2 && loopDir1 === loopDir2 && loopSwp1 === loopSwp2 && edgeDistances1 === edgeDistances2 && srcEndpt1 === srcEndpt2 && tgtEndpt1 === tgtEndpt2 && srcArr1 === srcArr2 && tgtArr1 === tgtArr2 && lineW1 === lineW2 && arrScl1 === arrScl2 && (edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2 || edgeIsUnbundled)) {
              ptCacheHit = true; // then the control points haven't changed and we can skip calculating them
            } else {
              ptCacheHit = false;

              rs.lastSrcCtlPtX = srcX2;
              rs.lastSrcCtlPtY = srcY2;
              rs.lastSrcCtlPtW = srcW2;
              rs.lastSrcCtlPtH = srcH2;
              rs.lastTgtCtlPtX = tgtX2;
              rs.lastTgtCtlPtY = tgtY2;
              rs.lastTgtCtlPtW = tgtW2;
              rs.lastTgtCtlPtH = tgtH2;
              rs.lastEdgeIndex = edgeIndex2;
              rs.lastNumEdges = numEdges2;
              rs.lastCurveStyle = curveStyle2;
              rs.lastCtrlptDists = ctrlptDists2;
              rs.lastCtrlptWs = ctrlptWs2;
              rs.lastSegmentDs = segmentDs2;
              rs.lastSegmentWs = segmentWs2;
              rs.lastStepSize = stepSize2;
              rs.lastLoopDir = loopDir2;
              rs.lastLoopSwp = loopSwp2;
              rs.lastEdgeDistances = edgeDistances2;
              rs.lastSrcEndpt = srcEndpt2;
              rs.lastTgtEndpt = tgtEndpt2;
              rs.lastSrcArr = srcArr2;
              rs.lastTgtArr = tgtArr2;
              rs.lastLineW = lineW2;
              rs.lastArrScl = arrScl2;
            }

            if (!ptCacheHit) {

              if (!pairEdges.calculatedIntersection && src !== tgt && (pairEdges.hasBezier || pairEdges.hasUnbundled)) {

                pairEdges.calculatedIntersection = true;

                // pt outside src shape to calc distance/displacement from src to tgt
                var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);

                pairEdges.srcIntn = srcOutside;

                // pt outside tgt shape to calc distance/displacement from src to tgt
                var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);

                pairEdges.tgtIntn = tgtOutside;

                var midptSrcPts = {
                  x1: srcOutside[0],
                  x2: tgtOutside[0],
                  y1: srcOutside[1],
                  y2: tgtOutside[1]
                };

                var posPts = {
                  x1: srcPos.x,
                  x2: tgtPos.x,
                  y1: srcPos.y,
                  y2: tgtPos.y
                };

                var dy = tgtOutside[1] - srcOutside[1];
                var dx = tgtOutside[0] - srcOutside[0];
                var l = Math.sqrt(dx * dx + dy * dy);

                var vector = {
                  x: dx,
                  y: dy
                };

                var vectorNorm = {
                  x: vector.x / l,
                  y: vector.y / l
                };
                vectorNormInverse = {
                  x: -vectorNorm.y,
                  y: vectorNorm.x
                };

                // if node shapes overlap, then no ctrl pts to draw
                if (tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) && srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y)) {
                  vectorNormInverse = {};
                  badBezier = true;
                }
              }

              if (!edgeIsSwapped) {
                rs.srcIntn = pairEdges.srcIntn;
                rs.tgtIntn = pairEdges.tgtIntn;
              } else {
                // ensure that the per-edge cached value for intersections are correct for swapped bundled edges
                rs.srcIntn = pairEdges.tgtIntn;
                rs.tgtIntn = pairEdges.srcIntn;
              }

              if (src === tgt) {
                // Self-edge

                rs.edgeType = 'self';

                var j = i;
                var loopDist = stepSize;

                if (edgeIsUnbundled) {
                  j = 0;
                  loopDist = ctrlptDist;
                }

                var loopAngle = loopDir - Math.PI / 2;
                var outAngle = loopAngle - loopSwp / 2;
                var inAngle = loopAngle + loopSwp / 2;

                // increase by step size for overlapping loops, keyed on direction and sweep values
                var dc = String(loopDir + '_' + loopSwp);
                j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

                rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
              } else if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src))) {
                // Compound edge

                rs.edgeType = 'compound';

                // because the line approximation doesn't apply for compound beziers
                // (loop/self edges are already elided b/c of cheap src==tgt check)
                rs.badBezier = false;

                var j = i;
                var loopDist = stepSize;

                if (edgeIsUnbundled) {
                  j = 0;
                  loopDist = ctrlptDist;
                }

                var loopW = 50;

                var loopaPos = {
                  x: srcPos.x - srcW / 2,
                  y: srcPos.y - srcH / 2
                };

                var loopbPos = {
                  x: tgtPos.x - tgtW / 2,
                  y: tgtPos.y - tgtH / 2
                };

                var loopPos = {
                  x: Math.min(loopaPos.x, loopbPos.x),
                  y: Math.min(loopaPos.y, loopbPos.y)
                };

                // avoids cases with impossible beziers
                var minCompoundStretch = 0.5;
                var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
                var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));

                rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
              } else if (curveStyle === 'segments') {
                // Segments (multiple straight lines)

                rs.edgeType = 'segments';
                rs.segpts = [];

                for (var s = 0; s < segmentsN; s++) {
                  var w = segmentWs.pfValue[s];
                  var d = segmentDs.pfValue[s];

                  var w1 = 1 - w;
                  var w2 = w;

                  var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

                  var adjustedMidpt = {
                    x: midptPts.x1 * w1 + midptPts.x2 * w2,
                    y: midptPts.y1 * w1 + midptPts.y2 * w2
                  };

                  rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
                }

                // Straight edge
              } else if (pairEdges.length % 2 === 1 && i === Math.floor(pairEdges.length / 2) && !edgeIsUnbundled) {

                rs.edgeType = 'straight';
              } else {
                // (Multi)bezier

                var multi = edgeIsUnbundled;

                rs.edgeType = multi ? 'multibezier' : 'bezier';
                rs.ctrlpts = [];

                for (var b = 0; b < bezierN; b++) {
                  var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
                  var manctrlptDist;
                  var sign = math.signum(normctrlptDist);

                  if (multi) {
                    ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
                    ctrlptWeight = ctrlptWs.value[b];
                  }

                  if (edgeIsUnbundled) {
                    // multi or single unbundled
                    manctrlptDist = ctrlptDist;
                  } else {
                    manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
                  }

                  var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

                  var w1 = 1 - ctrlptWeight;
                  var w2 = ctrlptWeight;

                  if (edgeIsSwapped) {
                    var temp = w1;
                    w1 = w2;
                    w2 = temp;
                  }

                  var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

                  var adjustedMidpt = {
                    x: midptPts.x1 * w1 + midptPts.x2 * w2,
                    y: midptPts.y1 * w1 + midptPts.y2 * w2
                  };

                  rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
                }
              }

              // find endpts for edge
              this.findEndpoints(edge);

              var badStart = !is.number(rs.startX) || !is.number(rs.startY);
              var badAStart = !is.number(rs.arrowStartX) || !is.number(rs.arrowStartY);
              var badEnd = !is.number(rs.endX) || !is.number(rs.endY);
              var badAEnd = !is.number(rs.arrowEndX) || !is.number(rs.arrowEndY);

              var minCpADistFactor = 3;
              var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
              var minCpADist = minCpADistFactor * arrowW;

              if (rs.edgeType === 'bezier') {
                var startACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY });
                var closeStartACp = startACpDist < minCpADist;
                var endACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY });
                var closeEndACp = endACpDist < minCpADist;

                var overlapping = false;

                if (badStart || badAStart || closeStartACp) {
                  overlapping = true;

                  // project control point along line from src centre to outside the src shape
                  // (otherwise intersection will yield nothing)
                  var cpD = { // delta
                    x: rs.ctrlpts[0] - srcPos.x,
                    y: rs.ctrlpts[1] - srcPos.y
                  };
                  var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
                  var cpM = { // normalised delta
                    x: cpD.x / cpL,
                    y: cpD.y / cpL
                  };
                  var radius = Math.max(srcW, srcH);
                  var cpProj = { // *2 radius guarantees outside shape
                    x: rs.ctrlpts[0] + cpM.x * 2 * radius,
                    y: rs.ctrlpts[1] + cpM.y * 2 * radius
                  };

                  var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

                  if (closeStartACp) {
                    rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
                    rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
                  } else {
                    rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
                    rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
                  }
                }

                if (badEnd || badAEnd || closeEndACp) {
                  overlapping = true;

                  // project control point along line from tgt centre to outside the tgt shape
                  // (otherwise intersection will yield nothing)
                  var cpD = { // delta
                    x: rs.ctrlpts[0] - tgtPos.x,
                    y: rs.ctrlpts[1] - tgtPos.y
                  };
                  var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
                  var cpM = { // normalised delta
                    x: cpD.x / cpL,
                    y: cpD.y / cpL
                  };
                  var radius = Math.max(srcW, srcH);
                  var cpProj = { // *2 radius guarantees outside shape
                    x: rs.ctrlpts[0] + cpM.x * 2 * radius,
                    y: rs.ctrlpts[1] + cpM.y * 2 * radius
                  };

                  var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, cpProj.x, cpProj.y, 0);

                  if (closeEndACp) {
                    rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
                    rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
                  } else {
                    rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
                    rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
                  }
                }

                if (overlapping) {
                  // recalc endpts
                  this.findEndpoints(edge);
                }
              }

              if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
                rs.allpts = [];

                rs.allpts.push(rs.startX, rs.startY);

                for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
                  // ctrl pt itself
                  rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);

                  // the midpt between ctrlpts as intermediate destination pts
                  if (b + 3 < rs.ctrlpts.length) {
                    rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
                  }
                }

                rs.allpts.push(rs.endX, rs.endY);

                var m, mt;
                if (rs.ctrlpts.length / 2 % 2 === 0) {
                  m = rs.allpts.length / 2 - 1;

                  rs.midX = rs.allpts[m];
                  rs.midY = rs.allpts[m + 1];
                } else {
                  m = rs.allpts.length / 2 - 3;
                  mt = 0.5;

                  rs.midX = math.qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
                  rs.midY = math.qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
                }
              } else if (rs.edgeType === 'straight') {
                // need to calc these after endpts
                rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];

                // default midpt for labels etc
                rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
                rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
              } else if (rs.edgeType === 'segments') {
                rs.allpts = [];
                rs.allpts.push(rs.startX, rs.startY);
                rs.allpts.push.apply(rs.allpts, rs.segpts);
                rs.allpts.push(rs.endX, rs.endY);

                if (rs.segpts.length % 4 === 0) {
                  var i2 = rs.segpts.length / 2;
                  var i1 = i2 - 2;

                  rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
                  rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
                } else {
                  var i1 = rs.segpts.length / 2 - 1;

                  rs.midX = rs.segpts[i1];
                  rs.midY = rs.segpts[i1 + 1];
                }
              }

              this.storeEdgeProjections(edge);
              this.calculateArrowAngles(edge);
            } // if point cache miss

            this.recalculateEdgeLabelProjections(edge);
            this.calculateLabelAngles(edge);
          } // for pair edges
        } // for pair ids

        for (var i = 0; i < haystackEdges.length; i++) {
          var edge = haystackEdges[i];
          var _p = edge._private;
          var rscratch = _p.rscratch;
          var rs = rscratch;

          if (!rscratch.haystack) {
            var angle = Math.random() * 2 * Math.PI;

            rscratch.source = {
              x: Math.cos(angle),
              y: Math.sin(angle)
            };

            var angle = Math.random() * 2 * Math.PI;

            rscratch.target = {
              x: Math.cos(angle),
              y: Math.sin(angle)
            };
          }

          var src = _p.source;
          var tgt = _p.target;
          var srcPos = src.position();
          var tgtPos = tgt.position();
          var srcW = src.width();
          var tgtW = tgt.width();
          var srcH = src.height();
          var tgtH = tgt.height();
          var radius = edge.pstyle('haystack-radius').value;
          var halfRadius = radius / 2; // b/c have to half width/height

          rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];

          rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
          rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

          // always override as haystack in case set to different type previously
          rscratch.edgeType = rscratch.lastCurveStyle = 'haystack';
          rscratch.haystack = true;

          this.storeEdgeProjections(edge);
          this.calculateArrowAngles(edge);
          this.recalculateEdgeLabelProjections(edge);
          this.calculateLabelAngles(edge);
        }
      };

      function getPts(pts) {
        var retPts = [];

        if (pts == null) {
          return;
        }

        for (var i = 0; i < pts.length; i += 2) {
          var x = pts[i];
          var y = pts[i + 1];

          retPts.push({ x: x, y: y });
        }

        return retPts;
      }

      BRp.getSegmentPoints = function (edge) {
        var rs = edge[0]._private.rscratch;
        var type = rs.edgeType;

        if (type === 'segments') {
          return getPts(rs.segpts);
        }
      };

      BRp.getControlPoints = function (edge) {
        var rs = edge[0]._private.rscratch;
        var type = rs.edgeType;

        if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
          return getPts(rs.ctrlpts);
        }
      };

      BRp.getEdgeMidpoint = function (edge) {
        var rs = edge[0]._private.rscratch;

        return {
          x: rs.midX,
          y: rs.midY
        };
      };

      module.exports = BRp;

      /***/
    },
    /* 115 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);

      var BRp = {};

      BRp.manualEndptToPx = function (node, prop) {
        var r = this;
        var npos = node.position();
        var w = node.outerWidth();
        var h = node.outerHeight();

        if (prop.value.length === 2) {
          var p = [prop.pfValue[0], prop.pfValue[1]];

          if (prop.units[0] === '%') {
            p[0] = p[0] * w;
          }

          if (prop.units[1] === '%') {
            p[1] = p[1] * h;
          }

          p[0] += npos.x;
          p[1] += npos.y;

          return p;
        } else {
          var angle = prop.pfValue[0];

          angle = -Math.PI / 2 + angle; // start at 12 o'clock

          var l = 2 * Math.max(w, h);

          var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];

          return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
        }
      };

      BRp.findEndpoints = function (edge) {
        var r = this;
        var intersect = void 0;

        var source = edge.source()[0];
        var target = edge.target()[0];

        var srcPos = source.position();
        var tgtPos = target.position();

        var tgtArShape = edge.pstyle('target-arrow-shape').value;
        var srcArShape = edge.pstyle('source-arrow-shape').value;

        var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
        var srcDist = edge.pstyle('source-distance-from-node').pfValue;

        var rs = edge._private.rscratch;

        var et = rs.edgeType;
        var self = et === 'self' || et === 'compound';
        var bezier = et === 'bezier' || et === 'multibezier' || self;
        var multi = et !== 'bezier';
        var lines = et === 'straight' || et === 'segments';
        var segments = et === 'segments';
        var hasEndpts = bezier || multi || lines;
        var srcManEndpt = edge.pstyle('source-endpoint');
        var srcManEndptVal = self ? 'outside-to-node' : srcManEndpt.value;
        var tgtManEndpt = edge.pstyle('target-endpoint');
        var tgtManEndptVal = self ? 'outside-to-node' : tgtManEndpt.value;

        rs.srcManEndpt = srcManEndpt;
        rs.tgtManEndpt = tgtManEndpt;

        var p1 = void 0; // last known point of edge on target side
        var p2 = void 0; // last known point of edge on source side

        var p1_i = void 0; // point to intersect with target shape
        var p2_i = void 0; // point to intersect with source shape

        if (bezier) {
          var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
          var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;

          p1 = cpEnd;
          p2 = cpStart;
        } else if (lines) {
          var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
          var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);

          p1 = tgtArrowFromPt;
          p2 = srcArrowFromPt;
        }

        if (tgtManEndptVal === 'inside-to-node') {
          intersect = [tgtPos.x, tgtPos.y];
        } else if (tgtManEndpt.units) {
          intersect = this.manualEndptToPx(target, tgtManEndpt);
        } else if (tgtManEndptVal === 'outside-to-line') {
          intersect = rs.tgtIntn; // use cached value from ctrlpt calc
        } else {
          if (tgtManEndptVal === 'outside-to-node') {
            p1_i = p1;
          } else if (tgtManEndptVal === 'outside-to-line') {
            p1_i = [srcPos.x, srcPos.y];
          }

          intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);
        }

        var arrowEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
        var edgeEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);

        rs.endX = edgeEnd[0];
        rs.endY = edgeEnd[1];

        rs.arrowEndX = arrowEnd[0];
        rs.arrowEndY = arrowEnd[1];

        if (srcManEndptVal === 'inside-to-node') {
          intersect = [srcPos.x, srcPos.y];
        } else if (srcManEndpt.units) {
          intersect = this.manualEndptToPx(source, srcManEndpt);
        } else if (srcManEndptVal === 'outside-to-line') {
          intersect = rs.srcIntn; // use cached value from ctrlpt calc
        } else {
          if (srcManEndptVal === 'outside-to-node') {
            p2_i = p2;
          } else if (srcManEndptVal === 'outside-to-line') {
            p2_i = [tgtPos.x, tgtPos.y];
          }

          intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);
        }

        var arrowStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
        var edgeStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);

        rs.startX = edgeStart[0];
        rs.startY = edgeStart[1];

        rs.arrowStartX = arrowStart[0];
        rs.arrowStartY = arrowStart[1];

        if (hasEndpts) {
          if (!is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY)) {
            rs.badLine = true;
          } else {
            rs.badLine = false;
          }
        }
      };

      BRp.getSourceEndpoint = function (edge) {
        var rs = edge[0]._private.rscratch;

        switch (rs.edgeType) {
          case 'haystack':
            return {
              x: rs.haystackPts[0],
              y: rs.haystackPts[1]
            };
          default:
            return {
              x: rs.arrowStartX,
              y: rs.arrowStartY
            };
        }
      };

      BRp.getTargetEndpoint = function (edge) {
        var rs = edge[0]._private.rscratch;

        switch (rs.edgeType) {
          case 'haystack':
            return {
              x: rs.haystackPts[2],
              y: rs.haystackPts[3]
            };
          default:
            return {
              x: rs.arrowEndX,
              y: rs.arrowEndY
            };
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 116 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var BRp = {};

      function pushBezierPts(r, edge, pts) {
        var qbezierAt = function qbezierAt(p1, p2, p3, t) {
          return math.qbezierAt(p1, p2, p3, t);
        };
        var _p = edge._private;
        var bpts = _p.rstyle.bezierPts;

        for (var i = 0; i < r.bezierProjPcts.length; i++) {
          var p = r.bezierProjPcts[i];

          bpts.push({
            x: qbezierAt(pts[0], pts[2], pts[4], p),
            y: qbezierAt(pts[1], pts[3], pts[5], p)
          });
        }
      }

      BRp.storeEdgeProjections = function (edge) {
        var _p = edge._private;
        var rs = _p.rscratch;
        var et = rs.edgeType;

        // clear the cached points state
        _p.rstyle.bezierPts = null;
        _p.rstyle.linePts = null;
        _p.rstyle.haystackPts = null;

        if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
          var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

          for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
            pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
          }
        } else if (et === 'segments') {
          var lpts = _p.rstyle.linePts = [];

          for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
            lpts.push({
              x: rs.allpts[i],
              y: rs.allpts[i + 1]
            });
          }
        } else if (et === 'haystack') {
          var hpts = rs.haystackPts;

          _p.rstyle.haystackPts = [{ x: hpts[0], y: hpts[1] }, { x: hpts[2], y: hpts[3] }];
        }

        _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
      };

      BRp.recalculateEdgeProjections = function (edges) {
        this.findEdgeControlPoints(edges);
      };

      module.exports = BRp;

      /***/
    },
    /* 117 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var is = __webpack_require__(0);
      var util = __webpack_require__(1);

      var BRp = {};

      BRp.recalculateNodeLabelProjection = function (node) {
        var content = node.pstyle('label').strValue;

        if (is.emptyString(content)) {
          return;
        }

        var textX, textY;
        var _p = node._private;
        var nodeWidth = node.width();
        var nodeHeight = node.height();
        var padding = node.padding();
        var nodePos = node.position();
        var textHalign = node.pstyle('text-halign').strValue;
        var textValign = node.pstyle('text-valign').strValue;
        var rs = _p.rscratch;
        var rstyle = _p.rstyle;

        switch (textHalign) {
          case 'left':
            textX = nodePos.x - nodeWidth / 2 - padding;
            break;

          case 'right':
            textX = nodePos.x + nodeWidth / 2 + padding;
            break;

          default:
            // e.g. center
            textX = nodePos.x;
        }

        switch (textValign) {
          case 'top':
            textY = nodePos.y - nodeHeight / 2 - padding;
            break;

          case 'bottom':
            textY = nodePos.y + nodeHeight / 2 + padding;
            break;

          default:
            // e.g. middle
            textY = nodePos.y;
        }

        rs.labelX = textX;
        rs.labelY = textY;
        rstyle.labelX = textX;
        rstyle.labelY = textY;

        this.applyLabelDimensions(node);
      };

      BRp.recalculateEdgeLabelProjections = function (edge) {
        var p;
        var _p = edge._private;
        var rs = _p.rscratch;
        var r = this;
        var content = {
          mid: edge.pstyle('label').strValue,
          source: edge.pstyle('source-label').strValue,
          target: edge.pstyle('target-label').strValue
        };

        if (content.mid || content.source || content.target) {
          // then we have to calculate...
        } else {
            return; // no labels => no calcs
          }

        // add center point to style so bounding box calculations can use it
        //
        p = {
          x: rs.midX,
          y: rs.midY
        };

        var setRs = function setRs(propName, prefix, value) {
          util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
          util.setPrefixedProperty(_p.rstyle, propName, prefix, value);
        };

        setRs('labelX', null, p.x);
        setRs('labelY', null, p.y);

        var createControlPointInfo = function createControlPointInfo() {
          if (createControlPointInfo.cache) {
            return createControlPointInfo.cache;
          } // use cache so only 1x per edge

          var ctrlpts = [];

          // store each ctrlpt info init
          for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
            var p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
            var p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] }; // ctrlpt
            var p2 = { x: rs.allpts[i + 4], y: rs.allpts[i + 5] };

            ctrlpts.push({
              p0: p0,
              p1: p1,
              p2: p2,
              startDist: 0,
              length: 0,
              segments: []
            });
          }

          var bpts = _p.rstyle.bezierPts;
          var nProjs = r.bezierProjPcts.length;

          function addSegment(cp, p0, p1, t0, t1) {
            var length = math.dist(p0, p1);
            var prevSegment = cp.segments[cp.segments.length - 1];
            var segment = {
              p0: p0,
              p1: p1,
              t0: t0,
              t1: t1,
              startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
              length: length
            };

            cp.segments.push(segment);

            cp.length += length;
          }

          // update each ctrlpt with segment info
          for (var i = 0; i < ctrlpts.length; i++) {
            var cp = ctrlpts[i];
            var prevCp = ctrlpts[i - 1];

            if (prevCp) {
              cp.startDist = prevCp.startDist + prevCp.length;
            }

            addSegment(cp, cp.p0, bpts[i * nProjs], 0, r.bezierProjPcts[0]); // first

            for (var j = 0; j < nProjs - 1; j++) {
              addSegment(cp, bpts[i * nProjs + j], bpts[i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
            }

            addSegment(cp, bpts[i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
          }

          return createControlPointInfo.cache = ctrlpts;
        };

        var calculateEndProjection = function calculateEndProjection(prefix) {
          var angle;
          var isSrc = prefix === 'source';

          if (!content[prefix]) {
            return;
          }

          var offset = edge.pstyle(prefix + '-text-offset').pfValue;

          var lineAngle = function lineAngle(p0, p1) {
            var dx = p1.x - p0.x;
            var dy = p1.y - p0.y;

            return Math.atan(dy / dx);
          };

          var bezierAngle = function bezierAngle(p0, p1, p2, t) {
            var t0 = math.bound(0, t - 0.001, 1);
            var t1 = math.bound(0, t + 0.001, 1);

            var lp0 = math.qbezierPtAt(p0, p1, p2, t0);
            var lp1 = math.qbezierPtAt(p0, p1, p2, t1);

            return lineAngle(lp0, lp1);
          };

          switch (rs.edgeType) {
            case 'self':
            case 'compound':
            case 'bezier':
            case 'multibezier':
              var cps = createControlPointInfo();
              var selected;
              var startDist = 0;
              var totalDist = 0;

              // find the segment we're on
              for (var i = 0; i < cps.length; i++) {
                var cp = cps[isSrc ? i : cps.length - 1 - i];

                for (var j = 0; j < cp.segments.length; j++) {
                  var seg = cp.segments[isSrc ? j : cp.segments.length - 1 - j];
                  var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

                  startDist = totalDist;
                  totalDist += seg.length;

                  if (totalDist >= offset || lastSeg) {
                    selected = { cp: cp, segment: seg };
                    break;
                  }
                }

                if (selected) {
                  break;
                }
              }

              var cp = selected.cp;
              var seg = selected.segment;
              var tSegment = (offset - startDist) / seg.length;
              var segDt = seg.t1 - seg.t0;
              var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

              t = math.bound(0, t, 1);
              p = math.qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
              angle = bezierAngle(cp.p0, cp.p1, cp.p2, t, p);

              break;

            case 'straight':
            case 'segments':
            case 'haystack':
              var d = 0,
                  di,
                  d0;
              var p0, p1;
              var l = rs.allpts.length;

              for (var i = 0; i + 3 < l; i += 2) {
                if (isSrc) {
                  p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
                  p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] };
                } else {
                  p0 = { x: rs.allpts[l - 2 - i], y: rs.allpts[l - 1 - i] };
                  p1 = { x: rs.allpts[l - 4 - i], y: rs.allpts[l - 3 - i] };
                }

                di = math.dist(p0, p1);
                d0 = d;
                d += di;

                if (d >= offset) {
                  break;
                }
              }

              var pD = offset - d0;
              var t = pD / di;

              t = math.bound(0, t, 1);
              p = math.lineAt(p0, p1, t);
              angle = lineAngle(p0, p1);

              break;
          }

          setRs('labelX', prefix, p.x);
          setRs('labelY', prefix, p.y);
          setRs('labelAutoAngle', prefix, angle);
        };

        calculateEndProjection('source');
        calculateEndProjection('target');

        this.applyLabelDimensions(edge);
      };

      BRp.applyLabelDimensions = function (ele) {
        this.applyPrefixedLabelDimensions(ele);

        if (ele.isEdge()) {
          this.applyPrefixedLabelDimensions(ele, 'source');
          this.applyPrefixedLabelDimensions(ele, 'target');
        }
      };

      BRp.applyPrefixedLabelDimensions = function (ele, prefix) {
        var _p = ele._private;

        var text = this.getLabelText(ele, prefix);
        var labelDims = this.calculateLabelDimensions(ele, text);

        util.setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, labelDims.width);
        util.setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, labelDims.width);

        util.setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, labelDims.height);
        util.setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, labelDims.height);
      };

      BRp.getLabelText = function (ele, prefix) {
        var _p = ele._private;
        var pfd = prefix ? prefix + '-' : '';
        var text = ele.pstyle(pfd + 'label').strValue;
        var textTransform = ele.pstyle('text-transform').value;
        var rscratch = function rscratch(propName, value) {
          if (value) {
            util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
            return value;
          } else {
            return util.getPrefixedProperty(_p.rscratch, propName, prefix);
          }
        };

        if (textTransform == 'none') {
          // passthrough
        } else if (textTransform == 'uppercase') {
          text = text.toUpperCase();
        } else if (textTransform == 'lowercase') {
          text = text.toLowerCase();
        }

        var wrapStyle = ele.pstyle('text-wrap').value;

        if (wrapStyle === 'wrap') {
          //console.log('wrap');

          var labelKey = rscratch('labelKey');

          // save recalc if the label is the same as before
          if (labelKey && rscratch('labelWrapKey') === labelKey) {
            // console.log('wrap cache hit');
            return rscratch('labelWrapCachedText');
          }
          // console.log('wrap cache miss');

          var lines = text.split('\n');
          var maxW = ele.pstyle('text-max-width').pfValue;
          var wrappedLines = [];

          for (var l = 0; l < lines.length; l++) {
            var line = lines[l];
            var lineDims = this.calculateLabelDimensions(ele, line, 'line=' + line);
            var lineW = lineDims.width;

            if (lineW > maxW) {
              // line is too long
              var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
              var subline = '';

              for (var w = 0; w < words.length; w++) {
                var word = words[w];
                var testLine = subline.length === 0 ? word : subline + ' ' + word;
                var testDims = this.calculateLabelDimensions(ele, testLine, 'testLine=' + testLine);
                var testW = testDims.width;

                if (testW <= maxW) {
                  // word fits on current line
                  subline += word + ' ';
                } else {
                  // word starts new line
                  wrappedLines.push(subline);
                  subline = word + ' ';
                }
              }

              // if there's remaining text, put it in a wrapped line
              if (!subline.match(/^\s+$/)) {
                wrappedLines.push(subline);
              }
            } else {
              // line is already short enough
              wrappedLines.push(line);
            }
          } // for

          rscratch('labelWrapCachedLines', wrappedLines);
          text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
          rscratch('labelWrapKey', labelKey);

          // console.log(text)
        } else if (wrapStyle === 'ellipsis') {
          var maxW = ele.pstyle('text-max-width').pfValue;
          var ellipsized = '';
          var ellipsis = '\u2026';
          var incLastCh = false;

          for (var i = 0; i < text.length; i++) {
            var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

            if (widthWithNextCh > maxW) {
              break;
            }

            ellipsized += text[i];

            if (i === text.length - 1) {
              incLastCh = true;
            }
          }

          if (!incLastCh) {
            ellipsized += ellipsis;
          }

          return ellipsized;
        } // if ellipsize

        return text;
      };

      BRp.calculateLabelDimensions = function (ele, text, extraKey) {
        var r = this;

        var cacheKey = ele._private.labelStyleKey + '$@$' + text;

        if (extraKey) {
          cacheKey += '$@$' + extraKey;
        }

        var cache = r.labelDimCache || (r.labelDimCache = {});

        if (cache[cacheKey]) {
          return cache[cacheKey];
        }

        var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
        var fStyle = ele.pstyle('font-style').strValue;
        var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
        var family = ele.pstyle('font-family').strValue;
        var weight = ele.pstyle('font-weight').strValue;

        var div = this.labelCalcDiv;

        if (!div) {
          div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef
          document.body.appendChild(div); // eslint-disable-line no-undef
        }

        var ds = div.style;

        // from ele style
        ds.fontFamily = family;
        ds.fontStyle = fStyle;
        ds.fontSize = size;
        ds.fontWeight = weight;

        // forced style
        ds.position = 'absolute';
        ds.left = '-9999px';
        ds.top = '-9999px';
        ds.zIndex = '-1';
        ds.visibility = 'hidden';
        ds.pointerEvents = 'none';
        ds.padding = '0';
        ds.lineHeight = '1';

        if (ele.pstyle('text-wrap').value === 'wrap') {
          ds.whiteSpace = 'pre'; // so newlines are taken into account
        } else {
          ds.whiteSpace = 'normal';
        }

        // put label content in div
        div.textContent = text;

        cache[cacheKey] = {
          width: Math.ceil(div.clientWidth / sizeMult),
          height: Math.ceil(div.clientHeight / sizeMult)
        };

        return cache[cacheKey];
      };

      BRp.calculateLabelAngles = function (ele) {
        var _p = ele._private;
        var rs = _p.rscratch;
        var isEdge = ele.isEdge();
        var rot = ele.pstyle('text-rotation');
        var rotStr = rot.strValue;

        if (rotStr === 'none') {
          rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
        } else if (isEdge && rotStr === 'autorotate') {
          rs.labelAngle = Math.atan(rs.midDispY / rs.midDispX);
          rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
          rs.targetLabelAngle = rs.targetLabelAutoAngle;
        } else if (rotStr === 'autorotate') {
          rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
        } else {
          rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 118 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var BRp = {};

      BRp.getNodeShape = function (node) {
        var r = this;
        var shape = node.pstyle('shape').value;

        if (node.isParent()) {
          if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
            return shape;
          } else {
            return 'rectangle';
          }
        }

        if (shape === 'polygon') {
          var points = node.pstyle('shape-polygon-points').value;

          return r.nodeShapes.makePolygon(points).name;
        }

        return shape;
      };

      module.exports = BRp;

      /***/
    },
    /* 119 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var BRp = {};

      BRp.registerCalculationListeners = function () {
        var cy = this.cy;
        var elesToUpdate = cy.collection();
        var r = this;

        var enqueue = function enqueue(eles, e) {
          var dirtyStyleCaches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          elesToUpdate.merge(eles);

          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var _p = ele._private;
            var rstyle = _p.rstyle;

            if (dirtyStyleCaches) {
              rstyle.clean = false;
              _p.bbCache = null;
            }

            var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

            if (!evts[e.type]) {
              evts[e.type] = true;
              evts.length++;
            }
          }
        };

        r.binder(cy)
        // nodes

        .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode(e) {
          var node = e.target;

          enqueue(node, e);
          enqueue(node.connectedEdges(), e);
        }).on('add.*', 'node', function onDirtyAddNode(e) {
          var ele = e.target;

          enqueue(ele, e);
        }).on('background.*', 'node', function onDirtyBgNode(e) {
          var ele = e.target;

          enqueue(ele, e, false);
        })

        // edges

        .on('add.* style.*', 'edge', function onDirtyEdge(e) {
          var edge = e.target;

          enqueue(edge, e);
          enqueue(edge.parallelEdges(), e);
        }).on('remove.*', 'edge', function onDirtyRemoveEdge(e) {
          var edge = e.target;
          var pEdges = edge.parallelEdges();

          for (var i = 0; i < pEdges.length; i++) {
            var pEdge = pEdges[i];

            if (!pEdge.removed()) {
              enqueue(pEdge, e);
            }
          }
        })

        // manual dirtying

        .on('dirty.*', 'node', function onDirtyEle(e) {
          var ele = e.target;

          enqueue(ele, e);
        });

        var updateEleCalcs = function updateEleCalcs(willDraw) {
          if (willDraw) {
            var fns = r.onUpdateEleCalcsFns;

            if (fns) {
              for (var i = 0; i < fns.length; i++) {
                var fn = fns[i];

                fn(willDraw, elesToUpdate);
              }
            }

            r.recalculateRenderedStyle(elesToUpdate, false);

            for (var i = 0; i < elesToUpdate.length; i++) {
              elesToUpdate[i]._private.rstyle.dirtyEvents = null;
            }

            elesToUpdate = cy.collection();
          }
        };

        r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
      };

      BRp.onUpdateEleCalcs = function (fn) {
        var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

        fns.push(fn);
      };

      BRp.recalculateRenderedStyle = function (eles, useCache) {
        var edges = [];
        var nodes = [];

        // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
        if (this.destroyed) {
          return;
        }

        // use cache by default for perf
        if (useCache === undefined) {
          useCache = true;
        }

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _p = ele._private;
          var rstyle = _p.rstyle;

          // only update if dirty and in graph
          if (useCache && rstyle.clean || ele.removed()) {
            continue;
          }

          // only update if not display: none
          if (ele.pstyle('display').value === 'none') {
            continue;
          }

          if (_p.group === 'nodes') {
            nodes.push(ele);
          } else {
            // edges
            edges.push(ele);
          }

          rstyle.clean = true;
          // rstyle.dirtyEvents = null;
        }

        // update node data from projections
        for (var i = 0; i < nodes.length; i++) {
          var ele = nodes[i];
          var _p = ele._private;
          var rstyle = _p.rstyle;
          var pos = ele.position();

          this.recalculateNodeLabelProjection(ele);

          rstyle.nodeX = pos.x;
          rstyle.nodeY = pos.y;
          rstyle.nodeW = ele.pstyle('width').pfValue;
          rstyle.nodeH = ele.pstyle('height').pfValue;
        }

        this.recalculateEdgeProjections(edges);

        // update edge data from projections
        for (var i = 0; i < edges.length; i++) {
          var ele = edges[i];
          var _p = ele._private;
          var rstyle = _p.rstyle;
          var rs = _p.rscratch;

          this.recalculateEdgeLabelProjections(ele);

          // update rstyle positions
          rstyle.srcX = rs.arrowStartX;
          rstyle.srcY = rs.arrowStartY;
          rstyle.tgtX = rs.arrowEndX;
          rstyle.tgtY = rs.arrowEndY;
          rstyle.midX = rs.midX;
          rstyle.midY = rs.midY;
          rstyle.labelAngle = rs.labelAngle;
          rstyle.sourceLabelAngle = rs.sourceLabelAngle;
          rstyle.targetLabelAngle = rs.targetLabelAngle;
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 120 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var zIndexSort = __webpack_require__(17);

      var BRp = {};

      BRp.updateCachedGrabbedEles = function () {
        var eles = this.cachedZSortedEles;

        if (!eles) {
          // just let this be recalculated on the next z sort tick
          return;
        }

        eles.drag = [];
        eles.nondrag = [];

        var grabTargets = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var rs = ele._private.rscratch;

          if (ele.grabbed() && !ele.isParent()) {
            grabTargets.push(ele);
          } else if (rs.inDragLayer) {
            eles.drag.push(ele);
          } else {
            eles.nondrag.push(ele);
          }
        }

        // put the grab target nodes last so it's on top of its neighbourhood
        for (var i = 0; i < grabTargets.length; i++) {
          var ele = grabTargets[i];

          eles.drag.push(ele);
        }
      };

      BRp.invalidateCachedZSortedEles = function () {
        this.cachedZSortedEles = null;
      };

      BRp.getCachedZSortedEles = function (forceRecalc) {
        if (forceRecalc || !this.cachedZSortedEles) {
          //console.time('cachezorder')

          var eles = this.cy.mutableElements().toArray();

          eles.sort(zIndexSort);

          eles.interactive = eles.filter(function (ele) {
            return ele.interactive();
          });

          this.cachedZSortedEles = eles;

          this.updateCachedGrabbedEles();
        } else {
          eles = this.cachedZSortedEles;
        }

        return eles;
      };

      module.exports = BRp;

      /***/
    },
    /* 121 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var BRp = {};

      BRp.getCachedImage = function (url, crossOrigin, onLoad) {
        var r = this;
        var imageCache = r.imageCache = r.imageCache || {};
        var cache = imageCache[url];

        if (cache) {
          if (!cache.image.complete) {
            cache.image.addEventListener('load', onLoad);
          }

          return cache.image;
        } else {
          cache = imageCache[url] = imageCache[url] || {};

          var image = cache.image = new Image(); // eslint-disable-line no-undef

          image.addEventListener('load', onLoad);
          image.addEventListener('error', function () {
            image.error = true;
          });

          // #1582 safari doesn't load data uris with crossOrigin properly
          // https://bugs.webkit.org/show_bug.cgi?id=123978
          var dataUriPrefix = 'data:';
          var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
          if (!isDataUri) {
            image.crossOrigin = crossOrigin; // prevent tainted canvas
          }

          image.src = url;

          return image;
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 122 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var Event = __webpack_require__(16);

      var BRp = {};

      BRp.registerBinding = function (target, event, handler, useCapture) {
        var args = Array.prototype.slice.apply(arguments, [1]); // copy
        var b = this.binder(target);

        return b.on.apply(b, args);
      };

      BRp.binder = function (tgt) {
        var r = this;

        var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement(tgt);

        if (r.supportsPassiveEvents == null) {

          // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
          var supportsPassive = false;
          try {
            var opts = Object.defineProperty({}, 'passive', {
              get: function get() {
                supportsPassive = true;
              }
            });

            window.addEventListener('test', null, opts);
          } catch (err) {}

          r.supportsPassiveEvents = supportsPassive;
        }

        var on = function on(event, handler, useCapture) {
          var args = Array.prototype.slice.call(arguments);

          if (tgtIsDom && r.supportsPassiveEvents) {
            // replace useCapture w/ opts obj
            args[2] = {
              capture: useCapture != null ? useCapture : false,
              passive: false,
              once: false
            };
          }

          r.bindings.push({
            target: tgt,
            args: args
          });

          (tgt.addEventListener || tgt.on).apply(tgt, args);

          return this;
        };

        return {
          on: on,
          addEventListener: on,
          addListener: on,
          bind: on
        };
      };

      BRp.nodeIsDraggable = function (node) {
        return node && node.isNode() && !node.locked() && node.grabbable();
      };

      BRp.nodeIsGrabbable = function (node) {
        return this.nodeIsDraggable(node) && node.interactive();
      };

      BRp.load = function () {
        var r = this;

        var triggerEvents = function triggerEvents(target, names, e, props) {
          if (target == null) {
            target = r.cy;
          }

          for (var i = 0; i < names.length; i++) {
            var name = names[i];

            target.emit(util.extend({ originalEvent: e, type: name }, props));
          }
        };

        var isMultSelKeyDown = function isMultSelKeyDown(e) {
          return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
        };

        var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
          var allowPassthrough = true;

          if (r.cy.hasCompoundNodes() && down && down.isEdge()) {
            // a compound node below the edge => no passthrough panning
            for (var i = 0; downs && i < downs.length; i++) {
              var down = downs[i];

              if (down.isNode() && down.isParent()) {
                allowPassthrough = false;
                break;
              }
            }
          } else {
            allowPassthrough = true;
          }

          return allowPassthrough;
        };

        var getDragListIds = function getDragListIds(opts) {
          var listHasId;

          if (opts.addToList && r.cy.hasCompoundNodes()) {
            // only needed for compound graphs
            if (!opts.addToList.hasId) {
              // build ids lookup if doesn't already exist
              opts.addToList.hasId = {};

              for (var i = 0; i < opts.addToList.length; i++) {
                var ele = opts.addToList[i];

                opts.addToList.hasId[ele.id()] = true;
              }
            }

            listHasId = opts.addToList.hasId;
          }

          return listHasId || {};
        };

        var setGrabbed = function setGrabbed(ele) {
          ele[0]._private.grabbed = true;
        };

        var setFreed = function setFreed(ele) {
          ele[0]._private.grabbed = false;
        };

        var setInDragLayer = function setInDragLayer(ele) {
          ele[0]._private.rscratch.inDragLayer = true;
        };

        var setOutDragLayer = function setOutDragLayer(ele) {
          ele[0]._private.rscratch.inDragLayer = false;
        };

        var setGrabTarget = function setGrabTarget(ele) {
          ele[0]._private.rscratch.isGrabTarget = true;
        };

        var removeGrabTarget = function removeGrabTarget(ele) {
          ele[0]._private.rscratch.isGrabTarget = false;
        };

        var addToDragList = function addToDragList(ele, opts) {
          var listHasId = getDragListIds(opts);

          if (!listHasId[ele.id()]) {
            opts.addToList.push(ele);
            listHasId[ele.id()] = true;

            setGrabbed(ele);
          }
        };

        // helper function to determine which child nodes and inner edges
        // of a compound node to be dragged as well as the grabbed and selected nodes
        var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
          if (!node.cy().hasCompoundNodes()) {
            return;
          }

          if (opts.inDragLayer == null && opts.addToList == null) {
            return;
          } // nothing to do

          var innerNodes = node.descendants();

          if (opts.inDragLayer) {
            innerNodes.forEach(setInDragLayer);
            innerNodes.connectedEdges().forEach(setInDragLayer);
          }

          if (opts.addToList) {
            innerNodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }
        };

        // adds the given nodes and its neighbourhood to the drag layer
        var addNodesToDrag = function addNodesToDrag(nodes, opts) {
          opts = opts || {};

          var hasCompoundNodes = nodes.cy().hasCompoundNodes();

          if (opts.inDragLayer) {
            nodes.forEach(setInDragLayer);

            nodes.neighborhood().stdFilter(function (ele) {
              return !hasCompoundNodes || ele.isEdge();
            }).forEach(setInDragLayer);
          }

          if (opts.addToList) {
            nodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }

          addDescendantsToDrag(nodes, opts); // always add to drag

          // also add nodes and edges related to the topmost ancestor
          updateAncestorsInDragLayer(nodes, {
            inDragLayer: opts.inDragLayer
          });

          r.updateCachedGrabbedEles();
        };

        var addNodeToDrag = addNodesToDrag;

        var freeDraggedElements = function freeDraggedElements(grabbedEles) {
          if (!grabbedEles) {
            return;
          }

          grabbedEles.hasId = {}; // clear the id list

          // just go over all elements rather than doing a bunch of (possibly expensive) traversals
          r.getCachedZSortedEles().forEach(function (ele) {
            setFreed(ele);
            setOutDragLayer(ele);
            removeGrabTarget(ele);
          });

          r.updateCachedGrabbedEles();
        };

        // helper function to determine which ancestor nodes and edges should go
        // to the drag layer (or should be removed from drag layer).
        var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {

          if (opts.inDragLayer == null && opts.addToList == null) {
            return;
          } // nothing to do

          if (!node.cy().hasCompoundNodes()) {
            return;
          }

          // find top-level parent
          var parent = node.ancestors().orphans();

          // no parent node: no nodes to add to the drag layer
          if (parent.same(node)) {
            return;
          }

          var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());

          var edges = nodes.connectedEdges();

          if (opts.inDragLayer) {
            edges.forEach(setInDragLayer);
            nodes.forEach(setInDragLayer);
          }

          if (opts.addToList) {
            nodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }
        };

        var haveMutationsApi = typeof MutationObserver !== 'undefined';

        // watch for when the cy container is removed from the dom
        if (haveMutationsApi) {
          r.removeObserver = new MutationObserver(function (mutns) {
            // eslint-disable-line no-undef
            for (var i = 0; i < mutns.length; i++) {
              var mutn = mutns[i];
              var rNodes = mutn.removedNodes;

              if (rNodes) {
                for (var j = 0; j < rNodes.length; j++) {
                  var rNode = rNodes[j];

                  if (rNode === r.container) {
                    r.destroy();
                    break;
                  }
                }
              }
            }
          });

          if (r.container.parentNode) {
            r.removeObserver.observe(r.container.parentNode, { childList: true });
          }
        } else {
          r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
            r.destroy();
          });
        }

        var onResize = util.debounce(function () {
          r.cy.resize();
        }, 100);

        if (haveMutationsApi) {
          r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

          r.styleObserver.observe(r.container, { attributes: true });
        }

        // auto resize
        r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

        var forEachUp = function forEachUp(domEle, fn) {
          while (domEle != null) {
            fn(domEle);

            domEle = domEle.parentNode;
          }
        };

        var invalidateCoords = function invalidateCoords() {
          r.invalidateContainerClientCoordsCache();
        };

        forEachUp(r.container, function (domEle) {
          r.registerBinding(domEle, 'transitionend', invalidateCoords);
          r.registerBinding(domEle, 'animationend', invalidateCoords);
          r.registerBinding(domEle, 'scroll', invalidateCoords);
        });

        // stop right click menu from appearing on cy
        r.registerBinding(r.container, 'contextmenu', function (e) {
          e.preventDefault();
        });

        var inBoxSelection = function inBoxSelection() {
          return r.selection[4] !== 0;
        };

        var eventInContainer = function eventInContainer(e) {
          // save cycles if mouse events aren't to be captured
          var containerPageCoords = r.findContainerClientCoords();
          var x = containerPageCoords[0];
          var y = containerPageCoords[1];
          var width = containerPageCoords[2];
          var height = containerPageCoords[3];

          var positions = e.touches ? e.touches : [e];
          var atLeastOnePosInside = false;

          for (var i = 0; i < positions.length; i++) {
            var p = positions[i];

            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
              atLeastOnePosInside = true;
              break;
            }
          }

          if (!atLeastOnePosInside) {
            return false;
          }

          var container = r.container;
          var target = e.target;
          var tParent = target.parentNode;
          var containerIsTarget = false;

          while (tParent) {
            if (tParent === container) {
              containerIsTarget = true;
              break;
            }

            tParent = tParent.parentNode;
          }

          if (!containerIsTarget) {
            return false;
          } // if target is outisde cy container, then this event is not for us

          return true;
        };

        // Primary key
        r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
          if (!eventInContainer(e)) {
            return;
          }

          e.preventDefault();
          r.hoverData.capture = true;
          r.hoverData.which = e.which;

          var cy = r.cy;
          var gpos = [e.clientX, e.clientY];
          var pos = r.projectIntoViewport(gpos[0], gpos[1]);
          var select = r.selection;
          var nears = r.findNearestElements(pos[0], pos[1], true, false);
          var near = nears[0];
          var draggedElements = r.dragData.possibleDragElements;

          r.hoverData.mdownPos = pos;
          r.hoverData.mdownGPos = gpos;

          var checkForTaphold = function checkForTaphold() {
            r.hoverData.tapholdCancelled = false;

            clearTimeout(r.hoverData.tapholdTimeout);

            r.hoverData.tapholdTimeout = setTimeout(function () {

              if (r.hoverData.tapholdCancelled) {
                return;
              } else {
                var ele = r.hoverData.down;

                if (ele) {
                  ele.emit({
                    originalEvent: e,
                    type: 'taphold',
                    position: { x: pos[0], y: pos[1] }
                  });
                } else {
                  cy.emit({
                    originalEvent: e,
                    type: 'taphold',
                    position: { x: pos[0], y: pos[1] }
                  });
                }
              }
            }, r.tapholdDuration);
          };

          // Right click button
          if (e.which == 3) {

            r.hoverData.cxtStarted = true;

            var cxtEvt = {
              originalEvent: e,
              type: 'cxttapstart',
              position: { x: pos[0], y: pos[1] }
            };

            if (near) {
              near.activate();
              near.emit(cxtEvt);

              r.hoverData.down = near;
            } else {
              cy.emit(cxtEvt);
            }

            r.hoverData.downTime = new Date().getTime();
            r.hoverData.cxtDragged = false;

            // Primary button
          } else if (e.which == 1) {

            if (near) {
              near.activate();
            }

            // Element dragging
            {
              // If something is under the cursor and it is draggable, prepare to grab it
              if (near != null) {

                if (r.nodeIsGrabbable(near)) {

                  var makeEvent = function makeEvent(type) {
                    return {
                      originalEvent: e,
                      type: type,
                      position: { x: pos[0], y: pos[1] }
                    };
                  };

                  var triggerGrab = function triggerGrab(ele) {
                    ele.emit(makeEvent('grab'));
                  };

                  setGrabTarget(near);

                  if (!near.selected()) {

                    draggedElements = r.dragData.possibleDragElements = [];
                    addNodeToDrag(near, { addToList: draggedElements });

                    near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
                  } else {
                    draggedElements = r.dragData.possibleDragElements = [];

                    var selectedNodes = cy.$(function (ele) {
                      return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
                    });

                    addNodesToDrag(selectedNodes, { addToList: draggedElements });

                    near.emit(makeEvent('grabon'));

                    selectedNodes.forEach(triggerGrab);
                  }

                  r.redrawHint('eles', true);
                  r.redrawHint('drag', true);
                }
              }

              r.hoverData.down = near;
              r.hoverData.downs = nears;
              r.hoverData.downTime = new Date().getTime();
            }

            triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
              position: { x: pos[0], y: pos[1] }
            });

            if (near == null) {
              select[4] = 1;

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.redrawHint('select', true);

              r.redraw();
            } else if (near.isEdge()) {
              select[4] = 1; // for future pan
            }

            checkForTaphold();
          }

          // Initialize selection box coordinates
          select[0] = select[2] = pos[0];
          select[1] = select[3] = pos[1];
        }, false);

        r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
          // eslint-disable-line no-undef
          var capture = r.hoverData.capture;

          if (!capture && !eventInContainer(e)) {
            return;
          }

          var preventDefault = false;
          var cy = r.cy;
          var zoom = cy.zoom();
          var gpos = [e.clientX, e.clientY];
          var pos = r.projectIntoViewport(gpos[0], gpos[1]);
          var mdownPos = r.hoverData.mdownPos;
          var mdownGPos = r.hoverData.mdownGPos;
          var select = r.selection;

          var near = null;
          if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
            near = r.findNearestElement(pos[0], pos[1], true, false);
          }
          var last = r.hoverData.last;
          var down = r.hoverData.down;

          var disp = [pos[0] - select[2], pos[1] - select[3]];

          var draggedElements = r.dragData.possibleDragElements;

          var isOverThresholdDrag;

          if (mdownGPos) {
            var dx = gpos[0] - mdownGPos[0];
            var dx2 = dx * dx;
            var dy = gpos[1] - mdownGPos[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;

            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
          }

          var multSelKeyDown = isMultSelKeyDown(e);

          if (isOverThresholdDrag) {
            r.hoverData.tapholdCancelled = true;
          }

          var updateDragDelta = function updateDragDelta() {
            var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

            if (dragDelta.length === 0) {
              dragDelta.push(disp[0]);
              dragDelta.push(disp[1]);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          };

          preventDefault = true;

          triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
            position: { x: pos[0], y: pos[1] }
          });

          var goIntoBoxMode = function goIntoBoxMode() {
            r.data.bgActivePosistion = undefined;

            if (!r.hoverData.selecting) {
              cy.emit('boxstart');
            }

            select[4] = 1;
            r.hoverData.selecting = true;

            r.redrawHint('select', true);
            r.redraw();
          };

          // trigger context drag if rmouse down
          if (r.hoverData.which === 3) {
            // but only if over threshold
            if (isOverThresholdDrag) {
              var cxtEvt = {
                originalEvent: e,
                type: 'cxtdrag',
                position: { x: pos[0], y: pos[1] }
              };

              if (down) {
                down.emit(cxtEvt);
              } else {
                cy.emit(cxtEvt);
              }

              r.hoverData.cxtDragged = true;

              if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {

                if (r.hoverData.cxtOver) {
                  r.hoverData.cxtOver.emit({
                    originalEvent: e,
                    type: 'cxtdragout',
                    position: { x: pos[0], y: pos[1] }
                  });
                }

                r.hoverData.cxtOver = near;

                if (near) {
                  near.emit({
                    originalEvent: e,
                    type: 'cxtdragover',
                    position: { x: pos[0], y: pos[1] }
                  });
                }
              }
            }

            // Check if we are drag panning the entire graph
          } else if (r.hoverData.dragging) {
            preventDefault = true;

            if (cy.panningEnabled() && cy.userPanningEnabled()) {
              var deltaP;

              if (r.hoverData.justStartedPan) {
                var mdPos = r.hoverData.mdownPos;

                deltaP = {
                  x: (pos[0] - mdPos[0]) * zoom,
                  y: (pos[1] - mdPos[1]) * zoom
                };

                r.hoverData.justStartedPan = false;
              } else {
                deltaP = {
                  x: disp[0] * zoom,
                  y: disp[1] * zoom
                };
              }

              cy.panBy(deltaP);

              r.hoverData.dragged = true;
            }

            // Needs reproject due to pan changing viewport
            pos = r.projectIntoViewport(e.clientX, e.clientY);

            // Checks primary button down & out of time & mouse not moved much
          } else if (select[4] == 1 && (down == null || down.isEdge())) {

            if (isOverThresholdDrag) {

              if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
                goIntoBoxMode();
              } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
                var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

                if (allowPassthrough) {
                  r.hoverData.dragging = true;
                  r.hoverData.justStartedPan = true;
                  select[4] = 0;

                  r.data.bgActivePosistion = math.array2point(mdownPos);

                  r.redrawHint('select', true);
                  r.redraw();
                }
              }

              if (down && down.isEdge() && down.active()) {
                down.unactivate();
              }
            }
          } else {
            if (down && down.isEdge() && down.active()) {
              down.unactivate();
            }

            if ((!down || !down.grabbed()) && near != last) {

              if (last) {
                triggerEvents(last, ['mouseout', 'tapdragout'], e, {
                  position: { x: pos[0], y: pos[1] }
                });
              }

              if (near) {
                triggerEvents(near, ['mouseover', 'tapdragover'], e, {
                  position: { x: pos[0], y: pos[1] }
                });
              }

              r.hoverData.last = near;
            }

            if (down) {

              if (isOverThresholdDrag) {
                // then we can take action

                if (cy.boxSelectionEnabled() && multSelKeyDown) {
                  // then selection overrides
                  if (down && down.grabbed()) {
                    freeDraggedElements(draggedElements);

                    down.emit('free');
                  }

                  goIntoBoxMode();
                } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
                  // drag node
                  var justStartedDrag = !r.dragData.didDrag;

                  if (justStartedDrag) {
                    r.redrawHint('eles', true);
                  }

                  r.dragData.didDrag = true; // indicate that we actually did drag the node

                  var toTrigger = [];

                  // now, add the elements to the drag layer if not done already
                  if (!r.hoverData.draggingEles) {
                    addNodesToDrag(cy.collection(draggedElements), { inDragLayer: true });
                  }

                  for (var i = 0; i < draggedElements.length; i++) {
                    var dEle = draggedElements[i];

                    // Locked nodes not draggable, as well as non-visible nodes
                    if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                      var dPos = dEle.position();

                      toTrigger.push(dEle);

                      if (is.number(disp[0]) && is.number(disp[1])) {
                        dPos.x += disp[0];
                        dPos.y += disp[1];

                        if (justStartedDrag) {
                          var dragDelta = r.hoverData.dragDelta;

                          if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                            dPos.x += dragDelta[0];
                            dPos.y += dragDelta[1];
                          }
                        }
                      }
                    }
                  }

                  r.hoverData.draggingEles = true;

                  var tcol = cy.collection(toTrigger);

                  tcol.dirtyCompoundBoundsCache();
                  tcol.emit('position drag');

                  r.redrawHint('drag', true);
                  r.redraw();
                }
              } else {
                // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
                updateDragDelta();
              }
            }

            // prevent the dragging from triggering text selection on the page
            preventDefault = true;
          }

          select[2] = pos[0];select[3] = pos[1];

          if (preventDefault) {
            if (e.stopPropagation) e.stopPropagation();
            if (e.preventDefault) e.preventDefault();
            return false;
          }
        }, false);

        r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
          // eslint-disable-line no-undef
          var capture = r.hoverData.capture;
          if (!capture) {
            return;
          }
          r.hoverData.capture = false;

          var cy = r.cy;var pos = r.projectIntoViewport(e.clientX, e.clientY);var select = r.selection;
          var near = r.findNearestElement(pos[0], pos[1], true, false);
          var draggedElements = r.dragData.possibleDragElements;var down = r.hoverData.down;
          var multSelKeyDown = isMultSelKeyDown(e);

          if (r.data.bgActivePosistion) {
            r.redrawHint('select', true);
            r.redraw();
          }

          r.hoverData.tapholdCancelled = true;

          r.data.bgActivePosistion = undefined; // not active bg now

          if (down) {
            down.unactivate();
          }

          if (r.hoverData.which === 3) {
            var cxtEvt = {
              originalEvent: e,
              type: 'cxttapend',
              position: { x: pos[0], y: pos[1] }
            };

            if (down) {
              down.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }

            if (!r.hoverData.cxtDragged) {
              var cxtTap = {
                originalEvent: e,
                type: 'cxttap',
                position: { x: pos[0], y: pos[1] }
              };

              if (down) {
                down.emit(cxtTap);
              } else {
                cy.emit(cxtTap);
              }
            }

            r.hoverData.cxtDragged = false;
            r.hoverData.which = null;
          } else if (r.hoverData.which === 1) {

            // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
            if (down == null && // not mousedown on node
            !r.dragData.didDrag // didn't move the node around
            && !r.hoverData.selecting // not box selection
            && !r.hoverData.dragged // didn't pan
            && !isMultSelKeyDown(e)) {

              cy.$(function (ele) {
                return ele.selected();
              }).unselect();

              if (draggedElements.length > 0) {
                r.redrawHint('eles', true);
              }

              r.dragData.possibleDragElements = draggedElements = [];
            }

            triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
              position: { x: pos[0], y: pos[1] }
            });

            if (!r.dragData.didDrag // didn't move a node around
            && !r.hoverData.dragged // didn't pan
            && !r.hoverData.selecting // not box selection
            && !r.hoverData.isOverThresholdDrag // didn't move too much
            ) {
                triggerEvents(down, ['click', 'tap', 'vclick'], e, {
                  position: { x: pos[0], y: pos[1] }
                });
              }

            // Single selection
            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
              if (near != null && near._private.selectable) {

                if (r.hoverData.dragging) {
                  // if panning, don't change selection state
                } else if (cy.selectionType() === 'additive' || multSelKeyDown) {
                  if (near.selected()) {
                    near.unselect();
                  } else {
                    near.select();
                  }
                } else {
                  if (!multSelKeyDown) {
                    cy.$(':selected').unmerge(near).unselect();
                    near.select();
                  }
                }

                r.redrawHint('eles', true);
              }
            }

            if (r.hoverData.selecting) {
              var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

              r.redrawHint('select', true);

              if (box.length > 0) {
                r.redrawHint('eles', true);
              }

              cy.emit('boxend');

              var eleWouldBeSelected = function eleWouldBeSelected(ele) {
                return ele.selectable() && !ele.selected();
              };

              if (cy.selectionType() === 'additive') {
                box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
              } else {
                if (!multSelKeyDown) {
                  cy.$(':selected').unmerge(box).unselect();
                }

                box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
              }

              // always need redraw in case eles unselectable
              r.redraw();
            }

            // Cancel drag pan
            if (r.hoverData.dragging) {
              r.hoverData.dragging = false;

              r.redrawHint('select', true);
              r.redrawHint('eles', true);

              r.redraw();
            }

            if (!select[4]) {
              r.redrawHint('drag', true);
              r.redrawHint('eles', true);

              var downWasGrabbed = down && down.grabbed();

              freeDraggedElements(draggedElements);

              if (downWasGrabbed) {
                down.emit('free');
              }
            }
          } // else not right mouse

          select[4] = 0;r.hoverData.down = null;

          r.hoverData.cxtStarted = false;
          r.hoverData.draggingEles = false;
          r.hoverData.selecting = false;
          r.hoverData.isOverThresholdDrag = false;
          r.dragData.didDrag = false;
          r.hoverData.dragged = false;
          r.hoverData.dragDelta = [];
          r.hoverData.mdownPos = null;
          r.hoverData.mdownGPos = null;
        }, false);

        var wheelHandler = function wheelHandler(e) {

          if (r.scrollingPage) {
            return;
          } // while scrolling, ignore wheel-to-zoom

          var cy = r.cy;
          var pos = r.projectIntoViewport(e.clientX, e.clientY);
          var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

          if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
            // if pan dragging or cxt dragging, wheel movements make no zoom
            e.preventDefault();
            return;
          }

          if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
            e.preventDefault();

            r.data.wheelZooming = true;
            clearTimeout(r.data.wheelTimeout);
            r.data.wheelTimeout = setTimeout(function () {
              r.data.wheelZooming = false;

              r.redrawHint('eles', true);
              r.redraw();
            }, 150);

            var diff;

            if (e.deltaY != null) {
              diff = e.deltaY / -250;
            } else if (e.wheelDeltaY != null) {
              diff = e.wheelDeltaY / 1000;
            } else {
              diff = e.wheelDelta / 1000;
            }

            diff = diff * r.wheelSensitivity;

            var needsWheelFix = e.deltaMode === 1;
            if (needsWheelFix) {
              // fixes slow wheel events on ff/linux and ff/windows
              diff *= 33;
            }

            cy.zoom({
              level: cy.zoom() * Math.pow(10, diff),
              renderedPosition: { x: rpos[0], y: rpos[1] }
            });
          }
        };

        // Functions to help with whether mouse wheel should trigger zooming
        // --
        r.registerBinding(r.container, 'wheel', wheelHandler, true);

        // disable nonstandard wheel events
        // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
        // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
        // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

        r.registerBinding(window, 'scroll', function scrollHandler(e) {
          // eslint-disable-line no-undef
          r.scrollingPage = true;

          clearTimeout(r.scrollingPageTimeout);
          r.scrollingPageTimeout = setTimeout(function () {
            r.scrollingPage = false;
          }, 250);
        }, true);

        // Functions to help with handling mouseout/mouseover on the Cytoscape container
        // Handle mouseout on Cytoscape container
        r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
          var pos = r.projectIntoViewport(e.clientX, e.clientY);

          r.cy.emit({
            originalEvent: e,
            type: 'mouseout',
            position: { x: pos[0], y: pos[1] }
          });
        }, false);

        r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
          var pos = r.projectIntoViewport(e.clientX, e.clientY);

          r.cy.emit({
            originalEvent: e,
            type: 'mouseover',
            position: { x: pos[0], y: pos[1] }
          });
        }, false);

        var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
        var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
        var center1, modelCenter1; // center point on start pinch to zoom
        var offsetLeft, offsetTop;
        var containerWidth, containerHeight;
        var twoFingersStartInside;

        var distance = function distance(x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        };

        var distanceSq = function distanceSq(x1, y1, x2, y2) {
          return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        };

        var touchstartHandler;
        r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
          if (!eventInContainer(e)) {
            return;
          }

          r.touchData.capture = true;
          r.data.bgActivePosistion = undefined;

          var cy = r.cy;
          var now = r.touchData.now;
          var earlier = r.touchData.earlier;

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
          }
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
          }
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
          }

          // record starting points for pinch-to-zoom
          if (e.touches[1]) {

            freeDraggedElements(r.dragData.touchDragEles);

            var offsets = r.findContainerClientCoords();
            offsetLeft = offsets[0];
            offsetTop = offsets[1];
            containerWidth = offsets[2];
            containerHeight = offsets[3];

            f1x1 = e.touches[0].clientX - offsetLeft;
            f1y1 = e.touches[0].clientY - offsetTop;

            f2x1 = e.touches[1].clientX - offsetLeft;
            f2y1 = e.touches[1].clientY - offsetTop;

            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;

            var pan = cy.pan();
            var zoom = cy.zoom();

            distance1 = distance(f1x1, f1y1, f2x1, f2y1);
            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
            center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
            modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];

            // consider context tap
            var cxtDistThreshold = 200;
            var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {

              var near1 = r.findNearestElement(now[0], now[1], true, true);
              var near2 = r.findNearestElement(now[2], now[3], true, true);

              if (near1 && near1.isNode()) {
                near1.activate().emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: { x: now[0], y: now[1] }
                });
                r.touchData.start = near1;
              } else if (near2 && near2.isNode()) {
                near2.activate().emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: { x: now[0], y: now[1] }
                });
                r.touchData.start = near2;
              } else {
                cy.emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: { x: now[0], y: now[1] }
                });
              }

              if (r.touchData.start) {
                r.touchData.start._private.grabbed = false;
              }
              r.touchData.cxt = true;
              r.touchData.cxtDragged = false;
              r.data.bgActivePosistion = undefined;

              r.redraw();
              return;
            }
          }

          if (e.touches[2]) {
            // ignore
          } else if (e.touches[1]) {
            // ignore
          } else if (e.touches[0]) {
            var nears = r.findNearestElements(now[0], now[1], true, true);
            var near = nears[0];

            if (near != null) {
              near.activate();

              r.touchData.start = near;
              r.touchData.starts = nears;

              if (r.nodeIsGrabbable(near)) {

                var draggedEles = r.dragData.touchDragEles = [];
                var selectedNodes = null;

                r.redrawHint('eles', true);
                r.redrawHint('drag', true);

                if (near.selected()) {
                  // reset drag elements, since near will be added again

                  selectedNodes = cy.$(function (ele) {
                    return ele.selected() && r.nodeIsGrabbable(ele);
                  });

                  addNodesToDrag(selectedNodes, { addToList: draggedEles });
                } else {
                  addNodeToDrag(near, { addToList: draggedEles });
                }

                setGrabTarget(near);

                var makeEvent = function makeEvent(type) {
                  return {
                    originalEvent: e,
                    type: type,
                    position: { x: now[0], y: now[1] }
                  };
                };

                near.emit(makeEvent('grabon'));

                if (selectedNodes) {
                  selectedNodes.forEach(function (n) {
                    n.emit(makeEvent('grab'));
                  });
                } else {
                  near.emit(makeEvent('grab'));
                }
              }
            }

            triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
              position: { x: now[0], y: now[1] }
            });

            if (near == null) {
              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.redrawHint('select', true);
              r.redraw();
            }

            // Tap, taphold
            // -----

            r.touchData.singleTouchMoved = false;
            r.touchData.singleTouchStartTime = +new Date();

            clearTimeout(r.touchData.tapholdTimeout);
            r.touchData.tapholdTimeout = setTimeout(function () {
              if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
              && !r.touchData.selecting // box selection shouldn't allow taphold through
              ) {
                  triggerEvents(r.touchData.start, ['taphold'], e, {
                    position: { x: now[0], y: now[1] }
                  });

                  if (!r.touchData.start) {
                    cy.$(':selected').unselect();
                  }
                }
            }, r.tapholdDuration);
          }

          if (e.touches.length >= 1) {
            var sPos = r.touchData.startPosition = [];

            for (var i = 0; i < now.length; i++) {
              sPos[i] = earlier[i] = now[i];
            }

            var touch0 = e.touches[0];

            r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
          }
        }, false);

        var touchmoveHandler;
        r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
          // eslint-disable-line no-undef
          var capture = r.touchData.capture;

          if (!capture && !eventInContainer(e)) {
            return;
          }

          var select = r.selection;
          var cy = r.cy;
          var now = r.touchData.now;
          var earlier = r.touchData.earlier;
          var zoom = cy.zoom();

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
          }
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
          }
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
          }

          var startGPos = r.touchData.startGPosition;
          var isOverThresholdDrag;

          if (capture && e.touches[0] && startGPos) {
            var disp = [];for (var j = 0; j < now.length; j++) {
              disp[j] = now[j] - earlier[j];
            }
            var dx = e.touches[0].clientX - startGPos[0];
            var dx2 = dx * dx;
            var dy = e.touches[0].clientY - startGPos[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;

            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
          }

          // context swipe cancelling
          if (capture && r.touchData.cxt) {
            e.preventDefault();

            var f1x2 = e.touches[0].clientX - offsetLeft,
                f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft,
                f2y2 = e.touches[1].clientY - offsetTop;
            // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
            var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
            var factorSq = distance2Sq / distance1Sq;

            var distThreshold = 150;
            var distThresholdSq = distThreshold * distThreshold;
            var factorThreshold = 1.5;
            var factorThresholdSq = factorThreshold * factorThreshold;

            // cancel ctx gestures if the distance b/t the fingers increases
            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
              r.touchData.cxt = false;

              r.data.bgActivePosistion = undefined;

              r.redrawHint('select', true);

              var cxtEvt = {
                originalEvent: e,
                type: 'cxttapend',
                position: { x: now[0], y: now[1] }
              };

              if (r.touchData.start) {
                r.touchData.start.unactivate().emit(cxtEvt);

                r.touchData.start = null;
              } else {
                cy.emit(cxtEvt);
              }
            }
          }

          // context swipe
          if (capture && r.touchData.cxt) {
            var cxtEvt = {
              originalEvent: e,
              type: 'cxtdrag',
              position: { x: now[0], y: now[1] }
            };
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            if (r.touchData.start) {
              r.touchData.start.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }

            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }
            r.touchData.cxtDragged = true;

            var near = r.findNearestElement(now[0], now[1], true, true);

            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {

              if (r.touchData.cxtOver) {
                r.touchData.cxtOver.emit({
                  originalEvent: e,
                  type: 'cxtdragout',
                  position: { x: now[0], y: now[1] }
                });
              }

              r.touchData.cxtOver = near;

              if (near) {
                near.emit({
                  originalEvent: e,
                  type: 'cxtdragover',
                  position: { x: now[0], y: now[1] }
                });
              }
            }

            // box selection
          } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
            e.preventDefault();

            r.data.bgActivePosistion = undefined;

            this.lastThreeTouch = +new Date();

            if (!r.touchData.selecting) {
              cy.emit('boxstart');
            }

            r.touchData.selecting = true;

            r.redrawHint('select', true);

            if (!select || select.length === 0 || select[0] === undefined) {
              select[0] = (now[0] + now[2] + now[4]) / 3;
              select[1] = (now[1] + now[3] + now[5]) / 3;
              select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
              select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
            } else {
              select[2] = (now[0] + now[2] + now[4]) / 3;
              select[3] = (now[1] + now[3] + now[5]) / 3;
            }

            select[4] = 1;
            r.touchData.selecting = true;

            r.redraw();

            // pinch to zoom
          } else if (capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
            // two fingers => pinch to zoom
            e.preventDefault();

            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            var draggedEles = r.dragData.touchDragEles;
            if (draggedEles) {
              r.redrawHint('drag', true);

              for (var i = 0; i < draggedEles.length; i++) {
                var de_p = draggedEles[i]._private;

                de_p.grabbed = false;
                de_p.rscratch.inDragLayer = false;
              }
            }

            // (x2, y2) for fingers 1 and 2
            var f1x2 = e.touches[0].clientX - offsetLeft,
                f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft,
                f2y2 = e.touches[1].clientY - offsetTop;

            var distance2 = distance(f1x2, f1y2, f2x2, f2y2);
            // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
            // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
            var factor = distance2 / distance1;

            if (twoFingersStartInside) {
              // delta finger1
              var df1x = f1x2 - f1x1;
              var df1y = f1y2 - f1y1;

              // delta finger 2
              var df2x = f2x2 - f2x1;
              var df2y = f2y2 - f2y1;

              // translation is the normalised vector of the two fingers movement
              // i.e. so pinching cancels out and moving together pans
              var tx = (df1x + df2x) / 2;
              var ty = (df1y + df2y) / 2;

              // adjust factor by the speed multiplier
              // var speed = 1.5;
              // if( factor > 1 ){
              //   factor = (factor - 1) * speed + 1;
              // } else {
              //   factor = 1 - (1 - factor) * speed;
              // }

              // now calculate the zoom
              var zoom1 = cy.zoom();
              var zoom2 = zoom1 * factor;
              var pan1 = cy.pan();

              // the model center point converted to the current rendered pos
              var ctrx = modelCenter1[0] * zoom1 + pan1.x;
              var ctry = modelCenter1[1] * zoom1 + pan1.y;

              var pan2 = {
                x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
                y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
              };

              // remove dragged eles
              if (r.touchData.start && r.touchData.start.active()) {
                var draggedEles = r.dragData.touchDragEles;

                freeDraggedElements(draggedEles);

                r.redrawHint('drag', true);
                r.redrawHint('eles', true);

                r.touchData.start.unactivate().emit('free');
              }

              cy.viewport({
                zoom: zoom2,
                pan: pan2,
                cancelOnFailedZoom: true
              });

              distance1 = distance2;
              f1x1 = f1x2;
              f1y1 = f1y2;
              f2x1 = f2x2;
              f2y1 = f2y2;

              r.pinching = true;
            }

            // Re-project
            if (e.touches[0]) {
              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
            }
            if (e.touches[1]) {
              var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
            }
            if (e.touches[2]) {
              var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
            }
          } else if (e.touches[0]) {
            var start = r.touchData.start;
            var last = r.touchData.last;
            var near;

            if (!r.hoverData.draggingEles && !r.swipePanning) {
              near = r.findNearestElement(now[0], now[1], true, true);
            }

            if (capture && start != null) {
              e.preventDefault();
            }

            // dragging nodes
            if (capture && start != null && r.nodeIsDraggable(start)) {

              if (isOverThresholdDrag) {
                // then dragging can happen
                var draggedEles = r.dragData.touchDragEles;
                var justStartedDrag = !r.dragData.didDrag;

                if (justStartedDrag) {
                  addNodesToDrag(cy.collection(draggedEles), { inDragLayer: true });
                }

                for (var k = 0; k < draggedEles.length; k++) {
                  var draggedEle = draggedEles[k];

                  if (r.nodeIsDraggable(draggedEle) && draggedEle.grabbed()) {
                    r.dragData.didDrag = true;
                    var dPos = draggedEle.position();

                    if (is.number(disp[0]) && is.number(disp[1])) {
                      dPos.x += disp[0];
                      dPos.y += disp[1];
                    }

                    if (justStartedDrag) {
                      r.redrawHint('eles', true);

                      var dragDelta = r.touchData.dragDelta;

                      if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                        dPos.x += dragDelta[0];
                        dPos.y += dragDelta[1];
                      }
                    }
                  }
                }

                var tcol = cy.collection(draggedEles);

                tcol.dirtyCompoundBoundsCache();
                tcol.emit('position drag');

                r.hoverData.draggingEles = true;

                r.redrawHint('drag', true);

                if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {

                  r.redrawHint('eles', true);
                }

                r.redraw();
              } else {
                // otherise keep track of drag delta for later
                var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

                if (dragDelta.length === 0) {
                  dragDelta.push(disp[0]);
                  dragDelta.push(disp[1]);
                } else {
                  dragDelta[0] += disp[0];
                  dragDelta[1] += disp[1];
                }
              }
            }

            // touchmove
            {
              triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
                position: { x: now[0], y: now[1] }
              });

              if ((!start || !start.grabbed()) && near != last) {
                if (last) {
                  last.emit({ originalEvent: e, type: 'tapdragout', position: { x: now[0], y: now[1] } });
                }
                if (near) {
                  near.emit({ originalEvent: e, type: 'tapdragover', position: { x: now[0], y: now[1] } });
                }
              }

              r.touchData.last = near;
            }

            // check to cancel taphold
            if (capture) {
              for (var i = 0; i < now.length; i++) {
                if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {

                  r.touchData.singleTouchMoved = true;
                }
              }
            }

            // panning
            if (capture && (start == null || start.isEdge()) && cy.panningEnabled() && cy.userPanningEnabled()) {

              var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

              if (allowPassthrough) {
                e.preventDefault();

                if (r.swipePanning) {
                  cy.panBy({
                    x: disp[0] * zoom,
                    y: disp[1] * zoom
                  });
                } else if (isOverThresholdDrag) {
                  r.swipePanning = true;

                  cy.panBy({
                    x: dx * zoom,
                    y: dy * zoom
                  });

                  if (start) {
                    start.unactivate();

                    if (!r.data.bgActivePosistion) {
                      r.data.bgActivePosistion = math.array2point(r.touchData.startPosition);
                    }

                    r.redrawHint('select', true);

                    r.touchData.start = null;
                  }
                }
              }

              // Re-project
              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
              now[0] = pos[0];now[1] = pos[1];
            }
          }

          for (var j = 0; j < now.length; j++) {
            earlier[j] = now[j];
          }
          //r.redraw();
        }, false);

        var touchcancelHandler;
        r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
          // eslint-disable-line no-undef
          var start = r.touchData.start;

          r.touchData.capture = false;

          if (start) {
            start.unactivate();
          }
        });

        var touchendHandler;
        r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
          // eslint-disable-line no-undef
          var start = r.touchData.start;

          var capture = r.touchData.capture;

          if (capture) {
            r.touchData.capture = false;

            e.preventDefault();
          } else {
            return;
          }

          var select = r.selection;

          r.swipePanning = false;
          r.hoverData.draggingEles = false;

          var cy = r.cy;
          var zoom = cy.zoom();
          var now = r.touchData.now;
          var earlier = r.touchData.earlier;

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
          }
          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
          }
          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
          }

          if (start) {
            start.unactivate();
          }

          var ctxTapend;
          if (r.touchData.cxt) {
            ctxTapend = {
              originalEvent: e,
              type: 'cxttapend',
              position: { x: now[0], y: now[1] }
            };

            if (start) {
              start.emit(ctxTapend);
            } else {
              cy.emit(ctxTapend);
            }

            if (!r.touchData.cxtDragged) {
              var ctxTap = {
                originalEvent: e,
                type: 'cxttap',
                position: { x: now[0], y: now[1] }
              };

              if (start) {
                start.emit(ctxTap);
              } else {
                cy.emit(ctxTap);
              }
            }

            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }
            r.touchData.cxt = false;
            r.touchData.start = null;

            r.redraw();
            return;
          }

          // no more box selection if we don't have three fingers
          if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
            r.touchData.selecting = false;

            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

            select[0] = undefined;
            select[1] = undefined;
            select[2] = undefined;
            select[3] = undefined;
            select[4] = 0;

            r.redrawHint('select', true);

            cy.emit('boxend');

            var eleWouldBeSelected = function eleWouldBeSelected(ele) {
              return ele.selectable() && !ele.selected();
            };

            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

            if (box.nonempty()) {
              r.redrawHint('eles', true);
            }

            r.redraw();
          }

          if (start != null) {
            start.unactivate();
          }

          if (e.touches[2]) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
          } else if (e.touches[1]) {
            // ignore
          } else if (e.touches[0]) {
            // ignore

            // Last touch released
          } else if (!e.touches[0]) {

            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            var draggedEles = r.dragData.touchDragEles;

            if (start != null) {

              var startWasGrabbed = start._private.grabbed;

              freeDraggedElements(draggedEles);

              r.redrawHint('drag', true);
              r.redrawHint('eles', true);

              if (startWasGrabbed) {
                start.emit('free');
              }

              triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
                position: { x: now[0], y: now[1] }
              });

              start.unactivate();

              r.touchData.start = null;
            } else {
              var near = r.findNearestElement(now[0], now[1], true, true);

              triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
                position: { x: now[0], y: now[1] }
              });
            }

            var dx = r.touchData.startPosition[0] - now[0];
            var dx2 = dx * dx;
            var dy = r.touchData.startPosition[1] - now[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;
            var rdist2 = dist2 * zoom * zoom;

            // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
            if (start != null && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
            ) {

                if (cy.selectionType() === 'single') {
                  cy.$(':selected').unmerge(start).unselect();
                  start.select();
                } else {
                  if (start.selected()) {
                    start.unselect();
                  } else {
                    start.select();
                  }
                }

                r.redrawHint('eles', true);
              }

            // Tap event, roughly same as mouse click event for touch
            if (!r.touchData.singleTouchMoved) {
              triggerEvents(start, ['tap', 'vclick'], e, {
                position: { x: now[0], y: now[1] }
              });
            }

            r.touchData.singleTouchMoved = true;
          }

          for (var j = 0; j < now.length; j++) {
            earlier[j] = now[j];
          }

          r.dragData.didDrag = false; // reset for next mousedown

          if (e.touches.length === 0) {
            r.touchData.dragDelta = [];
            r.touchData.startPosition = null;
            r.touchData.startGPosition = null;
          }

          if (e.touches.length < 2) {
            r.pinching = false;
            r.redrawHint('eles', true);
            r.redraw();
          }

          //r.redraw();
        }, false);

        // fallback compatibility layer for ms pointer events
        if (typeof TouchEvent === 'undefined') {

          var pointers = [];

          var makeTouch = function makeTouch(e) {
            return {
              clientX: e.clientX,
              clientY: e.clientY,
              force: 1,
              identifier: e.pointerId,
              pageX: e.pageX,
              pageY: e.pageY,
              radiusX: e.width / 2,
              radiusY: e.height / 2,
              screenX: e.screenX,
              screenY: e.screenY,
              target: e.target
            };
          };

          var makePointer = function makePointer(e) {
            return {
              event: e,
              touch: makeTouch(e)
            };
          };

          var addPointer = function addPointer(e) {
            pointers.push(makePointer(e));
          };

          var removePointer = function removePointer(e) {
            for (var i = 0; i < pointers.length; i++) {
              var p = pointers[i];

              if (p.event.pointerId === e.pointerId) {
                pointers.splice(i, 1);
                return;
              }
            }
          };

          var updatePointer = function updatePointer(e) {
            var p = pointers.filter(function (p) {
              return p.event.pointerId === e.pointerId;
            })[0];

            p.event = e;
            p.touch = makeTouch(e);
          };

          var addTouchesToEvent = function addTouchesToEvent(e) {
            e.touches = pointers.map(function (p) {
              return p.touch;
            });
          };

          var pointerIsMouse = function pointerIsMouse(e) {
            return e.pointerType === 'mouse' || e.pointerType === 4;
          };

          r.registerBinding(r.container, 'pointerdown', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            e.preventDefault();

            addPointer(e);

            addTouchesToEvent(e);
            touchstartHandler(e);
          });

          r.registerBinding(r.container, 'pointerup', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            removePointer(e);

            addTouchesToEvent(e);
            touchendHandler(e);
          });

          r.registerBinding(r.container, 'pointercancel', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            removePointer(e);

            addTouchesToEvent(e);
            touchcancelHandler(e);
          });

          r.registerBinding(r.container, 'pointermove', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled

            e.preventDefault();

            updatePointer(e);

            addTouchesToEvent(e);
            touchmoveHandler(e);
          });
        }
      };

      module.exports = BRp;

      /***/
    },
    /* 123 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var BRp = {};

      BRp.generatePolygon = function (name, points) {
        return this.nodeShapes[name] = {
          renderer: this,

          name: name,

          points: points,

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return math.polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
          }
        };
      };

      BRp.generateEllipse = function () {
        return this.nodeShapes['ellipse'] = {
          renderer: this,

          name: 'ellipse',

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return math.intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return math.checkInEllipse(x, y, width, height, centerX, centerY, padding);
          }
        };
      };

      BRp.generateRoundRectangle = function () {
        return this.nodeShapes['roundrectangle'] = {
          renderer: this,

          name: 'roundrectangle',

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

            var cornerRadius = math.getRoundRectangleRadius(width, height);
            var diam = cornerRadius * 2;

            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
              return true;
            }

            // Check top left quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

              return true;
            }

            // Check top right quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

              return true;
            }

            // Check bottom right quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            // Check bottom left quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            return false;
          }
        };
      };

      BRp.generateCutRectangle = function () {
        return this.nodeShapes['cutrectangle'] = {
          renderer: this,

          name: 'cutrectangle',

          cornerLength: math.getCutRectangleCornerLength(),

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
            var cl = this.cornerLength;
            var hh = height / 2;
            var hw = width / 2;
            var xBegin = centerX - hw;
            var xEnd = centerX + hw;
            var yBegin = centerY - hh;
            var yEnd = centerY + hh;

            // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
            return {
              topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
              topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
              bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
              bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
            };
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
            var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);

            return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
              return true;
            }
            var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
            return math.pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
          }

        };
      };

      BRp.generateBarrel = function () {
        return this.nodeShapes['barrel'] = {
          renderer: this,

          name: 'barrel',

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            // use two fixed t values for the bezier curve approximation

            var t0 = 0.15;
            var t1 = 0.5;
            var t2 = 0.85;

            var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

            var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
              // approximate curve pts based on the two t values
              var m0 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t0);
              var m1 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t1);
              var m2 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t2);

              return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
            };

            var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));

            return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
          },

          generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
            var hh = height / 2;
            var hw = width / 2;
            var xBegin = centerX - hw;
            var xEnd = centerX + hw;
            var yBegin = centerY - hh;
            var yEnd = centerY + hh;

            var curveConstants = math.getBarrelCurveConstants(width, height);
            var hOffset = curveConstants.heightOffset;
            var wOffset = curveConstants.widthOffset;
            var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;

            // points are in clockwise order, inner (imaginary) control pt on [4, 5]
            var pts = {
              topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
              topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
              bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
              bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
            };

            pts.topLeft.isTop = true;
            pts.topRight.isTop = true;
            pts.bottomLeft.isBottom = true;
            pts.bottomRight.isBottom = true;

            return pts;
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

            var curveConstants = math.getBarrelCurveConstants(width, height);
            var hOffset = curveConstants.heightOffset;
            var wOffset = curveConstants.widthOffset;

            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
              return true;
            }

            var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

            var getCurveT = function getCurveT(x, y, curvePts) {
              var x0 = curvePts[4];
              var x1 = curvePts[2];
              var x2 = curvePts[0];
              var y0 = curvePts[5];
              // var y1 = curvePts[ 3 ];
              var y2 = curvePts[1];

              var xMin = Math.min(x0, x2);
              var xMax = Math.max(x0, x2);
              var yMin = Math.min(y0, y2);
              var yMax = Math.max(y0, y2);

              if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
                var coeff = math.bezierPtsToQuadCoeff(x0, x1, x2);
                var roots = math.solveQuadratic(coeff[0], coeff[1], coeff[2], x);

                var validRoots = roots.filter(function (r) {
                  return 0 <= r && r <= 1;
                });

                if (validRoots.length > 0) {
                  return validRoots[0];
                }
              }
              return null;
            };

            var curveRegions = Object.keys(barrelCurvePts);
            for (var i = 0; i < curveRegions.length; i++) {
              var corner = curveRegions[i];
              var cornerPts = barrelCurvePts[corner];
              var t = getCurveT(x, y, cornerPts);

              if (t == null) {
                continue;
              }

              var y0 = cornerPts[5];
              var y1 = cornerPts[3];
              var y2 = cornerPts[1];
              var bezY = math.qbezierAt(y0, y1, y2, t);

              if (cornerPts.isTop && bezY <= y) {
                return true;
              }
              if (cornerPts.isBottom && y <= bezY) {
                return true;
              }
            }
            return false;
          }
        };
      };

      BRp.generateBottomRoundrectangle = function () {
        return this.nodeShapes['bottomroundrectangle'] = {
          renderer: this,

          name: 'bottomroundrectangle',

          points: math.generateUnitNgonPointsFitToSquare(4, 0),

          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },

          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            var topStartX = nodeX - (width / 2 + padding);
            var topStartY = nodeY - (height / 2 + padding);
            var topEndY = topStartY;
            var topEndX = nodeX + (width / 2 + padding);

            var topIntersections = math.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
            if (topIntersections.length > 0) {
              return topIntersections;
            }

            return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
          },

          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

            var cornerRadius = math.getRoundRectangleRadius(width, height);
            var diam = 2 * cornerRadius;

            // Check hBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
              return true;
            }

            // Check vBox
            if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
              return true;
            }

            // check non-rounded top side
            var outerWidth = width / 2 + 2 * padding;
            var outerHeight = height / 2 + 2 * padding;
            var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];
            if (math.pointInsidePolygonPoints(x, y, points)) {
              return true;
            }

            // Check bottom right quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            // Check bottom left quarter circle
            if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

              return true;
            }

            return false;
          }
        };
      };

      BRp.registerNodeShapes = function () {
        var nodeShapes = this.nodeShapes = {};
        var renderer = this;

        this.generateEllipse();

        this.generatePolygon('triangle', math.generateUnitNgonPointsFitToSquare(3, 0));

        this.generatePolygon('rectangle', math.generateUnitNgonPointsFitToSquare(4, 0));
        nodeShapes['square'] = nodeShapes['rectangle'];

        this.generateRoundRectangle();

        this.generateCutRectangle();

        this.generateBarrel();

        this.generateBottomRoundrectangle();

        this.generatePolygon('diamond', [0, 1, 1, 0, 0, -1, -1, 0]);

        this.generatePolygon('pentagon', math.generateUnitNgonPointsFitToSquare(5, 0));

        this.generatePolygon('hexagon', math.generateUnitNgonPointsFitToSquare(6, 0));

        this.generatePolygon('heptagon', math.generateUnitNgonPointsFitToSquare(7, 0));

        this.generatePolygon('octagon', math.generateUnitNgonPointsFitToSquare(8, 0));

        var star5Points = new Array(20);
        {
          var outerPoints = math.generateUnitNgonPoints(5, 0);
          var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);

          // Outer radius is 1; inner radius of star is smaller
          var innerRadius = 0.5 * (3 - Math.sqrt(5));
          innerRadius *= 1.57;

          for (var i = 0; i < innerPoints.length / 2; i++) {
            innerPoints[i * 2] *= innerRadius;
            innerPoints[i * 2 + 1] *= innerRadius;
          }

          for (var i = 0; i < 20 / 4; i++) {
            star5Points[i * 4] = outerPoints[i * 2];
            star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];

            star5Points[i * 4 + 2] = innerPoints[i * 2];
            star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
          }
        }

        star5Points = math.fitPolygonToSquare(star5Points);

        this.generatePolygon('star', star5Points);

        this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);

        this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);

        this.generatePolygon('concavehexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);

        this.generatePolygon('tag', [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1]);

        nodeShapes.makePolygon = function (points) {

          // use caching on user-specified polygons so they are as fast as native shapes

          var key = points.join('$');
          var name = 'polygon-' + key;
          var shape;

          if (shape = this[name]) {
            // got cached shape
            return shape;
          }

          // create and cache new shape
          return renderer.generatePolygon(name, points);
        };
      };

      module.exports = BRp;

      /***/
    },
    /* 124 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);

      var BRp = {};

      BRp.timeToRender = function () {
        return this.redrawTotalTime / this.redrawCount;
      };

      BRp.redraw = function (options) {
        options = options || util.staticEmptyObject();

        var r = this;

        if (r.averageRedrawTime === undefined) {
          r.averageRedrawTime = 0;
        }
        if (r.lastRedrawTime === undefined) {
          r.lastRedrawTime = 0;
        }
        if (r.lastDrawTime === undefined) {
          r.lastDrawTime = 0;
        }

        r.requestedFrame = true;
        r.renderOptions = options;
      };

      BRp.beforeRender = function (fn, priority) {
        // the renderer can't add tick callbacks when destroyed
        if (this.destroyed) {
          return;
        }

        priority = priority || 0;

        var cbs = this.beforeRenderCallbacks;

        cbs.push({ fn: fn, priority: priority });

        // higher priority callbacks executed first
        cbs.sort(function (a, b) {
          return b.priority - a.priority;
        });
      };

      var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
        var cbs = r.beforeRenderCallbacks;

        for (var i = 0; i < cbs.length; i++) {
          cbs[i].fn(willDraw, startTime);
        }
      };

      BRp.startRenderLoop = function () {
        var r = this;

        if (r.renderLoopStarted) {
          return;
        } else {
          r.renderLoopStarted = true;
        }

        var renderFn = function renderFn(requestTime) {
          if (r.destroyed) {
            return;
          }

          if (r.requestedFrame && !r.skipFrame) {
            beforeRenderCallbacks(r, true, requestTime);

            var startTime = util.performanceNow();

            r.render(r.renderOptions);

            var endTime = r.lastDrawTime = util.performanceNow();

            if (r.averageRedrawTime === undefined) {
              r.averageRedrawTime = endTime - startTime;
            }

            if (r.redrawCount === undefined) {
              r.redrawCount = 0;
            }

            r.redrawCount++;

            if (r.redrawTotalTime === undefined) {
              r.redrawTotalTime = 0;
            }

            var duration = endTime - startTime;

            r.redrawTotalTime += duration;
            r.lastRedrawTime = duration;

            // use a weighted average with a bias from the previous average so we don't spike so easily
            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

            r.requestedFrame = false;
          } else {
            beforeRenderCallbacks(r, false, requestTime);
          }

          r.skipFrame = false;

          util.requestAnimationFrame(renderFn);
        };

        util.requestAnimationFrame(renderFn);
      };

      module.exports = BRp;

      /***/
    },
    /* 125 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /*
      The canvas renderer was written by Yue Dong.
      
      Modifications tracked on Github.
      */

      var util = __webpack_require__(1);
      var is = __webpack_require__(0);
      var ElementTextureCache = __webpack_require__(126);
      var LayeredTextureCache = __webpack_require__(127);

      var CR = CanvasRenderer;
      var CRp = CanvasRenderer.prototype;

      CRp.CANVAS_LAYERS = 3;
      //
      CRp.SELECT_BOX = 0;
      CRp.DRAG = 1;
      CRp.NODE = 2;

      CRp.BUFFER_COUNT = 3;
      //
      CRp.TEXTURE_BUFFER = 0;
      CRp.MOTIONBLUR_BUFFER_NODE = 1;
      CRp.MOTIONBLUR_BUFFER_DRAG = 2;

      function CanvasRenderer(options) {
        var r = this;

        r.data = {
          canvases: new Array(CRp.CANVAS_LAYERS),
          contexts: new Array(CRp.CANVAS_LAYERS),
          canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),

          bufferCanvases: new Array(CRp.BUFFER_COUNT),
          bufferContexts: new Array(CRp.CANVAS_LAYERS)
        };

        var tapHlOff = '-webkit-tap-highlight-color: rgba(0,0,0,0);';

        r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef
        var containerStyle = r.data.canvasContainer.style;
        r.data.canvasContainer.setAttribute('style', tapHlOff);
        containerStyle.position = 'relative';
        containerStyle.zIndex = '0';
        containerStyle.overflow = 'hidden';

        var container = options.cy.container();
        container.appendChild(r.data.canvasContainer);

        if ((container.getAttribute('style') || '').indexOf(tapHlOff) < 0) {
          container.setAttribute('style', (container.getAttribute('style') || '') + tapHlOff);
        }

        for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
          var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
          r.data.contexts[i] = canvas.getContext('2d');
          canvas.setAttribute('style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + (is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : ''));
          canvas.style.position = 'absolute';
          canvas.setAttribute('data-id', 'layer' + i);
          canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
          r.data.canvasContainer.appendChild(canvas);

          r.data.canvasNeedsRedraw[i] = false;
        }
        r.data.topCanvas = r.data.canvases[0];

        r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
        r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
        r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');

        for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
          r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
          r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
          r.data.bufferCanvases[i].style.position = 'absolute';
          r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
          r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
          r.data.bufferCanvases[i].style.visibility = 'hidden';
          //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
        }

        r.pathsEnabled = true;

        r.data.eleTxrCache = new ElementTextureCache(r);
        r.data.lyrTxrCache = new LayeredTextureCache(r, r.data.eleTxrCache);

        r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
          for (var i = 0; i < eles.length; i++) {
            var ele = eles[i];
            var rs = ele._private.rstyle;
            var de = rs.dirtyEvents;

            if (ele.isNode() && de && de.length === 1 && de['position']) {
              // then keep cached ele texture
            } else {
              r.data.eleTxrCache.invalidateElement(ele);

              // NB this block of code should not be ported to 3.3 (unstable branch).
              // - This check is unneccesary in 3.3 as caches will be stored without respect to opacity.
              // - This fix may result in lowered performance for compound graphs.
              // - Ref : Opacity of child node is not updated for certain zoom levels after parent opacity is overriden #2078
              if (ele.isParent() && de['style']) {
                var op1 = rs.prevParentOpacity;
                var op2 = ele.pstyle('opacity').pfValue;

                rs.prevParentOpacity = op2;

                if (op1 !== op2) {
                  var descs = ele.descendants();

                  for (var j = 0; j < descs.length; j++) {
                    r.data.eleTxrCache.invalidateElement(descs[j]);
                  }
                }
              }
            }
          }

          if (eles.length > 0) {
            r.data.lyrTxrCache.invalidateElements(eles);
          }
        });
      }

      CRp.redrawHint = function (group, bool) {
        var r = this;

        switch (group) {
          case 'eles':
            r.data.canvasNeedsRedraw[CRp.NODE] = bool;
            break;
          case 'drag':
            r.data.canvasNeedsRedraw[CRp.DRAG] = bool;
            break;
          case 'select':
            r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;
            break;
        }
      };

      // whether to use Path2D caching for drawing
      var pathsImpld = typeof Path2D !== 'undefined';

      CRp.path2dEnabled = function (on) {
        if (on === undefined) {
          return this.pathsEnabled;
        }

        this.pathsEnabled = on ? true : false;
      };

      CRp.usePaths = function () {
        return pathsImpld && this.pathsEnabled;
      };

      [__webpack_require__(128), __webpack_require__(129), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132), __webpack_require__(133), __webpack_require__(134), __webpack_require__(135), __webpack_require__(136), __webpack_require__(137)].forEach(function (props) {
        util.extend(CRp, props);
      });

      module.exports = CR;

      /***/
    },
    /* 126 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);
      var util = __webpack_require__(1);
      var Heap = __webpack_require__(9);
      var defs = __webpack_require__(19);

      var minTxrH = 25; // the size of the texture cache for small height eles (special case)
      var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
      var minLvl = -4; // when scaling smaller than that we don't need to re-render
      var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
      var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
      var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
      var defTxrWidth = 1024; // default/minimum texture width
      var maxTxrW = 1024; // the maximum width of a texture
      var maxTxrH = 1024; // the maximum height of a texture
      var minUtility = 0.5; // if usage of texture is less than this, it is retired
      var maxFullness = 0.8; // fullness of texture after which queue removal is checked
      var maxFullnessChecks = 10; // dequeued after this many checks
      var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
      var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
      var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
      var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
      var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
      var deqFastCost = 0.9; // % of frame time to be used when >60fps
      var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
      var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

      var getTxrReasons = {
        dequeue: 'dequeue',
        downscale: 'downscale',
        highQuality: 'highQuality'
      };

      var ElementTextureCache = function ElementTextureCache(renderer) {
        var self = this;

        self.renderer = renderer;
        self.onDequeues = [];

        self.setupDequeueing();
      };

      var ETCp = ElementTextureCache.prototype;

      ETCp.reasons = getTxrReasons;

      // the list of textures in which new subtextures for elements can be placed
      ETCp.getTextureQueue = function (txrH) {
        var self = this;
        self.eleImgCaches = self.eleImgCaches || {};

        return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
      };

      // the list of usused textures which can be recycled (in use in texture queue)
      ETCp.getRetiredTextureQueue = function (txrH) {
        var self = this;

        var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
        var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];

        return rtxtrQ;
      };

      // queue of element draw requests at different scale levels
      ETCp.getElementQueue = function () {
        var self = this;

        var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
          return b.reqs - a.reqs;
        });

        return q;
      };

      // queue of element draw requests at different scale levels (element id lookup)
      ETCp.getElementIdToQueue = function () {
        var self = this;

        var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

        return id2q;
      };

      ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
        var self = this;
        var r = this.renderer;
        var rs = ele._private.rscratch;
        var zoom = r.cy.zoom();

        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
          return null;
        }

        if (lvl == null) {
          lvl = Math.ceil(math.log2(zoom * pxRatio));
        }

        if (lvl < minLvl) {
          lvl = minLvl;
        } else if (zoom >= maxZoom || lvl > maxLvl) {
          return null;
        }

        var scale = Math.pow(2, lvl);
        var eleScaledH = bb.h * scale;
        var eleScaledW = bb.w * scale;
        var caches = rs.imgCaches = rs.imgCaches || {};
        var eleCache = caches[lvl];

        if (eleCache) {
          return eleCache;
        }

        var txrH; // which texture height this ele belongs to

        if (eleScaledH <= minTxrH) {
          txrH = minTxrH;
        } else if (eleScaledH <= txrStepH) {
          txrH = txrStepH;
        } else {
          txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
        }

        if (eleScaledH > maxTxrH || eleScaledW > maxTxrW || !allowEdgeTxrCaching && ele.isEdge() || !allowParentTxrCaching && ele.isParent()) {
          return null; // caching large elements is not efficient
        }

        var txrQ = self.getTextureQueue(txrH);

        // first try the second last one in case it has space at the end
        var txr = txrQ[txrQ.length - 2];

        var addNewTxr = function addNewTxr() {
          return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
        };

        // try the last one if there is no second last one
        if (!txr) {
          txr = txrQ[txrQ.length - 1];
        }

        // if the last one doesn't exist, we need a first one
        if (!txr) {
          txr = addNewTxr();
        }

        // if there's no room in the current texture, we need a new one
        if (txr.width - txr.usedWidth < eleScaledW) {
          txr = addNewTxr();
        }

        var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);
        var scalableFrom = function scalableFrom(otherCache) {
          return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
        };

        var deqing = reason && reason === getTxrReasons.dequeue;
        var highQualityReq = reason && reason === getTxrReasons.highQuality;
        var downscaleReq = reason && reason === getTxrReasons.downscale;

        var higherCache; // the nearest cache with a higher level
        for (var l = lvl + 1; l <= maxLvl; l++) {
          var c = caches[l];

          if (c) {
            higherCache = c;break;
          }
        }

        var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

        var downscale = function downscale() {
          txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
        };

        // reset ele area in texture
        txr.context.setTransform(1, 0, 0, 1, 0, 0);
        txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

        if (scalableFrom(oneUpCache)) {
          // then we can relatively cheaply rescale the existing image w/o rerendering
          downscale();
        } else if (scalableFrom(higherCache)) {
          // then use the higher cache for now and queue the next level down
          // to cheaply scale towards the smaller level

          if (highQualityReq) {
            for (var l = higherCache.level; l > lvl; l--) {
              oneUpCache = self.getElement(ele, bb, pxRatio, l, getTxrReasons.downscale);
            }

            downscale();
          } else {
            self.queueElement(ele, higherCache.level - 1);

            return higherCache;
          }
        } else {

          var lowerCache; // the nearest cache with a lower level
          if (!deqing && !highQualityReq && !downscaleReq) {
            for (var l = lvl - 1; l >= minLvl; l--) {
              var c = caches[l];

              if (c) {
                lowerCache = c;break;
              }
            }
          }

          if (scalableFrom(lowerCache)) {
            // then use the lower quality cache for now and queue the better one for later

            self.queueElement(ele, lvl);

            return lowerCache;
          }

          txr.context.translate(txr.usedWidth, 0);
          txr.context.scale(scale, scale);

          r.drawElement(txr.context, ele, bb, scaledLabelShown);

          txr.context.scale(1 / scale, 1 / scale);
          txr.context.translate(-txr.usedWidth, 0);
        }

        eleCache = caches[lvl] = {
          ele: ele,
          x: txr.usedWidth,
          texture: txr,
          level: lvl,
          scale: scale,
          width: eleScaledW,
          height: eleScaledH,
          scaledLabelShown: scaledLabelShown
        };

        txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);

        txr.eleCaches.push(eleCache);

        self.checkTextureFullness(txr);

        return eleCache;
      };

      ETCp.invalidateElement = function (ele) {
        var self = this;
        var caches = ele._private.rscratch.imgCaches;

        if (caches) {
          for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
            var cache = caches[lvl];

            if (cache) {
              var txr = cache.texture;

              // remove space from the texture it belongs to
              txr.invalidatedWidth += cache.width;

              // remove refs with the element
              caches[lvl] = null;
              util.removeFromArray(txr.eleCaches, cache);

              // remove from queue since the old req was for the old state
              self.removeFromQueue(ele);

              // might have to remove the entire texture if it's not efficiently using its space
              self.checkTextureUtility(txr);
            }
          }
        }
      };

      ETCp.checkTextureUtility = function (txr) {
        // invalidate all entries in the cache if the cache size is small
        if (txr.invalidatedWidth >= minUtility * txr.width) {
          this.retireTexture(txr);
        }
      };

      ETCp.checkTextureFullness = function (txr) {
        // if texture has been mostly filled and passed over several times, remove
        // it from the queue so we don't need to waste time looking at it to put new things

        var self = this;
        var txrQ = self.getTextureQueue(txr.height);

        if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
          util.removeFromArray(txrQ, txr);
        } else {
          txr.fullnessChecks++;
        }
      };

      ETCp.retireTexture = function (txr) {
        var self = this;
        var txrH = txr.height;
        var txrQ = self.getTextureQueue(txrH);

        // retire the texture from the active / searchable queue:

        util.removeFromArray(txrQ, txr);

        txr.retired = true;

        // remove the refs from the eles to the caches:

        var eleCaches = txr.eleCaches;

        for (var i = 0; i < eleCaches.length; i++) {
          var eleCache = eleCaches[i];
          var ele = eleCache.ele;
          var lvl = eleCache.level;
          var imgCaches = ele._private.rscratch.imgCaches;

          if (imgCaches) {
            imgCaches[lvl] = null;
          }
        }

        util.clearArray(eleCaches);

        // add the texture to a retired queue so it can be recycled in future:

        var rtxtrQ = self.getRetiredTextureQueue(txrH);

        rtxtrQ.push(txr);
      };

      ETCp.addTexture = function (txrH, minW) {
        var self = this;
        var txrQ = self.getTextureQueue(txrH);
        var txr = {};

        txrQ.push(txr);

        txr.eleCaches = [];

        txr.height = txrH;
        txr.width = Math.max(defTxrWidth, minW);
        txr.usedWidth = 0;
        txr.invalidatedWidth = 0;
        txr.fullnessChecks = 0;

        txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
        txr.canvas.width = txr.width;
        txr.canvas.height = txr.height;

        txr.context = txr.canvas.getContext('2d');

        return txr;
      };

      ETCp.recycleTexture = function (txrH, minW) {
        var self = this;
        var txrQ = self.getTextureQueue(txrH);
        var rtxtrQ = self.getRetiredTextureQueue(txrH);

        for (var i = 0; i < rtxtrQ.length; i++) {
          var txr = rtxtrQ[i];

          if (txr.width >= minW) {
            txr.retired = false;

            txr.usedWidth = 0;
            txr.invalidatedWidth = 0;
            txr.fullnessChecks = 0;

            util.clearArray(txr.eleCaches);

            txr.context.setTransform(1, 0, 0, 1, 0, 0);
            txr.context.clearRect(0, 0, txr.width, txr.height);

            util.removeFromArray(rtxtrQ, txr);
            txrQ.push(txr);

            return txr;
          }
        }
      };

      ETCp.queueElement = function (ele, lvl) {
        var self = this;
        var q = self.getElementQueue();
        var id2q = self.getElementIdToQueue();
        var id = ele.id();
        var existingReq = id2q[id];

        if (existingReq) {
          // use the max lvl b/c in between lvls are cheap to make
          existingReq.level = Math.max(existingReq.level, lvl);
          existingReq.reqs++;

          q.updateItem(existingReq);
        } else {
          var req = {
            ele: ele,
            level: lvl,
            reqs: 1
          };

          q.push(req);

          id2q[id] = req;
        }
      };

      ETCp.dequeue = function (pxRatio /*, extent*/) {
        var self = this;
        var q = self.getElementQueue();
        var id2q = self.getElementIdToQueue();
        var dequeued = [];

        for (var i = 0; i < maxDeqSize; i++) {
          if (q.size() > 0) {
            var req = q.pop();
            var ele = req.ele;
            var caches = ele._private.rscratch.imgCaches;

            // dequeueing isn't necessary when an existing cache exists
            if (caches[req.level] != null) {
              continue;
            }

            id2q[ele.id()] = null;

            dequeued.push(req);

            var bb = ele.boundingBox();

            self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
          } else {
            break;
          }
        }

        return dequeued;
      };

      ETCp.removeFromQueue = function (ele) {
        var self = this;
        var q = self.getElementQueue();
        var id2q = self.getElementIdToQueue();
        var req = id2q[ele.id()];

        if (req != null) {
          // bring to front of queue
          req.reqs = util.MAX_INT;
          q.updateItem(req);

          q.pop(); // remove from queue

          id2q[ele.id()] = null; // remove from lookup map
        }
      };

      ETCp.onDequeue = function (fn) {
        this.onDequeues.push(fn);
      };
      ETCp.offDequeue = function (fn) {
        util.removeFromArray(this.onDequeues, fn);
      };

      ETCp.setupDequeueing = defs.setupDequeueing({
        deqRedrawThreshold: deqRedrawThreshold,
        deqCost: deqCost,
        deqAvgCost: deqAvgCost,
        deqNoDrawCost: deqNoDrawCost,
        deqFastCost: deqFastCost,
        deq: function deq(self, pxRatio, extent) {
          return self.dequeue(pxRatio, extent);
        },
        onDeqd: function onDeqd(self, deqd) {
          for (var i = 0; i < self.onDequeues.length; i++) {
            var fn = self.onDequeues[i];

            fn(deqd);
          }
        },
        shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
          for (var i = 0; i < deqd.length; i++) {
            var bb = deqd[i].ele.boundingBox();

            if (math.boundingBoxesIntersect(bb, extent)) {
              return true;
            }
          }

          return false;
        },
        priority: function priority(self) {
          return self.renderer.beforeRenderPriorities.eleTxrDeq;
        }
      });

      module.exports = ElementTextureCache;

      /***/
    },
    /* 127 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);
      var Heap = __webpack_require__(9);
      var is = __webpack_require__(0);
      var defs = __webpack_require__(19);

      var defNumLayers = 1; // default number of layers to use
      var minLvl = -4; // when scaling smaller than that we don't need to re-render
      var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
      var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
      var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
      var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
      var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
      var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
      var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
      var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
      var deqFastCost = 0.9; // % of frame time to be used when >60fps
      var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
      var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
      var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
      var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
      var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

      var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

      // var log = function(){ console.log.apply( console, arguments ); };

      var LayeredTextureCache = function LayeredTextureCache(renderer, eleTxrCache) {
        var self = this;

        var r = self.renderer = renderer;

        self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

        self.firstGet = true;

        self.lastInvalidationTime = util.performanceNow() - 2 * invalidThreshold;

        self.skipping = false;

        r.beforeRender(function (willDraw, now) {
          if (now - self.lastInvalidationTime <= invalidThreshold) {
            self.skipping = true;
          } else {
            self.skipping = false;
          }
        });

        var qSort = function qSort(a, b) {
          return b.reqs - a.reqs;
        };

        self.layersQueue = new Heap(qSort);

        self.eleTxrCache = eleTxrCache;

        self.setupEleCacheInvalidation();

        self.setupDequeueing();
      };

      var LTCp = LayeredTextureCache.prototype;

      var layerIdPool = 0;
      var MAX_INT = Math.pow(2, 53) - 1;

      LTCp.makeLayer = function (bb, lvl) {
        var scale = Math.pow(2, lvl);

        var w = Math.ceil(bb.w * scale);
        var h = Math.ceil(bb.h * scale);

        var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

        canvas.width = w;
        canvas.height = h;

        var layer = {
          id: layerIdPool = ++layerIdPool % MAX_INT,
          bb: bb,
          level: lvl,
          width: w,
          height: h,
          canvas: canvas,
          context: canvas.getContext('2d'),
          eles: [],
          elesQueue: [],
          reqs: 0
        };

        // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

        var cxt = layer.context;
        var dx = -layer.bb.x1;
        var dy = -layer.bb.y1;

        // do the transform on creation to save cycles (it's the same for all eles)
        cxt.scale(scale, scale);
        cxt.translate(dx, dy);

        return layer;
      };

      LTCp.getLayers = function (eles, pxRatio, lvl) {
        var self = this;
        var r = self.renderer;
        var cy = r.cy;
        var zoom = cy.zoom();
        var firstGet = self.firstGet;

        self.firstGet = false;

        // log('--\nget layers with %s eles', eles.length);
        //log eles.map(function(ele){ return ele.id() }) );

        if (lvl == null) {
          lvl = Math.ceil(math.log2(zoom * pxRatio));

          if (lvl < minLvl) {
            lvl = minLvl;
          } else if (zoom >= maxZoom || lvl > maxLvl) {
            return null;
          }
        }

        self.validateLayersElesOrdering(lvl, eles);

        var layersByLvl = self.layersByLevel;
        var scale = Math.pow(2, lvl);
        var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
        var bb;

        var lvlComplete = self.levelIsComplete(lvl, eles);
        var tmpLayers;

        var checkTempLevels = function checkTempLevels() {
          var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
            self.validateLayersElesOrdering(l, eles);

            if (self.levelIsComplete(l, eles)) {
              tmpLayers = layersByLvl[l];
              return true;
            }
          };

          var checkLvls = function checkLvls(dir) {
            if (tmpLayers) {
              return;
            }

            for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {
              if (canUseAsTmpLvl(l)) {
                break;
              }
            }
          };

          checkLvls(+1);
          checkLvls(-1);

          // remove the invalid layers; they will be replaced as needed later in this function
          for (var i = layers.length - 1; i >= 0; i--) {
            var layer = layers[i];

            if (layer.invalid) {
              util.removeFromArray(layers, layer);
            }
          }
        };

        if (!lvlComplete) {
          // if the current level is incomplete, then use the closest, best quality layerset temporarily
          // and later queue the current layerset so we can get the proper quality level soon

          checkTempLevels();
        } else {
          // log('level complete, using existing layers\n--');
          return layers;
        }

        var getBb = function getBb() {
          if (!bb) {
            bb = math.makeBoundingBox();

            for (var i = 0; i < eles.length; i++) {
              math.updateBoundingBox(bb, eles[i].boundingBox());
            }
          }

          return bb;
        };

        var makeLayer = function makeLayer(opts) {
          opts = opts || {};

          var after = opts.after;

          getBb();

          var area = bb.w * scale * (bb.h * scale);

          if (area > maxLayerArea) {
            return null;
          }

          var layer = self.makeLayer(bb, lvl);

          if (after != null) {
            var index = layers.indexOf(after) + 1;

            layers.splice(index, 0, layer);
          } else if (opts.insert === undefined || opts.insert) {
            // no after specified => first layer made so put at start
            layers.unshift(layer);
          }

          // if( tmpLayers ){
          //self.queueLayer( layer );
          // }

          return layer;
        };

        if (self.skipping && !firstGet) {
          // log('skip layers');
          return null;
        }

        // log('do layers');

        var layer = null;
        var maxElesPerLayer = eles.length / defNumLayers;
        var allowLazyQueueing = alwaysQueue && !firstGet;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var rs = ele._private.rscratch;
          var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

          // log('look at ele', ele.id());

          var existingLayer = caches[lvl];

          if (existingLayer) {
            // reuse layer for later eles
            // log('reuse layer for', ele.id());
            layer = existingLayer;
            continue;
          }

          if (!layer || layer.eles.length >= maxElesPerLayer || !math.boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
            // log('make new layer for ele %s', ele.id());

            layer = makeLayer({ insert: true, after: layer });

            // if now layer can be built then we can't use layers at this level
            if (!layer) {
              return null;
            }

            // log('new layer with id %s', layer.id);
          }

          if (tmpLayers || allowLazyQueueing) {
            // log('queue ele %s in layer %s', ele.id(), layer.id);
            self.queueLayer(layer, ele);
          } else {
            // log('draw ele %s in layer %s', ele.id(), layer.id);
            self.drawEleInLayer(layer, ele, lvl, pxRatio);
          }

          layer.eles.push(ele);

          caches[lvl] = layer;
        }

        // log('--');

        if (tmpLayers) {
          // then we only queued the current layerset and can't draw it yet
          return tmpLayers;
        }

        if (allowLazyQueueing) {
          // log('lazy queue level', lvl);
          return null;
        }

        return layers;
      };

      // a layer may want to use an ele cache of a higher level to avoid blurriness
      // so the layer level might not equal the ele level
      LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
        return lvl;
      };

      function imgSmoothing(context, bool) {
        if (context.imageSmoothingEnabled != null) {
          context.imageSmoothingEnabled = bool;
        } else {
          context.webkitImageSmoothingEnabled = bool;
          context.mozImageSmoothingEnabled = bool;
          context.msImageSmoothingEnabled = bool;
        }
      }

      LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
        var self = this;
        var r = this.renderer;
        var context = layer.context;
        var bb = ele.boundingBox();

        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
          return;
        }

        var eleCache = self.eleTxrCache;
        var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

        lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

        var cache = useEleTxrCaching ? eleCache.getElement(ele, bb, null, lvl, reason) : null;

        if (cache) {
          if (disableEleImgSmoothing) {
            imgSmoothing(context, false);
          }

          context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);

          if (disableEleImgSmoothing) {
            imgSmoothing(context, true);
          }
        } else {
          // if the element is not cacheable, then draw directly
          r.drawElement(context, ele);
        }
      };

      LTCp.levelIsComplete = function (lvl, eles) {
        var self = this;
        var layers = self.layersByLevel[lvl];

        if (!layers || layers.length === 0) {
          return false;
        }

        var numElesInLayers = 0;

        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];

          // if there are any eles needed to be drawn yet, the level is not complete
          if (layer.reqs > 0) {
            return false;
          }

          // if the layer is invalid, the level is not complete
          if (layer.invalid) {
            return false;
          }

          numElesInLayers += layer.eles.length;
        }

        // we should have exactly the number of eles passed in to be complete
        if (numElesInLayers !== eles.length) {
          return false;
        }

        return true;
      };

      LTCp.validateLayersElesOrdering = function (lvl, eles) {
        var layers = this.layersByLevel[lvl];

        if (!layers) {
          return;
        }

        // if in a layer the eles are not in the same order, then the layer is invalid
        // (i.e. there is an ele in between the eles in the layer)

        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          var offset = -1;

          // find the offset
          for (var j = 0; j < eles.length; j++) {
            if (layer.eles[0] === eles[j]) {
              offset = j;
              break;
            }
          }

          if (offset < 0) {
            // then the layer has nonexistant elements and is invalid
            this.invalidateLayer(layer);
            continue;
          }

          // the eles in the layer must be in the same continuous order, else the layer is invalid

          var o = offset;

          for (var j = 0; j < layer.eles.length; j++) {
            if (layer.eles[j] !== eles[o + j]) {
              // log('invalidate based on ordering', layer.id);

              this.invalidateLayer(layer);
              break;
            }
          }
        }
      };

      LTCp.updateElementsInLayers = function (eles, update) {
        var self = this;
        var isEles = is.element(eles[0]);

        // collect udpated elements (cascaded from the layers) and update each
        // layer itself along the way
        for (var i = 0; i < eles.length; i++) {
          var req = isEles ? null : eles[i];
          var ele = isEles ? eles[i] : eles[i].ele;
          var rs = ele._private.rscratch;
          var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

          for (var l = minLvl; l <= maxLvl; l++) {
            var layer = caches[l];

            if (!layer) {
              continue;
            }

            // if update is a request from the ele cache, then it affects only
            // the matching level
            if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
              continue;
            }

            update(layer, ele, req);
          }
        }
      };

      LTCp.haveLayers = function () {
        var self = this;
        var haveLayers = false;

        for (var l = minLvl; l <= maxLvl; l++) {
          var layers = self.layersByLevel[l];

          if (layers && layers.length > 0) {
            haveLayers = true;
            break;
          }
        }

        return haveLayers;
      };

      LTCp.invalidateElements = function (eles) {
        var self = this;

        self.lastInvalidationTime = util.performanceNow();

        // log('update invalidate layer time from eles');

        if (eles.length === 0 || !self.haveLayers()) {
          return;
        }

        self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
          self.invalidateLayer(layer);
        });
      };

      LTCp.invalidateLayer = function (layer) {
        // log('update invalidate layer time');

        this.lastInvalidationTime = util.performanceNow();

        if (layer.invalid) {
          return;
        } // save cycles

        var lvl = layer.level;
        var eles = layer.eles;
        var layers = this.layersByLevel[lvl];

        // log('invalidate layer', layer.id );

        util.removeFromArray(layers, layer);
        // layer.eles = [];

        layer.elesQueue = [];

        layer.invalid = true;

        if (layer.replacement) {
          layer.replacement.invalid = true;
        }

        for (var i = 0; i < eles.length; i++) {
          var caches = eles[i]._private.rscratch.imgLayerCaches;

          if (caches) {
            caches[lvl] = null;
          }
        }
      };

      LTCp.refineElementTextures = function (eles) {
        var self = this;

        // log('refine', eles.length);

        self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
          var rLyr = layer.replacement;

          if (!rLyr) {
            rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
            rLyr.replaces = layer;
            rLyr.eles = layer.eles;

            // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
          }

          if (!rLyr.reqs) {
            for (var i = 0; i < rLyr.eles.length; i++) {
              self.queueLayer(rLyr, rLyr.eles[i]);
            }

            // log('queue replacement layer refinement', rLyr.id);
          }
        });
      };

      LTCp.setupEleCacheInvalidation = function () {
        var self = this;
        var eleDeqs = [];

        if (!useEleTxrCaching) {
          return;
        }

        var updatedElesInLayers = util.debounce(function () {
          self.refineElementTextures(eleDeqs);

          eleDeqs = [];
        }, refineEleDebounceTime);

        self.eleTxrCache.onDequeue(function (reqs) {
          for (var i = 0; i < reqs.length; i++) {
            eleDeqs.push(reqs[i]);
          }

          updatedElesInLayers();
        });
      };

      LTCp.queueLayer = function (layer, ele) {
        var self = this;
        var q = self.layersQueue;
        var elesQ = layer.elesQueue;
        var hasId = elesQ.hasId = elesQ.hasId || {};

        // if a layer is going to be replaced, queuing is a waste of time
        if (layer.replacement) {
          return;
        }

        if (ele) {
          if (hasId[ele.id()]) {
            return;
          }

          elesQ.push(ele);
          hasId[ele.id()] = true;
        }

        if (layer.reqs) {
          layer.reqs++;

          q.updateItem(layer);
        } else {
          layer.reqs = 1;

          q.push(layer);
        }
      };

      LTCp.dequeue = function (pxRatio) {
        var self = this;
        var q = self.layersQueue;
        var deqd = [];
        var eleDeqs = 0;

        while (eleDeqs < maxDeqSize) {
          if (q.size() === 0) {
            break;
          }

          var layer = q.peek();

          // if a layer has been or will be replaced, then don't waste time with it
          if (layer.replacement) {
            // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
            q.pop();
            continue;
          }

          // if this is a replacement layer that has been superceded, then forget it
          if (layer.replaces && layer !== layer.replaces.replacement) {
            // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
            q.pop();
            continue;
          }

          if (layer.invalid) {
            // log('replacement layer %s is invalid; dequeued', layer.id);
            q.pop();
            continue;
          }

          var ele = layer.elesQueue.shift();

          if (ele) {
            // log('dequeue layer %s', layer.id);

            self.drawEleInLayer(layer, ele, layer.level, pxRatio);

            eleDeqs++;
          }

          if (deqd.length === 0) {
            // we need only one entry in deqd to queue redrawing etc
            deqd.push(true);
          }

          // if the layer has all its eles done, then remove from the queue
          if (layer.elesQueue.length === 0) {
            q.pop();

            layer.reqs = 0;

            // log('dequeue of layer %s complete', layer.id);

            // when a replacement layer is dequeued, it replaces the old layer in the level
            if (layer.replaces) {
              self.applyLayerReplacement(layer);
            }

            self.requestRedraw();
          }
        }

        return deqd;
      };

      LTCp.applyLayerReplacement = function (layer) {
        var self = this;
        var layersInLevel = self.layersByLevel[layer.level];
        var replaced = layer.replaces;
        var index = layersInLevel.indexOf(replaced);

        // if the replaced layer is not in the active list for the level, then replacing
        // refs would be a mistake (i.e. overwriting the true active layer)
        if (index < 0 || replaced.invalid) {
          // log('replacement layer would have no effect', layer.id);
          return;
        }

        layersInLevel[index] = layer; // replace level ref

        // replace refs in eles
        for (var i = 0; i < layer.eles.length; i++) {
          var _p = layer.eles[i]._private;
          var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

          if (cache) {
            cache[layer.level] = layer;
          }
        }

        // log('apply replacement layer %s over %s', layer.id, replaced.id);

        self.requestRedraw();
      };

      LTCp.requestRedraw = util.debounce(function () {
        var r = this.renderer;

        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        r.redraw();
      }, 100);

      LTCp.setupDequeueing = defs.setupDequeueing({
        deqRedrawThreshold: deqRedrawThreshold,
        deqCost: deqCost,
        deqAvgCost: deqAvgCost,
        deqNoDrawCost: deqNoDrawCost,
        deqFastCost: deqFastCost,
        deq: function deq(self, pxRatio) {
          return self.dequeue(pxRatio);
        },
        onDeqd: util.noop,
        shouldRedraw: util.trueify,
        priority: function priority(self) {
          return self.renderer.beforeRenderPriorities.lyrTxrDeq;
        }
      });

      module.exports = LayeredTextureCache;

      /***/
    },
    /* 128 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      var impl;

      CRp.arrowShapeImpl = function (name) {
        return (impl || (impl = {
          'polygon': function polygon(context, points) {
            for (var i = 0; i < points.length; i++) {
              var pt = points[i];

              context.lineTo(pt.x, pt.y);
            }
          },

          'triangle-backcurve': function triangleBackcurve(context, points, controlPoint) {
            var firstPt;

            for (var i = 0; i < points.length; i++) {
              var pt = points[i];

              if (i === 0) {
                firstPt = pt;
              }

              context.lineTo(pt.x, pt.y);
            }

            context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
          },

          'triangle-tee': function triangleTee(context, trianglePoints, teePoints) {
            if (context.beginPath) {
              context.beginPath();
            }

            var triPts = trianglePoints;
            for (var i = 0; i < triPts.length; i++) {
              var pt = triPts[i];

              context.lineTo(pt.x, pt.y);
            }

            if (context.closePath) {
              context.closePath();
            }

            if (context.beginPath) {
              context.beginPath();
            }

            var teePts = teePoints;
            var firstTeePt = teePoints[0];
            context.moveTo(firstTeePt.x, firstTeePt.y);

            for (var i = 0; i < teePts.length; i++) {
              var pt = teePts[i];

              context.lineTo(pt.x, pt.y);
            }
            if (context.closePath) {
              context.closePath();
            }
          },

          'triangle-cross': function triangleCross(context, trianglePoints, crossLinePoints) {
            if (context.beginPath) {
              context.beginPath();
            }

            var triPts = trianglePoints;
            for (var i = 0; i < triPts.length; i++) {
              var pt = triPts[i];

              context.lineTo(pt.x, pt.y);
            }

            if (context.closePath) {
              context.closePath();
            }

            if (context.beginPath) {
              context.beginPath();
            }

            var teePts = crossLinePoints;
            var firstTeePt = crossLinePoints[0];
            context.moveTo(firstTeePt.x, firstTeePt.y);

            for (var i = 0; i < teePts.length; i++) {
              var pt = teePts[i];

              context.lineTo(pt.x, pt.y);
            }
            if (context.closePath) {
              context.closePath();
            }
          },

          'circle': function circle(context, rx, ry, r) {
            context.arc(rx, ry, r, 0, Math.PI * 2, false);
          }
        }))[name];
      };

      module.exports = CRp;

      /***/
    },
    /* 129 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var CRp = {};

      CRp.drawElement = function (context, ele, shiftToOriginWithBb, showLabel) {
        var r = this;

        if (ele.isNode()) {
          r.drawNode(context, ele, shiftToOriginWithBb, showLabel);
        } else {
          r.drawEdge(context, ele, shiftToOriginWithBb, showLabel);
        }
      };

      CRp.drawCachedElement = function (context, ele, pxRatio, extent) {
        var r = this;
        var bb = ele.boundingBox();

        if (bb.w === 0 || bb.h === 0) {
          return;
        }

        if (!extent || math.boundingBoxesIntersect(bb, extent)) {
          var cache = r.data.eleTxrCache.getElement(ele, bb, pxRatio);

          if (cache != null) {
            context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);
          } else {
            // if the element is not cacheable, then draw directly
            r.drawElement(context, ele);
          }
        }
      };

      CRp.drawElements = function (context, eles) {
        var r = this;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          r.drawElement(context, ele);
        }
      };

      CRp.drawCachedElements = function (context, eles, pxRatio, extent) {
        var r = this;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          r.drawCachedElement(context, ele, pxRatio, extent);
        }
      };

      CRp.drawCachedNodes = function (context, eles, pxRatio, extent) {
        var r = this;

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];

          if (!ele.isNode()) {
            continue;
          }

          r.drawCachedElement(context, ele, pxRatio, extent);
        }
      };

      CRp.drawLayeredElements = function (context, eles, pxRatio, extent) {
        var r = this;

        var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

        if (layers) {
          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            var bb = layer.bb;

            if (bb.w === 0 || bb.h === 0) {
              continue;
            }

            context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
          }
        } else {
          // fall back on plain caching if no layers
          r.drawCachedElements(context, eles, pxRatio, extent);
        }
      };

      CRp.drawDebugPoints = function (context, eles) {
        var draw = function draw(x, y, color) {
          context.fillStyle = color;
          context.fillRect(x - 1, y - 1, 3, 3);
        };

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var rs = ele._private.rscratch;

          if (ele.isNode()) {
            var p = ele.position();

            draw(p.x, p.y, 'magenta');
          } else {
            var pts = rs.allpts;

            for (var j = 0; j + 1 < pts.length; j += 2) {
              var x = pts[j];
              var y = pts[j + 1];

              draw(x, y, 'cyan');
            }

            draw(rs.midX, rs.midY, 'yellow');
          }
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 130 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      CRp.drawEdge = function (context, edge, shiftToOriginWithBb, drawLabel) {
        var r = this;
        var rs = edge._private.rscratch;
        var usePaths = r.usePaths();

        if (!edge.visible()) {
          return;
        }

        // if bezier ctrl pts can not be calculated, then die
        if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
          // isNaN in case edge is impossible and browser bugs (e.g. safari)
          return;
        }

        var bb = void 0;
        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;

          context.translate(-bb.x1, -bb.y1);
        }

        var overlayPadding = edge.pstyle('overlay-padding').pfValue;
        var overlayWidth = 2 * overlayPadding;
        var overlayOpacity = edge.pstyle('overlay-opacity').value;
        var overlayColor = edge.pstyle('overlay-color').value;
        var lineColor = edge.pstyle('line-color').value;
        var opacity = edge.pstyle('opacity').value;
        var lineStyle = edge.pstyle('line-style').value;
        var edgeWidth = edge.pstyle('width').pfValue;

        var drawLine = function drawLine() {
          var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

          context.lineWidth = edgeWidth;
          context.lineCap = 'butt';

          r.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], strokeOpacity);

          r.drawEdgePath(edge, context, rs.allpts, lineStyle);
        };

        var drawOverlay = function drawOverlay() {
          var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : overlayOpacity;

          context.lineWidth = overlayWidth;

          if (rs.edgeType === 'self' && !usePaths) {
            context.lineCap = 'butt';
          } else {
            context.lineCap = 'round';
          }

          r.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], strokeOpacity);

          r.drawEdgePath(edge, context, rs.allpts, 'solid');
        };

        var drawArrows = function drawArrows() {
          var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

          r.drawArrowheads(context, edge, arrowOpacity);
        };

        var drawText = function drawText() {
          r.drawElementText(context, edge, drawLabel);
        };

        context.lineJoin = 'round';

        var ghost = edge.pstyle('ghost').value === 'yes';

        if (ghost) {
          var gx = edge.pstyle('ghost-offset-x').pfValue;
          var gy = edge.pstyle('ghost-offset-y').pfValue;
          var ghostOpacity = edge.pstyle('ghost-opacity').value;
          var effectiveGhostOpacity = opacity * ghostOpacity;

          context.translate(gx, gy);

          drawLine(effectiveGhostOpacity);
          drawArrows(effectiveGhostOpacity);

          context.translate(-gx, -gy);
        }

        drawLine();
        drawArrows();
        drawOverlay();
        drawText();

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      CRp.drawEdgePath = function (edge, context, pts, type) {
        var rs = edge._private.rscratch;
        var canvasCxt = context;
        var path = void 0;
        var pathCacheHit = false;
        var usePaths = this.usePaths();

        if (usePaths) {
          var pathCacheKey = pts.join('$');
          var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

          if (keyMatches) {
            path = context = rs.pathCache;
            pathCacheHit = true;
          } else {
            path = context = new Path2D(); // eslint-disable-line no-undef
            rs.pathCacheKey = pathCacheKey;
            rs.pathCache = path;
          }
        }

        if (canvasCxt.setLineDash) {
          // for very outofdate browsers
          switch (type) {
            case 'dotted':
              canvasCxt.setLineDash([1, 1]);
              break;

            case 'dashed':
              canvasCxt.setLineDash([6, 3]);
              break;

            case 'solid':
              canvasCxt.setLineDash([]);
              break;
          }
        }

        if (!pathCacheHit && !rs.badLine) {
          if (context.beginPath) {
            context.beginPath();
          }
          context.moveTo(pts[0], pts[1]);

          switch (rs.edgeType) {
            case 'bezier':
            case 'self':
            case 'compound':
            case 'multibezier':
              for (var i = 2; i + 3 < pts.length; i += 4) {
                context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
              }
              break;

            case 'straight':
            case 'segments':
            case 'haystack':
              for (var _i = 2; _i + 1 < pts.length; _i += 2) {
                context.lineTo(pts[_i], pts[_i + 1]);
              }
              break;
          }
        }

        context = canvasCxt;
        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        // reset any line dashes
        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }
      };

      CRp.drawArrowheads = function (context, edge, opacity) {
        var rs = edge._private.rscratch;
        var isHaystack = rs.edgeType === 'haystack';

        if (!isHaystack) {
          this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
        }

        this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);

        this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

        if (!isHaystack) {
          this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
        }
      };

      CRp.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
        if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
          return;
        }

        var self = this;
        var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;
        if (arrowShape === 'none') {
          return;
        }

        var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
        var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
        var edgeWidth = edge.pstyle('width').pfValue;
        var edgeOpacity = edge.pstyle('opacity').value;

        if (opacity === undefined) {
          opacity = edgeOpacity;
        }

        var gco = context.globalCompositeOperation;

        if (opacity !== 1 || arrowFill === 'hollow') {
          // then extra clear is needed
          context.globalCompositeOperation = 'destination-out';

          self.fillStyle(context, 255, 255, 255, 1);
          self.strokeStyle(context, 255, 255, 255, 1);

          self.drawArrowShape(edge, prefix, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);

          context.globalCompositeOperation = gco;
        } // otherwise, the opaque arrow clears it for free :)

        var color = edge.pstyle(prefix + '-arrow-color').value;
        self.fillStyle(context, color[0], color[1], color[2], opacity);
        self.strokeStyle(context, color[0], color[1], color[2], opacity);

        self.drawArrowShape(edge, prefix, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
      };

      CRp.drawArrowShape = function (edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
        var r = this;
        var usePaths = this.usePaths();
        var rs = edge._private.rscratch;
        var pathCacheHit = false;
        var path = void 0;
        var canvasContext = context;
        var translation = { x: x, y: y };
        var scale = edge.pstyle('arrow-scale').value;
        var size = this.getArrowWidth(edgeWidth, scale);
        var shapeImpl = r.arrowShapes[shape];

        if (usePaths) {
          var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
          rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
          rs.arrowPathCache = rs.arrowPathCache || {};

          var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
          if (alreadyCached) {
            path = context = rs.arrowPathCache[arrowType];
            pathCacheHit = true;
          } else {
            path = context = new Path2D(); // eslint-disable-line no-undef
            rs.arrowPathCacheKey[arrowType] = pathCacheKey;
            rs.arrowPathCache[arrowType] = path;
          }
        }

        if (context.beginPath) {
          context.beginPath();
        }

        if (!pathCacheHit) {
          shapeImpl.draw(context, size, angle, translation, edgeWidth);
        }

        if (!shapeImpl.leavePathOpen && context.closePath) {
          context.closePath();
        }

        context = canvasContext;

        if (fill === 'filled' || fill === 'both') {
          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        }

        if (fill === 'hollow' || fill === 'both') {
          context.lineWidth = shapeImpl.matchEdgeWidth ? edgeWidth : 1;
          context.lineJoin = 'miter';

          if (usePaths) {
            context.stroke(path);
          } else {
            context.stroke();
          }
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 131 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      CRp.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
        var r = this;

        // detect problematic cases for old browsers with bad images (cheaper than try-catch)
        if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
          return;
        }

        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
      };

      CRp.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
        var r = this;
        var pos = node.position();
        var nodeX = pos.x;
        var nodeY = pos.y;
        var styleObj = node.cy().style();
        var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
        var fit = getIndexedStyle(node, 'background-fit', 'value', index);
        var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
        var nodeW = node.width();
        var nodeH = node.height();
        var paddingX2 = node.padding() * 2;
        var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
        var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
        var rs = node._private.rscratch;
        var clip = node.pstyle('background-clip').value;
        var shouldClip = clip === 'node';
        var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;

        var imgW = img.width || img.cachedW;
        var imgH = img.height || img.cachedH;

        // workaround for broken browsers like ie
        if (null == imgW || null == imgH) {
          document.body.appendChild(img); // eslint-disable-line no-undef

          imgW = img.cachedW = img.width || img.offsetWidth;
          imgH = img.cachedH = img.height || img.offsetHeight;

          document.body.removeChild(img); // eslint-disable-line no-undef
        }

        var w = imgW;
        var h = imgH;

        if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
          if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
            w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
          } else {
            w = getIndexedStyle(node, 'background-width', 'pfValue', index);
          }
        }

        if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
          if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
            h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
          } else {
            h = getIndexedStyle(node, 'background-height', 'pfValue', index);
          }
        }

        if (w === 0 || h === 0) {
          return; // no point in drawing empty image (and chrome is broken in this case)
        }

        if (fit === 'contain') {
          var scale = Math.min(nodeTW / w, nodeTH / h);

          w *= scale;
          h *= scale;
        } else if (fit === 'cover') {
          var scale = Math.max(nodeTW / w, nodeTH / h);

          w *= scale;
          h *= scale;
        }

        var x = nodeX - nodeTW / 2; // left
        if (getIndexedStyle(node, 'background-position-x', 'units', index) === '%') {
          x += (nodeTW - w) * getIndexedStyle(node, 'background-position-x', 'pfValue', index);
        } else {
          x += getIndexedStyle(node, 'background-position-x', 'pfValue', index);
        }

        var y = nodeY - nodeTH / 2; // top
        if (getIndexedStyle(node, 'background-position-y', 'units', index) === '%') {
          y += (nodeTH - h) * getIndexedStyle(node, 'background-position-y', 'pfValue', index);
        } else {
          y += getIndexedStyle(node, 'background-position-y', 'pfValue', index);
        }

        if (rs.pathCache) {
          x -= nodeX;
          y -= nodeY;

          nodeX = 0;
          nodeY = 0;
        }

        var gAlpha = context.globalAlpha;

        context.globalAlpha = imgOpacity;

        if (repeat === 'no-repeat') {

          if (shouldClip) {
            context.save();

            if (rs.pathCache) {
              context.clip(rs.pathCache);
            } else {
              r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

              context.clip();
            }
          }

          r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

          if (shouldClip) {
            context.restore();
          }
        } else {
          var pattern = context.createPattern(img, repeat);
          context.fillStyle = pattern;

          r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

          context.translate(x, y);
          context.fill();
          context.translate(-x, -y);
        }

        context.globalAlpha = gAlpha;
      };

      module.exports = CRp;

      /***/
    },
    /* 132 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var util = __webpack_require__(1);
      var math = __webpack_require__(2);

      var CRp = {};

      CRp.eleTextBiggerThanMin = function (ele, scale) {
        if (!scale) {
          var zoom = ele.cy().zoom();
          var pxRatio = this.getPixelRatio();
          var lvl = Math.ceil(math.log2(zoom * pxRatio)); // the effective texture level

          scale = Math.pow(2, lvl);
        }

        var computedSize = ele.pstyle('font-size').pfValue * scale;
        var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

        if (computedSize < minSize) {
          return false;
        }

        return true;
      };

      CRp.drawElementText = function (context, ele, force) {
        var r = this;

        if (force === undefined) {
          if (!r.eleTextBiggerThanMin(ele)) {
            return;
          }
        } else {
          if (!force) {
            return;
          }
        }

        if (ele.isNode()) {
          var label = ele.pstyle('label');

          if (!label || !label.value) {
            return;
          }

          var textHalign = ele.pstyle('text-halign').strValue;
          var textValign = ele.pstyle('text-valign').strValue;

          switch (textHalign) {
            case 'left':
              context.textAlign = 'right';
              break;

            case 'right':
              context.textAlign = 'left';
              break;

            default:
              // e.g. center
              context.textAlign = 'center';
          }

          context.textBaseline = 'bottom';
        } else {
          var label = ele.pstyle('label');
          var srcLabel = ele.pstyle('source-label');
          var tgtLabel = ele.pstyle('target-label');

          if ((!label || !label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
            return;
          }

          context.textAlign = 'center';
          context.textBaseline = 'bottom';
        }

        r.drawText(context, ele);

        if (ele.isEdge()) {
          r.drawText(context, ele, 'source');

          r.drawText(context, ele, 'target');
        }
      };

      CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

      CRp.getFontCache = function (context) {
        var cache;

        this.fontCaches = this.fontCaches || [];

        for (var i = 0; i < this.fontCaches.length; i++) {
          cache = this.fontCaches[i];

          if (cache.context === context) {
            return cache;
          }
        }

        cache = {
          context: context
        };
        this.fontCaches.push(cache);

        return cache;
      };

      // set up canvas context with font
      // returns transformed text string
      CRp.setupTextStyle = function (context, ele) {
        // Font style
        var parentOpacity = ele.effectiveOpacity();
        var labelStyle = ele.pstyle('font-style').strValue;
        var labelSize = ele.pstyle('font-size').pfValue + 'px';
        var labelFamily = ele.pstyle('font-family').strValue;
        var labelWeight = ele.pstyle('font-weight').strValue;
        var opacity = ele.pstyle('text-opacity').value * ele.pstyle('opacity').value * parentOpacity;
        var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
        var color = ele.pstyle('color').value;
        var outlineColor = ele.pstyle('text-outline-color').value;

        var fontCacheKey = ele._private.fontKey;
        var cache = this.getFontCache(context);

        if (cache.key !== fontCacheKey) {
          context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

          cache.key = fontCacheKey;
        }

        // Calculate text draw position based on text alignment

        // so text outlines aren't jagged
        context.lineJoin = 'round';

        this.fillStyle(context, color[0], color[1], color[2], opacity);

        this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
      };

      function roundRect(ctx, x, y, width, height, radius) {
        var radius = radius || 5;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      // Draw text
      CRp.drawText = function (context, ele, prefix) {
        var _p = ele._private;
        var rscratch = _p.rscratch;
        var parentOpacity = ele.effectiveOpacity();
        if (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0) {
          return;
        }

        var textX = util.getPrefixedProperty(rscratch, 'labelX', prefix);
        var textY = util.getPrefixedProperty(rscratch, 'labelY', prefix);
        var text = this.getLabelText(ele, prefix);

        if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
          this.setupTextStyle(context, ele);

          var pdash = prefix ? prefix + '-' : '';
          var textW = util.getPrefixedProperty(rscratch, 'labelWidth', prefix);
          var textH = util.getPrefixedProperty(rscratch, 'labelHeight', prefix);
          var textAngle = util.getPrefixedProperty(rscratch, 'labelAngle', prefix);
          var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
          var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;

          var isEdge = ele.isEdge();
          var isNode = ele.isNode();

          var halign = ele.pstyle('text-halign').value;
          var valign = ele.pstyle('text-valign').value;

          if (isEdge) {
            halign = 'center';
            valign = 'center';
          }

          textX += marginX;
          textY += marginY;

          var rotation = ele.pstyle('text-rotation');
          var theta;

          if (rotation.strValue === 'autorotate') {
            theta = isEdge ? textAngle : 0;
          } else if (rotation.strValue === 'none') {
            theta = 0;
          } else {
            theta = rotation.pfValue;
          }

          if (theta !== 0) {
            var orgTextX = textX;
            var orgTextY = textY;

            context.translate(orgTextX, orgTextY);
            context.rotate(theta);

            textX = 0;
            textY = 0;
          }

          switch (valign) {
            case 'top':
              break;
            case 'center':
              textY += textH / 2;
              break;
            case 'bottom':
              textY += textH;
              break;
          }

          var backgroundOpacity = ele.pstyle('text-background-opacity').value;
          var borderOpacity = ele.pstyle('text-border-opacity').value;
          var textBorderWidth = ele.pstyle('text-border-width').pfValue;
          var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

          if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
            var bgX = textX - backgroundPadding;

            switch (halign) {
              case 'left':
                bgX -= textW;
                break;
              case 'center':
                bgX -= textW / 2;
                break;
              case 'right':
                break;
            }

            var bgY = textY - textH - backgroundPadding;
            var bgW = textW + 2 * backgroundPadding;
            var bgH = textH + 2 * backgroundPadding;

            if (backgroundOpacity > 0) {
              var textFill = context.fillStyle;
              var textBackgroundColor = ele.pstyle('text-background-color').value;

              context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
              var styleShape = ele.pstyle('text-background-shape').strValue;
              if (styleShape == 'roundrectangle') {
                roundRect(context, bgX, bgY, bgW, bgH, 2);
              } else {
                context.fillRect(bgX, bgY, bgW, bgH);
              }
              context.fillStyle = textFill;
            }

            if (textBorderWidth > 0 && borderOpacity > 0) {
              var textStroke = context.strokeStyle;
              var textLineWidth = context.lineWidth;
              var textBorderColor = ele.pstyle('text-border-color').value;
              var textBorderStyle = ele.pstyle('text-border-style').value;

              context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
              context.lineWidth = textBorderWidth;

              if (context.setLineDash) {
                // for very outofdate browsers
                switch (textBorderStyle) {
                  case 'dotted':
                    context.setLineDash([1, 1]);
                    break;
                  case 'dashed':
                    context.setLineDash([4, 2]);
                    break;
                  case 'double':
                    context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
                    context.setLineDash([]);
                    break;
                  case 'solid':
                    context.setLineDash([]);
                    break;
                }
              }

              context.strokeRect(bgX, bgY, bgW, bgH);

              if (textBorderStyle === 'double') {
                var whiteWidth = textBorderWidth / 2;

                context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
              }

              if (context.setLineDash) {
                // for very outofdate browsers
                context.setLineDash([]);
              }
              context.lineWidth = textLineWidth;
              context.strokeStyle = textStroke;
            }
          }

          var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

          if (lineWidth > 0) {
            context.lineWidth = lineWidth;
          }

          if (ele.pstyle('text-wrap').value === 'wrap') {
            var lines = util.getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
            var lineHeight = textH / lines.length;

            switch (valign) {
              case 'top':
                textY -= (lines.length - 1) * lineHeight;
                break;
              case 'center':
              case 'bottom':
                textY -= (lines.length - 1) * lineHeight;
                break;
            }

            for (var l = 0; l < lines.length; l++) {
              if (lineWidth > 0) {
                context.strokeText(lines[l], textX, textY);
              }

              context.fillText(lines[l], textX, textY);

              textY += lineHeight;
            }
          } else {
            if (lineWidth > 0) {
              context.strokeText(text, textX, textY);
            }

            context.fillText(text, textX, textY);
          }

          if (theta !== 0) {
            context.rotate(-theta);
            context.translate(-orgTextX, -orgTextY);
          }
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 133 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /* global Path2D */

      var is = __webpack_require__(0);

      var CRp = {};

      CRp.drawNode = function (context, node, shiftToOriginWithBb, drawLabel) {
        var r = this;
        var nodeWidth = void 0,
            nodeHeight = void 0;
        var _p = node._private;
        var rs = _p.rscratch;
        var pos = node.position();

        if (!is.number(pos.x) || !is.number(pos.y)) {
          return; // can't draw node with undefined position
        }

        if (!node.visible()) {
          return;
        }

        var parentOpacity = node.effectiveOpacity();

        var usePaths = r.usePaths();
        var path = void 0;
        var pathCacheHit = false;

        var padding = node.padding();

        nodeWidth = node.width() + 2 * padding;
        nodeHeight = node.height() + 2 * padding;

        //
        // setup shift

        var bb = void 0;
        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;

          context.translate(-bb.x1, -bb.y1);
        }

        //
        // load bg image

        var bgImgProp = node.pstyle('background-image');
        var urls = bgImgProp.value;
        var urlDefined = new Array(urls.length);
        var image = new Array(urls.length);
        var numImages = 0;
        for (var i = 0; i < urls.length; i++) {
          var url = urls[i];
          var defd = urlDefined[i] = url != null && url !== 'none';

          if (defd) {
            var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);

            numImages++;

            // get image, and if not loaded then ask to redraw when later loaded
            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
              node.emitAndNotify('background');
            });
          }
        }

        //
        // setup styles

        var darkness = node.pstyle('background-blacken').value;
        var borderWidth = node.pstyle('border-width').pfValue;
        var bgColor = node.pstyle('background-color').value;
        var bgOpacity = node.pstyle('background-opacity').value * parentOpacity;
        var borderColor = node.pstyle('border-color').value;
        var borderStyle = node.pstyle('border-style').value;
        var borderOpacity = node.pstyle('border-opacity').value * parentOpacity;

        context.lineJoin = 'miter'; // so borders are square with the node shape

        var setupShapeColor = function setupShapeColor() {
          var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;

          r.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], bgOpy);
        };

        var setupBorderColor = function setupBorderColor() {
          var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;

          r.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
        };

        //
        // setup shape

        var styleShape = node.pstyle('shape').strValue;
        var shapePts = node.pstyle('shape-polygon-points').pfValue;

        if (usePaths) {
          var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + (styleShape === 'polygon' ? '$' + shapePts.join('$') : '');

          context.translate(pos.x, pos.y);

          if (rs.pathCacheKey === pathCacheKey) {
            path = rs.pathCache;
            pathCacheHit = true;
          } else {
            path = new Path2D();
            rs.pathCacheKey = pathCacheKey;
            rs.pathCache = path;
          }
        }

        var drawShape = function drawShape() {
          if (!pathCacheHit) {

            var npos = pos;

            if (usePaths) {
              npos = {
                x: 0,
                y: 0
              };
            }

            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
          }

          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        };

        var drawImages = function drawImages() {
          var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

          var prevBging = _p.backgrounding;
          var totalCompleted = 0;

          for (var _i = 0; _i < image.length; _i++) {
            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
              totalCompleted++;
              r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
            }
          }

          _p.backgrounding = !(totalCompleted === numImages);
          if (prevBging !== _p.backgrounding) {
            // update style b/c :backgrounding state changed
            node.updateStyle(false);
          }
        };

        var drawPie = function drawPie() {
          var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parentOpacity;

          if (r.hasPie(node)) {
            r.drawPie(context, node, pieOpacity);

            // redraw/restore path if steps after pie need it
            if (redrawShape) {

              if (!usePaths) {
                r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
              }
            }
          }
        };

        var darken = function darken() {
          var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

          var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
          var c = darkness > 0 ? 0 : 255;

          if (darkness !== 0) {
            r.fillStyle(context, c, c, c, opacity);

            if (usePaths) {
              context.fill(path);
            } else {
              context.fill();
            }
          }
        };

        var drawBorder = function drawBorder() {
          if (borderWidth > 0) {

            context.lineWidth = borderWidth;
            context.lineCap = 'butt';

            if (context.setLineDash) {
              // for very outofdate browsers
              switch (borderStyle) {
                case 'dotted':
                  context.setLineDash([1, 1]);
                  break;

                case 'dashed':
                  context.setLineDash([4, 2]);
                  break;

                case 'solid':
                case 'double':
                  context.setLineDash([]);
                  break;
              }
            }

            if (usePaths) {
              context.stroke(path);
            } else {
              context.stroke();
            }

            if (borderStyle === 'double') {
              context.lineWidth = borderWidth / 3;

              var gco = context.globalCompositeOperation;
              context.globalCompositeOperation = 'destination-out';

              if (usePaths) {
                context.stroke(path);
              } else {
                context.stroke();
              }

              context.globalCompositeOperation = gco;
            }

            // reset in case we changed the border style
            if (context.setLineDash) {
              // for very outofdate browsers
              context.setLineDash([]);
            }
          }
        };

        var drawOverlay = function drawOverlay() {
          var overlayPadding = node.pstyle('overlay-padding').pfValue;
          var overlayOpacity = node.pstyle('overlay-opacity').value;
          var overlayColor = node.pstyle('overlay-color').value;

          if (overlayOpacity > 0) {
            r.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

            r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);

            context.fill();
          }
        };

        var drawText = function drawText() {
          r.drawElementText(context, node, drawLabel);
        };

        var ghost = node.pstyle('ghost').value === 'yes';

        if (ghost) {
          var gx = node.pstyle('ghost-offset-x').pfValue;
          var gy = node.pstyle('ghost-offset-y').pfValue;
          var ghostOpacity = node.pstyle('ghost-opacity').value;
          var effGhostOpacity = ghostOpacity * parentOpacity;

          context.translate(gx, gy);

          setupShapeColor(ghostOpacity * bgOpacity);
          drawShape();
          drawImages(effGhostOpacity);
          drawPie(darkness !== 0 || borderWidth !== 0);
          darken(effGhostOpacity);
          setupBorderColor(ghostOpacity * borderOpacity);
          drawBorder();

          context.translate(-gx, -gy);
        }

        setupShapeColor();
        drawShape();
        drawImages();
        drawPie(darkness !== 0 || borderWidth !== 0);
        darken();
        setupBorderColor();
        drawBorder();

        if (usePaths) {
          context.translate(-pos.x, -pos.y);
        }

        drawText();
        drawOverlay();

        //
        // clean up shift

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      // does the node have at least one pie piece?
      CRp.hasPie = function (node) {
        node = node[0]; // ensure ele ref

        return node._private.hasPie;
      };

      CRp.drawPie = function (context, node, nodeOpacity, pos) {
        node = node[0]; // ensure ele ref
        pos = pos || node.position();

        var cyStyle = node.cy().style();
        var pieSize = node.pstyle('pie-size');
        var x = pos.x;
        var y = pos.y;
        var nodeW = node.width();
        var nodeH = node.height();
        var radius = Math.min(nodeW, nodeH) / 2; // must fit in node
        var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
        var usePaths = this.usePaths();

        if (usePaths) {
          x = 0;
          y = 0;
        }

        if (pieSize.units === '%') {
          radius = radius * pieSize.pfValue;
        } else if (pieSize.pfValue !== undefined) {
          radius = pieSize.pfValue / 2;
        }

        for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
          // 1..N
          var size = node.pstyle('pie-' + i + '-background-size').value;
          var color = node.pstyle('pie-' + i + '-background-color').value;
          var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
          var percent = size / 100; // map integer range [0, 100] to [0, 1]

          // percent can't push beyond 1
          if (percent + lastPercent > 1) {
            percent = 1 - lastPercent;
          }

          var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
          var angleDelta = 2 * Math.PI * percent;
          var angleEnd = angleStart + angleDelta;

          // ignore if
          // - zero size
          // - we're already beyond the full circle
          // - adding the current slice would go beyond the full circle
          if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
            continue;
          }

          context.beginPath();
          context.moveTo(x, y);
          context.arc(x, y, radius, angleStart, angleEnd);
          context.closePath();

          this.fillStyle(context, color[0], color[1], color[2], opacity);

          context.fill();

          lastPercent += percent;
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 134 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      var util = __webpack_require__(1);

      var motionBlurDelay = 100;

      // var isFirefox = typeof InstallTrigger !== 'undefined';

      CRp.getPixelRatio = function () {
        var context = this.data.contexts[0];

        if (this.forcedPixelRatio != null) {
          return this.forcedPixelRatio;
        }

        var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

        return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
      };

      CRp.paintCache = function (context) {
        var caches = this.paintCaches = this.paintCaches || [];
        var needToCreateCache = true;
        var cache;

        for (var i = 0; i < caches.length; i++) {
          cache = caches[i];

          if (cache.context === context) {
            needToCreateCache = false;
            break;
          }
        }

        if (needToCreateCache) {
          cache = {
            context: context
          };
          caches.push(cache);
        }

        return cache;
      };

      CRp.fillStyle = function (context, r, g, b, a) {
        context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // turn off for now, seems context does its own caching

        // var cache = this.paintCache(context);

        // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // if( cache.fillStyle !== fillStyle ){
        //   context.fillStyle = cache.fillStyle = fillStyle;
        // }
      };

      CRp.strokeStyle = function (context, r, g, b, a) {
        context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // turn off for now, seems context does its own caching

        // var cache = this.paintCache(context);

        // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

        // if( cache.strokeStyle !== strokeStyle ){
        //   context.strokeStyle = cache.strokeStyle = strokeStyle;
        // }
      };

      // Resize canvas
      CRp.matchCanvasSize = function (container) {
        var r = this;
        var data = r.data;
        var bb = r.findContainerClientCoords();
        var width = bb[2];
        var height = bb[3];
        var pixelRatio = r.getPixelRatio();
        var mbPxRatio = r.motionBlurPxRatio;

        if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
          pixelRatio = mbPxRatio;
        }

        var canvasWidth = width * pixelRatio;
        var canvasHeight = height * pixelRatio;
        var canvas;

        if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
          return; // save cycles if same
        }

        r.fontCaches = null; // resizing resets the style

        var canvasContainer = data.canvasContainer;
        canvasContainer.style.width = width + 'px';
        canvasContainer.style.height = height + 'px';

        for (var i = 0; i < r.CANVAS_LAYERS; i++) {
          canvas = data.canvases[i];

          canvas.width = canvasWidth;
          canvas.height = canvasHeight;

          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        }

        for (var i = 0; i < r.BUFFER_COUNT; i++) {
          canvas = data.bufferCanvases[i];

          canvas.width = canvasWidth;
          canvas.height = canvasHeight;

          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        }

        r.textureMult = 1;
        if (pixelRatio <= 1) {
          canvas = data.bufferCanvases[r.TEXTURE_BUFFER];

          r.textureMult = 2;
          canvas.width = canvasWidth * r.textureMult;
          canvas.height = canvasHeight * r.textureMult;
        }

        r.canvasWidth = canvasWidth;
        r.canvasHeight = canvasHeight;
      };

      CRp.renderTo = function (cxt, zoom, pan, pxRatio) {
        this.render({
          forcedContext: cxt,
          forcedZoom: zoom,
          forcedPan: pan,
          drawAllLayers: true,
          forcedPxRatio: pxRatio
        });
      };

      CRp.render = function (options) {
        options = options || util.staticEmptyObject();

        var forcedContext = options.forcedContext;
        var drawAllLayers = options.drawAllLayers;
        var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
        var forcedZoom = options.forcedZoom;
        var forcedPan = options.forcedPan;
        var r = this;
        var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
        var cy = r.cy;var data = r.data;
        var needDraw = data.canvasNeedsRedraw;
        var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
        var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
        var mbPxRatio = r.motionBlurPxRatio;
        var hasCompoundNodes = cy.hasCompoundNodes();
        var inNodeDragGesture = r.hoverData.draggingEles;
        var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
        motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
        var motionBlurFadeEffect = motionBlur;

        if (!forcedContext) {
          if (r.prevPxRatio !== pixelRatio) {
            r.invalidateContainerClientCoordsCache();
            r.matchCanvasSize(r.container);

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }

          r.prevPxRatio = pixelRatio;
        }

        if (!forcedContext && r.motionBlurTimeout) {
          clearTimeout(r.motionBlurTimeout);
        }

        if (motionBlur) {
          if (r.mbFrames == null) {
            r.mbFrames = 0;
          }

          r.mbFrames++;

          if (r.mbFrames < 3) {
            // need several frames before even high quality motionblur
            motionBlurFadeEffect = false;
          }

          // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
          if (r.mbFrames > r.minMbLowQualFrames) {
            //r.fullQualityMb = false;
            r.motionBlurPxRatio = r.mbPxRBlurry;
          }
        }

        if (r.clearingMotionBlur) {
          r.motionBlurPxRatio = 1;
        }

        // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
        // because a rogue async texture frame would clear needDraw
        if (r.textureDrawLastFrame && !textureDraw) {
          needDraw[r.NODE] = true;
          needDraw[r.SELECT_BOX] = true;
        }

        var coreStyle = cy.style()._private.coreStyle;

        var zoom = cy.zoom();
        var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
        var pan = cy.pan();
        var effectivePan = {
          x: pan.x,
          y: pan.y
        };

        var vp = {
          zoom: zoom,
          pan: {
            x: pan.x,
            y: pan.y
          }
        };
        var prevVp = r.prevViewport;
        var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

        // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
        if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
          r.motionBlurPxRatio = 1;
        }

        if (forcedPan) {
          effectivePan = forcedPan;
        }

        // apply pixel ratio

        effectiveZoom *= pixelRatio;
        effectivePan.x *= pixelRatio;
        effectivePan.y *= pixelRatio;

        var eles = r.getCachedZSortedEles();

        function mbclear(context, x, y, w, h) {
          var gco = context.globalCompositeOperation;

          context.globalCompositeOperation = 'destination-out';
          r.fillStyle(context, 255, 255, 255, r.motionBlurTransparency);
          context.fillRect(x, y, w, h);

          context.globalCompositeOperation = gco;
        }

        function setContextTransform(context, clear) {
          var ePan, eZoom, w, h;

          if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
            ePan = {
              x: pan.x * mbPxRatio,
              y: pan.y * mbPxRatio
            };

            eZoom = zoom * mbPxRatio;

            w = r.canvasWidth * mbPxRatio;
            h = r.canvasHeight * mbPxRatio;
          } else {
            ePan = effectivePan;
            eZoom = effectiveZoom;

            w = r.canvasWidth;
            h = r.canvasHeight;
          }

          context.setTransform(1, 0, 0, 1, 0, 0);

          if (clear === 'motionBlur') {
            mbclear(context, 0, 0, w, h);
          } else if (!forcedContext && (clear === undefined || clear)) {
            context.clearRect(0, 0, w, h);
          }

          if (!drawAllLayers) {
            context.translate(ePan.x, ePan.y);
            context.scale(eZoom, eZoom);
          }
          if (forcedPan) {
            context.translate(forcedPan.x, forcedPan.y);
          }
          if (forcedZoom) {
            context.scale(forcedZoom, forcedZoom);
          }
        }

        if (!textureDraw) {
          r.textureDrawLastFrame = false;
        }

        if (textureDraw) {
          r.textureDrawLastFrame = true;

          var bb;

          if (!r.textureCache) {
            r.textureCache = {};

            bb = r.textureCache.bb = cy.mutableElements().boundingBox();

            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];

            var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];

            cxt.setTransform(1, 0, 0, 1, 0, 0);
            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);

            r.render({
              forcedContext: cxt,
              drawOnlyNodeLayer: true,
              forcedPxRatio: pixelRatio * r.textureMult
            });

            var vp = r.textureCache.viewport = {
              zoom: cy.zoom(),
              pan: cy.pan(),
              width: r.canvasWidth,
              height: r.canvasHeight
            };

            vp.mpan = {
              x: (0 - vp.pan.x) / vp.zoom,
              y: (0 - vp.pan.y) / vp.zoom
            };
          }

          needDraw[r.DRAG] = false;
          needDraw[r.NODE] = false;

          var context = data.contexts[r.NODE];

          var texture = r.textureCache.texture;
          var vp = r.textureCache.viewport;
          bb = r.textureCache.bb;

          context.setTransform(1, 0, 0, 1, 0, 0);

          if (motionBlur) {
            mbclear(context, 0, 0, vp.width, vp.height);
          } else {
            context.clearRect(0, 0, vp.width, vp.height);
          }

          var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
          var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
          r.fillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
          context.fillRect(0, 0, vp.width, vp.height);

          var zoom = cy.zoom();

          setContextTransform(context, false);

          context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
          context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
        } else if (r.textureOnViewport && !forcedContext) {
          // clear the cache since we don't need it
          r.textureCache = null;
        }

        var extent = cy.extent();
        var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles;
        var hideEdges = r.hideEdgesOnViewport && vpManip;

        var needMbClear = [];

        needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
        if (needMbClear[r.NODE]) {
          r.clearedForMotionBlur[r.NODE] = true;
        }

        needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
        if (needMbClear[r.DRAG]) {
          r.clearedForMotionBlur[r.DRAG] = true;
        }

        if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
          var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
          var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
          var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

          setContextTransform(context, clear);

          if (hideEdges) {
            r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
          } else {
            r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
          }

          if (r.debug) {
            r.drawDebugPoints(context, eles.nondrag);
          }

          if (!drawAllLayers && !motionBlur) {
            needDraw[r.NODE] = false;
          }
        }

        if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
          var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
          var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);

          setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

          if (hideEdges) {
            r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
          } else {
            r.drawCachedElements(context, eles.drag, pixelRatio, extent);
          }

          if (r.debug) {
            r.drawDebugPoints(context, eles.drag);
          }

          if (!drawAllLayers && !motionBlur) {
            needDraw[r.DRAG] = false;
          }
        }

        if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
          var context = forcedContext || data.contexts[r.SELECT_BOX];

          setContextTransform(context);

          if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
            var zoom = r.cy.zoom();
            var borderWidth = coreStyle['selection-box-border-width'].value / zoom;

            context.lineWidth = borderWidth;
            context.fillStyle = 'rgba(' + coreStyle['selection-box-color'].value[0] + ',' + coreStyle['selection-box-color'].value[1] + ',' + coreStyle['selection-box-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

            if (borderWidth > 0) {
              context.strokeStyle = 'rgba(' + coreStyle['selection-box-border-color'].value[0] + ',' + coreStyle['selection-box-border-color'].value[1] + ',' + coreStyle['selection-box-border-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

              context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
            }
          }

          if (data.bgActivePosistion && !r.hoverData.selecting) {
            var zoom = r.cy.zoom();
            var pos = data.bgActivePosistion;

            context.fillStyle = 'rgba(' + coreStyle['active-bg-color'].value[0] + ',' + coreStyle['active-bg-color'].value[1] + ',' + coreStyle['active-bg-color'].value[2] + ',' + coreStyle['active-bg-opacity'].value + ')';

            context.beginPath();
            context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
            context.fill();
          }

          var timeToRender = r.lastRedrawTime;
          if (r.showFps && timeToRender) {
            timeToRender = Math.round(timeToRender);
            var fps = Math.round(1000 / timeToRender);

            context.setTransform(1, 0, 0, 1, 0, 0);

            context.fillStyle = 'rgba(255, 0, 0, 0.75)';
            context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
            context.lineWidth = 1;
            context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

            var maxFps = 60;
            context.strokeRect(0, 30, 250, 20);
            context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
          }

          if (!drawAllLayers) {
            needDraw[r.SELECT_BOX] = false;
          }
        }

        // motionblur: blit rendered blurry frames
        if (motionBlur && mbPxRatio !== 1) {
          var cxtNode = data.contexts[r.NODE];
          var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];

          var cxtDrag = data.contexts[r.DRAG];
          var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

          var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
            cxt.setTransform(1, 0, 0, 1, 0, 0);

            if (needClear || !motionBlurFadeEffect) {
              cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
            } else {
              mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
            }

            var pxr = mbPxRatio;

            cxt.drawImage(txt, // img
            0, 0, // sx, sy
            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
            0, 0, // x, y
            r.canvasWidth, r.canvasHeight // w, h
            );
          };

          if (needDraw[r.NODE] || needMbClear[r.NODE]) {
            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
            needDraw[r.NODE] = false;
          }

          if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
            needDraw[r.DRAG] = false;
          }
        }

        r.prevViewport = vp;

        if (r.clearingMotionBlur) {
          r.clearingMotionBlur = false;
          r.motionBlurCleared = true;
          r.motionBlur = true;
        }

        if (motionBlur) {
          r.motionBlurTimeout = setTimeout(function () {
            r.motionBlurTimeout = null;

            r.clearedForMotionBlur[r.NODE] = false;
            r.clearedForMotionBlur[r.DRAG] = false;
            r.motionBlur = false;
            r.clearingMotionBlur = !textureDraw;
            r.mbFrames = 0;

            needDraw[r.NODE] = true;
            needDraw[r.DRAG] = true;

            r.redraw();
          }, motionBlurDelay);
        }

        if (!forcedContext) {
          cy.emit('render');
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 135 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var math = __webpack_require__(2);

      var CRp = {};

      // @O Polygon drawing
      CRp.drawPolygonPath = function (context, x, y, width, height, points) {

        var halfW = width / 2;
        var halfH = height / 2;

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(x + halfW * points[0], y + halfH * points[1]);

        for (var i = 1; i < points.length / 2; i++) {
          context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
        }

        context.closePath();
      };

      // Round rectangle drawing
      CRp.drawRoundRectanglePath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var cornerRadius = math.getRoundRectangleRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        }

        // Start at top middle
        context.moveTo(x, y - halfHeight);
        // Arc from middle top to right side
        context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
        // Arc from right side to bottom
        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
        // Arc from bottom to left side
        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
        // Arc from left side to topBorder
        context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
        // Join line
        context.lineTo(x, y - halfHeight);

        context.closePath();
      };

      CRp.drawBottomRoundRectanglePath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var cornerRadius = math.getRoundRectangleRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        }

        // Start at top middle
        context.moveTo(x, y - halfHeight);
        context.lineTo(x + halfWidth, y - halfHeight);
        context.lineTo(x + halfWidth, y);

        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);

        context.lineTo(x - halfWidth, y - halfHeight);
        context.lineTo(x, y - halfHeight);

        context.closePath();
      };

      CRp.drawCutRectanglePath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var cornerLength = math.getCutRectangleCornerLength();

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(x - halfWidth + cornerLength, y - halfHeight);

        context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
        context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
        context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
        context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
        context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
        context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
        context.lineTo(x - halfWidth, y - halfHeight + cornerLength);

        context.closePath();
      };

      CRp.drawBarrelPath = function (context, x, y, width, height) {

        var halfWidth = width / 2;
        var halfHeight = height / 2;

        var xBegin = x - halfWidth;
        var xEnd = x + halfWidth;
        var yBegin = y - halfHeight;
        var yEnd = y + halfHeight;

        var barrelCurveConstants = math.getBarrelCurveConstants(width, height);
        var wOffset = barrelCurveConstants.widthOffset;
        var hOffset = barrelCurveConstants.heightOffset;
        var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(xBegin, yBegin + hOffset);

        context.lineTo(xBegin, yEnd - hOffset);
        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);

        context.lineTo(xEnd - wOffset, yEnd);
        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);

        context.lineTo(xEnd, yBegin + hOffset);
        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);

        context.lineTo(xBegin + wOffset, yBegin);
        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);

        context.closePath();
      };

      var sin0 = Math.sin(0);
      var cos0 = Math.cos(0);

      var sin = {};
      var cos = {};

      var ellipseStepSize = Math.PI / 40;

      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
        sin[i] = Math.sin(i);
        cos[i] = Math.cos(i);
      }

      CRp.drawEllipsePath = function (context, centerX, centerY, width, height) {
        if (context.beginPath) {
          context.beginPath();
        }

        if (context.ellipse) {
          context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
        } else {
          var xPos, yPos;
          var rw = width / 2;
          var rh = height / 2;
          for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

            if (i === 0) {
              context.moveTo(xPos, yPos);
            } else {
              context.lineTo(xPos, yPos);
            }
          }
        }

        context.closePath();
      };

      module.exports = CRp;

      /***/
    },
    /* 136 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);

      var CRp = {};

      CRp.createBuffer = function (w, h) {
        var buffer = document.createElement('canvas'); // eslint-disable-line no-undef
        buffer.width = w;
        buffer.height = h;

        return [buffer, buffer.getContext('2d')];
      };

      CRp.bufferCanvasImage = function (options) {
        var cy = this.cy;
        var eles = cy.mutableElements();
        var bb = eles.boundingBox();
        var ctrRect = this.findContainerClientCoords();
        var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
        var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
        var specdMaxDims = is.number(options.maxWidth) || is.number(options.maxHeight);
        var pxRatio = this.getPixelRatio();
        var scale = 1;

        if (options.scale !== undefined) {
          width *= options.scale;
          height *= options.scale;

          scale = options.scale;
        } else if (specdMaxDims) {
          var maxScaleW = Infinity;
          var maxScaleH = Infinity;

          if (is.number(options.maxWidth)) {
            maxScaleW = scale * options.maxWidth / width;
          }

          if (is.number(options.maxHeight)) {
            maxScaleH = scale * options.maxHeight / height;
          }

          scale = Math.min(maxScaleW, maxScaleH);

          width *= scale;
          height *= scale;
        }

        if (!specdMaxDims) {
          width *= pxRatio;
          height *= pxRatio;
          scale *= pxRatio;
        }

        var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

        buffCanvas.width = width;
        buffCanvas.height = height;

        buffCanvas.style.width = width + 'px';
        buffCanvas.style.height = height + 'px';

        var buffCxt = buffCanvas.getContext('2d');

        // Rasterize the layers, but only if container has nonzero size
        if (width > 0 && height > 0) {

          buffCxt.clearRect(0, 0, width, height);

          buffCxt.globalCompositeOperation = 'source-over';

          var zsortedEles = this.getCachedZSortedEles();

          if (options.full) {
            // draw the full bounds of the graph
            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
            buffCxt.scale(scale, scale);

            this.drawElements(buffCxt, zsortedEles);

            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
          } else {
            // draw the current view
            var pan = cy.pan();

            var translation = {
              x: pan.x * scale,
              y: pan.y * scale
            };

            scale *= cy.zoom();

            buffCxt.translate(translation.x, translation.y);
            buffCxt.scale(scale, scale);

            this.drawElements(buffCxt, zsortedEles);

            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(-translation.x, -translation.y);
          }

          // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs
          if (options.bg) {
            buffCxt.globalCompositeOperation = 'destination-over';

            buffCxt.fillStyle = options.bg;
            buffCxt.rect(0, 0, width, height);
            buffCxt.fill();
          }
        }

        return buffCanvas;
      };

      function b64ToBlob(b64, mimeType) {
        var bytes = atob(b64);
        var buff = new ArrayBuffer(bytes.length);
        var buffUint8 = new Uint8Array(buff);

        for (var i = 0; i < bytes.length; i++) {
          buffUint8[i] = bytes.charCodeAt(i);
        }

        return new Blob([buff], { type: mimeType });
      }

      function b64UriToB64(b64uri) {
        var i = b64uri.indexOf(',');

        return b64uri.substr(i + 1);
      };

      function output(options, canvas, mimeType) {
        var b64Uri = canvas.toDataURL(mimeType, options.quality);

        switch (options.output) {
          case 'blob':
            return b64ToBlob(b64UriToB64(b64Uri), mimeType);

          case 'base64':
            return b64UriToB64(b64Uri);

          case 'base64uri':
          default:
            return b64Uri;
        }
      }

      CRp.png = function (options) {
        return output(options, this.bufferCanvasImage(options), 'image/png');
      };

      CRp.jpg = function (options) {
        return output(options, this.bufferCanvasImage(options), 'image/jpeg');
      };

      module.exports = CRp;

      /***/
    },
    /* 137 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var CRp = {};

      CRp.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
        switch (name) {
          case 'ellipse':
            return this.drawEllipsePath(context, centerX, centerY, width, height);
          case 'polygon':
            return this.drawPolygonPath(context, centerX, centerY, width, height, points);
          case 'roundrectangle':
            return this.drawRoundRectanglePath(context, centerX, centerY, width, height);
          case 'cutrectangle':
            return this.drawCutRectanglePath(context, centerX, centerY, width, height);
          case 'bottomroundrectangle':
            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);
          case 'barrel':
            return this.drawBarrelPath(context, centerX, centerY, width, height);
        }
      };

      module.exports = CRp;

      /***/
    },
    /* 138 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var is = __webpack_require__(0);
      var util = __webpack_require__(1);
      var Style = __webpack_require__(18);

      // a dummy stylesheet object that doesn't need a reference to the core
      // (useful for init)
      var Stylesheet = function Stylesheet() {
        if (!(this instanceof Stylesheet)) {
          return new Stylesheet();
        }

        this.length = 0;
      };

      var sheetfn = Stylesheet.prototype;

      sheetfn.instanceString = function () {
        return 'stylesheet';
      };

      // just store the selector to be parsed later
      sheetfn.selector = function (selector) {
        var i = this.length++;

        this[i] = {
          selector: selector,
          properties: []
        };

        return this; // chaining
      };

      // just store the property to be parsed later
      sheetfn.css = function (name, value) {
        var i = this.length - 1;

        if (is.string(name)) {
          this[i].properties.push({
            name: name,
            value: value
          });
        } else if (is.plainObject(name)) {
          var map = name;

          for (var j = 0; j < Style.properties.length; j++) {
            var prop = Style.properties[j];
            var mapVal = map[prop.name];

            if (mapVal === undefined) {
              // also try camel case name
              mapVal = map[util.dash2camel(prop.name)];
            }

            if (mapVal !== undefined) {
              var _name = prop.name;
              var _value = mapVal;

              this[i].properties.push({
                name: _name,
                value: _value
              });
            }
          }
        }

        return this; // chaining
      };

      sheetfn.style = sheetfn.css;

      // generate a real style object from the dummy stylesheet
      sheetfn.generateStyle = function (cy) {
        var style = new Style(cy);

        return this.appendToStyle(style);
      };

      // append a dummy stylesheet object on a real style object
      sheetfn.appendToStyle = function (style) {
        for (var i = 0; i < this.length; i++) {
          var context = this[i];
          var selector = context.selector;
          var props = context.properties;

          style.selector(selector); // apply selector

          for (var j = 0; j < props.length; j++) {
            var prop = props[j];

            style.css(prop.name, prop.value); // apply property
          }
        }

        return style;
      };

      module.exports = Stylesheet;

      /***/
    },
    /* 139 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = "snapshot-2fd4aa6cc2-1531006893492";

      /***/
    }]
    /******/)
  );
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"timers":334}],343:[function(require,module,exports){
'use strict';

var _ = require('underscore');

/**
 * detect and return the format on passed text
 *
 * @param {String} text
 * @return {String}
 */
function detectFormat(text) {
  log.debug('called detectFormat(' + text + ')');

  var format = 'Unknown';
  text = (text || '').trim();

  if (text === '') {
    log.info('detectFormat() received empty text');
    return format;
  }

  // get `word` to point to the first non-comment word
  var lines = text.split('\n');
  var wordIndex = 0,
      word = lines[wordIndex];

  while (word.startsWith('#')) {
    log.debug('detectFormat(): detected a comment: ' + word);
    wordIndex++;
    if (wordIndex === lines.length) break;
    word = lines[wordIndex];
  }

  if (word.match(/^\W*[\'|\"]</)) {
    format = 'CG3';
  } else if (word.match(/^\s*1/)) {
    format = 'CoNLL-U'; // UNSAFE: the first token in the string should start with "1"
  } else if (text.includes('(') && text.includes('\n') // SD needs to be at least two lines
  && (text.includes(')\n') || text[text.length - 1] === ')')) {

    format = 'SD'; // UNSAFE
  } else if (word.match(/\[/)) {
    format = 'Brackets'; // UNSAFE: this will catch any plain text string starting with "[" :/
  } else if (text[text.length - 1] !== ')') {
    format = 'plain text'; // UNSAFE
  }

  log.debug('detectFormat(): detected ' + format);
  return format;
}

module.exports = detectFormat;

},{"underscore":335}],344:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');
var $ = require('jquery');

var Menu = function () {
  function Menu(gui) {
    _classCallCheck(this, Menu);

    this.gui = gui;
    this.reset();
    this.bind();
  }

  _createClass(Menu, [{
    key: 'reset',
    value: function reset() {

      this.is_visible = false;
      this.pinned = {
        login: false,
        'manage-permissions': false,

        'save-corpus': false,
        'upload-corpus': false,
        'download-corpus': false,
        'discard-corpus': false,

        'export-as-png': false,
        'export-as-latex': false,

        'show-help': true,
        'show-settings': false,
        'show-table': false
      };
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _this = this;

      $('#btnMenuDropdown').click(function (e) {
        return _this.toggle(e);
      });
      $('.dropdown-group-item .pin').click(function (e) {
        return _this.togglePinned(e);
      });
    }
  }, {
    key: 'update',
    value: function update() {

      $('#dropdown-container .dropdown-toggle').removeClass('open');
      if (this.is_visible) {
        $('#dropdown-container .dropdown-toggle').addClass('open');
      }

      $('#dropdown-container .dropdown-content').removeClass('menu-show menu-hidden').addClass(this.is_visible ? 'menu-show' : 'menu-hidden');

      $('.dropdown-group-item.pinnable, .btn.pinnable').removeClass('pinned unpinned');
      _.each(this.pinned, function (bool, name) {
        $('.dropdown-group-item[name="' + name + '"]').addClass(bool ? 'pinned' : 'unpinned');
        $('.btn.pinnable[name="' + name + '"]').addClass(bool ? 'pinned' : 'unpinned');
      });

      $('.btn-group .btn').css('border-radius', '0');
      $('.btn-group').each(function (i, group) {
        group = $(group);

        var visible = false,
            first = null,
            last = null;

        group.children().each(function (j, btn) {
          btn = $(btn);

          if (!btn.hasClass('unpinned') && btn.hasClass('btn')) {
            first = first || btn;
            last = btn;
          }

          if (btn.hasClass('pinnable')) {
            visible = visible || btn.hasClass('pinned');
          } else {
            visible = true;
          }
        });

        group.css('display', visible ? 'inline-flex' : 'none');
        if (first) first.css('border-top-left-radius', '5px').css('border-bottom-left-radius', '5px');
        if (last) last.css('border-top-right-radius', '5px').css('border-bottom-right-radius', '5px');
      });
    }
  }, {
    key: 'toggle',
    value: function toggle(event) {
      this.is_visible = !this.is_visible;
      this.gui.update();
    }
  }, {
    key: 'togglePinned',
    value: function togglePinned(event) {
      var name = $(event.target).closest('.dropdown-group-item').attr('name');

      this.pinned[name] = !this.pinned[name];
      this.gui.update();
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        is_visible: this.is_visible,
        pinned: this.pinned
      };
    },
    set: function set(state) {

      this.reset();
      if (!state) return;

      if (state.is_visible !== undefined) this.is_visible = state.pinned;
      if (state.pinned !== undefined) this.pinned = state.pinned;
    }
  }]);

  return Menu;
}();

module.exports = Menu;

},{"jquery":327,"underscore":335}],345:[function(require,module,exports){
'use strict';

/**
 * Custom ERROR objects
 *
 * throwing custom error objects instead of relying on native JavaScript ones
 * allows us to do a few things:
 *  - we know explicitly whether this error arose in a predictable way (i.e. we
 *    have seen it before, we know why it's happening, etc.)
 *  - errors that are not (instanceof AnnotatrixError) will therefore be all
 *    "unforeseen" JavaScript errors, and we should prioritize fixing those
 *  - custom handling (e.g., log it to the console even if we catch it later on)
 *
 */

/**
 * AnnotatrixError
 *
 * underspecified common ancestor of all custom errors, so it will be on the prototype
 * chain (all will be an "instanceof" AnnotatrixError)
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AnnotatrixError = function (_Error) {
  _inherits(AnnotatrixError, _Error);

  function AnnotatrixError() {
    var _ref;

    _classCallCheck(this, AnnotatrixError);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // maintains proper stack trace for where our error was thrown (i.e. doesn't
    //   include the constructor, but only available on V8)
    var _this = _possibleConstructorReturn(this, (_ref = AnnotatrixError.__proto__ || Object.getPrototypeOf(AnnotatrixError)).call.apply(_ref, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this, AnnotatrixError);

    // override prototype name
    _this.name = 'AnnotatrixError';

    // log all errors, even if we eventually catch them ... note that this does
    //   not show the full stack trace
    log.error(_this.message);
    return _this;
  }

  return AnnotatrixError;
}(Error);

/**
 * NotImplementedError
 *
 * throw this if we get somewhere that we know has not been implemented
 */


var NotImplementedError = function (_AnnotatrixError) {
  _inherits(NotImplementedError, _AnnotatrixError);

  function NotImplementedError() {
    var _ref2;

    _classCallCheck(this, NotImplementedError);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _this2 = _possibleConstructorReturn(this, (_ref2 = NotImplementedError.__proto__ || Object.getPrototypeOf(NotImplementedError)).call.apply(_ref2, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this2, NotImplementedError);

    _this2.name = 'NotImplementedError';
    return _this2;
  }

  return NotImplementedError;
}(AnnotatrixError);

/**
 * AssertionError
 *
 * throw this if Tester.assert() fails
 */


var AssertionError = function (_AnnotatrixError2) {
  _inherits(AssertionError, _AnnotatrixError2);

  function AssertionError() {
    var _ref3;

    _classCallCheck(this, AssertionError);

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var _this3 = _possibleConstructorReturn(this, (_ref3 = AssertionError.__proto__ || Object.getPrototypeOf(AssertionError)).call.apply(_ref3, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this3, AssertionError);

    _this3.name = 'AssertionError';
    return _this3;
  }

  return AssertionError;
}(AnnotatrixError);

/**
 * GUIError
 */


var GUIError = function (_AnnotatrixError3) {
  _inherits(GUIError, _AnnotatrixError3);

  function GUIError() {
    var _ref4;

    _classCallCheck(this, GUIError);

    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    var _this4 = _possibleConstructorReturn(this, (_ref4 = GUIError.__proto__ || Object.getPrototypeOf(GUIError)).call.apply(_ref4, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this4, GUIError);

    _this4.name = 'GUIError';
    return _this4;
  }

  return GUIError;
}(AnnotatrixError);

/**
 * ParseError
 */


var ParseError = function (_AnnotatrixError4) {
  _inherits(ParseError, _AnnotatrixError4);

  function ParseError() {
    var _ref5;

    _classCallCheck(this, ParseError);

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    var _this5 = _possibleConstructorReturn(this, (_ref5 = ParseError.__proto__ || Object.getPrototypeOf(ParseError)).call.apply(_ref5, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this5, ParseError);

    _this5.name = 'ParseError';
    return _this5;
  }

  return ParseError;
}(AnnotatrixError);

/**
 *
 */


var DeserializationError = function (_AnnotatrixError5) {
  _inherits(DeserializationError, _AnnotatrixError5);

  function DeserializationError() {
    var _ref6;

    _classCallCheck(this, DeserializationError);

    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    var _this6 = _possibleConstructorReturn(this, (_ref6 = DeserializationError.__proto__ || Object.getPrototypeOf(DeserializationError)).call.apply(_ref6, [this].concat(args)));

    if (Error.captureStackTrace) Error.captureStackTrace(_this6, DeserializationError);

    _this6.name = 'DeserializationError';
    return _this6;
  }

  return DeserializationError;
}(AnnotatrixError);

module.exports = {
  AnnotatrixError: AnnotatrixError,
  NotImplementedError: NotImplementedError,
  // AssertionError,
  GUIError: GUIError,
  ParseError: ParseError,
  DeserializationError: DeserializationError
};

},{}],346:[function(require,module,exports){
(function (global){
'use strict';

/**
 * shared functions
 */

var _ = require('underscore');

module.exports = {

  inBrowser: function inBrowser() {
    try {
      return !!window;
    } catch (e) {
      return false;
    }
  },

  global: function (_global) {
    function global() {
      return _global.apply(this, arguments);
    }

    global.toString = function () {
      return _global.toString();
    };

    return global;
  }(function () {
    try {
      // browser
      return window;
    } catch (e) {
      // node
      return global;
    }
  })

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"underscore":335}],347:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var _ = require('underscore');

var cfg = require('./config');
var cytoscape = require('./cytoscape/cytoscape');
var errors = require('./errors');
var funcs = require('./funcs');
var sort = require('./sort');
var validate = require('./validate');
var ProgressBar = require('./progress-bar');

var Graph = function () {
  function Graph(options) {
    var _this = this;

    _classCallCheck(this, Graph);

    this.options = _.defaults(options, {
      container: funcs.inBrowser() ? $('#cy') : null,
      boxSelectionEnabled: false,
      autounselectify: true,
      autoungrabify: true,
      zoomingEnabled: true,
      userZoomingEnabled: false,
      wheelSensitivity: 0.1,
      style: require('./cy-style'),
      layout: null,
      elements: []
    });

    // only do this for in-browser ... add the .selfcomplete method to $()
    if (gui.inBrowser) require('./selfcomplete');

    this.progressBar = new ProgressBar();

    // cy handlers
    this.click = {
      form: function form(event) {
        var target = event.target;
        log.debug('called onClickFormNode(' + target.attr('id') + ')');

        if (gui.moving_dependency) {

          var dep = cy.$('.selected');
          var source = cy.$('.arc-source');

          _this.makeDependency(source, target);
          _this.removeDependency(dep);
          cy.$('.moving').removeClass('moving');
          gui.moving_dependency = false;

          // right-click the new edge
          cy.$('#' + source.attr('id') + ' -> #' + target.attr('id')).trigger('cxttapend');
        } else {

          _this.save();

          cy.$('.arc-source').removeClass('arc-source');
          cy.$('.arc-target').removeClass('arc-target');
          cy.$('.selected').removeClass('selected');

          if (target.hasClass('activated')) {
            target.removeClass('activated');
          } else {

            var _source = cy.$('.activated');
            target.addClass('activated');

            // if there was already an activated node
            if (_source.length === 1) {
              _this.makeDependency(_source, target);
              _source.removeClass('activated');
              target.removeClass('activated');
            }
          }
        }
      },
      pos: function pos(event) {
        var target = event.target;
        log.debug('called onClickPosNode(' + target.attr('id') + ')');

        _this.save();
        gui.editing = target;

        cy.$('.activated').removeClass('activated');
        cy.$('.arc-source').removeClass('arc-source');
        cy.$('.arc-target').removeClass('arc-target');
        cy.$('.selected').removeClass('selected');

        editLabel(target);
      },
      multiword: function multiword(event) {
        var target = event.target;

        if (target.hasClass('multiword-active')) {
          target.removeClass('multiword-active');
        } else {
          cy.$('.multiword-active').removeClass('multiword-active');
          target.addClass('multiword-active');
        }
      },
      dependency: function dependency(event) {
        var target = event.target;
        log.debug('called onClickDependencyEdge(' + target.attr('id') + ')');

        _this.save();
        gui.editing = target;

        cy.$('.activated').removeClass('activated');
        cy.$('.arc-source').removeClass('arc-source');
        cy.$('.arc-target').removeClass('arc-target');
        cy.$('.selected').removeClass('selected');

        editLabel(target);
      }
    };
    this.cxttapend = {
      form: function form(event) {
        var target = event.target;
        log.debug('called onCxttapendFormNode(' + target.attr('id') + ')');

        _this.save();
        gui.editing = target;

        cy.$('.activated').removeClass('activated');
        cy.$('.arc-source').removeClass('arc-source');
        cy.$('.arc-target').removeClass('arc-target');
        cy.$('.selected').removeClass('selected');

        editLabel(target);
      },
      dependency: function dependency(event) {
        var target = event.target;
        log.debug('called onCxttapendDependencyEdge(' + target.attr('id') + ')');

        /**
         * Activated when an arc is selected. Adds classes showing what is selected.
         */

        _this.save();

        cy.$('.activated').removeClass('activated');

        if (target.hasClass('selected')) {

          cy.$('#' + target.data('source')).removeClass('arc-source');
          cy.$('#' + target.data('target')).removeClass('arc-target'); // visual effects on targeted node
          target.removeClass('selected');
        } else {

          cy.$('.arc-source').removeClass('arc-source');
          cy.$('#' + target.data('source')).addClass('arc-source');

          cy.$('.arc-target').removeClass('arc-target');
          cy.$('#' + target.data('target')).addClass('arc-target');

          cy.$('.selected').removeClass('selected');
          target.addClass('selected');
        }
      }
    };
  }

  _createClass(Graph, [{
    key: 'eles',
    value: function eles() {
      if (manager.graphable) return _.map(manager.current.eles, function (ele) {
        if (ele.data.name === 'dependency') {

          var src = ele.data.sourceAnalysis,
              tar = ele.data.targetAnalysis;

          ele.data.label = gui.is_ltr ? tar.num < src.num ? src.deprel + '\u22B3' : '\u22B2' + src.deprel : tar.num < src.num ? '\u22B2' + src.deprel : src.deprel + '\u22B3';

          ele.data.ctrl = new Array(4).fill(getEdgeHeight(src.num, tar.num));
          ele.classes = 'dependency';
        }

        return ele;
      });
      return [];
    }
  }, {
    key: 'update',
    value: function update() {
      if (gui.graph_disabled) return;

      this.options.layout = {
        name: 'tree',
        padding: 0,
        nodeDimensionsIncludeLabels: false,
        cols: gui.is_vertical ? 2 : undefined,
        rows: gui.is_vertical ? undefined : 2,
        sort: gui.is_vertical ? sort.vertical : gui.is_ltr ? sort.ltr : sort.rtl
      };
      this.options.elements = this.eles();

      window.cy = cytoscape(this.options).minZoom(0.1).maxZoom(10.0).zoom(gui.zoom).pan(gui.pan);

      // add a slight delay to ensure this gets drawn last
      if (!gui.zoom && !gui.pan) setTimeout(function () {
        cy.fit().center();
        gui.zoom = cy.zoom();
        gui.pan = cy.pan();
      }, 5);

      this.bind();
      this.progressBar.update();
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _this2 = this;

      /**
       * Binds event handlers to cy elements.
       * NOTE: If you change the style of a node (e.g. its selector) then
       * you also need to update it here.
       */

      // set a countdown to triggering a "background" click unless a node/edge intercepts it
      $('#cy canvas, #mute').mouseup(function (event) {
        gui.intercepted = false;
        setTimeout(function () {
          return _this2.clear();
        }, 100);
      });
      $('#cy canvas').mousemove(function (event) {
        gui.intercepted = true;
      });
      $('#edit').mouseup(function (event) {
        gui.intercepted = true;
      });
      cy.on('click cxttapend', '*', function (event) {
        gui.intercepted = true;

        // DEBUG: this line should be taken out in production
        console.info('clicked ' + event.target.attr('id') + ', data:', event.target.data());
      });

      // bind the cy events
      cy.on('click', 'node.form', function (e) {
        return _this2.click.form(e);
      });
      cy.on('click', 'node.pos', function (e) {
        return _this2.click.pos(e);
      });
      cy.on('click', '$node > node', function (e) {
        return _this2.click.multiword(e);
      });
      cy.on('click', 'edge.dependency', function (e) {
        return _this2.click.dependency(e);
      });
      cy.on('cxttapend', 'node.form', function (e) {
        return _this2.cxttapend.form(e);
      });
      cy.on('cxttapend', 'edge.dependency', function (e) {
        return _this2.cxttapend.dependency(e);
      });
    }
  }, {
    key: 'clear',
    value: function clear() {
      log.info('called onClickCanvas(intercepted: ' + gui.intercepted + ')');

      // intercepted by clicking a canvas subobject || mousemove (i.e. drag) || #edit
      if (gui.intercepted) return;

      this.save();

      cy.$('.activated').removeClass('activated');
      cy.$('.multiword-active').removeClass('multiword-active');
      cy.$('.arc-source').removeClass('arc-source');
      cy.$('.arc-target').removeClass('arc-target');
      cy.$('.selected').removeClass('selected');
      cy.$('.moving').removeClass('moving');
      cy.$('.merge').removeClass('merge');
      gui.moving_dependency = false;

      $('#mute').removeClass('activated');
      $('#edit').removeClass('activated');
    }
  }, {
    key: 'save',
    value: function save() {
      log.debug('called saveGraphEdits(target:' + (gui.editing ? gui.editing.attr('id') : 'null') + ', text:' + (gui.editing ? $('#edit').val() : '') + ')');

      cy.$('.input').removeClass('input');

      if (gui.editing === null) return; // nothing to do

      var analysis = gui.editing.data().analysis || gui.editing.data().sourceAnalysis,
          attr = gui.editing.data().attr,
          oldValue = analysis[attr],
          newValue = $('#edit').val();

      modify(analysis.id, attr, newValue);

      window.undoManager.add({
        undo: function undo() {
          modify(analysis.id, attr, oldValue);
        },
        redo: function redo() {
          modify(analysis.id, attr, newValue);
        }
      });

      gui.editing = null;
    }
  }, {
    key: 'makeDependency',
    value: function makeDependency(src, tar) {
      var _this3 = this;

      log.debug('called makeDependency(' + src.attr('id') + '=>' + tar.attr('id') + ')');
      /**
       * Called by clicking a form-node while there is already an active form-node.
       * Changes the text data and redraws the graph. Currently supports only conllu.
       */

      src = src.data('analysis');
      tar = tar.data('analysis');

      if (src === tar) {
        log.warn('makeDependency(): unable to create dependency within superToken ' + src.superTokenId);
        return;
      }

      addHead(src.id, tar.id);

      undoManager.add({
        undo: function undo() {
          removeHead(src.id, tar.id);
          _this3.clear();
        },
        redo: function redo() {
          addHead(src.id, tar.id);
          _this3.clear();
        }
      });

      /*
      // TODO:
      // If the target POS tag is PUNCT set the deprel to @punct [99%]
      // IF the target POS tag is CCONJ set the deprel to @cc [88%]
      // IF the target POS tag is SCONJ set the deprel to @mark [86%]
      // IF the target POS tag is DET set the deprel to @det [83%]
       const POS_TO_REL = {
          'PUNCT': 'punct',
          'DET': 'det',
          'CCONJ': 'cc',
          'SCONJ': 'mark'
      }
       // TODO: Put this somewhere better
      if (thisToken.upostag in POS_TO_REL)
          sentAndPrev = changeConlluAttr(sent, indices, 'deprel', POS_TO_REL[thisToken.upostag]);
       let isValidDep = true;
      if (thisToken.upostag === 'PUNCT' && !is_projective_nodes(sent.tokens, [targetIndex])) {
          log.warn('writeArc(): Non-projective punctuation');
          isValidDep = false
      }*/
    }
  }, {
    key: 'removeDependency',
    value: function removeDependency(ele) {
      log.debug('called removeDependency(' + ele.attr('id') + ')');

      var src = ele.data('sourceAnalysis'),
          tar = ele.data('targetAnalysis');

      removeHead(src.id, tar.id);

      undoManager.add({
        undo: function undo() {
          addHead(src.id, tar.id);
        },
        redo: function redo() {
          removeHead(src.id, tar.id);
        }
      });
    }
  }, {
    key: 'setRoot',
    value: function setRoot(ele) {
      log.debug('called setAsRoot(' + ele.attr('id') + ')');

      // check if there is already a root
      var oldRoot = void 0;
      manager.current.forEach(function (token) {
        token.forEach(function (analysis) {
          if (analysis.head == 0 || analysis.deprel.toLowerCase() == 'root') oldRoot = analysis;
        });
      });

      // set new root
      var newRoot = ele.data('analysis');
      if (!newRoot) return;

      if (oldRoot) {
        modify(oldRoot.id, 'head', []);
        modify(oldRoot.id, 'deprel', undefined);
      }

      var oldHead = newRoot.head,
          oldDeprel = newRoot.deprel;

      modify(newRoot.id, 'head', '0');
      modify(newRoot.id, 'deprel', 'root');

      undoManager.add({
        undo: function undo() {
          if (oldRoot) {
            modify(oldRoot.id, 'head', '0');
            modify(oldRoot.id, 'deprel', 'root');
          }

          modify(newRoot.id, 'head', oldHead);
          modify(newRoot.id, 'deprel', oldDeprel);
        },
        redo: function redo() {
          if (oldRoot) {
            modify(oldRoot.id, 'head', []);
            modify(oldRoot.id, 'deprel', undefined);
          }

          modify(newRoot.id, 'head', '0');
          modify(newRoot.id, 'deprel', 'root');
        }
      });
    }
  }, {
    key: 'merge',
    value: function merge(direction, strategy) {
      throw new errors.NotImplementedError('merging not implemented');
      log.error('called mergeNodes(' + dir + ')');

      // old: (toMerge, side, how)

      /* Support for merging tokens into either a new token or a supertoken.
      Recieves the node to merge, side (right or left) and a string denoting
      how to merge the nodes. In case of success, redraws the tree. */
      // const indices = findConlluId(toMerge);

      var oldSentence = manager.sentence;

      // prefer traits on this one
      var major = cy.$('.merge').data('conllu');
      // either one to the left or to the right (w/o wrapping)
      var minor = manager.current.tokens[major.superTokenId + (direction === 'left' ? -1 : 1)];

      // make sure we have stuff
      if (!major || !minor) {
        log.error('mergeNodes(): cannot merge these tokens');
        return;
      }

      manager.current.merge(major, minor, strategy);

      undoManager.add({
        undo: function undo() {
          manager.parse(oldSentence);
        },
        redo: function redo() {
          manager.parse(manager.conllu);
        }
      });
    }
  }]);

  return Graph;
}();

function getEdgeHeight(srcNum, tarNum) {

  var edgeHeight = cfg.defaultEdgeHeight * (tarNum - srcNum);
  if (gui.is_ltr) edgeHeight *= -1;
  if (Math.abs(edgeHeight) !== 1) edgeHeight *= cfg.defaultEdgeCoeff;
  if (gui.is_vertical) edgeHeight = 45;

  log.debug('getEdgeHeight(): ' + edgeHeight);

  return edgeHeight;
}

function editLabel(target) {
  log.debug('called editLabel(' + target.attr('id') + ')');

  target.addClass('input');

  // get rid of direction arrows
  var label = target.data('label').replace(/[]/, '');
  target.data('label', label);

  // get bounding box
  var bbox = target.renderedBoundingBox();
  bbox.color = target.style('background-color');
  if (target.data('name') === 'dependency') {
    bbox.w = 100;
    bbox.h = cy.nodes()[0].renderedHeight();
    bbox.color = 'white';

    if (gui.is_vertical) {
      bbox.y1 += (bbox.y2 - bbox.y1) / 2 - 15;
      bbox.x1 = bbox.x2 - 70;
    } else {
      bbox.x1 += (bbox.x2 - bbox.x1) / 2 - 50;
    }
  }

  // TODO: rank the labels + make the style better
  var autocompletes = target.data('name') === 'pos-node' ? validate.U_POS : target.data('name') === 'dependency' ? validate.U_DEPRELS : [];

  // add the edit input
  $('#edit').val('').focus().val(label).css('top', bbox.y1).css('left', bbox.x1).css('height', bbox.h).css('width', bbox.w + 5).attr('target', target.attr('id')).addClass('activated').selfcomplete({
    lookup: autocompletes,
    tabDisabled: false,
    autoSelectFirst: true,
    lookupLimit: 5
  });

  // add the background-mute div
  $('#mute').addClass('activated').css('height', gui.is_vertical ? gui.tokens.length * 50 + 'px' : $(window).width() - 10);

  $('#edit').focus(); // move cursor to the end
  if (target.data('name') === 'dependency') $('#edit').select(); // highlight the current contents
}

function modify(id, attr, value) {

  // check we don't have any whitespace
  if (/\s+/g.test(value)) {
    var message = 'ERROR: Unable to add changes with whitespace!  Try creating a new node first.';
    log.error(message);
    alert(message); // TODO: probably should streamline errors
    gui.editing = null;
    return;
  }

  var ana = manager.current.getById(id);

  ana[attr] = value;
  gui.update();
}

function addHead(srcId, tarId) {
  var dep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  var src = manager.current.getById(srcId),
      tar = manager.current.getById(tarId);

  src.addHead(tar, dep);
  gui.update();
}

function removeHead(srcId, tarId) {
  var src = manager.current.getById(srcId),
      tar = manager.current.getById(tarId);

  src.removeHead(tar);
  gui.update();
}

module.exports = Graph;

},{"./config":339,"./cy-style":341,"./cytoscape/cytoscape":342,"./errors":345,"./funcs":346,"./progress-bar":355,"./selfcomplete":356,"./sort":358,"./validate":368,"jquery":327,"underscore":335}],348:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var _ = require('underscore');

var Menu = require('./dropdown-menu');
var convert = require('./convert');
var funcs = require('./funcs');
var errors = require('./errors');
var setupUndos = require('./undo-manager');
var table = require('./table');
var storage = require('./local-storage');

var KEYS = {
  DELETE: 46,
  BACKSPACE: 8,
  ENTER: 13,
  ESC: 27,
  TAB: 9,
  RIGHT: 39,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  MINUS: 173,
  MINUS_: 189,
  EQUALS: 61,
  EQUALS_: 187,
  SHIFT: 16,
  CTRL: 17,
  OPT: 18,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  META: 224,
  D: 68,
  I: 73,
  J: 74,
  K: 75,
  M: 77,
  P: 80,
  R: 82,
  S: 83,
  X: 88,
  Y: 89,
  Z: 90,
  0: 48
};

var pressed = {}; // used for onCtrlKeyup

var GUI = function () {
  function GUI() {
    var _this = this;

    _classCallCheck(this, GUI);

    this.keys = KEYS;

    this.is_textarea_visible = true;
    this.are_labels_visible = true;
    this.is_vertical = false;
    this.is_ltr = true;
    this.is_enhanced = false;

    this.pan = this.pan || null;
    this.zoom = this.zoom || null;
    this.graph_disabled = false;
    this.intercepted = false;
    this.moving_dependency = false;
    this.editing = null;

    this.inBrowser = funcs.inBrowser();

    if (this.inBrowser) {
      setupUndos();
      undoManager.setCallback(function () {
        return _this.update();
      });

      this.menu = new Menu(this);
      this.modals = require('./modals/index');
    }

    this.toggle = {
      dropdown: function dropdown(event) {
        return _this.menu.toggle(event);
      },
      pin: function pin(event) {
        return _this.menu.togglePinned(event);
      },

      table: function table(event) {
        _this.is_table_view = !_this.is_table_view;
        _this.update();
      },

      tableColumn: function tableColumn(event) {

        var target = $(event.target),
            col = target.attr('col-id');

        _this.column_visible(col, !_this.column_visible(col));
        target.toggleClass('column-hidden').find('i').toggleClass('fa-angle-double-right').toggleClass('fa-angle-double-left');

        $('td[col-id=' + col + ']').css('visibility', _this.column_visible(col) ? 'visible' : 'hidden');

        _this.update();
      },

      textarea: function textarea(event) {

        $('#btnToggleTextarea i').toggleClass('fa-chevron-up').toggleClass('fa-chevron-down');
        _this.is_textarea_visible = !_this.is_textarea_visible;

        _this.update();
      },

      rtl: function rtl(event) {

        $('#RTL .fa').toggleClass('fa-align-right').toggleClass('fa-align-left');
        _this.is_ltr = !_this.is_ltr;

        _this.update();
      },

      vertical: function vertical(event) {

        $('#vertical .fa').toggleClass('fa-rotate-90');
        _this.is_vertical = !_this.is_vertical;

        _this.update();
      },

      enhanced: function enhanced(event) {

        $('#enhanced .fa').toggleClass('fa-tree').toggleClass('fa-magic');
        _this.is_enhanced = !_this.is_enhanced;

        _this.update();
      }
    };
  }

  _createClass(GUI, [{
    key: 'update',
    value: function update() {
      if (!this.inBrowser) return;

      this.menu.update();

      // textarea
      $('#text-data').val(manager.sentence);

      // navigation buttons
      $('.btn').removeClass('disabled');

      manager.updateFilter();
      $('#total-sentences').text(manager.totalSentences);
      $('#current-sentence').val(manager.currentSentence);
      if (!manager.index && (manager._filtered.length || manager.length)) $('#btnPrevSentence').addClass('disabled');
      if (manager.index === (manager._filtered.length || manager.length) - 1) $('#btnNextSentence').addClass('disabled');
      if (!server.is_running) $('#btnUploadCorpus').addClass('disabled');
      if (manager.format !== 'CoNLL-U') $('#btnToggleTable').addClass('disabled');

      $('#btnUndo').prop('disabled', !undoManager.hasUndo());
      $('#btnRedo').prop('disabled', !undoManager.hasRedo());

      $('.nav-link').removeClass('active').show();
      $('#text-data').prop('readonly', false);
      $('.readonly').removeClass('readonly');

      switch (manager.format) {
        case 'Unknown':
          $('.nav-link').hide();
          $('#tabOther').addClass('active').show().text(manager.format);
          break;
        case 'CoNLL-U':
          $('#tabConllu').addClass('active');
          $('#tabOther').hide();
          break;
        case 'CG3':
          $('#tabCG3').addClass('active');
          $('#tabOther').hide();
          break;
        case 'plain text':
          $('#tabText').hide(); // NOTE: no break here
          if (manager.current.nx_initialized) {
            $('#text-data').prop('readonly', true);
            $('#tabOther').addClass('readonly');
          }
        default:
          $('#tabOther').addClass('active').show().text(manager.format);
          break;
      }

      if (manager.format !== 'CoNLL-U') this.is_table_view = false;

      if (this.is_table_view) {
        $('#btnToggleTable i').removeClass('fa-code');
        $('#text-data').hide();
        $('#table-data').show();
        table.build();
      } else {
        $('#btnToggleTable i').addClass('fa-code');
        $('#text-data').show();
        $('#table-data').hide();
      }

      if (this.is_textarea_visible) {
        $('#data-container').show();
        $('#top-buttons-container').removeClass('extra-space');
        $('#btnToggleTable').show();
      } else {
        $('#data-container').hide();
        $('#top-buttons-container').addClass('extra-space');
        $('.nav-link').not('.active').hide();
        $('#btnToggleTable').hide();
      }

      $('#label-container').css('display', this.are_labels_visible && this.is_textarea_visible ? 'flex' : 'none');

      try {
        // need this in case `cy` DNE
        this.zoom = cy.zoom();
        this.pan = cy.pan();
      } catch (e) {
        this.zoom = null;
        this.pan = null;
      }
      labeler.update();
      graph.update();
    }
  }, {
    key: 'read',
    value: function read(id) {
      if (!this.inBrowser) return;

      switch (id) {
        case 'text-data':
        case 'current-sentence':
          return $('#' + id).val();
        default:
          throw new TypeError('unable to read "' + id + '"');
      }
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _this2 = this;

      if (!this.inBrowser) return;

      $('#btnPrevSentence').click(function (e) {
        return manager.prev();
      });
      $('#btnNextSentence').click(function (e) {
        return manager.next();
      });
      $('#current-sentence').blur(function (e) {
        var index = parseInt(_this2.read('current-sentence')) - 1;
        manager.index = index;
      });
      $('#btnRemoveSentence').click(function (e) {
        return manager.removeSentence();
      });
      $('#btnAddSentence').click(function (e) {
        return manager.insertSentence();
      });

      $('[name="save-corpus"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.save();
      });
      $('[name="upload-corpus"]').click(function (e) {
        if (!$(e.target).is('.pin')) _this2.modals.upload.show();
      });
      $('[name="download-corpus"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.export();
      });
      $('[name="discard-corpus"]').click(function (e) {
        if ($(e.target).is('.pin')) return;

        var conf = confirm('Do you want to clear the corpus (remove all sentences)?');
        if (!conf) {
          log.info('corpus::clear(): not clearing corpus');
          return;
        }

        storage.clear();
        manager.reset();
      });

      $('[name="export-as-png"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.export.png();
      });
      $('[name="export-as-latex"]').click(function (e) {
        if (!$(e.target).is('.pin')) manager.export.latex();
      });

      $('[name="show-labels"]').click(function (e) {
        if ($(e.target).is('.pin')) return;

        _this2.are_labels_visible = !_this2.are_labels_visible;
        _this2.update();
      });
      $('[name="show-help"]').click(function (e) {
        if (!$(e.target).is('.pin')) window.open('help.html', '_blank').focus();
      });
      $('[name="show-settings"]').click(function (e) {
        if (!$(e.target).is('.pin')) window.open('settings.html', '_blank').focus();
      });

      $('#tabText').click(function (e) {
        manager.parse(convert.to.plainText(_this2.read('text-data')));
      });
      $('#tabConllu').click(function (e) {
        manager.current.nx_initialized = true;
        manager.parse(convert.to.conllu(_this2.read('text-data')));
      });
      $('#tabCG3').click(function (e) {
        manager.current.nx_initialized = true;
        manager.parse(convert.to.cg3(_this2.read('text-data')));
      });

      $('[name="show-table"]').click(function (e) {
        if (!$(e.target).is('.pin')) _this2.toggle.table(e);
      });
      $('.thead-default th').click(function (e) {
        return _this2.toggle.tableColumn(e);
      });
      $('#btnToggleTextarea').click(function (e) {
        return _this2.toggle.textarea(e);
      });

      $('#label-clear-filter').click(function (e) {
        labeler.clearFilter();
        gui.update();
      });

      $('#RTL').click(function (e) {
        return _this2.toggle.rtl(e);
      });
      $('#vertical').click(function (e) {
        return _this2.toggle.vertical(e);
      });
      $('#enhanced').click(function (e) {
        return _this2.toggle.enhanced(e);
      });

      $('#current-sentence').keyup(function (e) {
        return onKeyupInCurrentSentence(e);
      });
      $('#text-data').keyup(function (e) {
        return onEditTextData(e);
      });
      $('#edit').keyup(function (e) {
        return onKeyupInEditLabel(e);
      });
      onkeyup = onKeyupInDocument;

      // prevent accidentally leaving the page
      window.onbeforeunload = function () {
        manager.save();
        // DEBUG: uncomment this line for production
        // return 'Are you sure you want to leave?';
      };
    }
  }, {
    key: 'column_visible',
    value: function column_visible(col, bool) {
      if (typeof bool === 'boolean') manager.current.column_visibilities[col] = bool;

      return manager.current.column_visibilities[col];
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      cy.zoom(this.zoom * 1.1);
      this.update();

      return this;
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      cy.zoom(this.zoom / 1.1);
      this.update();

      return this;
    }
  }, {
    key: 'state',
    get: function get() {
      return {

        menu: this.menu ? this.menu.state : null,
        is_textarea_visible: this.is_textarea_visible,
        are_labels_visible: this.are_labels_visible,
        is_vertical: this.is_vertical,
        is_ltr: this.is_ltr,
        is_enhanced: this.is_enhanced,

        pan: this.pan,
        zoom: this.zoom

      };
    },
    set: function set(state) {

      this.menu.state = state.menu;

      this.is_textarea_visible = state.is_textarea_visible, this.are_labels_visible = state.are_labels_visible, this.is_vertical = state.is_vertical;
      this.is_ltr = state.is_ltr;
      this.is_enhanced = state.is_enhanced;

      this.pan = state.pan;
      this.zoom = state.zoom;

      this.update();
    }
  }, {
    key: 'is_table_view',
    get: function get() {
      return manager.current.is_table_view;
    },
    set: function set(bool) {

      manager.current.is_table_view = false;
      if (typeof bool === 'boolean' && manager.format === 'CoNLL-U') manager.current.is_table_view = bool;

      return manager.current.is_table_view;
    }
  }]);

  return GUI;
}();

function onKeyupInDocument(event) {
  log.info('called onKeyupInDocument(' + event.which + ')');

  // returns true if it caught something
  if (onCtrlKeyup(event)) return;

  // editing an input
  if ($('#text-data').is(':focus') || $('#edit').is(':focus')) return;

  // if we get here, we're handling a keypress without an input-focus or ctrl-press
  // (which means it wasn't already handled)
  log.debug('onKeyupInDocument(): handling event.which:' + event.which);

  switch (event.which) {
    case KEYS.DELETE:
    case KEYS.BACKSPACE:
    case KEYS.X:
      if (cy.$('.selected').length) {
        graph.removeDependency(cy.$('.selected'));
      } /* else if (cy.$('.supAct').length) {
         removeSup(st);
        }*/
      break;

    case KEYS.D:
      if (cy.$('.selected').length) {
        cy.$('.selected').toggleClass('moving');
        gui.moving_dependency = !gui.moving_dependency;
      }
      break;

    case KEYS.M:
      if (cy.$('node.form.merge').length) {

        cy.$('node.form.activated').removeClass('activated');

        cy.$('node.form.merge').addClass('activated').removeClass('merge');
      } else if (cy.$('node.form.activated').length) {

        cy.$('node.form.activated').removeClass('activated').addClass('merge');
      }

      break;

    case KEYS.P:
      /* if (text not focused)
        setPunct();*/
      break;

    case KEYS.R:
      if (cy.$('node.form.activated')) graph.setRoot(cy.$('node.form.activated'));
      break;

    case KEYS.S:
      // wf.addClass('supertoken');
      // wf.removeClass('activated');
      break;

    case KEYS.LEFT:

      // avoid panning the window
      if (event.preventDefault) event.preventDefault();

      if (cy.$('node.form.merge').length) mergeNodes('left');
      break;

    case KEYS.RIGHT:

      // avoid panning the window
      if (event.preventDefault) event.preventDefault();

      if (cy.$('node.form.merge').length) {
        mergeNodes('right');
      } /*else if (cy.$('.supertoken')) {
        // mergeNodes(toMerge, KEYS.SIDES[key.which], 'subtoken');
        // mergeNodes(toSup, KEYS.SIDES[key.which], 'supertoken');
        }*/
      break;

    case KEYS.EQUALS:
    case KEYS.EQUALS_:
      if (event.shiftKey) {
        gui.zoomIn();
      } else {
        cy.fit().center();
      }
      break;

    case KEYS.MINUS:
    case KEYS.MINUS_:
      if (event.shiftKey) {
        gui.zoomOut();
      } else {
        cy.fit().center();
      }
      break;

    case KEYS.ENTER:
      gui.intercepted = false;
      graph.clear();
      break;

  }
}
function onCtrlKeyup(event) {
  log.debug('called onCtrlKeyup(which:' + event.which + ', pressed:' + JSON.stringify(pressed) + ')');

  // handle Ctrl + <keypress>
  // solution based on https://stackoverflow.com/a/12444641/5181692
  pressed[event.which] = event.type == 'keyup';
  log.info('ctrl: ' + pressed[KEYS.CTRL] + ', shift: ' + pressed[KEYS.CTRL] + ', y: ' + pressed[KEYS.Y] + ', z: ' + pressed[KEYS.Z] + ', this: ' + event.which);

  if (!pressed[KEYS.CTRL]) return false;

  if (pressed[KEYS.PAGE_DOWN]) {
    var _pressed;

    if (pressed[KEYS.SHIFT]) {
      manager.last();
    } else {
      manager.next();
    }
    pressed = (_pressed = {}, _defineProperty(_pressed, KEYS.CTRL, true), _defineProperty(_pressed, KEYS.SHIFT, pressed[KEYS.SHIFT]), _pressed);
    return true;
  } else if (pressed[KEYS.PAGE_UP]) {
    var _pressed2;

    if (pressed[KEYS.SHIFT]) {
      manager.first();
    } else {
      manager.prev();
    }
    pressed = (_pressed2 = {}, _defineProperty(_pressed2, KEYS.CTRL, true), _defineProperty(_pressed2, KEYS.SHIFT, pressed[KEYS.SHIFT]), _pressed2);
    return true;
  } else if (pressed[KEYS.Z] && !pressed[KEYS.SHIFT]) {
    undoManager.undo();
    pressed = _defineProperty({}, KEYS.CTRL, true);
    return true;
  } else if (pressed[KEYS.Y] || pressed[KEYS.Z]) {
    var _pressed4;

    undoManager.redo();
    pressed = (_pressed4 = {}, _defineProperty(_pressed4, KEYS.CTRL, true), _defineProperty(_pressed4, KEYS.SHIFT, pressed[KEYS.SHIFT]), _pressed4);
    setTimeout(function () {
      // catch only events w/in next 500 msecs
      pressed[KEYS.SHIFT] = false;
    }, 500);
    return true;
  } else if (47 < event.which && event.which < 58) {
    // key in 0-9

    if ($(':focus').is('input')) return false;

    var num = event.which - 48;
    cy.zoom(Math.pow(1.5, num - 5));
    gui.update();
    return true;
  } else {
    log.error('onCtrlKeyup(): uncaught key combination');
  }

  return false;
}
function onKeyupInCurrentSentence(event) {
  log.debug('called onKeyupInCurrentSentence(' + event.which + ')');

  switch (event.which) {
    case KEYS.ENTER:
      manager.index = parseInt(gui.read('current-sentence')) - 1;
      break;
    case KEYS.LEFT:
    case KEYS.J:
      manager.prev();
      break;
    case KEYS.RIGHT:
    case KEYS.K:
      manager.next();
      break;
    case KEYS.MINUS:
      manager.removeSentence();
      break;
    case KEYS.EQUALS:
      manager.insertSentence();
      break;
  }
}
function onKeyupInEditLabel(event) {
  log.debug('called onKeyupInEditLabel(' + event.which + ')');

  switch (event.which) {
    case KEYS.ENTER:
      graph.clear();
      break;
    case KEYS.TAB:
      console.log('what should happen here???');
      break;
    case KEYS.ESC:
      gui.editing = null;
      graph.clear();
      break;
  }
}
function onEditTextData(event) {
  log.debug('called onEditTextData(key: ' + event.which + ', parseTimer: ' + gui.parseTimer + ')');

  switch (event.which) {
    case KEYS.ESC:
      this.blur();
      break;

    case KEYS.ENTER:
      onEnter(event);
      break;

    default:
      // wait a full second before parsing (this prevents immediate trimming
      //   of whitespace and other annoying side effects), and avoid redundant
      //   parsing if we edit again w/in that 1-sec window
      clearTimeout(gui.parseTimer);
      gui.parseTimer = setTimeout(function () {
        manager.parse();
      }, 1000);
  }
}
function onEnter(event) {
  log.debug('called onEnter()');

  var sentence = manager.sentence,
      cursor = $('#text-data').prop('selectionStart') - 1,
      lines = sentence.split(/\n/),
      lineId = null,
      before = void 0,
      during = void 0,
      after = void 0,
      cursorLine = 0;

  if (gui.is_table_view) {

    var target = $(event.target);
    cursor = parseInt(target.attr('row-id')) || parseInt(target.attr('col-id'));
    cursorLine = target.attr('row-id');
  } else {

    if (manager.format === 'Unknown' || manager.format === 'plain text') return;

    // get current line number
    var acc = 0;
    $.each(lines, function (i, line) {
      acc += line.length;
      if (acc + i < cursor) cursorLine = i + 1;
    });
    log.debug('onEnter(): cursor on line[' + cursorLine + ']: "' + lines[cursorLine] + '"');

    // advance the cursor until we are at the end of a line that isn't followed by a comment
    //   or at the very beginning of the textarea
    if (cursor !== 0 || sentence.startsWith('#')) {
      log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '" (not at textarea start OR textarea has comments)');
      while (sentence[cursor + 1] === '#' || sentence[cursor] !== '\n') {
        log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '", line[' + cursorLine + ']: ' + lines[cursorLine]);
        if (cursor === sentence.length) break;
        if (sentence[cursor] === '\n') cursorLine++;
        cursor++;
      }
    } else {
      log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '" (at textarea start)');
      cursorLine = -1;
    }
  }

  log.debug('onEnter(): cursor[' + cursor + ']: "' + sentence[cursor] + '", line[' + cursorLine + ']: ' + lines[cursorLine]);

  if (event.preventDefault) // bc of testing, sometimes these are fake events
    event.preventDefault();

  switch (manager.format) {
    case 'CoNLL-U':

      if (cursor) {
        var tabs = lines[cursorLine].split('\t');
        var token = manager.current.getById(tabs[0]).token;
        manager.current.insertTokenAfter(token);
      } else {
        var _token = manager.current[0].token;
        manager.current.insertTokenBefore(_token);
      }

      // parse but persist the table settings
      var is_table_view = manager.current.is_table_view;
      var column_visibilities = manager.current.column_visibilities;
      manager.parse(manager.conllu);
      manager.current.is_table_view = is_table_view;
      manager.current.column_visibilities = column_visibilities;

      break;

    case 'CG3':

      throw new errors.NotImplementedError('can\'t onEnter with CG3 :/');
      /*
      // advance to the end of an analysis
      log.debug(`onEnter(): line[${cursorLine}]: "${lines[cursorLine]}", cursor[${cursor}]: "${sentence[cursor]}"`);
      while (cursorLine < lines.length - 1) {
          if (lines[cursorLine + 1].startsWith('"<'))
              break;
          cursorLine++;
          cursor += lines[cursorLine].length + 1;
          log.debug(`onEnter(): incrementing line[${cursorLine}]: "${lines[cursorLine]}", cursor[${cursor}]: "${sentence[cursor]}"`);
      }
       lineId = lines.slice(0, cursorLine + 1).reduce((acc, line) => {
          return acc + line.startsWith('"<');
      }, 0) + 1;
      log.debug(`onEnter(): inserting line with id: ${lineId}`);
      log.debug(`onEnter(): resetting all content lines: [${lines}]`);
       const incrementIndices = (lines, lineId) => {
        return lines.map((line) => {
          if (line.startsWith('#'))
            return line;
          (line.match(/[#>][0-9]+/g) || []).map((match) => {
            let id = parseInt(match.slice(1));
            id += (id >= lineId ? 1 : 0);
            line = line.replace(match, `${match.slice(0,1)}${id}`)
          });
          return line;
        });
      }
      before = incrementIndices(lines.slice(0, cursorLine + 1), lineId);
      during = [`"<_>"`, `\t${getCG3Analysis(lineId, {id:lineId})}`];
      after = incrementIndices(lines.slice(cursorLine + 1), lineId);
       log.debug(`onEnter(): preceding line(s) : [${before}]`);
      log.debug(`onEnter(): interceding lines : [${during}]`);
      log.debug(`onEnter(): proceeding line(s): [${after}]`);
       $('#text-data').val(before.concat(during, after).join('\n'))
        .prop('selectionStart', cursor)
        .prop('selectionEnd', cursor);*/

      break;

    default:
      insertSentence();
  }

  gui.update();
}

function mergeNodes(direction) {

  // the highlighted one is the "major" token
  var major = cy.$('node.form.merge').data().analysis;

  // find the "minor" token by moving either one clump to the left or right
  var minorClump = major.clump + (direction === 'left' && gui.is_ltr || direction === 'right' && !gui.is_ltr ? -1 : 1);

  // iterate tokens until we find a matching candidate
  var minor = null;
  major.sentence.forEach(function (token) {
    if (token.analysis.clump === minorClump) minor = token.analysis;
  });

  // do the merge
  if (major && minor) major.token.mergeWith(minor.token);

  // clean up
  cy.$('node.form.merge').removeClass('merge');
  gui.update();
}

module.exports = GUI;

},{"./convert":340,"./dropdown-menu":344,"./errors":345,"./funcs":346,"./local-storage":351,"./modals/index":353,"./table":359,"./undo-manager":367,"jquery":327,"underscore":335}],349:[function(require,module,exports){
'use strict';

require('babel-polyfill');

var Log = require('./browser-logger');
var Manager = require('./manager');
var Server = require('./server');

var funcs = require('./funcs');

// on ready
$(function () {

	funcs.global().log = new Log();
	funcs.global().server = new Server();
	funcs.global().manager = new Manager();
});

module.exports = require('./test/data/index');

},{"./browser-logger":338,"./funcs":346,"./manager":352,"./server":357,"./test/data/index":363,"babel-polyfill":1}],350:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');
var $ = require('jquery');
var DeserializationError = require('./errors').DeserializationError;

var regex = {
  labelComment: /(labels|tags)\s*=\s+(.*)$/,
  labelContent: /([\w-:]+)/,
  labelByName: function labelByName(name) {
    return new RegExp('(\\s+)' + name + '(\\s+|$)');
  }
};

// NOTE: 16777215 (base 10) = ffffff (base 16)
var magic = 16777215;
var ENTER = 13;

var Label = function () {
  function Label(name) {
    _classCallCheck(this, Label);

    name = name || 'default';

    this.name = name;
    this.bColor = hashStringToHex(name);
    this.tColor = getTextColor(this.bColor);
    this.desc = '';
  }

  _createClass(Label, [{
    key: 'changeColor',
    value: function changeColor(color) {

      if (color) {
        color = (color.match(/^#?([a-f\d]{6})/i) || [])[1];
        var int = parseInt(color, 16);
        if (isNaN(int) || int < 0 || int > magic) return false; // out of bounds

        color = '#' + color;
      } else {
        color = getRandomHexColor();
      }

      this.bColor = color;
      this.tColor = getTextColor(color);

      return true;
    }
  }, {
    key: 'render',
    value: function render(labeler) {

      var inComments = labeler.has(this.name),
          filtering = labeler._filter.has(this.name);

      $('#labels-horiz').append($('<li>').attr('name', this.name).addClass('label horiz').addClass(inComments ? 'in-comments' : 'not-in-comments').addClass(filtering ? 'filtering' : 'not-filtering').append($('<div>').addClass('label-text').text(this.name).css('background-color', this.bColor).css('color', this.tColor).click(function (e) {
        return labeler.handle.click.label(e);
      })).append($('<div>').addClass('label-hidden').append($('<div>').addClass('label-hidden-group').append($('<div>').addClass('label-hidden-item').append($('<strong>').text('Name')).append($('<input>').attr('name', 'label-name').val(this.name).keyup(function (e) {
        return labeler.handle.keyup.name(e);
      }))).append($('<div>').addClass('label-hidden-item').append($('<strong>').text('Description')).append($('<input>').attr('name', 'label-desc').val(this.desc).keyup(function (e) {
        return labeler.handle.keyup.desc(e);
      }))).append($('<div>').addClass('label-hidden-item').append($('<strong>').text('Color')).append($('<div>').addClass('label-hidden-item-inner').append($('<span>').addClass('hex-color-group').text('#').append($('<input>').attr('name', 'label-color').attr('pattern', '[A-Fa-f\\d]{6}').val(this.bColor.substr(1)).keyup(function (e) {
        return labeler.handle.keyup.color(e);
      }))).append($('<button>').attr('type', 'button').addClass('btn btn-secondary refresh-color').css('background-color', this.bColor).click(function (e) {
        return labeler.handle.click.refresh(e);
      }).append($('<i>').addClass('fa fa-refresh')))))).append($('<hr>')).append($('<div>').addClass('label-hidden-group').append($('<div>').addClass('label-hidden-item').append($('<div>').addClass('label-hidden-item-inner').append($('<input>').attr('name', 'filtering').attr('type', 'checkbox').prop('checked', filtering).click(function (e) {
        return labeler.handle.click.checkbox.filtering(e);
      })).append($('<span>').addClass('filtering-label checkbox-label').text('filtering'))))).append($('<hr>')).append($('<div>').addClass('label-hidden-group').append($('<div>').addClass('label-hidden-item delete-item').append($('<button>').attr('type', 'button').addClass('btn btn-secondary delete-button').text('delete').click(function (e) {
        return labeler.handle.click.delete(e);
      }))))));
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        name: this.name,
        desc: this.desc,
        bColor: this.bColor,
        tColor: this.tColor
      };
    },
    set: function set(state) {
      if (!state.name) throw new DeserializationError('cannot set name to "' + state.name + '"');

      state.desc = state.desc || '';
      if (typeof state.desc !== 'string') throw new DeserializationError('cannot set description to non-string value');

      this.name = state.name;
      this.desc = state.desc;

      if (!this.changeColor(state.bColor)) throw new DeserializationError('cannot set background color to "' + state.bColor + '"');
    }
  }]);

  return Label;
}();

var Labeler = function () {
  function Labeler() {
    var _this = this;

    _classCallCheck(this, Labeler);

    this._labels = [];
    this._filter = new Set();

    // don't want the "jQuery needs a window" errors during testing
    if (!gui || !gui.inBrowser) return this;

    $('#label-input').keyup(function (e) {
      if (e.which === ENTER) _this.handle.enter(e);
    });

    this.handle = {
      enter: function enter(event) {
        var names = $('#label-input').val().trim();
        _.each(names.split(/\s+/), function (name) {

          var added = false;
          if (name) added = _this.add(name);

          if (added) _this.addInComments(name); // add to the comments
        });

        $('#label-input').val('');
        gui.update();
      },

      click: {
        label: function label(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name');

          if (_this.has(name)) {
            _this.removeInComments(name);
          } else {
            _this.addInComments(name);
          }

          manager.updateFilter();
          gui.update();
          flashDropdown(name);
        },

        refresh: function refresh(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              label = _this.get(name);

          label.changeColor();
          gui.update();
          flashDropdown(name);
        },

        checkbox: {
          filtering: function filtering(event) {
            var target = $(event.target),
                name = target.closest('li').attr('name');

            _this.toggleFilter(name);
            manager.updateFilter();
            gui.update();
            flashDropdown(name);
          }
        },

        delete: function _delete(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name');

          var response = confirm('Are you sure you want to delete the label "' + name + '" from all sentences?');
          if (!response) return;

          _this.remove(name);
          gui.update();
        }
      },

      keyup: {
        name: function name(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              value = target.val();

          if (event.which === ENTER) {

            if (_this.has(value)) {
              // TODO: alert
              return; // don't want multiple things with the same name
            }

            if (!regex.labelContent.test(value)) {
              // TODO: alert
              return; // must match our content pattern
            }

            _this.edit(name, { name: value });
            _this.editInComments(name, value);
            gui.update();
            flashDropdown(value, 'label-name');
          }
        },

        desc: function desc(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              value = target.val();

          if (event.which === ENTER) {
            _this.edit(name, { desc: value });
            gui.update();
            flashDropdown(name, 'label-desc');
          }
        },

        color: function color(event) {
          var target = $(event.target),
              name = target.closest('li').attr('name'),
              value = target.val();

          if (event.which === ENTER) {
            _this.edit(name, { color: value });
            gui.update();
            flashDropdown(name, 'label-color');
          }
        }
      }
    };
  }

  _createClass(Labeler, [{
    key: 'parse',
    value: function parse(comments) {
      var _this2 = this;

      _.each(Labeler.parseComments(comments), function (label) {
        if (label) _this2.add(label);
      });

      return this; // chaining
    }
  }, {
    key: 'has',
    value: function has(index, name) {

      if (name === undefined) {
        name = index;
        index = manager.index;
      }

      var comments = manager.getSentence(index).comments;

      var has = false;
      _.each(comments, function (comment) {
        _.each(Labeler.parseComment(comment), function (label) {
          if (name === label) has = true;
        });
      });

      return has;
    }
  }, {
    key: 'get',
    value: function get(name) {

      var ret = null;
      if (name && typeof name === 'string') _.each(this._labels, function (label) {
        if (label.name === name) ret = label;
      });

      return ret;
    }
  }, {
    key: 'add',
    value: function add(name) {

      var found = false;
      _.each(this._labels, function (label) {
        if (label.name === name) found = true;
      });

      if (!found) this._labels.push(new Label(name));

      return !found; // so we know if success or not
    }
  }, {
    key: 'remove',
    value: function remove(name) {
      this._labels = this._labels.filter(function (label) {
        if (label.name !== name) return label;
      });
      for (var i = 0; i < manager.length; i++) {
        this.removeInComments(i, name);
      }
    }
  }, {
    key: 'edit',
    value: function edit(name, values) {
      var label = this.get(name);
      if (!label) return null;

      if (values.name) {
        for (var i = 0; i < manager.length; i++) {
          this.editInComments(i, label.name, values.name);
        }
        label.name = values.name;
      }

      if (values.desc || values.desc === '') label.desc = values.desc;

      if (values.color) label.changeColor(values.color.startsWith('#') ? values.color : '#' + values.color);
    }
  }, {
    key: 'update',
    value: function update() {
      var _this3 = this;

      if (!gui || !gui.inBrowser) return;

      $('#label-clear-filter .label-text').addClass('disabled');
      if (this._filter.size) $('#label-clear-filter .label-text').removeClass('disabled');

      $('.label.horiz').detach();
      _.each(this._labels, function (label) {
        return label.render(_this3);
      });
    }
  }, {
    key: 'addInComments',
    value: function addInComments(index, name) {

      if (name === undefined) {
        name = index;
        index = manager.index;
      }

      var done = false;
      manager.getSentence(index).comments = manager.getSentence(index).comments.map(function (comment) {

        if (comment.match(regex.labelComment) && !done) {
          comment = comment + ' ' + name;
          done = true;
        }

        return comment;
      });

      if (!done) manager.getSentence(index).comments = manager.getSentence(index).comments.concat(['labels = ' + name]);
    }
  }, {
    key: 'removeInComments',
    value: function removeInComments(index, name) {

      if (name === undefined) {
        name = index;
        index = manager.index;
      }

      manager.getSentence(index).comments = manager.getSentence(index).comments.map(function (comment) {
        return comment.replace(regex.labelByName(name), '$1');
      });
    }
  }, {
    key: 'editInComments',
    value: function editInComments(index, oldName, newName) {

      if (newName === undefined) {
        newName = oldName;
        oldName = index;
        index = manager.index;
      }

      manager.getSentence(index).comments = manager.getSentence(index).comments.map(function (comment) {
        return comment.replace(regex.labelByName(name), '$1' + newName + '$2');
      });
    }
  }, {
    key: 'addFilter',
    value: function addFilter(name) {
      var _this4 = this;

      // make sure it's a valid name
      manager.map(function (i) {
        if (_this4.has(i, name)) _this4._filter.add(name);
      });

      return this; // chaining
    }
  }, {
    key: 'filter',
    value: function filter(name) {
      return this.addFilter(name); // alias
    }
  }, {
    key: 'removeFilter',
    value: function removeFilter(name) {
      this._filter.delete(name);
      return this;
    }
  }, {
    key: 'unfilter',
    value: function unfilter(name) {
      return this.removeFilter(name); // alias
    }
  }, {
    key: 'clearFilter',
    value: function clearFilter() {
      var _this5 = this;

      this._filter.forEach(function (name) {
        return _this5.removeFilter(name);
      });
      return this;
    }
  }, {
    key: 'toggleFilter',
    value: function toggleFilter(name) {

      if (this._filter.has(name)) {
        this.removeFilter(name);
      } else {
        this.addFilter(name);
      }

      return this;
    }
  }, {
    key: 'state',
    get: function get() {
      return {
        labels: this._labels.map(function (label) {
          return label.state;
        }),
        filter: Array.from(this._filter)
      };
    },
    set: function set(state) {
      var _this6 = this;

      this._labels = state.labels.map(function (labelState) {
        var label = new Label();
        label.state = labelState;
        return label;
      });

      this._filter = new Set();
      _.each(state.filter, function (name) {
        _this6.addFilter(name);
      });
    }
  }], [{
    key: 'parseComment',
    value: function parseComment(comment) {
      var labels = [];
      var labelString = comment.match(regex.labelComment);

      if (labelString) labelString[2].split(/\s/).forEach(function (label) {

        var content = label.match(regex.labelContent);
        if (content) labels.push(content[1]);
      });

      return labels;
    }
  }, {
    key: 'parseComments',
    value: function parseComments(comments) {
      return _.reduce(comments, function (l, comment) {
        return l.concat(Labeler.parseComment(comment));
      }, []);
    }
  }]);

  return Labeler;
}();

function flashDropdown(name, inputName) {
  var dropdown = $('li[name="' + name + '"] .label-hidden');

  // show dropdown part immediately
  dropdown.css('display', 'flex');

  // wait 0.5 secs to return to standard dropdown behavior
  setTimeout(function () {
    return dropdown.css('display', '');
  }, 500);

  if (inputName) {
    dropdown.find('input[name="' + inputName + '"]').focus();
  }
}

function hashStringToHex(string) {
  var hash = 0;
  for (var i = 0; i < string.length; i++) {
    hash = string.charCodeAt(i) + ((hash << 5) - hash);
  }

  var hex = '#';
  for (var _i = 0; _i < 3; _i++) {
    var value = hash >> _i * 8 & 0xFF;
    hex += ('00' + value.toString(16)).substr(-2);
  }
  return hex;
}

function getRandomHexColor() {

  var color = '';
  do {
    color = '#' + Math.floor(Math.random() * magic).toString(16);
  } while (color.length !== 7);

  return color;
}

function hexToRGB(hex) {
  var match = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);

  if (match) return [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16)];
}

function getTextColor(background) {

  var color = '#ffffff';

  var rgb = hexToRGB(background);
  if (!rgb) return color;

  var _rgb = _slicedToArray(rgb, 3),
      r = _rgb[0],
      g = _rgb[1],
      b = _rgb[2];

  if (Math.pow(r, 2) + Math.pow(g, 2) + Math.pow(b, 2) > Math.pow(255 - r, 2) + Math.pow(255 - g, 2) + Math.pow(255 - b, 2)) color = '#000000';

  return color;
}

module.exports = Labeler;

},{"./errors":345,"jquery":327,"underscore":335}],351:[function(require,module,exports){
'use strict';

var KEY = require('./config').localStorageKey;

function isAvailable() {

  try {
    localStorage;
  } catch (e) {
    return false;
  }

  /* Taken from https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API */

  try {
    var x = '__storage_test__';

    localStorage.setItem(x, x);
    localStorage.removeItem(x);
    return true;
  } catch (e) {

    return e instanceof DOMException && (e.code === 1014 // Firefox
    || e.code === 22 // everything else

    // test name field too, because code might not be present
    || e.name === 'NS_ERROR_DOM_QUOTA_REACHED' // Firefox
    || e.name === 'QuotaExceededError') // everything else

    // acknowledge QuotaExceededError only if there's something already stored
    && localStorage.length !== 0;
  }
}

function getAvailableSpace() {

  /* Returns the remaining available space in localStorage */
  if (!isAvailable()) return 0;

  var max = 10 * 1024 * 1024,
      testKey = 'size-test-' + Math.random().toString(); // generate random key
  var i = 64,
      string1024 = '',
      string = '',
      found = 0;

  if (localStorage) {

    error = error || 25e4;

    // fill a string with 1024 symbols/bytes
    while (i--) {
      string1024 += 1e16;
    } // fill a string with "max" amount of symbols/bytes
    i = max / 1024;
    while (i--) {
      string += string1024;
    }i = max;

    // binary search
    while (i > 1) {
      try {
        localStorage.setItem(testKey, string.substr(0, i));
        localStorage.removeItem(testKey);

        if (found < i - error) {
          found = i;
          i *= 1.5;
        } else {
          break;
        }
      } catch (e) {
        localStorage.removeItem(testKey);
        i = found + (i - found) / 2;
      }
    }
  }

  return found;
}

function isQuotaExceeded(event) {

  if (event && event.code === 22) {
    return true;
  } else if (event && event.code === 1014) {
    return event.name === 'NS_ERROR_DOM_QUOTA_REACHED';
  } else if (event) {
    return event.number === -2147024882; // IE8
  }

  return false;
}

function formatUploadSize(fileSize) {

  if (fileSize < 1024) return fileSize + ' B';

  if (fileSize < 1048576) return (fileSize / 1024).toFixed(1) + ' kB';

  return (fileSize / 1048576).toFixed(1) + ' mB';
}

function save(value) {

  if (!isAvailable()) return null;

  return localStorage.setItem(KEY, value);
}

function load() {

  if (!isAvailable()) return null;

  return localStorage.getItem(KEY);
}

function clear() {

  if (!isAvailable()) return null;

  return localStorage.removeItem(KEY);
}

module.exports = {
  isAvailable: isAvailable,
  //isQuotaExceeded,
  //getAvailableSpace,
  //formatUploadSize,
  save: save,
  load: load,
  clear: clear
};

},{"./config":339}],352:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var _ = require('underscore');
var nx = require('notatrix');
nx.Sentence.prototype.currentFormat = null;

var cfg = require('./config');
var funcs = require('./funcs');
var GUI = require('./gui');
var Graph = require('./graph');
var Labeler = require('./labels');
var errors = require('./errors');
var detectFormat = require('./detect');
var storage = require('./local-storage');
var convert = require('./convert');

var Manager = function () {
  function Manager() {
    var _this = this;

    _classCallCheck(this, Manager);

    funcs.global().manager = this;
    funcs.global().gui = new GUI();
    funcs.global().graph = new Graph();
    funcs.global().labeler = new Labeler();
    gui.bind();

    this.reset();
    this.load();

    // save once every ? msecs
    setInterval(function () {
      return _this.save();
    }, cfg.saveInterval);
  }

  _createClass(Manager, [{
    key: 'reset',
    value: function reset() {
      this.filename = cfg.defaultFilename;

      this._sentences = [];
      this._index = -1;

      this._filtered = [];
      this._filterIndex = null;

      this.insertSentence(cfg.defaultSentence);
    }
  }, {
    key: 'map',
    value: function map(callback) {
      return this._sentences.map(function (sentence, i) {
        return callback(i, sentence);
      });
    }
  }, {
    key: 'updateFilter',
    value: function updateFilter() {
      var _this2 = this;

      this._filtered = [];
      this._filterIndex = -1;
      this.map(function (i) {
        labeler._filter.forEach(function (name) {

          // ones that have this label
          if (labeler.has(i, name) && _this2._filtered.indexOf(i) === -1) {

            // save to array
            _this2._filtered.push(i);

            // keep counting up for the _filterIndex
            if (i <= _this2.index) _this2._filterIndex++;
          }
        });
      });

      if (this._filterIndex < 0) this._filterIndex = null;

      // if we filter out our current sentence
      if (this._filtered.length && this._filtered.indexOf(this._index) === -1) this.index = 0;

      return this;
    }
  }, {
    key: 'first',
    value: function first() {

      this.updateFilter();

      this.index = this.length ? 0 : -1;
      return this;
    }
  }, {
    key: 'prev',
    value: function prev() {

      if (!this.length) return null;

      this.updateFilter();

      var index = this._filtered.length ? this._filterIndex : this._index;

      if (index === 0) {
        log.warn('Annotatrix: already at the first sentence!');
        return null;
      }

      this.index = --index;
      return this;
    }
  }, {
    key: 'next',
    value: function next() {

      if (!this.length) return null;

      this.updateFilter();

      var index = this._filtered.length ? this._filterIndex : this._index;
      var total = this._filtered.length ? this._filtered.length - 1 : this._length - 1;

      if (index === total) {
        log.warn('Annotatrix: already at the last sentence!');
        return null;
      }

      this.index = ++index;
      return this;
    }
  }, {
    key: 'last',
    value: function last() {

      this.updateFilter();

      this.index = this._filtered.length ? this._filtered.length - 1 : this.length - 1;
      return this;
    }
  }, {
    key: 'setSentence',
    value: function setSentence(index, text) {

      if (text === null || text === undefined) {
        // if only passed 1 arg
        text = index || '';
        index = this.index;
      }

      if (0 > index || index > this.length - 1) return null;

      this._sentences[index] = updateSentence(this._sentences[index], text);
      gui.update();

      return this.getSentence(index);
    }
  }, {
    key: 'getSentence',
    value: function getSentence(index) {

      if (index === undefined) index = this.index;

      if (0 > index || index > this.length - 1) return null;

      return this._sentences[index];
    }
  }, {
    key: 'insertSentence',
    value: function insertSentence(index, text) {

      if (text === null || text === undefined) {
        // if only passed 1 arg
        text = index || cfg.defaultInsertedSentence;
        index = this.index + 1;
      }

      index = parseFloat(index);
      if (isNaN(index)) throw new errors.AnnotatrixError('cannot insert at NaN');

      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);

      var sent = updateSentence({}, text);
      this._sentences = this._sentences.slice(0, index).concat(sent).concat(this._sentences.slice(index));

      this.index = index;
      gui.update();

      return sent.text;
    }
  }, {
    key: 'removeSentence',
    value: function removeSentence(index) {

      if (!this.length) return null;

      if (index === undefined) // if not passed args
        index = this.index;

      index = parseFloat(index);
      if (isNaN(index)) throw new errors.AnnotatrixError('cannot insert at NaN');

      index = index < 0 ? 0 : index > this.length - 1 ? this.length - 1 : parseInt(index);

      var removed = this._sentences.splice(index, 1)[0];
      if (!this.length) this.insertSentence();
      this.index--;

      gui.update();

      return removed;
    }
  }, {
    key: 'pushSentence',
    value: function pushSentence(text) {
      return this.insertSentence(Infinity, text);
    }
  }, {
    key: 'popSentence',
    value: function popSentence(text) {
      return this.removeSentence(Infinity);
    }
  }, {
    key: 'split',
    value: function split(text) {

      // split into sentences
      var splitted = void 0;
      if (detectFormat(text) === 'plain text') {

        // match non-punctuation (optionally) followed by punctuation
        var matched = text.match(/[^.!?]+[.!?]*/g);
        log.debug('parse(): match group: ' + matched);
        splitted = matched === null ? [text.trim()] : matched;
      } else {

        // match between multiple newlines
        splitted = text.split(/\n{2,}/g).map(function (chunk) {
          return chunk.trim();
        });
      }

      // removing extra whitespace in reverseorder
      for (var i = splitted.length - 1; i >= 0; i--) {
        if (splitted[i].trim() === '') splitted.splice(i, 1);
      }
      return splitted.length ? splitted : ['']; // need a default if empty
    }
  }, {
    key: 'parse',
    value: function parse(text) {
      var _this3 = this;

      // if not passed explicitly, read from the textarea
      text = text || gui.read('text-data');
      var splitted = this.split(text);

      // set the first one at the current index
      this._sentences[this.index] = new nx.Sentence(); // hack to get around updateSentence() behavior
      this.setSentence(this.index, splitted[0]);

      // iterate over all elements except the first
      _.each(splitted, function (split, i) {
        if (i) _this3.insertSentence(split);
      });

      gui.update();
      return this; // chaining
    }
  }, {
    key: 'save',
    value: function save() {

      var state = JSON.stringify({
        filename: this.filename,
        index: this._index,
        sentences: this.map(function (i, sent) {
          return {
            nx: sent.nx,
            column_visibilities: sent.column_visibilities,
            currentFormat: sent.currentFormat,
            is_table_view: sent.is_table_view,
            nx_initialized: sent.nx_initialized
          };
        }),
        gui: gui.state,
        labeler: labeler.state
      });

      storage.save(state);
      if (server && server.is_running) server.save(state);

      return state;
    }
  }, {
    key: 'load',
    value: function load(state) {

      state = state || (server && server.is_running ? server.load() : storage.load());

      if (!state) // unable to load
        return null;

      // parse it back from a string
      if (typeof state === 'string') state = JSON.parse(state);

      this.filename = state.filename;
      this._index = state.index;

      this._sentences = state.sentences.map(function (sent) {

        var sentence = nx.Sentence.fromNx(sent.nx);
        sentence.column_visibilities = sent.column_visibilities;
        sentence.currentFormat = sent.currentFormat;
        sentence.is_table_view = sent.is_table_view;
        sentence.nx_initialized = sent.nx_initialized;

        labeler.parse(sentence.comments);

        return sentence;
      });

      labeler.state = state.labeler;
      this.updateFilter(); // use the filters set in labeler

      // this triggers a gui refresh
      gui.state = state.gui;

      return state;
    }
  }, {
    key: 'upload',
    value: function upload() {
      // function handleUploadButtonPressed() {
      //     // Replaces current content
      //     CONTENTS = TEMPCONTENTS;
      //     localStorage.setItem("corpus", CONTENTS);
      //     getLocalStorageMaxSize()
      //     $("#localStorageAvailable").text(LOCALSTORAGE_AVAILABLE / 1024 + "k");
      //     loadDataInIndex();
      //     $("#uploadFileButton").attr("disabled", "disabled");
      //     $("#uploadFileSizeError").hide();
      //     $('#fileModal').modal('hide');
      // }
      console.log('upload');
      return;
      return this.save();
    }
  }, {
    key: 'export',
    value: function _export() {

      if (!gui.inBrowser) return null;

      // export corpora to file
      if (server.is_running) {
        server.download();
      } else {

        var link = $('<a>').attr('download', this.filename).attr('href', 'data:text/plain; charset=utf-8,' + this.encode());
        $('body').append(link);
        link[0].click();
      }
    }
  }, {
    key: 'encode',
    value: function encode() {
      var _this4 = this;

      return encodeURIComponent(this.map(function (i, sent) {
        return '[UD-Annotatrix: id="' + (i + 1) + '" format="' + _this4.format + '"]\n      ' + (_this4.format === 'Unknown' ? '' : _this4.sentence);
      }).join('\n\n'));
    }
  }, {
    key: 'print',
    value: function print() {
      throw new Error('print() not implemented');
    }
  }, {
    key: 'length',
    get: function get() {
      return this._sentences.length;
    }
  }, {
    key: 'totalSentences',
    get: function get() {
      return this._filtered.length ? this._filtered.length + ' (total: ' + this.length + ')' : '' + this.length;
    }
  }, {
    key: 'currentSentence',
    get: function get() {
      return this.index + 1;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {

      var total = this._filtered.length || this.length;

      index = parseInt(index);
      if (isNaN(index)) {
        log.warn('Annotatrix: index out of range: ' + index);
        index = this._filterIndex || this.index;
      } else if (index < 0 && total) {
        log.warn('Annotatrix: index out of range: ' + (index + 1));
        index = 0;
      } else if (index > total - 1) {
        log.warn('Annotatrix: index out of range: ' + (index + 1));
        index = total - 1;
      }

      if (this._filtered.length) {
        this._filterIndex = index;
        this._index = this._filtered[index];
      } else {
        this._filterIndex = null;
        this._index = index;
      }

      gui.update();
      return this.index;
    }
  }, {
    key: 'current',
    get: function get() {
      return this._sentences[this.index];
    },
    set: function set(sent) {
      if (sent instanceof nx.Sentence) this._sentences[this.index] = sent;
    }
  }, {
    key: 'sentence',
    get: function get() {
      if (!this.current) return null;

      if (this.format === 'CoNLL-U') {
        return this.current.conllu;
      } else if (this.format === 'CG3') {
        return this.current.cg3;
      } else {
        return this.current.text;
      }
    },
    set: function set(text) {
      return this.setSentence(text);
    }
  }, {
    key: 'sentences',
    get: function get() {
      return this.map(function (i, sent) {
        return sent.text;
      });
    }
  }, {
    key: 'format',
    get: function get() {
      if (this.current) return this.current.currentFormat;
    }
  }, {
    key: 'comments',
    get: function get() {
      if (this.current) return this.current.comments;
    },
    set: function set(comments) {
      if (!this.current) return;

      this.current.comments = comments;
      gui.update();
    }
  }, {
    key: 'tokens',
    get: function get() {
      if (this.current) return this.current.tokens;
    }
  }, {
    key: 'conllu',
    get: function get() {
      if (this.current) return this.current.conllu;
    }
  }, {
    key: 'cg3',
    get: function get() {
      if (this.current) return this.current.cg3;
    }
  }, {
    key: 'graphable',
    get: function get() {
      return this.format === 'CoNLL-U' || this.format === 'CG3';
    }
  }]);

  return Manager;
}();

function updateSentence(oldSent, text) {

  var currentSent = manager.current,
      oldFormat = manager.format,
      newFormat = detectFormat(text);

  var sent = void 0;

  if (newFormat === 'CoNLL-U') {

    if (oldFormat === 'plain text') {
      // don't overwrite stuff :)
      sent = currentSent;
    } else {
      sent = nx.Sentence.fromConllu(text);
    }
  } else if (newFormat === 'CG3') {

    if (oldFormat === 'plain text') {
      // don't overwrite stuff :)
      sent = currentSent;
    } else {
      sent = nx.Sentence.fromCG3(text);
    }
  } else if (newFormat === 'plain text') {

    if (oldSent.nx_initialized) {
      // don't overwrite stuff :)
      sent = oldSent;
    } else {
      sent = nx.Sentence.fromText(text);
    }
  } else if (newFormat === 'Unknown') {

    sent = nx.Sentence.fromText('');
  } else {

    text = convert.to.conllu(text);
    if (oldFormat === 'plain text') {
      // don't overwrite stuff :)
      sent = currentSent;
    } else {
      sent = nx.Sentence.fromConllu(text);
    }
  }

  sent.currentFormat = newFormat;
  sent.nx_initialized = oldSent.nx_initialized || false;
  sent.is_table_view = oldSent.is_table_view || false;
  sent.column_visibilities = oldSent.column_visibilities || new Array(10).fill(true);

  labeler.parse(sent.comments);

  return sent;
}

module.exports = Manager;

},{"./config":339,"./convert":340,"./detect":343,"./errors":345,"./funcs":346,"./graph":347,"./gui":348,"./labels":350,"./local-storage":351,"jquery":327,"notatrix":330,"underscore":335}],353:[function(require,module,exports){
'use strict';

module.exports = {
  upload: require('./upload')
};

},{"./upload":354}],354:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var $ = require('jquery');

var modal = $('#upload-modal');

function show() {
  modal.show();
}

function hide() {
  modal.hide();
}

/*function submit() {
  const file = getFile();

}*/

function enable() {
  modal.find('[type="submit"]').prop('disabled', false);
}

/*function getFile() {
  return document.getElementById('upload-filename').files[0];
}*/

modal.find('[name="close"]').click(hide);

module.exports = {
  show: show,
  hide: hide,
  enable: enable
};

},{"jquery":327,"underscore":335}],355:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProgressBar = function () {
  function ProgressBar() {
    _classCallCheck(this, ProgressBar);

    this.element = gui.inBrowser ? $('#progressBar') : null;
  }

  _createClass(ProgressBar, [{
    key: 'update',
    value: function update() {
      if (!manager.current || !this.element) return;

      var percentage = manager.current.progress * 100;
      this.element.css('width', percentage + '%');
    }
  }]);

  return ProgressBar;
}();

module.exports = ProgressBar;

},{}],356:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Note: I had to change the name from [Aa]utocomplete to [Ss]elfcomplete
// in order to get this to work at the same time as JQuery-UI

/**
*  Ajax Selfcomplete for jQuery, version 1.4.4
*  (c) 2017 Tomas Kirda
*
*  Ajax Selfcomplete for jQuery is freely distributable under the terms of an MIT-style license.
*  For details, see the web site: https://github.com/devbridge/jQuery-Selfcomplete
*/

/*jslint  browser: true, white: true, single: true, this: true, multivar: true */
/*global define, window, document, jQuery, exports, require */

// Expose plugin as an AMD module if AMD loader is present:
(function (factory) {
    "use strict";

    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof require === 'function') {
        // Browserify
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function ($) {
    'use strict';

    var utils = function () {
        return {
            escapeRegExChars: function escapeRegExChars(value) {
                return value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
            },
            createNode: function createNode(containerClass) {
                var div = document.createElement('div');
                div.className = containerClass;
                div.style.position = 'absolute';
                div.style.display = 'none';
                return div;
            }
        };
    }(),
        keys = {
        ESC: 27,
        TAB: 9,
        RETURN: 13,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40
    },
        noop = $.noop;

    function Selfcomplete(el, options) {
        var that = this;

        // Shared variables:
        that.element = el;
        that.el = $(el);
        that.suggestions = [];
        that.badQueries = [];
        that.selectedIndex = -1;
        that.currentValue = that.element.value;
        that.timeoutId = null;
        that.cachedResponse = {};
        that.onChangeTimeout = null;
        that.onChange = null;
        that.isLocal = false;
        that.suggestionsContainer = null;
        that.noSuggestionsContainer = null;
        that.options = $.extend({}, Selfcomplete.defaults, options);
        that.classes = {
            selected: 'selfcomplete-selected',
            suggestion: 'selfcomplete-suggestion'
        };
        that.hint = null;
        that.hintValue = '';
        that.selection = null;

        // Initialize and set options:
        that.initialize();
        that.setOptions(options);
    }

    Selfcomplete.utils = utils;

    $.Selfcomplete = Selfcomplete;

    Selfcomplete.defaults = {
        ajaxSettings: {},
        autoSelectFirst: false,
        appendTo: 'body',
        serviceUrl: null,
        lookup: null,
        onSelect: null,
        width: 'auto',
        minChars: 1,
        maxHeight: 300,
        deferRequestBy: 0,
        params: {},
        formatResult: _formatResult,
        formatGroup: _formatGroup,
        delimiter: null,
        zIndex: 9999,
        type: 'GET',
        noCache: false,
        onSearchStart: noop,
        onSearchComplete: noop,
        onSearchError: noop,
        preserveInput: false,
        containerClass: 'selfcomplete-suggestions',
        tabDisabled: false,
        dataType: 'text',
        currentRequest: null,
        triggerSelectOnValidInput: true,
        preventBadQueries: true,
        lookupFilter: _lookupFilter,
        paramName: 'query',
        transformResult: _transformResult,
        showNoSuggestionNotice: false,
        noSuggestionNotice: 'No results',
        orientation: 'bottom',
        forceFixPosition: false
    };

    function _lookupFilter(suggestion, originalQuery, queryLowerCase) {
        return suggestion.value.toLowerCase().startsWith(queryLowerCase) !== false;
    };

    function _transformResult(response) {
        return typeof response === 'string' ? $.parseJSON(response) : response;
    };

    function _formatResult(suggestion, currentValue) {
        // Do not replace anything if the current value is empty
        if (!currentValue) {
            return suggestion.value;
        }

        var pattern = '(' + utils.escapeRegExChars(currentValue) + ')';

        return suggestion.value.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/&lt;(\/?strong)&gt;/g, '<$1>');
    };

    function _formatGroup(suggestion, category) {
        return '<div class="selfcomplete-group">' + category + '</div>';
    };

    Selfcomplete.prototype = {

        initialize: function initialize() {
            var that = this,
                suggestionSelector = '.' + that.classes.suggestion,
                selected = that.classes.selected,
                options = that.options,
                container;

            // Remove selfcomplete attribute to prevent native suggestions:
            that.element.setAttribute('selfcomplete', 'off');

            // html() deals with many types: htmlString or Element or Array or jQuery
            that.noSuggestionsContainer = $('<div class="selfcomplete-no-suggestion"></div>').html(this.options.noSuggestionNotice).get(0);

            that.suggestionsContainer = Selfcomplete.utils.createNode(options.containerClass);

            container = $(that.suggestionsContainer);

            container.appendTo(options.appendTo || 'body');

            // Only set width if it was provided:
            if (options.width !== 'auto') {
                container.css('width', options.width);
            }

            // Listen for mouse over event on suggestions list:
            container.on('mouseover.selfcomplete', suggestionSelector, function () {
                that.activate($(this).data('index'));
            });

            // Deselect active element when mouse leaves suggestions container:
            container.on('mouseout.selfcomplete', function () {
                that.selectedIndex = -1;
                container.children('.' + selected).removeClass(selected);
            });

            // Listen for click event on suggestions list:
            container.on('click.selfcomplete', suggestionSelector, function () {
                that.select($(this).data('index'));
            });

            container.on('click.selfcomplete', function () {
                clearTimeout(that.blurTimeoutId);
            });

            that.fixPositionCapture = function () {
                if (that.visible) {
                    that.fixPosition();
                }
            };

            $(window).on('resize.selfcomplete', that.fixPositionCapture);

            that.el.on('keydown.selfcomplete', function (e) {
                that.onKeyPress(e);
            });
            that.el.on('keyup.selfcomplete', function (e) {
                that.onKeyUp(e);
            });
            that.el.on('blur.selfcomplete', function () {
                that.onBlur();
            });
            that.el.on('focus.selfcomplete', function () {
                that.onFocus();
            });
            that.el.on('change.selfcomplete', function (e) {
                that.onKeyUp(e);
            });
            that.el.on('input.selfcomplete', function (e) {
                that.onKeyUp(e);
            });
        },

        onFocus: function onFocus() {
            var that = this;

            that.fixPosition();

            if (that.el.val().length >= that.options.minChars) {
                that.onValueChange();
            }
        },

        onBlur: function onBlur() {
            var that = this;

            // If user clicked on a suggestion, hide() will
            // be canceled, otherwise close suggestions
            that.blurTimeoutId = setTimeout(function () {
                that.hide();
            }, 200);
        },

        abortAjax: function abortAjax() {
            var that = this;
            if (that.currentRequest) {
                that.currentRequest.abort();
                that.currentRequest = null;
            }
        },

        setOptions: function setOptions(suppliedOptions) {
            var that = this,
                options = $.extend({}, that.options, suppliedOptions);

            that.isLocal = Array.isArray(options.lookup);

            if (that.isLocal) {
                options.lookup = that.verifySuggestionsFormat(options.lookup);
            }

            options.orientation = that.validateOrientation(options.orientation, 'bottom');

            // Adjust height, width and z-index:
            $(that.suggestionsContainer).css({
                'max-height': options.maxHeight + 'px',
                'width': options.width + 'px',
                'z-index': options.zIndex
            });

            this.options = options;
        },

        clearCache: function clearCache() {
            this.cachedResponse = {};
            this.badQueries = [];
        },

        clear: function clear() {
            this.clearCache();
            this.currentValue = '';
            this.suggestions = [];
        },

        disable: function disable() {
            var that = this;
            that.disabled = true;
            clearTimeout(that.onChangeTimeout);
            that.abortAjax();
        },

        enable: function enable() {
            this.disabled = false;
        },

        fixPosition: function fixPosition() {
            // Use only when container has already its content

            var that = this,
                $container = $(that.suggestionsContainer),
                containerParent = $container.parent().get(0);
            // Fix position automatically when appended to body.
            // In other cases force parameter must be given.
            if (containerParent !== document.body && !that.options.forceFixPosition) {
                return;
            }

            // Choose orientation
            var orientation = that.options.orientation,
                containerHeight = $container.outerHeight(),
                height = that.el.outerHeight(),
                offset = that.el.offset(),
                styles = { 'top': offset.top, 'left': offset.left };

            if (orientation === 'auto') {
                var viewPortHeight = $(window).height(),
                    scrollTop = $(window).scrollTop(),
                    topOverflow = -scrollTop + offset.top - containerHeight,
                    bottomOverflow = scrollTop + viewPortHeight - (offset.top + height + containerHeight);

                orientation = Math.max(topOverflow, bottomOverflow) === topOverflow ? 'top' : 'bottom';
            }

            if (orientation === 'top') {
                styles.top += -containerHeight;
            } else {
                styles.top += height;
            }

            // If container is not positioned to body,
            // correct its position using offset parent offset
            if (containerParent !== document.body) {
                var opacity = $container.css('opacity'),
                    parentOffsetDiff;

                if (!that.visible) {
                    $container.css('opacity', 0).show();
                }

                parentOffsetDiff = $container.offsetParent().offset();
                styles.top -= parentOffsetDiff.top;
                styles.left -= parentOffsetDiff.left;

                if (!that.visible) {
                    $container.css('opacity', opacity).hide();
                }
            }

            if (that.options.width === 'auto') {
                styles.width = that.el.outerWidth() + 'px';
            }

            $container.css(styles);
        },

        isCursorAtEnd: function isCursorAtEnd() {
            var that = this,
                valLength = that.el.val().length,
                selectionStart = that.element.selectionStart,
                range;

            if (typeof selectionStart === 'number') {
                return selectionStart === valLength;
            }
            if (document.selection) {
                range = document.selection.createRange();
                range.moveStart('character', -valLength);
                return valLength === range.text.length;
            }
            return true;
        },

        onKeyPress: function onKeyPress(e) {
            var that = this;

            // If suggestions are hidden and user presses arrow down, display suggestions:
            if (!that.disabled && !that.visible && e.which === keys.DOWN && that.currentValue) {
                that.suggest();
                return;
            }

            if (that.disabled || !that.visible) {
                return;
            }

            switch (e.which) {
                case keys.ESC:
                    that.el.val(that.currentValue);
                    that.hide();
                    break;
                case keys.RIGHT:
                    if (that.hint && that.options.onHint && that.isCursorAtEnd()) {
                        that.selectHint();
                        break;
                    }
                    return;
                case keys.TAB:
                    if (that.hint && that.options.onHint) {
                        that.selectHint();
                        return;
                    }
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    if (that.options.tabDisabled === false) {
                        return;
                    }
                    break;
                case keys.RETURN:
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    break;
                case keys.UP:
                    that.moveUp();
                    break;
                case keys.DOWN:
                    that.moveDown();
                    break;
                default:
                    return;
            }

            // Cancel event if function did not return:
            e.stopImmediatePropagation();
            e.preventDefault();
        },

        onKeyUp: function onKeyUp(e) {
            var that = this;

            if (that.disabled) {
                return;
            }

            switch (e.which) {
                case keys.UP:
                case keys.DOWN:
                    return;
            }

            clearTimeout(that.onChangeTimeout);

            if (that.currentValue !== that.el.val()) {
                that.findBestHint();
                if (that.options.deferRequestBy > 0) {
                    // Defer lookup in case when value changes very quickly:
                    that.onChangeTimeout = setTimeout(function () {
                        that.onValueChange();
                    }, that.options.deferRequestBy);
                } else {
                    that.onValueChange();
                }
            }
        },

        onValueChange: function onValueChange() {
            if (this.ignoreValueChange) {
                this.ignoreValueChange = false;
                return;
            }

            var that = this,
                options = that.options,
                value = that.el.val(),
                query = that.getQuery(value);

            if (that.selection && that.currentValue !== query) {
                that.selection = null;
                (options.onInvalidateSelection || $.noop).call(that.element);
            }

            clearTimeout(that.onChangeTimeout);
            that.currentValue = value;
            that.selectedIndex = -1;

            // Check existing suggestion for the match before proceeding:
            if (options.triggerSelectOnValidInput && that.isExactMatch(query)) {
                that.select(0);
                return;
            }

            if (query.length < options.minChars) {
                that.hide();
            } else {
                that.getSuggestions(query);
            }
        },

        isExactMatch: function isExactMatch(query) {
            var suggestions = this.suggestions;

            return suggestions.length === 1 && suggestions[0].value.toLowerCase() === query.toLowerCase();
        },

        getQuery: function getQuery(value) {
            var delimiter = this.options.delimiter,
                parts;

            if (!delimiter) {
                return value;
            }
            parts = value.split(delimiter);
            return $.trim(parts[parts.length - 1]);
        },

        getSuggestionsLocal: function getSuggestionsLocal(query) {
            var that = this,
                options = that.options,
                queryLowerCase = query.toLowerCase(),
                filter = options.lookupFilter,
                limit = parseInt(options.lookupLimit, 10),
                data;

            data = {
                suggestions: $.grep(options.lookup, function (suggestion) {
                    return filter(suggestion, query, queryLowerCase);
                })
            };

            if (limit && data.suggestions.length > limit) {
                data.suggestions = data.suggestions.slice(0, limit);
            }

            return data;
        },

        getSuggestions: function getSuggestions(q) {
            var response,
                that = this,
                options = that.options,
                serviceUrl = options.serviceUrl,
                params,
                cacheKey,
                ajaxSettings;

            options.params[options.paramName] = q;

            if (options.onSearchStart.call(that.element, options.params) === false) {
                return;
            }

            params = options.ignoreParams ? null : options.params;

            if ($.isFunction(options.lookup)) {
                options.lookup(q, function (data) {
                    that.suggestions = data.suggestions;
                    that.suggest();
                    options.onSearchComplete.call(that.element, q, data.suggestions);
                });
                return;
            }

            if (that.isLocal) {
                response = that.getSuggestionsLocal(q);
            } else {
                if ($.isFunction(serviceUrl)) {
                    serviceUrl = serviceUrl.call(that.element, q);
                }
                cacheKey = serviceUrl + '?' + $.param(params || {});
                response = that.cachedResponse[cacheKey];
            }

            if (response && Array.isArray(response.suggestions)) {
                that.suggestions = response.suggestions;
                that.suggest();
                options.onSearchComplete.call(that.element, q, response.suggestions);
            } else if (!that.isBadQuery(q)) {
                that.abortAjax();

                ajaxSettings = {
                    url: serviceUrl,
                    data: params,
                    type: options.type,
                    dataType: options.dataType
                };

                $.extend(ajaxSettings, options.ajaxSettings);

                that.currentRequest = $.ajax(ajaxSettings).done(function (data) {
                    var result;
                    that.currentRequest = null;
                    result = options.transformResult(data, q);
                    that.processResponse(result, q, cacheKey);
                    options.onSearchComplete.call(that.element, q, result.suggestions);
                }).fail(function (jqXHR, textStatus, errorThrown) {
                    options.onSearchError.call(that.element, q, jqXHR, textStatus, errorThrown);
                });
            } else {
                options.onSearchComplete.call(that.element, q, []);
            }
        },

        isBadQuery: function isBadQuery(q) {
            if (!this.options.preventBadQueries) {
                return false;
            }

            var badQueries = this.badQueries,
                i = badQueries.length;

            while (i--) {
                if (q.indexOf(badQueries[i]) === 0) {
                    return true;
                }
            }

            return false;
        },

        hide: function hide() {
            var that = this,
                container = $(that.suggestionsContainer);

            if ($.isFunction(that.options.onHide) && that.visible) {
                that.options.onHide.call(that.element, container);
            }

            that.visible = false;
            that.selectedIndex = -1;
            clearTimeout(that.onChangeTimeout);
            $(that.suggestionsContainer).hide();
            that.signalHint(null);
        },

        suggest: function suggest() {
            if (!this.suggestions.length) {
                if (this.options.showNoSuggestionNotice) {
                    this.noSuggestions();
                } else {
                    this.hide();
                }
                return;
            }

            var that = this,
                options = that.options,
                groupBy = options.groupBy,
                formatResult = options.formatResult,
                value = that.getQuery(that.currentValue),
                className = that.classes.suggestion,
                classSelected = that.classes.selected,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer),
                beforeRender = options.beforeRender,
                html = '',
                category,
                formatGroup = function formatGroup(suggestion, index) {
                var currentCategory = suggestion.data[groupBy];

                if (category === currentCategory) {
                    return '';
                }

                category = currentCategory;

                return options.formatGroup(suggestion, category);
            };

            if (options.triggerSelectOnValidInput && that.isExactMatch(value)) {
                that.select(0);
                return;
            }

            // Build suggestions inner HTML:
            $.each(that.suggestions, function (i, suggestion) {
                if (groupBy) {
                    html += formatGroup(suggestion, value, i);
                }

                html += '<div class="' + className + '" data-index="' + i + '">' + formatResult(suggestion, value, i) + '</div>';
            });

            this.adjustContainerWidth();

            noSuggestionsContainer.detach();
            container.html(html);

            if ($.isFunction(beforeRender)) {
                beforeRender.call(that.element, container, that.suggestions);
            }

            that.fixPosition();
            container.show();

            // Select first value by default:
            if (options.autoSelectFirst) {
                that.selectedIndex = 0;
                container.scrollTop(0);
                container.children('.' + className).first().addClass(classSelected);
            }

            that.visible = true;
            that.findBestHint();
        },

        noSuggestions: function noSuggestions() {
            var that = this,
                beforeRender = that.options.beforeRender,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer);

            this.adjustContainerWidth();

            // Some explicit steps. Be careful here as it easy to get
            // noSuggestionsContainer removed from DOM if not detached properly.
            noSuggestionsContainer.detach();

            // clean suggestions if any
            container.empty();
            container.append(noSuggestionsContainer);

            if ($.isFunction(beforeRender)) {
                beforeRender.call(that.element, container, that.suggestions);
            }

            that.fixPosition();

            container.show();
            that.visible = true;
        },

        adjustContainerWidth: function adjustContainerWidth() {
            var that = this,
                options = that.options,
                width,
                container = $(that.suggestionsContainer);

            // If width is auto, adjust width before displaying suggestions,
            // because if instance was created before input had width, it will be zero.
            // Also it adjusts if input width has changed.
            if (options.width === 'auto') {
                width = that.el.outerWidth();
                container.css('width', width > 0 ? width : 300);
            } else if (options.width === 'flex') {
                // Trust the source! Unset the width property so it will be the max length
                // the containing elements.
                container.css('width', '');
            }
        },

        findBestHint: function findBestHint() {
            var that = this,
                value = that.el.val().toLowerCase(),
                bestMatch = null;

            if (!value) {
                return;
            }

            $.each(that.suggestions, function (i, suggestion) {
                var foundMatch = suggestion.value.toLowerCase().indexOf(value) === 0;
                if (foundMatch) {
                    bestMatch = suggestion;
                }
                return !foundMatch;
            });

            that.signalHint(bestMatch);
        },

        signalHint: function signalHint(suggestion) {
            var hintValue = '',
                that = this;
            if (suggestion) {
                hintValue = that.currentValue + suggestion.value.substr(that.currentValue.length);
            }
            if (that.hintValue !== hintValue) {
                that.hintValue = hintValue;
                that.hint = suggestion;
                (this.options.onHint || $.noop)(hintValue);
            }
        },

        verifySuggestionsFormat: function verifySuggestionsFormat(suggestions) {
            // If suggestions is string array, convert them to supported format:
            if (suggestions.length && typeof suggestions[0] === 'string') {
                return $.map(suggestions, function (value) {
                    return { value: value, data: null };
                });
            }

            return suggestions;
        },

        validateOrientation: function validateOrientation(orientation, fallback) {
            orientation = $.trim(orientation || '').toLowerCase();

            if ($.inArray(orientation, ['auto', 'bottom', 'top']) === -1) {
                orientation = fallback;
            }

            return orientation;
        },

        processResponse: function processResponse(result, originalQuery, cacheKey) {
            var that = this,
                options = that.options;

            result.suggestions = that.verifySuggestionsFormat(result.suggestions);

            // Cache results if cache is not disabled:
            if (!options.noCache) {
                that.cachedResponse[cacheKey] = result;
                if (options.preventBadQueries && !result.suggestions.length) {
                    that.badQueries.push(originalQuery);
                }
            }

            // Return if originalQuery is not matching current query:
            if (originalQuery !== that.getQuery(that.currentValue)) {
                return;
            }

            that.suggestions = result.suggestions;
            that.suggest();
        },

        activate: function activate(index) {
            var that = this,
                activeItem,
                selected = that.classes.selected,
                container = $(that.suggestionsContainer),
                children = container.find('.' + that.classes.suggestion);

            container.find('.' + selected).removeClass(selected);

            that.selectedIndex = index;

            if (that.selectedIndex !== -1 && children.length > that.selectedIndex) {
                activeItem = children.get(that.selectedIndex);
                $(activeItem).addClass(selected);
                return activeItem;
            }

            return null;
        },

        selectHint: function selectHint() {
            var that = this,
                i = $.inArray(that.hint, that.suggestions);

            that.select(i);
        },

        select: function select(i) {
            var that = this;
            that.hide();
            that.onSelect(i);
        },

        moveUp: function moveUp() {
            var that = this;

            if (that.selectedIndex === -1) {
                return;
            }

            if (that.selectedIndex === 0) {
                $(that.suggestionsContainer).children().first().removeClass(that.classes.selected);
                that.selectedIndex = -1;
                that.ignoreValueChange = false;
                that.el.val(that.currentValue);
                that.findBestHint();
                return;
            }

            that.adjustScroll(that.selectedIndex - 1);
        },

        moveDown: function moveDown() {
            var that = this;

            if (that.selectedIndex === that.suggestions.length - 1) {
                return;
            }

            that.adjustScroll(that.selectedIndex + 1);
        },

        adjustScroll: function adjustScroll(index) {
            var that = this,
                activeItem = that.activate(index);

            if (!activeItem) {
                return;
            }

            var offsetTop,
                upperBound,
                lowerBound,
                heightDelta = $(activeItem).outerHeight();

            offsetTop = activeItem.offsetTop;
            upperBound = $(that.suggestionsContainer).scrollTop();
            lowerBound = upperBound + that.options.maxHeight - heightDelta;

            if (offsetTop < upperBound) {
                $(that.suggestionsContainer).scrollTop(offsetTop);
            } else if (offsetTop > lowerBound) {
                $(that.suggestionsContainer).scrollTop(offsetTop - that.options.maxHeight + heightDelta);
            }

            if (!that.options.preserveInput) {
                // During onBlur event, browser will trigger "change" event,
                // because value has changed, to avoid side effect ignore,
                // that event, so that correct suggestion can be selected
                // when clicking on suggestion with a mouse
                that.ignoreValueChange = true;
                that.el.val(that.getValue(that.suggestions[index].value));
            }

            that.signalHint(null);
        },

        onSelect: function onSelect(index) {
            var that = this,
                onSelectCallback = that.options.onSelect,
                suggestion = that.suggestions[index];

            that.currentValue = that.getValue(suggestion.value);

            if (that.currentValue !== that.el.val() && !that.options.preserveInput) {
                that.el.val(that.currentValue);
            }

            that.signalHint(null);
            that.suggestions = [];
            that.selection = suggestion;

            if ($.isFunction(onSelectCallback)) {
                onSelectCallback.call(that.element, suggestion);
            }
        },

        getValue: function getValue(value) {
            var that = this,
                delimiter = that.options.delimiter,
                currentValue,
                parts;

            if (!delimiter) {
                return value;
            }

            currentValue = that.currentValue;
            parts = currentValue.split(delimiter);

            if (parts.length === 1) {
                return value;
            }

            return currentValue.substr(0, currentValue.length - parts[parts.length - 1].length) + value;
        },

        dispose: function dispose() {
            var that = this;
            that.el.off('.selfcomplete').removeData('selfcomplete');
            $(window).off('resize.selfcomplete', that.fixPositionCapture);
            $(that.suggestionsContainer).remove();
        }
    };

    // Create chainable jQuery plugin:
    $.fn.devbridgeSelfcomplete = function (options, args) {
        var dataKey = 'selfcomplete';
        // If function invoked without argument return
        // instance of the first matched element:
        if (!arguments.length) {
            return this.first().data(dataKey);
        }

        return this.each(function () {
            var inputElement = $(this),
                instance = inputElement.data(dataKey);

            if (typeof options === 'string') {
                if (instance && typeof instance[options] === 'function') {
                    instance[options](args);
                }
            } else {
                // If instance already exists, destroy it:
                if (instance && instance.dispose) {
                    instance.dispose();
                }
                instance = new Selfcomplete(this, options);
                inputElement.data(dataKey, instance);
            }
        });
    };

    // Don't overwrite if it already exists
    if (!$.fn.selfcomplete) {
        $.fn.selfcomplete = $.fn.devbridgeSelfcomplete;
    }
});

},{"jquery":327}],357:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');
var storage = require('./local-storage');

var Server = function () {
	function Server() {
		_classCallCheck(this, Server);

		this.treebank_id = getTreebankId();
		this.check();
	}

	_createClass(Server, [{
		key: 'check',
		value: function check() {
			var _this = this;

			this.is_running = false;
			try {
				$.ajax({
					type: 'POST',
					url: '/annotatrix/running',
					data: {
						content: 'check'
					},
					dataType: 'json',
					success: function success(data) {
						log.info('checkServer AJAX response: ' + JSON.stringify(data));
						_this.is_running = true;
						gui.update();
						gui.modals.upload.enable();
						_this.load();
					},
					error: function error(data) {
						log.error('Unable to complete AJAX request for check()');
					}
				});
			} catch (e) {
				log.error('AJAX error in check(): ' + e.message);
			}
		}
	}, {
		key: 'save',
		value: function save(state) {

			if (!this.is_running) return null;

			try {
				$.ajax({
					type: 'POST',
					url: '/save',
					data: {
						state: state,
						treebank_id: this.treebank_id
					},
					dataType: 'json',
					success: function success(data) {
						if (data.status === 'failure') {
							log.error('Unable to save(): server error');
						} else {
							log.info('Successfully saved to server');
						}
					},
					error: function error(data) {
						log.error('Unable to complete AJAX request for save()');
					}
				});
			} catch (e) {
				log.error('AJAX error in save(): ' + e.message);
			}
		}
	}, {
		key: 'load',
		value: function load() {

			if (!this.is_running) return null;

			try {
				$.ajax({
					type: 'GET',
					url: '/load/' + this.treebank_id + '/',
					success: function success(data) {
						if (data.status === 'failure') {
							log.error('Unable to load(): server error');
						} else {
							log.info('Successfully loaded from server');

							manager.load({
								filename: data.filename,
								gui: JSON.parse(data.gui),
								sentences: data.sentences.map(JSON.parse),
								labeler: JSON.parse(data.labeler),
								index: 0
							});
						}
					},
					error: function error(data) {
						log.critical('Unable to complete AJAX request for load()');
					}
				});
			} catch (e) {
				log.critical('AJAX error in load(): ' + e.message);
			}

			return null; // want the loading to fail
		}
	}, {
		key: 'download',
		value: function download() {
			if (!this.is_running) return null;

			var treebank_id = location.href.split('/')[4];
			window.open('./download?treebank_id=' + treebank_id, '_blank');
		}
	}]);

	return Server;
}();

function getTreebankId() {
	return location.href.split('/')[4];
}

module.exports = Server;

},{"./local-storage":351,"jquery":327}],358:[function(require,module,exports){
'use strict';

var _ = require('underscore');

// NB: sorting will break if sentence has more than this many tokens
var LARGE_NUMBER = 10000;

function vertical(n1, n2) {

  var num = function num(node) {
    var id = parseInt(node.data('num')),
        offset = node.data('name') === 'pos-node' ? 0 : 0.5;

    return isNaN(id) ? -Infinity : id + offset;
  };

  var num1 = num(n1);
  var num2 = num(n2);

  return num1 === num2 ? 0 : num1 < num2 ? -1 : 1;
}

function ltr(n1, n2) {

  var num = function num(node) {
    var id = parseInt(node.data('num')),
        offset = node.data('name') === 'pos-node' ? LARGE_NUMBER : 0;

    return isNaN(id) ? -Infinity : id + offset;
  };

  var num1 = num(n1);
  var num2 = num(n2);

  return num1 === num2 ? 0 : num1 < num2 ? -1 : 1;
}

function rtl(n1, n2) {
  var num = function num(node) {
    var id = parseInt(node.data('num')),
        offset = node.data('name') === 'pos-node' ? 0 : LARGE_NUMBER;

    return isNaN(id) ? -Infinity : id + offset;
  };

  var num1 = num(n1);
  var num2 = num(n2);

  return num1 === num2 ? 0 : num1 < num2 ? 1 : -1;
}

module.exports = {
  vertical: vertical,
  ltr: ltr,
  rtl: rtl
};

},{"underscore":335}],359:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var validate = require('./validate');

function build() {
  $('#table-data tbody').empty();

  manager.current.forEach(function (token, i) {
    var tr = $('<tr>').attr('id', 'table_' + i);

    $.each(['id', 'form', 'lemma', 'upostag', 'xpostag', 'feats', 'head', 'deprel', 'deps', 'misc'], function (j, field) {

      var value = token.analysis[field];

      var valid = {},
          td = $('<td>'),
          inputSpan = $('<span>').attr('name', 'input'),
          errorSpan = $('<span>').attr('name', 'error');

      if (value !== '_') {
        if (j === 3) valid = validate.is_upos(value);
        if (j === 7) valid = validate.is_udeprel(value);
      }

      td.prop('contenteditable', true).attr('row-id', i).attr('col-id', j).attr('tok-id', token.analysis.id).attr('field', field).attr('name', j === 0 ? 'index' : 'content').css('visibility', gui.column_visible(j) ? 'visible' : 'hidden').blur(edit).keyup(function (event) {
        if (event.which === gui.keys.ESC) {
          $(event.target).blur();
        } else if (event.which === gui.keys.ENTER) {
          gui.onEnter(event);
        }
      });

      inputSpan.text(value);

      if (valid.err) {
        log.warn('buildTable(): error parsing cell (err:"' + valid.err + '", value:"' + value + '")');
        /*document.l10n.formatValue(valid.err, valid.data).then(title => {
          errorSpan.addClass('fa fa-exclamation-triangle')
            .addClass('parse-error')
            .attr('aria-hidden', 'true')
            .attr('title', title);
        });*/
      }
      tr.append(td.append(inputSpan).append(errorSpan));
    });

    $('#table-data tbody').append(tr);
  });
}

function edit(event) {

  var target = $(event.target),
      id = target.attr('tok-id'),
      ana = manager.current.getById(id),
      field = target.attr('field'),
      value = target.text();

  ana[field] = value;
  gui.update();
}

module.exports = {
  build: build,
  edit: edit
};

},{"./validate":368,"jquery":327}],360:[function(require,module,exports){
'use strict';

module.exports = {
  0: '[root [nsubj I] have [obj [amod [advmod too] many] commitments] [advmod right now] [punct .]]'
};

},{}],361:[function(require,module,exports){
'use strict';

module.exports = {
	nested: '# sent_id = wikipedia:Poyvi_Paragu\xE1i:11\n# text = Poyvi pete\u0129ha \xF1ane ret\xE3megua niko ojepuru\u2019yp\xFDkuri 15 jasypo guive 16 jasypote\u0129 meve ary 1811-pe.\n# text[spa] = Bandera uno nosotros de-de _ \xE9l-se-utiliz\xF3-_ 15 maio desde 16 junio hasta a\xF1o 1811-en.\n"<Poyvi>"\n\t"poyvi" n\n"<pete\u0129ha>"\n\t"pete" n incp\n\t\t"\u0129" v tv pres\n\t\t\t"ha" subs\n\t"pete\u0129ha" num\n"<\xF1ane>"\n\t"\xF1and\xE9" prn pers p1 incl pl\n"<ret\xE3megua>"\n\t"*ret\xE3megua"\n"<niko>"\n\t"*niko"\n"<ojepuru\u02BCyp\xFDkuri>"\n\t"*ojepuru\u02BCyp\xFDkuri"\n"<15>"\n\t"15" num @amod\n"<jasypo>"\n\t"ja" n incp\n\t\t"sy" n incp\n\t\t\t"po" n\n\t"ja" n incp\n\t\t"sy" n incp\n\t\t\t"po" v iv pres\n\t"ja" n incp\n\t\t"sy" n incp\n\t\t\t"po" v tv pres\n\t"ja" prn p1 pl\n\t\t"sy" n incp\n\t\t\t"po" n\n\t"ja" prn p1 pl\n\t\t"sy" n incp\n\t\t\t"po" v iv pres\n\t"ja" prn p1 pl\n\t\t"sy" n incp\n\t\t\t"po" v tv pres\n\t"jasy" n incp\n\t\t"po" n\n\t"jasy" n incp\n\t\t"po" v iv pres\n\t"jasy" n incp\n\t\t"po" v tv pres\n\t"jasypo" n\n"<guive>"\n\t"guive" post @case\n"<16>"\n\t"16" num @amod\n"<jasypote\u0129>"\n\t"jasypote\u0129" n\n"<meve>"\n\t"peve" post @case\n"<ary>"\n\t"ary" n\n"<1811-pe>"\n\t"1811" num\n\t\t"pe" post @case',

	/*nested_2: `"<ab>"
 	"A" #1->
 		"B" #2->
 "<cde>"
 	"C" #3->
 		"D" #4->
 			"E" #5->
 "<f>"
 	"F" #6->
 "<h>"
 	"H" #7->`,*/

	kdt_tagged_1: '# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt\n"<\u04E8\u0441\u043A\u0435\u043C\u0435\u043D\u043D\u0456\u04A3>"\n\t"\u04E8\u0441\u043A\u0435\u043C\u0435\u043D" np top gen @nmod:poss #1->3\n"<\u0430\u0440>"\n\t"\u0430\u0440" adj @amod #2->3\n"<\u0436\u0430\u0493\u044B\u043D\u0434\u0430>"\n\t"\u0436\u0430\u049B" n px3sp loc @conj #3->7\n"<,>"\n\t"," cm @punct #4->7\n"<\u0411\u04B1\u049B\u0442\u044B\u0440\u043C\u0430\u043D\u044B\u04A3>"\n\t"\u0411\u04B1\u049B\u0442\u044B\u0440\u043C\u0430" np top gen @nmod:poss #5->7\n"<\u043E\u04A3>"\n\t"\u043E\u04A3" adj @amod #6->7\n"<\u0436\u0430\u0493\u044B\u043D\u0434\u0430>"\n\t"\u0436\u0430\u049B" n px3sp loc @nmod #7->11\n"<\u04D9\u043B\u0435\u043C\u0433\u0435>"\n\t"\u04D9\u043B\u0435\u043C" n dat @nmod #8->9\n"<\u0430\u044F\u043D>"\n\t"\u0430\u044F\u043D" adj @acl #9->10\n"<\u0410\u043B\u0442\u0430\u0439>"\n\t"\u0410\u043B\u0442\u0430\u0439" np top nom @nsubj #10->11\n"<\u0431\u0430\u0440>"\n\t"\u0431\u0430\u0440" adj @root #11->0\n\t\t"\u0435" cop aor p3 sg @cop #12->11\n"<.>"\n\t"." sent @punct #13->11',

	kdt_tagged_2: '# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt\n"<\u0410\u0442\u0442\u0430\u043D>"\n\t"\u0430\u0442\u0442\u0430\u043D" v iv imp p2 sg @root #1->0\n"<!>"\n\t"!" sent @punct #2->1',

	kdt_tagged_3: '# https://github.com/apertium/apertium-kaz/blob/master/texts/kdt.tagged.txt\n"<\u041C\u0430\u043D\u0430\u0493\u044B>"\n\t"\u043C\u0430\u043D\u0430\u0493\u044B" det dem @det #1->3\n"<\u0430\u043B\u0430>"\n\t"\u0430\u043B\u0430" adj @amod #2->3\n"<\u0430\u0442\u0442\u044B>"\n\t"\u0430\u0442\u0442\u044B" adj subst nom @nsubj #3->4\n"<\u043A\u0456\u043C>"\n\t"\u043A\u0456\u043C" prn itg nom @root #4->0\n\t\t"\u0435" cop aor p3 sg @cop #5->4\n"<?>"\n\t"?" sent @punct #6->4',

	0: '"<\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D>"\n\t"\u043F\u0430\u0442\u0448\u0430" n ins @nmod #1->3\n"<\u0441\u043E\u0493\u044B\u0441>"\n\t"\u0441\u043E\u0493\u044B\u0441" n nom @obj #2->3\n"<\u0430\u0448\u049B\u0430\u043D\u0434\u0430>"\n\t"\u0430\u0448" v tv ger_past loc @advcl #3->12\n"<,>"\n\t"," cm @punct #4->12\n"<\u0435\u043B-\u0436\u04B1\u0440\u0442>"\n\t"\u0435\u043B-\u0436\u04B1\u0440\u0442" n nom @conj #5->7\n"<,>"\n\t"," cm @punct #6->7\n"<\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B>"\n\t"\u043E\u0442\u0430\u043D" n px1sg acc @obj #7->8\n"<\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430>"\n\t"\u049B\u043E\u0440\u0493\u0430" v tv ger dat @advcl #8->12\n"<,>"\n\t"," cm @punct #9->12\n"<\u0431\u0456\u0437>"\n\t"\u0431\u0456\u0437" prn pers p1 pl nom @nsubj #10->12\n"<\u0441\u043E\u0493\u044B\u0441\u049B\u0430>"\n\t"\u0441\u043E\u0493\u044B\u0441" n dat @nmod #11->12\n"<\u0431\u0430\u0440\u0434\u044B\u049B>"\n\t"\u0431\u0430\u0440" v iv ifi p1 pl @root #12->0\n"<.>"\n\t"." sent @punct #13->12',

	1: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n"<He>"\n\t"he" det pos f sp @det #1->2\n"<boued>"\n\t"boued" n m sg @obj #2->4\n"<e>"\n\t"e" vpart obj @aux #3->4\n"<tebr>"\n\t"debri\xF1" vblex pri p3 sg @root #4->0\n"<Mona>"\n\t"Mona" np ant f sg @nsubj #5->4\n"<er>"\n\t"e" pr @case #6->8\n\t\t"an" det def sp @det #7->8\n"<gegin>"\n\t"kegin" n f sg @obl #8->4\n"<.>"\n\t"." sent @punct #9->4',

	2: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n"<He>"\n\t"he" det pos f sp @det #1->2\n"<boued>"\n\t"boued" n m sg @obj #2->4\n"<e>"\n\t"e" vpart obj @aux #3->4\n"<tebr>"\n\t"debri\xF1" vblex pri p3 sg @root #4->0\n"<Mona>"\n\t"Mona" np ant f sg @nsubj #5->4\n"<er>"\n\t"e" pr @case #6->8\n\t\t"an" det def sp @det #7->8\n"<gegin>"\n\t"kegin" n f sg @obl #8->4\n\t"kegin" n f pl @obl\n"<.>"\n\t"." sent @punct #9->4', // note: changed line `"kegin" n f pl @obl #8->4`

	with_semicolumn: '\n"<Siedzieli\u015Bmy>"\n\t"siedzie\u0107" vblex impf past p1 m pl\n"<w>"\n\t"w" pr\n"<moim>"\n;   "m\xF3j" prn pos mi sg loc\n"<pokoju>"\n\t"pok\xF3j" n mi sg loc\n"<,>"\n\t"," cm\n"<pal\u0105c>"\n\t"pali\u0107" vblex impf pprs adv\n"<i>"\n\t"i" cnjcoo\n"<rozmawiaj\u0105c>"\n\t"rozmawia\u0107" vblex impf pprs adv\n"<o>"\n\t"o" pr\n"<tem>"\n\t"to" prn dem mi sg loc\n"<,>"\n\t"," cm\n"<jak>"\n\t"jak" rel adv\n"<marni>"\n\t"marny" adj sint mp pl nom\n"<jeste\u015Bmy>"\n\t"by\u0107" vbser pres p1 pl\n"<,>"\n\t"," cm\n"<marni>"\n\t"marny" adj sint mp pl nom\n"<z>"\n\t"z" pr\n"<lekarskiego>"\n\t"lekarski" adj mi sg gen\n"<punktu>"\n\t"punkt" n mi sg gen\n"<widzenia>"\n;   "widzie\u0107" vblex impf ger nt sg gen\n"<chc\u0119>"\n\t"chcie\u0107" vblex impf pres p1 sg\n"<powiedzie\u0107>"\n\t"powiedzie\u0107" vblex perf inf\n"<,>"\n\t"," cm\n"<naturalnie>"\n\t"naturalnie" adv sint\n"<.>"\n\t"." sent',

	simple: '"<\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D>"\n\t"\u043F\u0430\u0442\u0448\u0430" n ins @nmod #1->3\n"<\u0441\u043E\u0493\u044B\u0441>"\n\t"\u0441\u043E\u0493\u044B\u0441" n nom @obj #2->3\n"<\u0430\u0448\u049B\u0430\u043D\u0434\u0430>"\n\t"\u0430\u0448" v tv ger_past loc @advcl #3->12\n"<,>"\n\t"," cm @punct #4->12\n"<\u0435\u043B-\u0436\u04B1\u0440\u0442>"\n\t"\u0435\u043B-\u0436\u04B1\u0440\u0442" n nom @conj #5->7\n"<,>"\n\t"," cm @punct #6->7\n"<\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B>"\n\t"\u043E\u0442\u0430\u043D" n px1sg acc @obj #7->8\n"<\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430>"\n\t"\u049B\u043E\u0440\u0493\u0430" v tv ger dat @advcl #8->12\n"<,>"\n\t"," cm @punct #9->12\n"<\u0431\u0456\u0437>"\n\t"\u0431\u0456\u0437" prn pers p1 pl nom @nsubj #10->12\n"<\u0441\u043E\u0493\u044B\u0441\u049B\u0430>"\n\t"\u0441\u043E\u0493\u044B\u0441" n dat @nmod #11->12\n"<\u0431\u0430\u0440\u0434\u044B\u049B>"\n\t"\u0431\u0430\u0440" v iv ifi p1 pl @root #12->0\n"<.>"\n\t"." sent @punct #13->12',

	simple_with_comments: '# comment #1\n# comment #2\n"<\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D>"\n\t"\u043F\u0430\u0442\u0448\u0430" n ins @nmod #1->3\n"<\u0441\u043E\u0493\u044B\u0441>"\n\t"\u0441\u043E\u0493\u044B\u0441" n nom @obj #2->3\n"<\u0430\u0448\u049B\u0430\u043D\u0434\u0430>"\n\t"\u0430\u0448" v tv ger_past loc @advcl #3->12\n"<,>"\n\t"," cm @punct #4->12\n"<\u0435\u043B-\u0436\u04B1\u0440\u0442>"\n\t"\u0435\u043B-\u0436\u04B1\u0440\u0442" n nom @conj #5->7\n"<,>"\n\t"," cm @punct #6->7\n"<\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B>"\n\t"\u043E\u0442\u0430\u043D" n px1sg acc @obj #7->8\n"<\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430>"\n\t"\u049B\u043E\u0440\u0493\u0430" v tv ger dat @advcl #8->12\n"<,>"\n\t"," cm @punct #9->12\n"<\u0431\u0456\u0437>"\n\t"\u0431\u0456\u0437" prn pers p1 pl nom @nsubj #10->12\n"<\u0441\u043E\u0493\u044B\u0441\u049B\u0430>"\n\t"\u0441\u043E\u0493\u044B\u0441" n dat @nmod #11->12\n"<\u0431\u0430\u0440\u0434\u044B\u049B>"\n\t"\u0431\u0430\u0440" v iv ifi p1 pl @root #12->0\n"<.>"\n\t"." sent @punct #13->12',

	with_spans: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n"<He>"\n\t"he" det pos f sp @det #1->2\n"<boued>"\n\t"boued" n m sg @obj #2->4\n"<e>"\n\t"e" vpart obj @aux #3->4\n"<tebr>"\n\t"debri\xF1" vblex pri p3 sg @root #4->0\n"<Mona>"\n\t"Mona" np ant f sg @nsubj #5->4\n"<er>"\n\t"e" pr @case #6->8\n\t\t"an" det def sp @det #7->8\n"<gegin>"\n\t"kegin" n f sg @obl #8->4\n"<.>"\n\t"." sent @punct #9->4',

	apertium_kaz_1: '# https://bpaste.net/show/be7c03e6213e\n"<\u0427\u0430\u0443>"\n\t"*\u0427\u0430\u0443"\n"<->"\n\t"\u0445" guio\n\t"-" guio\n"<\u0447\u0430\u0443>"\n\t"*\u0447\u0430\u0443"\n"<\u0448\u044B\u0493\u0443>"\n\t"\u0448\u044B\u0493\u0443" n attr\n\t"\u0448\u044B\u049B" v tv ger nom\n\t"\u0448\u044B\u049B" v iv ger nom\n\t"\u0448\u044B\u0493\u0443" n nom\n;\t"\u0448\u044B\u0493\u0443" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u0448\u044B\u0493\u0443" n nom\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n;\t"\u0448\u044B\u049B" vaux ger nom REMOVE:766\n"<\u0442\u0435\u0433\u0456\u043D\u0435\u043D>"\n\t"\u0442\u0435\u043A" n px3sp abl\n;\t"\u0442\u0435\u043A" n px3sp abl\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u0442\u0435\u043A" n px3sp abl\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0448\u043F\u0438\u0446\u0442\u0435\u0440>"\n\t"*\u0448\u043F\u0438\u0446\u0442\u0435\u0440"\n"<\u0442\u043E\u0431\u044B\u043D\u0430>"\n\t"\u0442\u043E\u043F" n px3sp dat\n"<\u0436\u0430\u0442\u0430\u0434\u044B>"\n\t"\u0436\u0430\u0442" v iv aor p3 sg\n;\t"\u0436\u0430\u0442" vaux aor p3 pl REMOVE:766\n;\t"\u0436\u0430\u0442" vaux aor p3 sg REMOVE:766\n;\t"\u0436\u0430\u0442" v iv aor p3 pl REMOVE:846\n"<.>"\n\t"." sent',

	apertium_kaz_2: '# https://bpaste.net/show/be7c03e6213e\n"<\u049A\u0430\u043D\u044B\u043D\u0434\u0430>"\n\t"\u049B\u0430\u043D" n px3sp loc\n;\t"\u049B\u0430\u043D" n px3sp loc\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u049B\u0430\u043D" n px3sp loc\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0442\u0438\u0431\u0435\u0442>"\n\t"*\u0442\u0438\u0431\u0435\u0442"\n"<\u0438\u0442\u0456\u043D\u0456\u04A3>"\n\t"\u0438\u0442" n px3sp gen\n"<(>"\n\t"(" lpar\n"<\u043C\u0430\u0441\u0442\u0438\u0444>"\n\t"*\u043C\u0430\u0441\u0442\u0438\u0444"\n"<)>"\n\t")" rpar\n"<\u049B\u0430\u043D\u044B>"\n\t"\u049B\u0430\u043D" n px3sp nom\n;\t"\u049B\u0430\u043D" n px3sp nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u049B\u0430\u043D" n px3sp nom\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0431\u0430\u0440>"\n\t"\u0431\u0430\u0440" adj SELECT:1118\n\t"\u0431\u0430\u0440" adj subst nom SELECT:1118\n\t\t"\u0435" cop aor p3 sg\n\t"\u0431\u0430\u0440" adj subst nom SELECT:1118\n\t"\u0431\u0430\u0440" adj SELECT:1118\n\t\t"\u0435" cop aor p3 sg\n;\t"\u0431\u0430\u0440" n attr REMOVE:567\n;\t"\u0431\u0430\u0440" adj\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" adj subst nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" n nom SELECT:1118\n;\t"\u0431\u0430\u0440" det qnt SELECT:1118\n;\t"\u0431\u0430\u0440" v iv imp p2 sg SELECT:1118\n;\t"\u0431\u0430\u0440" n nom SELECT:1118\n;\t\t"\u0435" cop aor p3 sg\n"<\u0434\u0435\u0433\u0435\u043D>"\n\t"\u0434\u0435" v tv gpr_past SELECT:813\n\t"\u0434\u0435" v tv gpr_past subst nom SELECT:813\n;\t"\u0434\u0435" v tv ger_past nom SELECT:813\n;\t"\u0434\u0435" v tv past p3 pl SELECT:813\n;\t"\u0434\u0435" v tv past p3 sg SELECT:813\n"<\u0442\u04B1\u0436\u044B\u0440\u044B\u043C>"\n\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n nom\n\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n attr\n;\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:294\n;\t"\u0442\u04B1\u0436\u044B\u0440\u044B\u043C" n nom\n;\t\t"\u0435" cop aor p3 sg REMOVE:294\n"<\u0431\u0430\u0440>"\n\t"\u0431\u0430\u0440" adj\n\t"\u0431\u0430\u0440" n nom\n\t"\u0431\u0430\u0440" adj\n\t\t"\u0435" cop aor p3 sg\n\t"\u0431\u0430\u0440" adj subst nom\n\t\t"\u0435" cop aor p3 sg\n\t"\u0431\u0430\u0440" adj subst nom\n\t"\u0431\u0430\u0440" v iv imp p2 sg\n\t"\u0431\u0430\u0440" n nom\n\t\t"\u0435" cop aor p3 sg\n;\t"\u0431\u0430\u0440" det qnt REMOVE:551\n;\t"\u0431\u0430\u0440" n attr REMOVE:567\n;\t"\u0431\u0430\u0440" adj subst nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" adj\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n;\t"\u0431\u0430\u0440" n nom\n;\t\t"\u0435" cop aor p3 pl REMOVE:853\n"<.>"\n\t"." sent'

};

},{}],362:[function(require,module,exports){
'use strict';

module.exports = {
  labels_1: '# text = "This is a simple sentence."\n# labels = label1 another_label a-third-label\n1\tThis\tThis\t_\t_\t_\t_\t_\t_\t_\n2\tis\tis\t_\t_\t_\t_\t_\t_\t_\n3\ta\ta\t_\t_\t_\t_\t_\t_\t_\n4\tsimple\tsimple\t_\t_\t_\t_\t_\t_\t_\n5\tsentence\tsentence\t_\t_\t_\t_\t_\t_\t_\n6\t.\t.\tPUNCT\tPUNCT\t_\t_\t_\t_\t_',

  labels_2: '# labels = one_label second third-label\n# labels = row_2 again:here this, that\n1\tThis\tThis\t_\t_\t_\t_\t_\t_\t_',

  labels_3: '# tags = this-is-a-tag test testing test\n1\tThis\tThis\t_\t_\t_\t_\t_\t_\t_',

  labels_4: '# labels = new label1 one_label this-is-a-tag\n1\tHullo\thello\t_\t_\t_\t_\t_\t_\t_',

  nested_2: '# text = ab cde f h\n1-2\tab\t_\t_\t_\t_\t_\t_\t_\t_\n1\ta\tA\t_\t_\t_\t_\t_\t_\t_\n2\tb\tB\t_\t_\t_\t_\t_\t_\t_\n3-5\tcde\t_\t_\t_\t_\t_\t_\t_\t_\n3\tc\tC\t_\t_\t_\t_\t_\t_\t_\n4\td\tD\t_\t_\t_\t_\t_\t_\t_\n5\te\tE\t_\t_\t_\t_\t_\t_\t_\n6\tf\tF\t_\t_\t_\t_\t_\t_\t_\n6.1\tsilent_g\tG\t_\t_\t_\t_\t_\t_\t_\n7\th\tH\t_\t_\t_\t_\t_\t_\t_',

  t: '# testing :)\n1-3\tHe\the\tdet\t_\tpos|f|sp\t_\tdet\t_\t_\n1\tboued\tboued\tn\t_\tm|sg\t4\tobj\t_\t_\n2\te\te\tvpart\t_\tobj\t4\taux\t_\t_\n3\ttebr\tdebri\xF1\tvblex\t_\tpri|p3|sg\t0\troot\t_\t_\n4\tdoob\tdoobie\tnp\t_\t_\t3\t_\t_\t_\n5\tMona\tMona\tnp\t_\tant|f|sg\t4\tnsubj\t_\t_',

  empty: '1      Sue       Sue       _       _       _       _       _       _       _\n2      likes     like       _       _       _       _       _       _       _\n3      coffee    coffee       _       _       _       _       _       _       _\n4      and       and       _       _       _       _       _       _       _\n5      Bill      Bill       _       _       _       _       _       _       _\n5.1    likes     like       _       _       _       _       _       _       _\n6      tea       tea       _       _       _       _       _       _       _',

  0: '# sent_id = _\n# text = this is a test\n1\tthis\t_\t_\t_\t_\t_\t_\t_\t_\n2\tis\t_\t_\t_\t_\t_\t_\t_\t_\n3\ta\t_\t_\t_\t_\t_\t_\t_\t_\n4\ttest\t_\t_\t_\t_\t_\t_\t_\t_',

  1: '1\tthis\t_\t_\t_\t_\t_\t_\t_\t_\n2\tis\t_\t_\t_\t_\t_\t_\t_\t_\n3\ta\t_\t_\t_\t_\t_\t_\t_\t_\n4\ttest\t_\t_\t_\t_\t_\t_\t_\t_',

  cat_ancora: '# url = https://raw.githubusercontent.com/UniversalDependencies/UD_Catalan-AnCora/dev/ca_ancora-ud-test.conllu\n# sent_id = test-s1\n# text = El darrer n\xFAmero de l\'Observatori del Mercat de Treball d\'Osona inclou un informe especial sobre la contractaci\xF3 a trav\xE9s de les empreses de treball temporal, les ETT.\n# orig_file_sentence 001#1\n1\tEl\tel\tDET\tDET\tDefinite=Def|Gender=Masc|Number=Sing|PronType=Art\t3\tdet\t_\t_\n2\tdarrer\tdarrer\tADJ\tADJ\tGender=Masc|Number=Sing|NumType=Ord\t3\tamod\t_\t_\n3\tn\xFAmero\tn\xFAmero\tNOUN\tNOUN\tGender=Masc|Number=Sing\t13\tnsubj\t_\t_\n4\tde\tde\tADP\tADP\tAdpType=Prep\t6\tcase\t_\t_\n5\tl\'\tel\tDET\tDET\tDefinite=Def|Number=Sing|PronType=Art\t6\tdet\t_\tSpaceAfter=No\n6\tObservatori\tObservatori\tPROPN\tPROPN\t_\t3\tnmod\t_\tMWE=Observatori_del_Mercat_de_Treball_d\'_Osona|MWEPOS=PROPN\n7\tdel\tdel\tADP\tADP\tAdpType=Preppron|Gender=Masc|Number=Sing\t8\tcase\t_\t_\n8\tMercat\tMercat\tPROPN\tPROPN\t_\t6\tflat\t_\t_\n9\tde\tde\tADP\tADP\tAdpType=Prep\t10\tcase\t_\t_\n10\tTreball\tTreball\tPROPN\tPROPN\t_\t6\tflat\t_\t_\n11\td\'\td\'\tADP\tADP\tAdpType=Prep\t12\tcase\t_\tSpaceAfter=No\n12\tOsona\tOsona\tPROPN\tPROPN\t_\t6\tflat\t_\t_\n13\tinclou\tincloure\tVERB\tVERB\tMood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin\t0\troot\t_\t_\n14\tun\tun\tNUM\tNUM\tGender=Masc|Number=Sing|NumType=Card\t15\tnummod\t_\t_\n15\tinforme\tinforme\tNOUN\tNOUN\tGender=Masc|Number=Sing\t13\tobj\t_\t_\n16\tespecial\tespecial\tADJ\tADJ\tNumber=Sing\t15\tamod\t_\t_\n17\tsobre\tsobre\tADP\tADP\tAdpType=Prep\t19\tcase\t_\t_\n18\tla\tel\tDET\tDET\tDefinite=Def|Gender=Fem|Number=Sing|PronType=Art\t19\tdet\t_\t_\n19\tcontractaci\xF3\tcontractaci\xF3\tNOUN\tNOUN\tGender=Fem|Number=Sing\t15\tnmod\t_\t_\n20\ta\ta\tADP\tADP\tAdpType=Prep\t24\tcase\t_\tMWE=a_trav\xE9s_de|MWEPOS=ADP\n21\ttrav\xE9s\ttrav\xE9s\tNOUN\tNOUN\t_\t20\tfixed\t_\t_\n22\tde\tde\tADP\tADP\tAdpType=Prep\t20\tfixed\t_\t_\n23\tles\tel\tDET\tDET\tDefinite=Def|Gender=Fem|Number=Plur|PronType=Art\t24\tdet\t_\t_\n24\tempreses\tempresa\tNOUN\tNOUN\tGender=Fem|Number=Plur\t19\tnmod\t_\t_\n25\tde\tde\tADP\tADP\tAdpType=Prep\t26\tcase\t_\t_\n26\ttreball\ttreball\tNOUN\tNOUN\tGender=Masc|Number=Sing\t24\tnmod\t_\t_\n27\ttemporal\ttemporal\tADJ\tADJ\tNumber=Sing\t26\tamod\t_\tSpaceAfter=No\n28\t,\t,\tPUNCT\tPUNCT\tPunctType=Comm\t30\tpunct\t_\t_\n29\tles\tel\tDET\tDET\tDefinite=Def|Gender=Fem|Number=Plur|PronType=Art\t30\tdet\t_\t_\n30\tETT\tETT\tPROPN\tPROPN\t_\t24\tappos\t_\tSpaceAfter=No\n31\t.\t.\tPUNCT\tPUNCT\tPunctType=Peri\t13\tpunct\t_\t_',

  with_tabs: '# sent_id = chapID01:paragID1:sentID1\n# text = \u041A\u0435\u0447\u0430\u0435\u043D\u044C \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F \u043A\u0430\u0440\u0432\u043E\u0442 .\n# text[eng] = Kechai was awoken by annoying flies.\n1\t\u041A\u0435\u0447\u0430\u0435\u043D\u044C\t\u041A\u0435\u0447\u0430\u0439\tN\tN\tSem/Ant_Mal|Prop|SP|Gen|Indef\t2\tobj\t_\t\u041A\u0435\u0447\u0430\u0435\u043D\u044C\n2\t\u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C\t\u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0435\u043C\u0441\tV\tV\tTV|Ind|Prt1|ScPl3|OcSg3\t0\troot\t_\t\u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C\n3\t\u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F\t\u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u043E\u043C\u0441\tPRC\tPrc\tV|TV|PrcPrsL|Sg|Nom|Indef\t4\tamod\t\u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F\t_\n4\t\u043A\u0430\u0440\u0432\u043E\u0442\t\u043A\u0430\u0440\u0432\u043E\tN\tN\tSem/Ani|N|Pl|Nom|Indef\t2\tnsubj\t_\t\u043A\u0430\u0440\u0432\u043E\u0442\n5\t.\t.\tCLB\tCLB\tCLB\t2\tpunct\t_\t.',

  without_tabs: '# sent_id = chapID01:paragID1:sentID1\n# text = \u041A\u0435\u0447\u0430\u0435\u043D\u044C \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F \u043A\u0430\u0440\u0432\u043E\u0442 .\n# text[eng] = Kechai was awoken by annoying flies.\n1 \u041A\u0435\u0447\u0430\u0435\u043D\u044C \u041A\u0435\u0447\u0430\u0439 N N Sem/Ant_Mal|Prop|SP|Gen|Indef 2 obj _ \u041A\u0435\u0447\u0430\u0435\u043D\u044C\n2 \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0435\u043C\u0441 V V TV|Ind|Prt1|ScPl3|OcSg3 0 root _ \u0441\u044B\u0440\u0433\u043E\u0437\u0442\u0438\u0437\u044C\n3 \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u043E\u043C\u0441 PRC Prc V|TV|PrcPrsL|Sg|Nom|Indef 4 amod \u043D\u0430\u043B\u043A\u0441\u0442\u0430\u0432\u0442\u044B\u0446\u044F\t_\n4 \u043A\u0430\u0440\u0432\u043E\u0442 \u043A\u0430\u0440\u0432\u043E N N Sem/Ani|N|Pl|Nom|Indef 2 nsubj _ \u043A\u0430\u0440\u0432\u043E\u0442\n5 . . CLB CLB CLB 2 punct _ .',

  from_cg3_with_semicolumn: '1\tSiedzieli\u015Bmy\tsiedzie\u0107\tvblex\t_\timpf|past|p1|m|pl\t_\t_\t_\t_\n2\tw\tw\tpr\t_\t_\t_\t_\t_\t_\n3\tmoim\tm\xF3j\tprn\t_\tpos|mi|sg|loc\t_\t_\t_\t_\n4\tpokoju\tpok\xF3j\tn\t_\tmi|sg|loc\t_\t_\t_\t_\n5\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n6\tpal\u0105c\tpali\u0107\tvblex\t_\timpf|pprs|adv\t_\t_\t_\t_\n7\ti\ti\tcnjcoo\t_\t_\t_\t_\t_\t_\n8\trozmawiaj\u0105c\trozmawia\u0107\tvblex\t_\timpf|pprs|adv\t_\t_\t_\t_\n9\to\to\tpr\t_\t_\t_\t_\t_\t_\n10\ttem\tto\tprn\t_\tdem|mi|sg|loc\t_\t_\t_\t_\n11\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n12\tjak\tjak\trel\t_\tadv\t_\t_\t_\t_\n13\tmarni\tmarny\tadj\t_\tsint|mp|pl|nom\t_\t_\t_\t_\n14\tjeste\u015Bmy\tby\u0107\tvbser\t_\tpres|p1|pl\t_\t_\t_\t_\n15\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n16\tmarni\tmarny\tadj\t_\tsint|mp|pl|nom\t_\t_\t_\t_\n17\tz\tz\tpr\t_\t_\t_\t_\t_\t_\n18\tlekarskiego\tlekarski\tadj\t_\tmi|sg|gen\t_\t_\t_\t_\n19\tpunktu\tpunkt\tn\t_\tmi|sg|gen\t_\t_\t_\t_\n20\twidzenia\twidzie\u0107\tvblex\t_\timpf|ger|nt|sg|gen\t_\t_\t_\t_\n21\tchc\u0119\tchcie\u0107\tvblex\t_\timpf|pres|p1|sg\t_\t_\t_\t_\n22\tpowiedzie\u0107\tpowiedzie\u0107\tvblex\t_\tperf|inf\t_\t_\t_\t_\n23\t,\t,\tcm\t_\t_\t_\t_\t_\t_\n24\tnaturalnie\tnaturalnie\tadv\t_\tsint\t_\t_\t_\t_\n25\t.\t.\tsent\t_\t_\t_\t_\t_\t_',

  from_cg3_simple: '1\t\u041F\u0430\u0442\u0448\u0430\u043C\u0435\u043D\t\u043F\u0430\u0442\u0448\u0430\tn\t_\tins\t3\tnmod\t_\t_\n2\t\u0441\u043E\u0493\u044B\u0441\t\u0441\u043E\u0493\u044B\u0441\tn\t_\tnom\t3\tobj\t_\t_\n3\t\u0430\u0448\u049B\u0430\u043D\u0434\u0430\t\u0430\u0448\tv\t_\ttv|ger_past|loc\t12\tadvcl\t_\t_\n4\t,\t,\tcm\t_\t_\t12\tpunct\t_\t_\n5\t\u0435\u043B-\u0436\u04B1\u0440\u0442\t\u0435\u043B-\u0436\u04B1\u0440\u0442\tn\t_\tnom\t7\tconj\t_\t_\n6\t,\t,\tcm\t_\t_\t7\tpunct\t_\t_\n7\t\u043E\u0442\u0430\u043D\u044B\u043C\u0434\u044B\t\u043E\u0442\u0430\u043D\tn\t_\tpx1sg|acc\t8\tobj\t_\t_\n8\t\u049B\u043E\u0440\u0493\u0430\u0443\u0493\u0430\t\u049B\u043E\u0440\u0493\u0430\tv\t_\ttv|ger|dat\t12\tadvcl\t_\t_\n9\t,\t,\tcm\t_\t_\t12\tpunct\t_\t_\n10\t\u0431\u0456\u0437\t\u0431\u0456\u0437\tprn\t_\tpers|p1|pl|nom\t12\tnsubj\t_\t_\n11\t\u0441\u043E\u0493\u044B\u0441\u049B\u0430\t\u0441\u043E\u0493\u044B\u0441\tn\t_\tdat\t12\tnmod\t_\t_\n12\t\u0431\u0430\u0440\u0434\u044B\u049B\t\u0431\u0430\u0440\tv\t_\tiv|ifi|p1|pl\t0\troot\t_\t_\n13\t.\t.\tsent\t_\t_\t12\tpunct\t_\t_\n',

  from_cg3_with_spans: '# text = He boued e tebr Mona er gegin.\n# text[eng] = Mona eats her food here in the kitchen.\n# labels = press_1986 ch_syntax p_197 to_check\n1\tHe\the\tdet\t_\tpos|f|sp\t2\tdet\t_\t_\n2\tboued\tboued\tn\t_\tm|sg\t4\tobj\t_\t_\n3\te\te\tvpart\t_\tobj\t4\taux\t_\t_\n4\ttebr\tdebri\xF1\tvblex\t_\tpri|p3|sg\t0\troot\t_\t_\n5\tMona\tMona\tnp\t_\tant|f|sg\t4\tnsubj\t_\t_\n6-7\ter\t_\t_\t_\t_\t_\t_\t_\t_\n6\t_\te\tpr\t_\t_\t8\tcase\t_\t_\n7\t_\tan\tdet\t_\tdef|sp\t8\tdet\t_\t_\n8\tgegin\tkegin\tn\t_\tf|sg\t4\tobl\t_\t_\n9\t.\t.\tsent\t_\t_\t4\tpunct\t_\t_\n',

  rueter_long: '# sent_id = BryzhinskijMixail_Kirdazht_manu:3859\n# text = \u041D\u043E \u0437\u044F\u0440\u0441 \u0432\u0430\u043B\u0433\u0441\u044C , \u0437\u044F\u0440\u0441 \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044C \u0434\u044B \u043C\u0435\u043A\u0435\u0432 \u043F\u0430\u0440\u0441\u0442\u0435 \u043F\u0435\u043A\u0441\u0442\u043D\u0435\u0441\u044C \u0432\u0435\u043B\u0435 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C , \u043A\u0443\u0436\u043E \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C , \u043A\u0443\u0440\u043E \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u0434\u044B \u044D\u0441\u0435\u0441\u0442 \u044E\u0440\u0442\u0441 \u0441\u043E\u0432\u0430\u043C\u043E \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u044D\u0440\u044C\u0432\u0430 \u043B\u0438\u0441\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C \u0441\u043E\u0432\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C \u0442\u0435 \u0441\u0432\u0430\u043B \u0442\u0435\u0439\u043D\u0435\u043C\u0430 , \u043A\u0435\u043D\u043A\u0448\u0442\u043D\u0435 \u0441\u0432\u0430\u043B \u043F\u0435\u043A\u0441\u0442\u0430\u0437\u044C \u0443\u043B\u0435\u0437\u0442 ; \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044B\u0437\u044C \u043A\u0435\u043B\u0435\u0441 \u0430\u043D\u0441\u044F\u043A \u0432\u0430\u043B\u0441\u043A\u0435 \u043C\u0430\u0440\u0442\u043E \u0434\u044B \u0447\u043E\u043F\u043E\u043D\u044C\u0431\u0435\u043B\u0435\u0432 \u2014 \u0440\u0430\u043A\u0448\u0430\u043D\u044C \u043B\u0438\u0432\u0442\u0435\u043C\u0430 \u0441\u043E\u0432\u0430\u0432\u0442\u043E\u043C\u0430 \u0448\u043A\u0430\u043D\u0435 , \u043A\u0443\u0439\u043C\u0435\u0441\u044C \u0442\u0430\u0433\u043E \u0441\u0442\u0430\u043A\u0430\u043B\u0433\u0430\u0434\u0441\u044C .\n# text_en = But by the time he got down the hill, opened and closed the village gate, the lane gate, the cluster gate and the one to their own home (something everyone coming or going had to do, so the gates would always be closed; they were only opened in the morning and at dusk for taking out and letting in the cattle), the wicker of clay had grown heavy again.\n# text_fi = Kun Ket\u0161ai tuli m\xE4elt\xE4 alas, avasi ja sulki huolellisesti kyl\xE4ver\xE4j\xE4ns\xE4, ??aukio/kentt\xE4ver\xE4j\xE4n, kujaver\xE4j\xE4n ja oman kotiver\xE4j\xE4n, savikontti ehti taas alkaa painaa h\xE4nen selk\xE4\xE4ns\xE4. (Kaikkien k\xE4vij\xF6iden tulee tehd\xE4 n\xE4in, jotta ver\xE4j\xE4t olisivat aina kiinni, ver\xE4j\xE4th\xE4n pidet\xE4\xE4n selkosen sel\xE4ll\xE4\xE4n vain aamulla ja illansuussa, kun karjaa ajetaan laitumelle tai kotiin.)\n1 \u041D\u043E \u043D\u043E CCONJ CC _ 3 cc _ _\n2 \u0437\u044F\u0440\u0441 \u0437\u044F\u0440\u0441 ADV Adv|Der/Ill|Adv|Sem/Time Derivation=Ill|AdvType=Tim 3 mark _ _\n3 \u0432\u0430\u043B\u0433\u0441\u044C \u0432\u0430\u043B\u0433\u043E\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 51 advcl _ SpaceAfter=No\n4 , , PUNCT CLB _ 6 punct _ _\n5 \u0437\u044F\u0440\u0441 \u0437\u044F\u0440\u0441 ADV Adv|Der/Ill|Adv|Sem/Time Derivation=Ill|AdvType=Tim 6 mark _ _\n6 \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044C \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 3 conj _ _\n7 \u0434\u044B \u0434\u044B CCONJ CC _ 10 cc _ _\n8 \u043C\u0435\u043A\u0435\u0432 \u043C\u0435\u043A\u0435\u0432 ADV Adv|Lat|Sg|Nom|Indef Case=Lat|Case=Nom|Definite=Ind|Number=Sing 10 advmod _ _\n9 \u043F\u0430\u0440\u0441\u0442\u0435 \u043F\u0430\u0440\u0441\u0442\u0435 ADV Adv|Manner AdvType=Man 10 advmod _ _\n10 \u043F\u0435\u043A\u0441\u0442\u043D\u0435\u0441\u044C \u043F\u0435\u043A\u0441\u0442\u043D\u0435\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 3 conj _ _\n11 \u0432\u0435\u043B\u0435 \u0432\u0435\u043B\u0435 NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 10 obj _ _\n12 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 11 goeswith _ SpaceAfter=No\n13 , , PUNCT CLB _ 15 punct _ _\n14 \u043A\u0443\u0436\u043E \u043A\u0443\u0436\u043E NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 12 conj _ _\n15 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 14 goeswith _ SpaceAfter=No\n16 , , PUNCT CLB _ 18 punct _ _\n17 \u043A\u0443\u0440\u043E \u043A\u0443\u0440\u043E NOUN N|Sem/Inanim_Cnt|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 12 conj _ _\n18 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 17 goeswith _ _\n19 \u0434\u044B \u0434\u044B CCONJ CC _ 23 cc _ _\n20 \u044D\u0441\u0435\u0441\u0442 \u044D\u0441\u044C PRON Pron|Refl|Pl3|Gen|Variant=Short Case=Gen|Number=Plur|Person=3|PronType=Refl|Variant=Short 22 nmod _ _\n21 \u044E\u0440\u0442\u0441 \u044E\u0440\u0442 NOUN N|Sem/Inanim_Cnt|SP|Ill|Indef Case=Ill|Definite=Ind|Number=Plur,Sing 20 case _ _\n22 \u0441\u043E\u0432\u0430\u043C\u043E \u0441\u043E\u0432\u0430\u043C\u043E NOUN N|IV|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing|Valency=1 23 compound _ _\n23 \u043A\u0435\u043D\u043A\u0448\u0435\u043D\u0442\u044C \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Sg|Gen|Def Case=Gen|Definite=Def|Number=Sing 12 conj _ _\n24 ( ( PUNCT PUNCT _ 29 punct _ SpaceAfter=No\n25 \u044D\u0440\u044C\u0432\u0430 \u044D\u0440\u044C\u0432\u0430 DET Det|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 26 det _ _\n26 \u043B\u0438\u0441\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C-\u0441\u043E\u0432\u0438\u0446\u044F\u043D\u0442\u0435\u043D\u044C \u043B\u0438\u0441\u0438\u0446\u044F\u0442-\u0441\u043E\u0432\u0438\u0446\u044F\u0442 NOUN N|V|NomAg|Sg|Dat|Def Case=Dat|Definite=Def|Derivation=NomAg|Number=Sing 29 obl _ _\n27 \u0442\u0435 \u0442\u0435 PRON Pron|Dem|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing|PronType=Dem 29 nsubj _ _\n28 \u0441\u0432\u0430\u043B \u0441\u0432\u0430\u043B ADV Adv|Tot|Sem/Time_dur PronType=Tot|PronType=Tot 29 advmod _ _\n29 \u0442\u0435\u0439\u043D\u0435\u043C\u0430 \u0442\u0435\u0439\u043D\u0435\u043Cc VERB V|TV|Oblig|Clitic=Cop|Prs|ScSg3 Valency=2|VerbForm=Oblig|Clitic=Cop|Number[subj]=Sing|Person[subj]=3|Tense=Pres 3 parataxis _ SpaceAfter=No\n30 , , PUNCT CLB _ 33 punct _ _\n31 \u043A\u0435\u043D\u043A\u0448\u0442\u043D\u0435 \u043A\u0435\u043D\u043A\u0448 NOUN N|Sem/Inanim_Cnt|Pl|Nom|Def Case=Nom|Definite=Def|Number=Plur 34 nsubj _ _\n32 \u0441\u0432\u0430\u043B \u0441\u0432\u0430\u043B ADV Adv|Tot|Sem/Time_dur PronType=Tot|PronType=Tot 33 advmod _ _\n33 \u043F\u0435\u043A\u0441\u0442\u0430\u0437\u044C \u043F\u0435\u043A\u0441\u0442\u0430\u043C\u0441 VERB V|Der/\u041E\u0437\u044C|Ger Derivation=Ozj|VerbForm=Conv 29 ccomp _ _\n34 \u0443\u043B\u0435\u0437\u0442 \u0443\u043B\u0435\u043C\u0441 AUX V|IV|Opt|ScPl3 Mood=Opt|Number[subj]=Plur|Person[subj]=3|Valency=1 33 cop _ SpaceAfter=No\n35 ; ; PUNCT CLB _ 29 punct _ _\n36 \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u0441\u044B\u0437\u044C \u043F\u0430\u043D\u0436\u0442\u043D\u0435\u043C\u0441 VERB V|Ind|Prs|ScPl3|Obj3 Mood=Ind|Number[subj]=Plur|Person[subj]=3|Tense=Pres|Obj3 29 conj _ _\n37 \u043A\u0435\u043B\u0435\u0441 \u043A\u0435\u043B\u0435\u0441 ADV Adv Adv 36 advmod _ _\n38 \u0430\u043D\u0441\u044F\u043A \u0430\u043D\u0441\u044F\u043A ADV Adv Adv 39 advmod _ _\n39 \u0432\u0430\u043B\u0441\u043A\u0435 \u0432\u0430\u043B\u0441\u043A\u0435 NOUN N|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 36 obl _ _\n40 \u043C\u0430\u0440\u0442\u043E \u043C\u0430\u0440\u0442\u043E ADP Adp|Po AdpType=Post 39 case _ _\n41 \u0434\u044B \u0434\u044B CCONJ CC _ 42 cc _ _\n42 \u0447\u043E\u043F\u043E\u043D\u044C\u0431\u0435\u043B\u0435\u0432 \u0447\u043E\u043F\u043E\u043D\u044C\u0431\u0435\u043B\u0435\u0432 ADV Adv|Lat Case=Lat 39 conj _ _\n43 \u2014 \u2014 PUNCT CLB _ 46 punct _ _\n44 \u0440\u0430\u043A\u0448\u0430\u043D\u044C \u0440\u0430\u043A\u0448\u0430 NOUN N|Sem/Anim_Cnt|SP|Gen|Indef Case=Gen|Definite=Ind|Number=Plur,Sing 45 nmod:gobj _ _\n45 \u043B\u0438\u0432\u0442\u0435\u043C\u0430-\u0441\u043E\u0432\u0430\u0432\u0442\u043E\u043C\u0430 \u043B\u0438\u0432\u0442\u0435\u043C\u0430-\u0441\u043E\u0432\u0430\u0432\u0442\u043E\u043C\u0430 NOUN N|Sg|Nom|Indef Case=Nom|Definite=Ind|Number=Sing 36 nmod _ _\n46 \u0448\u043A\u0430\u043D\u0435 \u0448\u043A\u0430 NOUN N|Sem/Time|SP|Temp|Indef Case=Temp|Definite=Ind|Number=Plur,Sing 39 conj _ SpaceAfter=No\n47 ) ) PUNCT PUNCT _ 29 punct _ SpaceAfter=No\n48 , , PUNCT CLB _ 29 punct _ _\n49 \u043A\u0443\u0439\u043C\u0435\u0441\u044C \u043A\u0443\u0439\u043C\u0435 NOUN N|Sem/Inanim_Cnt|Sg|Nom|Def Case=Nom|Definite=Def|Number=Sing 51 nsubj _ _\n50 \u0442\u0430\u0433\u043E \u0442\u0430\u0433\u043E ADV Adv|Sem/Time AdvType=Tim 51 advmod _ _\n51 \u0441\u0442\u0430\u043A\u0430\u043B\u0433\u0430\u0434\u0441\u044C \u0441\u0442\u0430\u043A\u0430\u043B\u0433\u0430\u0434\u043E\u043C\u0441 VERB V|Ind|Prt1|ScSg3 Mood=Ind|Number[subj]=Sing|Person[subj]=3|Tense=Prt1 0 root _ SpaceAfter=No\n52 . . PUNCT CLB _ 51 punct _ _',

  katya_aplonova_large_arrows: '# sent_id = html/meyer_gorog-contes_bambara_10amadu_tara.dis.html:16\n# text = ko ni i sera ka jiri nin bulu s\xF2r\xF2 ka na ni a ye, ko c\xE8k\xF2r\xF2ba b\xE8 se ka furak\xE8 o la.\n1\tko\tk\xF3\tPART\tcop\t_\t4\tdiscourse\t_\tGloss=QUOT\n2\tni\tn\xED\tSCONJ\tconj\t_\t4\tmark\t_\tGloss=si\n3\ti\t\xED\tPRON\tpers\tPronType=Prs\t4\tnsubj\t_\tGloss=2.SG\n4\tsera\tsera\tVERB\tv\tAspect=Perf|Valency=1|Polarity=Pos\t19\tadvcl\t_\tGloss=arriver|Morf=arriver,PFV.INTR\n5\tka\tk\xE0\tAUX\tpm\t_\t9\taux\t_\tGloss=INF\n6\tjiri\tj\xEDri\tNOUN\tn\t_\t8\tnmod:poss\t_\tGloss=arbre\n7\tnin\tn\xECn\tDET\tprn/dtm\tPronType=Dem|Definite-Def\t6\tdet\t_\tGloss=DEM\n8\tbulu\tb\xFAlu\tNOUN\tn\t_\t9\tobj\t_\tGloss=feuille\n9\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tVERB\tv\t_\t4\txcomp\t_\tGloss=obtenir\n10\tka\tk\xE0\tAUX\tpm\t_\t11\taux\t_\tGloss=INF\n11\tna\tn\xE0\tVERB\tv\t_\t9\txcomp\t_\tGloss=venir\n12\tni\tn\xED\tADP\tconj/prep\t_\t13\tcase\t_\tGloss=et\n13\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t11\tobl\t_\tGloss=3SG\n14\tye\ty\xE9\tADP\tpp\t_\t13\tcase\t_\tGloss=PP\n15\t,\t,\tPUNCT\t_\t_\t4\tpunct\t_\tGloss=,\n16\tko\tk\xF3\tPART\tcop\t_\t19\tdiscourse\t_\tGloss=QUOT\n17\tc\xE8k\xF2r\xF2ba\tc\u025B\u0300.k\u0254r\u0254.ba\tNOUN\tn\t_\t19\tnsubj\t_\tGloss=vieillard|Morf=vieillard,m\xE2le,vieux,AUGM\n18\tb\xE8\tb\u025B\u0301\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t19\taux\t_\tGloss=IPFV.AFF\n19\tse\ts\xE9\tVERB\tv\t_\t0\troot\t_\tGloss=arriver\n20\tka\tk\xE0\tAUX\tpm\t_\t21\taux\t_\tGloss=INF\n21\tfurak\xE8\tf\xFAra.k\u025B\tVERB\tv\t_\t19\txcomp\t_\tGloss=soigner|Morf=soigner,feuille,faire\n22\to\t\xF2\tPRON\tprn\t_\t21\tobl\t_\tGloss=ce\n23\tla\tl\xE1\tADP\tpp\t_\t22\tcase\t_\tGloss=dans\n24\t.\t.\tPUNCT\t_\t_\t19\tpunct\t_\tGloss=.\n',

  katya_aplonova_long: '# sent_id = html/meyer_gorog-contes_bambara_10amadu_tara.dis.html:19\n# text = ko u ye m\xF2g\xF2 nyini a ye, min b\xE8 a furak\xE8 sisan ko c\xE8 ye furak\xE8li cogoya b\xE8\xE8 f\xF2, ko fura nin s\xF2r\xF2 ka g\xE8l\xE8n ko epi ko ni o ye a s\xF2r\xF2 u ye ale den de ye, ni min b\xE8 sa de furanyini f\xE8 a ka sa nin min b\xE8 balo o ka balo ko u k\xF2n\xF2nt\xF2 b\xE8\xE8 ka taga fura nin nyini, ko u k\xF2n\xF2nt\xF2 b\xE8\xE8 ka taga ko nin min seginna ka a s\xF2r\xF2 fura ma na, ko a b\xE8 o den nin haramuya ka o g\xE8n, ka a b\xE8 a ba fana g\xE8n ko u ka a fil\xE8 u y\xE8r\xE8 ni min ma s\xF2n fana ko a b\xE8 o g\xE8n, o ni a ba b\xE8\xE8.\n# label = too_long_to_cut\n1\tko\tk\xF3\tPART\tcop\t_\t5\tdiscourse\t_\tGloss=QUOT\n2\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t5\tnsubj\t_\tGloss=3PL\n3\tye\ty\xE9\tAUX\tpm\tAspect=Perf|Valency=2|Polarity=Pos\t5\taux\t_\tGloss=PFV.TR\n4\tm\xF2g\xF2\tm\u0254\u0300g\u0254\tNOUN\tn\t_\t5\tobj\t_\tGloss=homme\n5\tnyini\t\u0272\xEDni\tVERB\tv\t_\t0\troot\t_\tGloss=chercher\n6\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t5\tobl\t_\tGloss=3SG\n7\tye\ty\xE9\tADP\tpp\t_\t6\tcase\t_\tGloss=PP\n8\t,\t,\tPUNCT\t_\t_\t5\tpunct\t_\tGloss=,\n9\tmin\tm\xEDn\tPRON\tprn\tPronType=Rel\t_\t_\t_\tGloss=REL\n10\tb\xE8\tb\u025B\u0301\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n11\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n12\tfurak\xE8\tf\xFAra.k\u025B\tVERB\tv\t_\t_\t_\t_\tGloss=soigner|Morf=soigner,feuille,faire\n13\tsisan\ts\xEDsan\tADV\tadv/n\t_\t_\t_\t_\tGloss=maintenant\n14\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n15\tc\xE8\tc\u025B\u0300\tNOUN\tn\t_\t_\t_\t_\tGloss=m\xE2le\n16\tye\tye\tAUX\tpm\tAspect=Perf|Valency=2|Polarity=Pos\t_\t_\t_\tGloss=PFV.TR\n17\tfurak\xE8li\tf\xFArak\u025Bli\tNOUN\tn\tVerbalForm=Vnoun\t_\t_\t_\tGloss=traitement|Morf=traitement,feuille,faire,NMLZ\n18\tcogoya\tc\xF3goya\tNOUN\tn\t_\t_\t_\t_\tGloss=mani\xE8re|Morf=mani\xE8re,mani\xE8re,ABSTR\n19\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n20\tf\xF2\tf\u0254\u0301\tVERB\tv\t_\t_\t_\t_\tGloss=dire\n21\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n22\tko\tk\xF3\tPART\tcop\t_\t27\tdiscourse\t_\tGloss=QUOT\n23\tfura\tf\xFAra\tNOUN\tn\t_\t25\tnmod:poss\t_\tGloss=feuille\n24\tnin\tn\xECn\tDET\tdtm\tPronType=Dem|Definite-Def\t23\tdet\t_\tGloss=DEM\n25\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tNOUN\tv\t_\t27\tnsubj\t_\tGloss=obtenir\n26\tka\tka\tAUX\tpm\tPolarity=Pos\t27\taux\t_\tGloss=QUAL.AFF\n27\tg\xE8l\xE8n\tg\u025B\u0300l\u025Bn\tVERB\tvq\t_\t_\t_\t_\tGloss=dur\n28\tko\tk\xF3\tPART\tcop\t_\t29\tdiscourse\t_\tGloss=QUOT\n29\tepi\tepi\tCCONJ\tconj\t_\t27\tcc\t_\tGloss=ETRG.FRA\n30\tko\tk\xF3\tVERB\tcop\t_\t37\tdiscourse\t_\tGloss=QUOT\n31\tni\tn\xED\tSCONJ\tconj\t_\t35\tmark\t_\tGloss=si\n32\to\t\xF2\tPRON\tprn\t_\t35\tnsubj\t_\tGloss=ce\n33\tye\tye\tAUX\tpm\tAspect=Perf|Valency=2|Polarity=Pos\t35\taux\t_\tGloss=PFV.TR\n34\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t35\tobj\t_\tGloss=3SG\n35\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tVERB\tv\t_\t37\tadvcl\t_\tGloss=obtenir\n36\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t37\tnsubj\t_\tGloss=3PL\n37\tye\ty\xE9\tVERB\tcop\tPolarity=Pos\t27\tparataxis\t_\tGloss=EQU\n38\tale\t\xE0l\xEA\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3|PronType=Emp\t39\tnmod:poss\t_\tGloss=3SG.EMPH\n39\tden\td\xE9n\tNOUN\tn\t_\t37\tobl\t_\tGloss=enfant\n40\tde\td\xE8\tPART\tprt\t_\t39\tdiscourse\t_\tGloss=FOC\n41\tye\ty\xE9\tADP\tpp\t_\t39\tcase\t_\tGloss=PP\n42\t,\t,\tPUNCT\t_\t_\t37\tpunct\t_\tGloss=,\n43\tni\tn\xED\tSCONJ\tconj\t_\t46\tmark\t_\tGloss=si\n44\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t46\t_\t_\tGloss=REL\n45\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t46\t_\t_\tGloss=IPFV.AFF\n46\tsa\ts\xE0\tVERB\tv\t_\t52\t_\t_\tGloss=mourir\n47\tde\td\xE8\tPART\tprt\t_\t46\t_\t_\tGloss=FOC\n48\tfuranyini\tfura\u0272ini\tNOUN\tn\t_\t46\t_\t_\tGloss=feuille|Morf=feuille,chercher\n49\tf\xE8\tf\u025B\u0300\tADP\tpp\t_\t48\t_\t_\tGloss=par\n50\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t52\t_\t_\tGloss=3SG\n51\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t52\t_\t_\tGloss=SBJV\n52\tsa\ts\xE0\tVERB\tv\t_\t37\t_\t_\tGloss=mourir\n53\tnin\tn\xED\tSCONJ\tconj\t_\t56\tmark\t_\tGloss=quand\n54\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t56\t_\t_\tGloss=REL\n55\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t56\t_\t_\tGloss=IPFV.AFF\n56\tbalo\tb\xE1lo\tVERB\tv\t_\t59\t_\t_\tGloss=vivre\n57\to\t\xF2\tPRON\tprn\t_\t59\t_\t_\tGloss=ce\n58\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t59\t_\t_\tGloss=SBJV\n59\tbalo\tb\xE1lo\tVERB\tv\t_\t52\t_\t_\tGloss=vivre\n60\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n61\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n62\tk\xF2n\xF2nt\xF2\tk\u0254\u0300n\u0254nt\u0254n\tNUM\tnum\t_\t_\t_\t_\tGloss=neuf\n63\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n64\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t_\t_\t_\tGloss=SBJV\n65\ttaga\tt\xE1ga\tVERB\tv\t_\t59\t_\t_\tGloss=aller\n66\tfura\tf\xFAra\tNOUN\tn\t_\t_\t_\t_\tGloss=feuille\n67\tnin\tn\xECn\tDET\tdtm\tPronType=Dem|Definite-Def\t_\t_\t_\tGloss=DEM\n68\tnyini\t\u0272\xEDni\tVERB\tv\t_\t_\t_\t_\tGloss=chercher\n69\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n70\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n71\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n72\tk\xF2n\xF2nt\xF2\tk\u0254\u0300n\u0254nt\u0254n\tNUM\tnum\t_\t_\t_\t_\tGloss=neuf\n73\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n74\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t_\t_\t_\tGloss=SBJV\n75\ttaga\tt\xE1ga\tVERB\tv\t_\t65\t_\t_\tGloss=aller\n76\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n77\tnin\tn\xED\tSCONJ\tconj\t_\t_\t_\t_\tGloss=quand\n78\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t_\t_\t_\tGloss=REL\n79\tseginna\tseginna\tVERB\tv\tAspect=Perf|Valency=1|Polarity=Pos\t85\t_\t_\tGloss=revenir|Morf=revenir,PFV.INTR\n80\tka\tk\xE0\tAUX\tpm\t_\t_\t_\t_\tGloss=INF\n81\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n82\ts\xF2r\xF2\ts\u0254\u0300r\u0254\tVERB\tv\t_\t_\t_\t_\tGloss=obtenir\n83\tfura\tf\xFAra\tNOUN\tn\t_\t_\t_\t_\tGloss=feuille\n84\tma\tma\tAUX\tpm\tPolarity=Neg|Aspect=Perf\t_\t_\t_\tGloss=PFV.NEG\n85\tna\tn\xE0\tVERB\tv\t_\t75\t_\t_\tGloss=venir\n86\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n87\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n88\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n89\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n90\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n91\tden\td\xE9n\tNOUN\tn\t_\t_\t_\t_\tGloss=enfant\n92\tnin\tn\xECn\tDET\tdtm\tPronType=Dem|Definite-Def\t_\t_\t_\tGloss=DEM\n93\tharamuya\th\xE0ramuya\tVERB\tv\t_\t85\t_\t_\tGloss=interdire|Morf=interdire,interdire,ABSTR\n94\tka\tk\xE0\tAUX\tpm\t_\t_\t_\t_\tGloss=INF\n95\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n96\tg\xE8n\tg\u025B\u0301n\tVERB\tv\t_\t_\t_\t_\tGloss=chasser\n97\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n98\tka\tk\xE0\tAUX\tpm\t_\t_\t_\t_\tGloss=INF\n99\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n100\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n101\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n102\tba\tb\xE1\tNOUN\tn\t_\t_\t_\t_\tGloss=m\xE8re\n103\tfana\tf\xE1na\tPART\tprt\t_\t_\t_\t_\tGloss=aussi\n104\tg\xE8n\tg\u025B\u0301n\tVERB\tv\t_\t_\t_\t_\tGloss=chasser\n105\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n106\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n107\tka\tka\tAUX\tpm\tMood=Subj|Polarity=Aff\t_\t_\t_\tGloss=SBJV\n108\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n109\tfil\xE8\tf\xEDl\u025B\tVERB\tv\t_\t_\t_\t_\tGloss=regarder\n110\tu\t\xF9\tPRON\tpers\tPronType=Prs|Number=Plur|Person=3\t_\t_\t_\tGloss=3PL\n111\ty\xE8r\xE8\ty\u025B\u0300r\u025B\u0302\tDET\tdtm\t_\t_\t_\t_\tGloss=m\xEAme\n112\tni\tn\xED\tSCONJ\tconj\t_\t_\t_\t_\tGloss=si\n113\tmin\tm\xEEn\tPRON\tprn\tPronType=Rel\t_\t_\t_\tGloss=REL\n114\tma\tma\tAUX\tpm\tPolarity=Neg|Aspect=Perf\t_\t_\t_\tGloss=PFV.NEG\n115\ts\xF2n\ts\u0254\u0300n\tVERB\tv\t_\t_\t_\t_\tGloss=accepter\n116\tfana\tf\xE1na\tPART\tprt\t_\t_\t_\t_\tGloss=aussi\n117\tko\tk\xF3\tPART\tcop\t_\t_\t_\t_\tGloss=QUOT\n118\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n119\tb\xE8\tb\u025B\tAUX\tpm\tPolarity=Pos|Aspect=Imp\t_\t_\t_\tGloss=IPFV.AFF\n120\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n121\tg\xE8n\tg\u025B\u0301n\tVERB\tv\t_\t_\t_\t_\tGloss=chasser\n122\t,\t,\tPUNCT\t_\t_\t_\t_\t_\tGloss=,\n123\to\t\xF2\tPRON\tprn\t_\t_\t_\t_\tGloss=ce\n124\tni\tni\tCCONJ\tconj\t_\t_\t_\t_\tGloss=et\n125\ta\t\xE0\tPRON\tpers\tPronType=Prs|Number=Sing|Person=3\t_\t_\t_\tGloss=3SG\n126\tba\tb\xE1\tNOUN\tn\t_\t_\t_\t_\tGloss=m\xE8re\n127\tb\xE8\xE8\tb\u025B\u0301\u025B\tDET\tdtm\t_\t_\t_\t_\tGloss=tout\n128\t.\t.\tPUNCT\t_\t_\t_\t_\t_\tGloss=.',

  ud_example_tabs: '1\tThey\tthey\tPRON\tPRP\tCase=Nom|Number=Plur\t2\tnsubj\t2:nsubj|4:nsubj\t_\n2\tbuy\tbuy\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Pres\t0\troot\t0:root\t_\n3\tand\tand\tCONJ\tCC\t_\t4\tcc\t4:cc\t_\n4\tsell\tsell\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Pres\t2\tconj\t0:root|2:conj\t_\n5\tbooks\tbook\tNOUN\tNNS\tNumber=Plur\t2\tobj\t2:obj|4:obj\t_\n6\t.\t.\tPUNCT\t.\t_\t2\tpunct\t2:punct\t_',

  ud_example_spaces: '1    They     they    PRON    PRP    Case=Nom|Number=Plur               2    nsubj    2:nsubj|4:nsubj _\n2    buy      buy     VERB    VBP    Number=Plur|Person=3|Tense=Pres    0    root     0:root          _\n3    and      and     CONJ    CC     _                                  4    cc       4:cc            _\n4    sell     sell    VERB    VBP    Number=Plur|Person=3|Tense=Pres    2    conj     0:root|2:conj   _\n5    books    book    NOUN    NNS    Number=Plur                        2    obj      2:obj|4:obj     _\n6    .        .       PUNCT   .      _                                  2    punct    2:punct         _',

  ud_example_modified: '1\tThey\tthey\tPRON\tPRP\tCase=Nom|Number=Plur\t2\tnsubj\t2:nsubj|4:nsubj\t_\n2\tbuy\tbuy\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Presroot\t0:root\t_\t_\t_\n3\tand\tand\tCONJ\tCC\t_\t4\tcc\t4:cc\t_\n4\tsell\tsell\tVERB\tVBP\tNumber=Plur|Person=3|Tense=Presconj\t0:root|2:conj\t_\t_\t_\n5\tbooks\tbook\tNOUN\tNNS\tNumber=Plur\t2\tobj\t2:obj|4:obj\t_\n6\t.\t.\tPUNCT\t.\t_\t2\tpunct\t2:punct\t_'
};

},{}],363:[function(require,module,exports){
'use strict';

module.exports = {
  'Brackets': require('./brackets'),
  'CG3': require('./cg3'),
  'CoNLL-U': require('./conllu'),
  'plain text': require('./plain-text'),
  'SD': require('./sd'),
  'Unknown': require('./unknown')
};

},{"./brackets":360,"./cg3":361,"./conllu":362,"./plain-text":364,"./sd":365,"./unknown":366}],364:[function(require,module,exports){
'use strict';

module.exports = {
  0: 'this is a test',
  1: 'this is a test.',
  2: 'this is a test...',
  3: 'this is a test?',
  4: '\tthis is a test',
  5: 'More sentences = more data; ipso facto, yes.',
  parens_and_numbers: '\u0414\u04D9\u04AF\u043B\u04D9\u0442\u043B\u04D9\u0440\u043D\u0435\u04A3, \u0448\u0443\u043B \u0438\u0441\u04D9\u043F\u0442\u04D9\u043D \u0420\u0443\u0441\u0438\u044F\u043D\u0435\u04A3 \u0434\u04D9, \u0434\u0438\u04A3\u0433\u0435\u0437 \u0447\u0438\u043A\u043B\u04D9\u0440\u0435 \u044F\u0440\u0434\u0430\u043D 12 \u043C\u0438\u043B\u044C (\u044F\u043A\u0438 22,2 \u043A\u043C) \u0435\u0440\u0430\u043A\u043B\u044B\u043A\u0442\u0430 \u0443\u0437\u0443\u044B \u043A\u0438\u043B\u0435\u0448\u0435\u043D\u0433\u04D9\u043D'
};

},{}],365:[function(require,module,exports){
'use strict';

module.exports = {
  0: 'And Robert the fourth place .\ncc(Robert, And)\norphan(Robert, place)\npunct(Robert, .)\namod(place, fourth)\ndet(place, the)',

  1: 'ROOT And Robert the fourth place .\nroot(ROOT, Robert)\ncc(Robert, And)\norphan(Robert, place)\npunct(Robert, .)\namod(place, fourth)\ndet(place, the)',

  2: 'ROOT I love French fries .\nroot(ROOT, love)',

  // https://github.com/UniversalDependencies/docs/blob/pages-source/_u-dep/ccomp.md
  ccomp_1: 'He says that you like to swim\nccomp(says, like)\nmark(like, that)',

  ccomp_2: 'He says you like to swim\nccomp(says, like)',

  ccomp_3: 'The boss said to start digging\nccomp(said, start)\nmark(start, to)',

  ccomp_4: 'We started digging\nxcomp(started, digging)',

  ccomp_5: 'The important thing is to keep calm.\nccomp(is, keep)\nnsubj(is, thing)',

  ccomp_6: 'The problem is that this has never been tried .\nccomp(is, tried)\nnsubj(is, problem)'
};

},{}],366:[function(require,module,exports){
'use strict';

module.exports = {
  0: '',
  1: '\n',
  2: ' ',
  3: '\t',
  4: ' \t\n',
  5: '    '
};

},{}],367:[function(require,module,exports){
'use strict';

var $ = require('jquery');
var UndoManager = require('undo-manager');

module.exports = function () {
	window.undoManager = new UndoManager();

	$('#btnUndo').click(function () {
		undoManager.undo();
	});
	$('#btnRedo').click(function () {
		undoManager.redo();
	});
};

},{"jquery":327,"undo-manager":336}],368:[function(require,module,exports){
'use strict';

var $ = require('jquery');

var U_DEPRELS = ['acl', 'advcl', 'advmod', 'amod', 'appos', 'aux', 'case', 'cc', 'ccomp', 'clf', 'compound', 'conj', 'cop', 'csubj', 'dep', 'det', 'discourse', 'dislocated', 'expl', 'fixed', 'flat', 'goeswith', 'iobj', 'list', 'mark', 'nmod', 'nsubj', 'nummod', 'obj', 'obl', 'orphan', 'parataxis', 'punct', 'reparandum', 'root', 'vocative', 'xcomp'];
var U_POS = ['ADJ', 'ADP', 'ADV', 'AUX', 'CCONJ', 'DET', 'INTJ', 'NOUN', 'NUM', 'PART', 'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'SYM', 'VERB', 'X'];

// TODO: Make this more clever, e.g. CCONJ can have a dependent in certain
// circumstances, e.g. and / or
var U_POS_LEAF = ['AUX', 'CCONJ', 'PART', 'PUNCT', 'SCONJ']; // no ADP

function is_upos(s) {
  log.debug('called is_pos(' + s + ')');

  // Checks if a relation is in the list of valid parts of speech
  // @s = the input relation
  // returns a bool
  for (var i = 0, n = U_POS.length; i < n; i++) {
    if (U_POS[i] === (s || '').toUpperCase()) return { err: null, data: {} };
  }
  return { err: 'err_upos_invalid', data: { tag: s } };
}

function is_udeprel(s) {
  log.debug('called is_udeprel(' + s + ')');

  // Checks if a relation is in the list of valid relations
  // @s = the input relation
  // returns a bool

  // Language-specific relations are `${universal_relation}:${some_string}`
  s = (s || '').split(':')[0];

  for (var i = 0, n = U_DEPRELS.length; i < n; i++) {
    if (U_DEPRELS[i] === s.toLowerCase()) return { err: null, data: {} };
  }
  return { err: 'err_udeprel_invalid', data: { label: s } };
}

function is_leaf(s) {
  log.debug('called is_leaf(' + s + ')');

  // Checks if a node is in the list of part-of-speech tags which
  // are usually leaf nodes
  // @s = part of speech tag

  // http://universaldependencies.org/u/dep/punct.html
  // Tokens with the relation punct always attach to content words (except in cases of ellipsis) and can never have dependents.

  for (var i = 0, n = U_POS_LEAF.length; i < n; i++) {
    if (U_POS_LEAF[i] === (s || '').toUpperCase()) return { err: null, data: {} };
  }
  return { err: 'err_udep_leaf_node', data: { tag: s } };
}

function is_projective_nodes(tree, nodeList) {
  log.debug('called is_projective_nodes(tree: ' + JSON.stringify(tree) + ', nodeList: ' + JSON.stringify(nodeList) + ')');

  var heads = {};

  $.each(tree, function (i, node) {
    if (node) {
      if (node.head && node.id) {
        heads[id] = head;
        nodes.push(id);
      }
    }
  });

  var nodes = Object.keys(heads);
  log.debug('is_projective_nodes(): heads: ' + JSON.stringify(heads));

  $.each(nodeList, function (i, nodeIdFromList) {
    var nodeToCheck = nodes[nodeIdFromList],
        headToCheck = heads[nodeIdFromList];

    $.each(nodes, function (j, node) {
      var head = heads[node];

      log.debug('is_projective_nodes(): checking (node: ' + nodeToCheck + ', head: ' + headToCheck + ') against (node: ' + node + ', head: ' + head + ')');
      if (node > nodeToCheck && node < headToCheck && (head > headToCheck || head < nodeToCheck)) return false;
      if (node > headToCheck && node < nodeToCheck && (head > nodeToCheck || head < headToCheck)) return false;
      if (head > nodeToCheck && head < headToCheck && (node < nodeToCheck || node > headToCheck)) return false;
      if (head > headToCheck && head < nodeToCheck && (node > nodeToCheck || node < headToCheck)) return false;
    });
  });

  log.debug('is_projective_nodes(): got true');
  return true;
}

/*
function is_projective(tree) {
    log.debug(`called is_projective(${JSON.stringify(tree)})`);

    // Checks to see if a graph is projective
    var nodes = [];
    var heads = {};
    for(let node in tree) {
        if (!tree[node] || tree[node] == undefined) {
            continue;
        }
        var head = tree[node].head;
        var id = tree[node].id;
        if (!head || !id) {
            continue;
        }
        head = parseInt(head);
        id = parseInt(id.slice(2));
        heads[id] = head;
        nodes.push(id);
    }

//    console.log('is_projective()','heads', heads);
//    console.log('is_projective()','nodes', nodes);

    var res = true;

    for(let i in nodes) {
        var n_i =  nodes[i];
        for(let j in nodes) {
            var n_j =  nodes[j];
            //console.log('i:',nodes[i],'j:',nodes[j],'h(i):',heads[n_i],'h(j):',heads[n_j]);
            if ((nodes[j] > nodes[i]) && (nodes[j] < heads[n_i])) {
                if ((heads[n_j] > heads[n_i]) || (heads[n_j] < nodes[i])) {
                    res = false;
                    console.log('[0] is_projective()',res);
                    return res;
                }
            }
            if ((nodes[j] > heads[n_i]) && (nodes[j] < nodes[i])) {
                if ((heads[n_j] > nodes[i]) || (heads[n_j] < heads[n_i])) {
                    res = false;
                    console.log('[1] is_projective()',res);
                    return res;
                }
            }
            if (heads[n_j] > nodes[i] && heads[n_j] < heads[n_i]) {
                if (nodes[j] < nodes[i] || nodes[j] > heads[n_i]) {
                    res = false;
                    console.log('[2] is_projective()',res);
                    return res;
                }
            }
            if (heads[n_j] > heads[n_i] && heads[n_j] < nodes[i]) {
                if (nodes[j] > nodes[i] || nodes[j] < heads[n_i]) {
                    res = false;
                    console.log('[3] is_projective()',res);
                    return res;
                }
            }
        }
    }
//    console.log('is_projective()', res);

    return res;
}
*/

function is_depend_cycles(tree) {
  log.debug('called is_depend_cycles(' + JSON.stringify(tree) + ')');

  var _is_cyclic_util = function _is_cyclic_util(start_vertex) {
    log.debug('called _is_cyclic_util(' + start_vertex + ')');

    // Finds cycles starting at a vertex
    var current_vertex = start_vertex,
        visited = [current_vertex];

    while (g.get(current_vertex) !== undefined && g.get(current_vertex) !== start_vertex && visited.indexOf(g.get(current_vertex)) === -1) {

      current_vertex = g.get(current_vertex);
      visited.push(current_vertex);
    }

    if (g.get(current_vertex) !== undefined && g.get(current_vertex) == start_vertex) return visited;

    return [];
  };
  var get_cycles = function get_cycles() {
    log.debug('called get_cycles()');

    // Finds all cycles
    var cycles = [];
    for (var node = 0; node < vertices; node++) {
      var c_data = _is_cyclic_util(node);
      if (c_data.length > 0) {
        c_data = normalize_cycle(c_data);
        var isEqual = false;
        for (var j = 0, l = cycles.length; j < l; j++) {
          if (checkIfEqual(cycles[j], c_data)) {
            isEqual = true;
            break;
          }
        }
        if (!isEqual) cycles.push(c_data);
      }
    }

    log.debug('cycles: ' + JSON.stringify(cycles));
    return cycles;
  };
  var _is_cyclic = function _is_cyclic() {
    log.debug('called _is_cyclic()');

    var cycles = get_cycles();
    return cycles.length ? cycles : null;
  };
  var normalize_cycle = function normalize_cycle(a) {
    log.debug('called normalize_cycle(' + JSON.stringify(a) + ')');

    //Normalizes cycles for easy comparisons
    var b = a.slice().sort(),
        loc = a.indexOf(b[0]),
        c = new Array(a.length).fill(0);

    for (var i = 0, l = a.length; i < l; i++) {
      var index = i - loc;
      if (index < 0) index += a.length;

      c[index] = a[i];
    }

    log.debug('normalized cycle: ' + JSON.stringify(c));
    return c;
  };
  var checkIfEqual = function checkIfEqual(a, b) {
    log.debug('called checkIfEqual(a: ' + JSON.stringify(a) + ', b: ' + JSON.stringify(b) + ')');

    //Checks if two cycles are equal
    if (a.length !== b.length) return false;

    for (var i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  };
  var parseId = function parseId(id) {
    log.debug('called parseId(' + id + ')');
    return parseInt(id.substr(2));
  };

  // Finds the cycles in the tree
  var g = new Map(),
      data = tree,
      vertices = Object.keys(data).length + 1,
      id_to_word = new Map();

  $.each(data, function (i, word) {
    var head = parseInt(word.head),
        id = parseId(word.id);
    if (!isNaN(head) && !isNaN(id)) {
      g.set(id, head);
      id_to_word.set(id, word.form);
    }
  });

  var is_cyclic = _is_cyclic();
  log.debug('is_depend_cycles(): has cycles: ' + is_cyclic);

  if (is_cyclic) {

    var c_list = get_cycles();
    log.debug('is_depend_cycles(): cycle list: ' + JSON.stringify(c_list));

    $.each(c_list, function (i, cycle) {
      log.debug('is_depend_cycles(): cycle: ' + JSON.stringify(cycle));

      var output = cycle.map(function (element) {
        var form = id_to_word.get(element);
        return String(form);
      }).join('-->');

      log.debug('is_depend_cycles(): output: ' + JSON.stringify(output));
    });
  }

  return is_cyclic;
}

function is_relation_conflict(tree) {
  log.debug('called is_relation_conflict(' + JSON.stringify(tree) + ')');

  var count = new Map();
  $.each(tree, function (i, word) {
    if (word.deprel !== undefined) {
      list = (count.has(word.deprel) ? count.get(word.deprel) : []).concat(word.head);
      count.set(word.deprel, list);
    }
  });
  log.debug('count: ' + JSON.stringify(count));

  var totalSubjects = new Map();
  if (count.has('nsubj')) {
    $.each(count.get('nsubj'), function (i, nsubj) {
      value = totalSubjects.has(nsubj) ? totalSubjects.get(nsubj) + 1 : 1;
      totalSubjects.set(nsubj, value);
    });
  }
  if (count.has('csubj')) {
    $.each(count.get('csubj'), function (i, csubj) {
      value = totalSubjects.has(csubj) ? totalSubjects.get(csubj) + 1 : 1;
      totalSubjects.set(nsubj, value);
    });
  }
  log.debug('totalSubjects: ' + JSON.stringify(totalSubjects));

  var totalObjects = new Map();
  if (count.has('obj')) {
    $.each(count.get('obj'), function (i, obj) {
      value = totalObjects.has(obj) ? totalObjects.get(obj) + 1 : 1;
      totalObjects.set(obj, value);
    });
  }
  log.debug('totalObjects: ' + JSON.stringify(totalObjects));

  var conflicts = new Map();
  totalSubjects.forEach(function (i, subj, map) {
    if (i > 1) {
      list = (conflicts.has(subj) ? conflicts.get(subj) : []).concat('subj');
      conflicts.set(subj, list);
    }
  });
  totalObjects.forEach(function (i, obj, map) {
    if (i > 1) {
      list = (conflicts.has(obj) ? conflicts.get(obj) : []).concat('obj');
      conflicts.set(obj, list);
    }
  });
  if (count.has('obj') && count.has('ccomp')) conflicts.set('objccomp', []);
  log.debug('conflicts: ' + JSON.stringify(conflicts));

  return conflicts;
}

module.exports = {
  U_DEPRELS: U_DEPRELS,
  U_POS: U_POS,
  is_upos: is_upos,
  is_udeprel: is_udeprel,
  is_leaf: is_leaf,
  is_projective_nodes: is_projective_nodes,
  is_depend_cycles: is_depend_cycles,
  is_relation_conflict: is_relation_conflict
};

},{"jquery":327}]},{},[349])(349)
});
